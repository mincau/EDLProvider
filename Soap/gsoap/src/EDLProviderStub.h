/* EDLProviderStub.h
   Generated by gSOAP 2.8.18 from D:\Sandbox\EdlProvider\Soap\gsoap\src\EDLProviderInterface.h

Copyright(C) 2000-2014, Robert van Engelen, Genivia Inc. All Rights Reserved.
The generated code is released under one of the following licenses:
GPL or Genivia's license for commercial use.
This program is released under the GPL with the additional exemption that
compiling, linking, and/or using OpenSSL is allowed.
*/

#ifndef EDLProviderStub_H
#define EDLProviderStub_H
#include <vector>
#define SOAP_NAMESPACE_OF_edlprovider	"http://temp/edlprovider"
#define SOAP_NAMESPACE_OF_fims	"http://base.fims.tv"
#define SOAP_NAMESPACE_OF_fimstime	"http://baseTime.fims.tv"
#define SOAP_NAMESPACE_OF_fimsdescription	"http://description.fims.tv"
#include "stdsoap2.h"
#if GSOAP_VERSION != 20818
# error "GSOAP VERSION MISMATCH IN GENERATED CODE: PLEASE REINSTALL PACKAGE"
#endif


/******************************************************************************\
 *                                                                            *
 * Enumerations                                                               *
 *                                                                            *
\******************************************************************************/


#ifndef SOAP_TYPE_edlprovider__EdlProviderErrorCodeType
#define SOAP_TYPE_edlprovider__EdlProviderErrorCodeType (187)
/* edlprovider:EdlProviderErrorCodeType */
enum edlprovider__EdlProviderErrorCodeType { edlprovider__EdlProviderErrorCodeType__EXT_USCORES00_USCORE0001 = 0, edlprovider__EdlProviderErrorCodeType__EXT_USCORES00_USCORE0002 = 1 };
#endif

#ifndef SOAP_TYPE_fims__CurrentVersion
#define SOAP_TYPE_fims__CurrentVersion (188)
/* fims:CurrentVersion */
enum fims__CurrentVersion { fims__CurrentVersion__1_USCORE1_USCORE0 = 0 };
#endif

#ifndef SOAP_TYPE_fims__QueueStatusType
#define SOAP_TYPE_fims__QueueStatusType (191)
/* fims:QueueStatusType */
enum fims__QueueStatusType { fims__QueueStatusType__started = 0, fims__QueueStatusType__stopped = 1, fims__QueueStatusType__locked = 2 };
#endif

#ifndef SOAP_TYPE_fims__PriorityType
#define SOAP_TYPE_fims__PriorityType (192)
/* fims:PriorityType */
enum fims__PriorityType { fims__PriorityType__low = 0, fims__PriorityType__medium = 1, fims__PriorityType__high = 2, fims__PriorityType__urgent = 3, fims__PriorityType__immediate = 4 };
#endif

#ifndef SOAP_TYPE_fims__StorageTypes
#define SOAP_TYPE_fims__StorageTypes (193)
/* fims:StorageTypes */
enum fims__StorageTypes { fims__StorageTypes__online = 0, fims__StorageTypes__offline = 1, fims__StorageTypes__hsm = 2, fims__StorageTypes__archive = 3, fims__StorageTypes__playout = 4, fims__StorageTypes__other = 5 };
#endif

#ifndef SOAP_TYPE_fims__QueueCommandType
#define SOAP_TYPE_fims__QueueCommandType (194)
/* fims:QueueCommandType */
enum fims__QueueCommandType { fims__QueueCommandType__status = 0, fims__QueueCommandType__clear = 1, fims__QueueCommandType__stop = 2, fims__QueueCommandType__start = 3, fims__QueueCommandType__lock = 4, fims__QueueCommandType__unlock = 5 };
#endif

#ifndef SOAP_TYPE_fims__JobCommandType
#define SOAP_TYPE_fims__JobCommandType (195)
/* fims:JobCommandType */
enum fims__JobCommandType { fims__JobCommandType__cancel = 0, fims__JobCommandType__pause = 1, fims__JobCommandType__resume = 2, fims__JobCommandType__restart = 3, fims__JobCommandType__stop = 4, fims__JobCommandType__cleanup = 5, fims__JobCommandType__modifyPriority = 6 };
#endif

#ifndef SOAP_TYPE_fims__HashFunctionTypes
#define SOAP_TYPE_fims__HashFunctionTypes (196)
/* fims:HashFunctionTypes */
enum fims__HashFunctionTypes { fims__HashFunctionTypes__CRC32 = 0, fims__HashFunctionTypes__CRC64 = 1, fims__HashFunctionTypes__MD5 = 2, fims__HashFunctionTypes__SHA1 = 3, fims__HashFunctionTypes__SHA256 = 4, fims__HashFunctionTypes__SHA384 = 5, fims__HashFunctionTypes__SHA512 = 6 };
#endif

#ifndef SOAP_TYPE_fims__JobStatusType
#define SOAP_TYPE_fims__JobStatusType (197)
/* fims:JobStatusType */
enum fims__JobStatusType { fims__JobStatusType__new_ = 0, fims__JobStatusType__queued = 1, fims__JobStatusType__scheduled = 2, fims__JobStatusType__running = 3, fims__JobStatusType__paused = 4, fims__JobStatusType__completed = 5, fims__JobStatusType__canceled = 6, fims__JobStatusType__stopped = 7, fims__JobStatusType__failed = 8, fims__JobStatusType__cleaned = 9, fims__JobStatusType__unknown = 10 };
#endif

#ifndef SOAP_TYPE_fims__AudioSampleType
#define SOAP_TYPE_fims__AudioSampleType (198)
/* fims:AudioSampleType */
enum fims__AudioSampleType { fims__AudioSampleType__float_ = 0, fims__AudioSampleType__integer = 1 };
#endif

#ifndef SOAP_TYPE_fims__ScanningFormatType
#define SOAP_TYPE_fims__ScanningFormatType (199)
/* fims:ScanningFormatType */
enum fims__ScanningFormatType { fims__ScanningFormatType__interlaced = 0, fims__ScanningFormatType__progressive = 1 };
#endif

#ifndef SOAP_TYPE_fims__ScanningOrderType
#define SOAP_TYPE_fims__ScanningOrderType (200)
/* fims:ScanningOrderType */
enum fims__ScanningOrderType { fims__ScanningOrderType__top = 0, fims__ScanningOrderType__bottom = 1 };
#endif

#ifndef SOAP_TYPE_fims__BitRateModeType
#define SOAP_TYPE_fims__BitRateModeType (201)
/* fims:BitRateModeType */
enum fims__BitRateModeType { fims__BitRateModeType__constant = 0, fims__BitRateModeType__variable = 1 };
#endif

#ifndef SOAP_TYPE_fims__ErrorCodeType
#define SOAP_TYPE_fims__ErrorCodeType (202)
/* fims:ErrorCodeType */
enum fims__ErrorCodeType { fims__ErrorCodeType__INF_USCORES00_USCORE0001 = 0, fims__ErrorCodeType__INF_USCORES00_USCORE0002 = 1, fims__ErrorCodeType__INF_USCORES00_USCORE0003 = 2, fims__ErrorCodeType__INF_USCORES00_USCORE0004 = 3, fims__ErrorCodeType__INF_USCORES00_USCORE0005 = 4, fims__ErrorCodeType__INF_USCORES00_USCORE0006 = 5, fims__ErrorCodeType__INF_USCORES00_USCORE0007 = 6, fims__ErrorCodeType__SVC_USCORES00_USCORE0001 = 7, fims__ErrorCodeType__SVC_USCORES00_USCORE0002 = 8, fims__ErrorCodeType__SVC_USCORES00_USCORE0003 = 9, fims__ErrorCodeType__SVC_USCORES00_USCORE0004 = 10, fims__ErrorCodeType__SVC_USCORES00_USCORE0005 = 11, fims__ErrorCodeType__SVC_USCORES00_USCORE0006 = 12, fims__ErrorCodeType__SVC_USCORES00_USCORE0007 = 13, fims__ErrorCodeType__SVC_USCORES00_USCORE0008 = 14, fims__ErrorCodeType__SVC_USCORES00_USCORE0009 = 15, fims__ErrorCodeType__SVC_USCORES00_USCORE0010 = 16, fims__ErrorCodeType__SVC_USCORES00_USCORE0011 = 17, fims__ErrorCodeType__SVC_USCORES00_USCORE0012 = 18, fims__ErrorCodeType__SVC_USCORES00_USCORE0013 = 19, fims__ErrorCodeType__SVC_USCORES00_USCORE0014 = 20, fims__ErrorCodeType__SVC_USCORES00_USCORE0015 = 21, fims__ErrorCodeType__SVC_USCORES00_USCORE0016 = 22, fims__ErrorCodeType__SVC_USCORES00_USCORE0017 = 23, fims__ErrorCodeType__SVC_USCORES00_USCORE0018 = 24, fims__ErrorCodeType__SVC_USCORES00_USCORE0019 = 25, fims__ErrorCodeType__SVC_USCORES00_USCORE0020 = 26, fims__ErrorCodeType__SVC_USCORES00_USCORE0021 = 27, fims__ErrorCodeType__SVC_USCORES00_USCORE0022 = 28, fims__ErrorCodeType__DAT_USCORES00_USCORE0001 = 29, fims__ErrorCodeType__DAT_USCORES00_USCORE0002 = 30, fims__ErrorCodeType__DAT_USCORES00_USCORE0003 = 31, fims__ErrorCodeType__DAT_USCORES00_USCORE0004 = 32, fims__ErrorCodeType__DAT_USCORES00_USCORE0005 = 33, fims__ErrorCodeType__DAT_USCORES00_USCORE0006 = 34, fims__ErrorCodeType__DAT_USCORES00_USCORE0007 = 35, fims__ErrorCodeType__DAT_USCORES00_USCORE0008 = 36, fims__ErrorCodeType__DAT_USCORES00_USCORE0009 = 37, fims__ErrorCodeType__DAT_USCORES00_USCORE0010 = 38, fims__ErrorCodeType__DAT_USCORES00_USCORE0011 = 39, fims__ErrorCodeType__DAT_USCORES00_USCORE0012 = 40, fims__ErrorCodeType__DAT_USCORES00_USCORE0013 = 41, fims__ErrorCodeType__DAT_USCORES00_USCORE0014 = 42, fims__ErrorCodeType__EXT_USCORES00_USCORE0000 = 43, fims__ErrorCodeType__SEC_USCORES00_USCORE0001 = 44, fims__ErrorCodeType__SEC_USCORES00_USCORE0002 = 45, fims__ErrorCodeType__SEC_USCORES00_USCORE0003 = 46, fims__ErrorCodeType__SEC_USCORES00_USCORE0004 = 47, fims__ErrorCodeType__SEC_USCORES00_USCORE0005 = 48, fims__ErrorCodeType__SEC_USCORES00_USCORE0006 = 49 };
#endif

#ifndef SOAP_TYPE_fims__JobInfoSelectionType
#define SOAP_TYPE_fims__JobInfoSelectionType (203)
/* fims:JobInfoSelectionType */
enum fims__JobInfoSelectionType { fims__JobInfoSelectionType__mandatory = 0, fims__JobInfoSelectionType__all = 1 };
#endif

#ifndef SOAP_TYPE_fims__DataTypeType
#define SOAP_TYPE_fims__DataTypeType (204)
/* fims:DataTypeType */
enum fims__DataTypeType { fims__DataTypeType__duration = 0, fims__DataTypeType__dateTime = 1, fims__DataTypeType__time = 2, fims__DataTypeType__date = 3, fims__DataTypeType__gYearMonth = 4, fims__DataTypeType__gYear = 5, fims__DataTypeType__gMonthDay = 6, fims__DataTypeType__gDay = 7, fims__DataTypeType__gMonth = 8, fims__DataTypeType__boolean = 9, fims__DataTypeType__base64Binary = 10, fims__DataTypeType__hexBinary = 11, fims__DataTypeType__float_ = 12, fims__DataTypeType__double_ = 13, fims__DataTypeType__anyURI = 14, fims__DataTypeType__decimal = 15, fims__DataTypeType__integer = 16, fims__DataTypeType__nonPositiveInteger = 17, fims__DataTypeType__nonNegativeInteger = 18, fims__DataTypeType__long_ = 19, fims__DataTypeType__positiveInteger = 20, fims__DataTypeType__negativeInteger = 21, fims__DataTypeType__int_ = 22, fims__DataTypeType__unsignedLong = 23, fims__DataTypeType__unsignedInt = 24, fims__DataTypeType__short_ = 25, fims__DataTypeType__unsignedShort = 26, fims__DataTypeType__byte = 27, fims__DataTypeType__unsignedByte = 28 };
#endif

#ifndef SOAP_TYPE_fims__BMStatusType
#define SOAP_TYPE_fims__BMStatusType (205)
/* fims:BMStatusType */
enum fims__BMStatusType { fims__BMStatusType__new_ = 0, fims__BMStatusType__online = 1, fims__BMStatusType__offline = 2, fims__BMStatusType__removed = 3, fims__BMStatusType__purged = 4, fims__BMStatusType__invalid = 5, fims__BMStatusType__processing = 6 };
#endif

#ifndef SOAP_TYPE_fims__QueryGroupOperatorType
#define SOAP_TYPE_fims__QueryGroupOperatorType (206)
/* fims:QueryGroupOperatorType */
enum fims__QueryGroupOperatorType { fims__QueryGroupOperatorType__and_ = 0, fims__QueryGroupOperatorType__or_ = 1 };
#endif

#ifndef SOAP_TYPE_fims__QueryParameterOperatorType
#define SOAP_TYPE_fims__QueryParameterOperatorType (207)
/* fims:QueryParameterOperatorType */
enum fims__QueryParameterOperatorType { fims__QueryParameterOperatorType__equal = 0, fims__QueryParameterOperatorType__notEqual = 1, fims__QueryParameterOperatorType__greater = 2, fims__QueryParameterOperatorType__less = 3 };
#endif

#ifndef SOAP_TYPE_fims__EventType
#define SOAP_TYPE_fims__EventType (208)
/* fims:EventType */
enum fims__EventType { fims__EventType__system = 0, fims__EventType__content = 1 };
#endif

#ifndef SOAP_TYPE_fims__EventSubType
#define SOAP_TYPE_fims__EventSubType (209)
/* fims:EventSubType */
enum fims__EventSubType { fims__EventSubType__systemException = 0, fims__EventSubType__systemPerformance = 1, fims__EventSubType__created = 2, fims__EventSubType__removed = 3, fims__EventSubType__purged = 4, fims__EventSubType__relocated = 5, fims__EventSubType__newFormatAvailable = 6, fims__EventSubType__copied = 7, fims__EventSubType__qced = 8, fims__EventSubType__modified = 9, fims__EventSubType__custom = 10 };
#endif

#ifndef SOAP_TYPE_fims__EventClassificationType
#define SOAP_TYPE_fims__EventClassificationType (210)
/* fims:EventClassificationType */
enum fims__EventClassificationType { fims__EventClassificationType__error = 0, fims__EventClassificationType__warning = 1, fims__EventClassificationType__information = 2 };
#endif

#ifndef SOAP_TYPE__fims__QueryServiceDescriptionRequestType_responseType
#define SOAP_TYPE__fims__QueryServiceDescriptionRequestType_responseType (242)
/* fims:QueryServiceDescriptionRequestType-responseType */
enum _fims__QueryServiceDescriptionRequestType_responseType { _fims__QueryServiceDescriptionRequestType_responseType__ref = 0, _fims__QueryServiceDescriptionRequestType_responseType__value = 1 };
#endif

/******************************************************************************\
 *                                                                            *
 * Types with Custom Serializers                                              *
 *                                                                            *
\******************************************************************************/

#ifndef SOAP_TYPE_xsd__duration
#define SOAP_TYPE_xsd__duration (16)
typedef LONG64 xsd__duration;
#endif

/******************************************************************************\
 *                                                                            *
 * Classes and Structs                                                        *
 *                                                                            *
\******************************************************************************/


#if 0 /* volatile type: do not declare here, declared elsewhere */

#endif

#ifndef SOAP_TYPE_xsd__base64Binary
#define SOAP_TYPE_xsd__base64Binary (8)
/* Base64 schema type: */
class SOAP_CMAC xsd__base64Binary
{
public:
	unsigned char *__ptr;
	int __size;
	char *id;	/* optional element of type xsd:string */
	char *type;	/* optional element of type xsd:string */
	char *options;	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 8; } /* = unique type id SOAP_TYPE_xsd__base64Binary */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         xsd__base64Binary() { xsd__base64Binary::soap_default(NULL); }
	virtual ~xsd__base64Binary() { }
};
#endif

#ifndef SOAP_TYPE_xsd__hexBinary
#define SOAP_TYPE_xsd__hexBinary (17)
/* hexBinary schema type: */
class SOAP_CMAC xsd__hexBinary
{
public:
	unsigned char *__ptr;
	int __size;
public:
	virtual int soap_type() const { return 17; } /* = unique type id SOAP_TYPE_xsd__hexBinary */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         xsd__hexBinary() { xsd__hexBinary::soap_default(NULL); }
	virtual ~xsd__hexBinary() { }
};
#endif

#if 0 /* volatile type: do not declare here, declared elsewhere */

#endif

#ifndef SOAP_TYPE_edlprovider__ArrayOfstring
#define SOAP_TYPE_edlprovider__ArrayOfstring (30)
/* edlprovider:ArrayOfstring */
class SOAP_CMAC edlprovider__ArrayOfstring
{
public:
	std::vector<std::wstring >string;	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 30; } /* = unique type id SOAP_TYPE_edlprovider__ArrayOfstring */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         edlprovider__ArrayOfstring() { edlprovider__ArrayOfstring::soap_default(NULL); }
	virtual ~edlprovider__ArrayOfstring() { }
};
#endif

#ifndef SOAP_TYPE_edlprovider__ArrayOfClips
#define SOAP_TYPE_edlprovider__ArrayOfClips (31)
/* edlprovider:ArrayOfClips */
class SOAP_CMAC edlprovider__ArrayOfClips
{
public:
	std::vector<class edlprovider__ClipType * >clips;	/* optional element of type edlprovider:ClipType */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 31; } /* = unique type id SOAP_TYPE_edlprovider__ArrayOfClips */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         edlprovider__ArrayOfClips() { edlprovider__ArrayOfClips::soap_default(NULL); }
	virtual ~edlprovider__ArrayOfClips() { }
};
#endif

#ifndef SOAP_TYPE_edlprovider__ClipType
#define SOAP_TYPE_edlprovider__ClipType (32)
/* edlprovider:ClipType */
class SOAP_CMAC edlprovider__ClipType
{
public:
	class fimstime__TimeType *markIn;	/* required element of type fimstime:TimeType */
	fimstime__TimeType *markOut;	/* required element of type fimstime:TimeType */
	class fims__BMObjectType *clipInfo;	/* required element of type fims:BMObjectType */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 32; } /* = unique type id SOAP_TYPE_edlprovider__ClipType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         edlprovider__ClipType() { edlprovider__ClipType::soap_default(NULL); }
	virtual ~edlprovider__ClipType() { }
};
#endif

#ifndef SOAP_TYPE_edlprovider__MapItemType
#define SOAP_TYPE_edlprovider__MapItemType (33)
/* edlprovider:MapItemType */
class SOAP_CMAC edlprovider__MapItemType
{
public:
	std::wstring edlType;	/* required element of type xsd:string */
	std::wstring edlExtension;	/* required element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 33; } /* = unique type id SOAP_TYPE_edlprovider__MapItemType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         edlprovider__MapItemType() { edlprovider__MapItemType::soap_default(NULL); }
	virtual ~edlprovider__MapItemType() { }
};
#endif

#ifndef SOAP_TYPE_edlprovider__EdlCreateRequestBaseType
#define SOAP_TYPE_edlprovider__EdlCreateRequestBaseType (34)
/* edlprovider:EdlCreateRequestBaseType */
class SOAP_CMAC edlprovider__EdlCreateRequestBaseType
{
public:
	std::wstring edlType;	/* required element of type xsd:string */
	edlprovider__ArrayOfClips *clips;	/* optional element of type edlprovider:ArrayOfClips */
	std::wstring *edlSequenceName;	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 34; } /* = unique type id SOAP_TYPE_edlprovider__EdlCreateRequestBaseType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         edlprovider__EdlCreateRequestBaseType() { edlprovider__EdlCreateRequestBaseType::soap_default(NULL); }
	virtual ~edlprovider__EdlCreateRequestBaseType() { }
};
#endif

#ifndef SOAP_TYPE_edlprovider__EdlCreateResponseType
#define SOAP_TYPE_edlprovider__EdlCreateResponseType (37)
/* edlprovider:EdlCreateResponseType */
class SOAP_CMAC edlprovider__EdlCreateResponseType
{
public:
	xsd__base64Binary *getEdlResult;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type xsd:base64Binary */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 37; } /* = unique type id SOAP_TYPE_edlprovider__EdlCreateResponseType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         edlprovider__EdlCreateResponseType() { edlprovider__EdlCreateResponseType::soap_default(NULL); }
	virtual ~edlprovider__EdlCreateResponseType() { }
};
#endif

#ifndef SOAP_TYPE_edlprovider__InstalledEdlsResponseType
#define SOAP_TYPE_edlprovider__InstalledEdlsResponseType (38)
/* edlprovider:InstalledEdlsResponseType */
class SOAP_CMAC edlprovider__InstalledEdlsResponseType
{
public:
	class _edlprovider__Map *edlprovider__Map;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of type edlprovider:Map */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 38; } /* = unique type id SOAP_TYPE_edlprovider__InstalledEdlsResponseType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         edlprovider__InstalledEdlsResponseType() { edlprovider__InstalledEdlsResponseType::soap_default(NULL); }
	virtual ~edlprovider__InstalledEdlsResponseType() { }
};
#endif

#ifndef SOAP_TYPE__edlprovider__Map
#define SOAP_TYPE__edlprovider__Map (40)
/* edlprovider:Map */
class SOAP_CMAC _edlprovider__Map
{
public:
	std::vector<edlprovider__MapItemType * >item;	/* optional element of type edlprovider:MapItemType */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 40; } /* = unique type id SOAP_TYPE__edlprovider__Map */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _edlprovider__Map() { _edlprovider__Map::soap_default(NULL); }
	virtual ~_edlprovider__Map() { }
};
#endif

#ifndef SOAP_TYPE_fims__ExtensionGroup
#define SOAP_TYPE_fims__ExtensionGroup (41)
/* fims:ExtensionGroup */
class SOAP_CMAC fims__ExtensionGroup
{
public:
	std::vector<char * >__any;
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 41; } /* = unique type id SOAP_TYPE_fims__ExtensionGroup */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         fims__ExtensionGroup() { fims__ExtensionGroup::soap_default(NULL); }
	virtual ~fims__ExtensionGroup() { }
};
#endif

#ifndef SOAP_TYPE_fims__ExtensionAttributes
#define SOAP_TYPE_fims__ExtensionAttributes (42)
/* fims:ExtensionAttributes */
class SOAP_CMAC fims__ExtensionAttributes
{
public:
	char *__anyAttribute;	/* optional attribute */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 42; } /* = unique type id SOAP_TYPE_fims__ExtensionAttributes */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         fims__ExtensionAttributes() { fims__ExtensionAttributes::soap_default(NULL); }
	virtual ~fims__ExtensionAttributes() { }
};
#endif

#ifndef SOAP_TYPE_fims__ResourceReferenceType
#define SOAP_TYPE_fims__ResourceReferenceType (43)
/* fims:ResourceReferenceType */
class SOAP_CMAC fims__ResourceReferenceType
{
public:
	std::wstring resourceID;	/* required element of type fims:ResourceIDType */
	std::wstring *revisionID;	/* optional element of type fims:RevisionIDType */
	std::wstring *location;	/* optional element of type xsd:anyURI */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 43; } /* = unique type id SOAP_TYPE_fims__ResourceReferenceType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         fims__ResourceReferenceType() { fims__ResourceReferenceType::soap_default(NULL); }
	virtual ~fims__ResourceReferenceType() { }
};
#endif

#ifndef SOAP_TYPE_fims__ExtensionBaseType
#define SOAP_TYPE_fims__ExtensionBaseType (45)
/* fims:ExtensionBaseType */
class SOAP_CMAC fims__ExtensionBaseType
{
public:
	fims__ExtensionGroup *ExtensionGroup;	/* optional element of type fims:ExtensionGroup */
	fims__ExtensionAttributes *ExtensionAttributes;	/* optional element of type fims:ExtensionAttributes */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 45; } /* = unique type id SOAP_TYPE_fims__ExtensionBaseType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         fims__ExtensionBaseType() { fims__ExtensionBaseType::soap_default(NULL); }
	virtual ~fims__ExtensionBaseType() { }
};
#endif

#ifndef SOAP_TYPE_fims__AsyncEndpointType
#define SOAP_TYPE_fims__AsyncEndpointType (46)
/* fims:AsyncEndpointType */
class SOAP_CMAC fims__AsyncEndpointType
{
public:
	std::wstring replyTo;	/* required element of type xsd:anyURI */
	std::wstring faultTo;	/* required element of type xsd:anyURI */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 46; } /* = unique type id SOAP_TYPE_fims__AsyncEndpointType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         fims__AsyncEndpointType() { fims__AsyncEndpointType::soap_default(NULL); }
	virtual ~fims__AsyncEndpointType() { }
};
#endif

#ifndef SOAP_TYPE_fims__AncillaryDataFormatType
#define SOAP_TYPE_fims__AncillaryDataFormatType (56)
/* fims:AncillaryDataFormatType */
class SOAP_CMAC fims__AncillaryDataFormatType
{
public:
	std::wstring *DID;	/* optional element of type xsd:integer */
	std::wstring *SDID;	/* optional element of type xsd:integer */
	std::wstring *lineNumber;	/* optional element of type xsd:integer */
	std::wstring *wrappingType;	/* optional element of type xsd:integer */
	fims__ExtensionGroup *ExtensionGroup;	/* optional element of type fims:ExtensionGroup */
	fims__ExtensionAttributes *ExtensionAttributes;	/* optional element of type fims:ExtensionAttributes */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 56; } /* = unique type id SOAP_TYPE_fims__AncillaryDataFormatType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         fims__AncillaryDataFormatType() { fims__AncillaryDataFormatType::soap_default(NULL); }
	virtual ~fims__AncillaryDataFormatType() { }
};
#endif

#ifndef SOAP_TYPE_fims__BMTrackType
#define SOAP_TYPE_fims__BMTrackType (58)
/* fims:BMTrackType */
class SOAP_CMAC fims__BMTrackType
{
public:
	fims__ExtensionGroup *ExtensionGroup;	/* optional element of type fims:ExtensionGroup */
	fims__ExtensionAttributes *ExtensionAttributes;	/* optional element of type fims:ExtensionAttributes */
	std::wstring *trackID;	/* optional attribute */
	std::wstring *trackName;	/* optional attribute */
	std::wstring *language;	/* optional attribute */
	std::wstring *typeLabel;	/* optional attribute */
	std::wstring *typeDefinition;	/* optional attribute */
	std::wstring *typeLink;	/* optional attribute */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 58; } /* = unique type id SOAP_TYPE_fims__BMTrackType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         fims__BMTrackType() { fims__BMTrackType::soap_default(NULL); }
	virtual ~fims__BMTrackType() { }
};
#endif

#ifndef SOAP_TYPE_fims__CodecType
#define SOAP_TYPE_fims__CodecType (59)
/* fims:CodecType */
class SOAP_CMAC fims__CodecType
{
public:
	std::wstring *name;	/* optional element of type xsd:string */
	std::wstring *vendor;	/* optional element of type xsd:string */
	std::wstring *version;	/* optional element of type xsd:string */
	std::wstring *family;	/* optional element of type xsd:string */
	std::wstring *typeLabel;	/* optional attribute */
	std::wstring *typeDefinition;	/* optional attribute */
	std::wstring *typeLink;	/* optional attribute */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 59; } /* = unique type id SOAP_TYPE_fims__CodecType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         fims__CodecType() { fims__CodecType::soap_default(NULL); }
	virtual ~fims__CodecType() { }
};
#endif

#ifndef SOAP_TYPE_fims__TransferAtomType
#define SOAP_TYPE_fims__TransferAtomType (69)
/* fims:TransferAtomType */
class SOAP_CMAC fims__TransferAtomType
{
public:
	std::wstring destination;	/* required element of type xsd:anyURI */
	fims__ExtensionGroup *ExtensionGroup;	/* optional element of type fims:ExtensionGroup */
	fims__ExtensionAttributes *ExtensionAttributes;	/* optional element of type fims:ExtensionAttributes */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 69; } /* = unique type id SOAP_TYPE_fims__TransferAtomType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         fims__TransferAtomType() { fims__TransferAtomType::soap_default(NULL); }
	virtual ~fims__TransferAtomType() { }
};
#endif

#ifndef SOAP_TYPE_fims__TransformAtomType
#define SOAP_TYPE_fims__TransformAtomType (70)
/* fims:TransformAtomType */
class SOAP_CMAC fims__TransformAtomType
{
public:
	class fims__VideoFormatType *videoFormat;	/* optional element of type fims:VideoFormatType */
	class fims__AudioFormatType *audioFormat;	/* optional element of type fims:AudioFormatType */
	class fims__ContainerFormatType *containerFormat;	/* optional element of type fims:ContainerFormatType */
	fims__ExtensionGroup *ExtensionGroup;	/* optional element of type fims:ExtensionGroup */
	fims__ExtensionAttributes *ExtensionAttributes;	/* optional element of type fims:ExtensionAttributes */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 70; } /* = unique type id SOAP_TYPE_fims__TransformAtomType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         fims__TransformAtomType() { fims__TransformAtomType::soap_default(NULL); }
	virtual ~fims__TransformAtomType() { }
};
#endif

#ifndef SOAP_TYPE_fims__HashType
#define SOAP_TYPE_fims__HashType (74)
/* fims:HashType */
class SOAP_CMAC fims__HashType
{
public:
	class fims__HashFunctionType *hashFunction;	/* required element of type fims:HashFunctionType */
	xsd__hexBinary value;	/* required element of type xsd:hexBinary */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 74; } /* = unique type id SOAP_TYPE_fims__HashType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         fims__HashType() { fims__HashType::soap_default(NULL); }
	virtual ~fims__HashType() { }
};
#endif

#ifndef SOAP_TYPE_fims__ProcessedInfoType
#define SOAP_TYPE_fims__ProcessedInfoType (75)
/* fims:ProcessedInfoType */
class SOAP_CMAC fims__ProcessedInfoType
{
public:
	std::wstring percentageProcessedCompleted;	/* required element of type xsd:nonNegativeInteger */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 75; } /* = unique type id SOAP_TYPE_fims__ProcessedInfoType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         fims__ProcessedInfoType() { fims__ProcessedInfoType::soap_default(NULL); }
	virtual ~fims__ProcessedInfoType() { }
};
#endif

#ifndef SOAP_TYPE_fims__StartProcessType
#define SOAP_TYPE_fims__StartProcessType (80)
/* fims:StartProcessType */
class SOAP_CMAC fims__StartProcessType
{
public:
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 80; } /* = unique type id SOAP_TYPE_fims__StartProcessType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         fims__StartProcessType() { fims__StartProcessType::soap_default(NULL); }
	virtual ~fims__StartProcessType() { }
};
#endif

#ifndef SOAP_TYPE_fims__StopProcessType
#define SOAP_TYPE_fims__StopProcessType (85)
/* fims:StopProcessType */
class SOAP_CMAC fims__StopProcessType
{
public:
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 85; } /* = unique type id SOAP_TYPE_fims__StopProcessType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         fims__StopProcessType() { fims__StopProcessType::soap_default(NULL); }
	virtual ~fims__StopProcessType() { }
};
#endif

#ifndef SOAP_TYPE_fims__StartJobType
#define SOAP_TYPE_fims__StartJobType (91)
/* fims:StartJobType */
class SOAP_CMAC fims__StartJobType
{
public:
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 91; } /* = unique type id SOAP_TYPE_fims__StartJobType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         fims__StartJobType() { fims__StartJobType::soap_default(NULL); }
	virtual ~fims__StartJobType() { }
};
#endif

#ifndef SOAP_TYPE_fims__ManageJobRequestType
#define SOAP_TYPE_fims__ManageJobRequestType (95)
/* fims:ManageJobRequestType */
class SOAP_CMAC fims__ManageJobRequestType
{
public:
	std::wstring jobID;	/* required element of type fims:UID */
	enum fims__JobCommandType jobCommand;	/* required element of type fims:JobCommandType */
	enum fims__PriorityType *priority;	/* optional element of type fims:PriorityType */
	fims__ExtensionGroup *ExtensionGroup;	/* optional element of type fims:ExtensionGroup */
	fims__ExtensionAttributes *ExtensionAttributes;	/* optional element of type fims:ExtensionAttributes */
	enum fims__CurrentVersion version;	/* required attribute */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 95; } /* = unique type id SOAP_TYPE_fims__ManageJobRequestType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         fims__ManageJobRequestType() { fims__ManageJobRequestType::soap_default(NULL); }
	virtual ~fims__ManageJobRequestType() { }
};
#endif

#ifndef SOAP_TYPE_fims__ManageJobResponseType
#define SOAP_TYPE_fims__ManageJobResponseType (96)
/* fims:ManageJobResponseType */
class SOAP_CMAC fims__ManageJobResponseType
{
public:
	class fims__JobType *job;	/* required element of type fims:JobType */
	fims__ExtensionGroup *ExtensionGroup;	/* optional element of type fims:ExtensionGroup */
	fims__ExtensionAttributes *ExtensionAttributes;	/* optional element of type fims:ExtensionAttributes */
	enum fims__CurrentVersion version;	/* required attribute */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 96; } /* = unique type id SOAP_TYPE_fims__ManageJobResponseType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         fims__ManageJobResponseType() { fims__ManageJobResponseType::soap_default(NULL); }
	virtual ~fims__ManageJobResponseType() { }
};
#endif

#ifndef SOAP_TYPE_fims__ManageQueueRequestType
#define SOAP_TYPE_fims__ManageQueueRequestType (97)
/* fims:ManageQueueRequestType */
class SOAP_CMAC fims__ManageQueueRequestType
{
public:
	std::wstring *queueID;	/* optional element of type fims:UID */
	enum fims__QueueCommandType queueCommand;	/* required element of type fims:QueueCommandType */
	fims__ExtensionGroup *ExtensionGroup;	/* optional element of type fims:ExtensionGroup */
	fims__ExtensionAttributes *ExtensionAttributes;	/* optional element of type fims:ExtensionAttributes */
	enum fims__CurrentVersion version;	/* required attribute */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 97; } /* = unique type id SOAP_TYPE_fims__ManageQueueRequestType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         fims__ManageQueueRequestType() { fims__ManageQueueRequestType::soap_default(NULL); }
	virtual ~fims__ManageQueueRequestType() { }
};
#endif

#ifndef SOAP_TYPE_fims__ManageQueueResponseType
#define SOAP_TYPE_fims__ManageQueueResponseType (98)
/* fims:ManageQueueResponseType */
class SOAP_CMAC fims__ManageQueueResponseType
{
public:
	class fims__QueueType *queue;	/* required element of type fims:QueueType */
	fims__ExtensionGroup *ExtensionGroup;	/* optional element of type fims:ExtensionGroup */
	fims__ExtensionAttributes *ExtensionAttributes;	/* optional element of type fims:ExtensionAttributes */
	enum fims__CurrentVersion version;	/* required attribute */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 98; } /* = unique type id SOAP_TYPE_fims__ManageQueueResponseType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         fims__ManageQueueResponseType() { fims__ManageQueueResponseType::soap_default(NULL); }
	virtual ~fims__ManageQueueResponseType() { }
};
#endif

#ifndef SOAP_TYPE_fims__QueryJobRequestType
#define SOAP_TYPE_fims__QueryJobRequestType (99)
/* fims:QueryJobRequestType */
class SOAP_CMAC fims__QueryJobRequestType
{
public:
	enum fims__JobInfoSelectionType jobInfoSelection;	/* required element of type fims:JobInfoSelectionType */
	fims__ExtensionGroup *ExtensionGroup;	/* optional element of type fims:ExtensionGroup */
	fims__ExtensionAttributes *ExtensionAttributes;	/* optional element of type fims:ExtensionAttributes */
	enum fims__CurrentVersion version;	/* required attribute */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 99; } /* = unique type id SOAP_TYPE_fims__QueryJobRequestType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         fims__QueryJobRequestType() { fims__QueryJobRequestType::soap_default(NULL); }
	virtual ~fims__QueryJobRequestType() { }
};
#endif

#ifndef SOAP_TYPE_fims__QueryJobResponseType
#define SOAP_TYPE_fims__QueryJobResponseType (102)
/* fims:QueryJobResponseType */
class SOAP_CMAC fims__QueryJobResponseType
{
public:
	class fims__JobsType *jobs;	/* optional element of type fims:JobsType */
	std::wstring *notReportedResultsNumber;	/* optional element of type xsd:nonNegativeInteger */
	fims__ExtensionGroup *ExtensionGroup;	/* optional element of type fims:ExtensionGroup */
	fims__ExtensionAttributes *ExtensionAttributes;	/* optional element of type fims:ExtensionAttributes */
	enum fims__CurrentVersion version;	/* required attribute */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 102; } /* = unique type id SOAP_TYPE_fims__QueryJobResponseType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         fims__QueryJobResponseType() { fims__QueryJobResponseType::soap_default(NULL); }
	virtual ~fims__QueryJobResponseType() { }
};
#endif

#ifndef SOAP_TYPE_fims__QueryServiceDescriptionRequestType
#define SOAP_TYPE_fims__QueryServiceDescriptionRequestType (103)
/* fims:QueryServiceDescriptionRequestType */
class SOAP_CMAC fims__QueryServiceDescriptionRequestType
{
public:
	enum _fims__QueryServiceDescriptionRequestType_responseType responseType;	/* optional attribute */
	enum fims__CurrentVersion version;	/* required attribute */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 103; } /* = unique type id SOAP_TYPE_fims__QueryServiceDescriptionRequestType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         fims__QueryServiceDescriptionRequestType() { fims__QueryServiceDescriptionRequestType::soap_default(NULL); }
	virtual ~fims__QueryServiceDescriptionRequestType() { }
};
#endif

#ifndef SOAP_TYPE_fims__QueryServiceDescriptionResponseType
#define SOAP_TYPE_fims__QueryServiceDescriptionResponseType (104)
/* fims:QueryServiceDescriptionResponseType */
class SOAP_CMAC fims__QueryServiceDescriptionResponseType
{
public:
	class fims__ServiceType *service;	/* required element of type fims:ServiceType */
	enum fims__CurrentVersion version;	/* required attribute */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 104; } /* = unique type id SOAP_TYPE_fims__QueryServiceDescriptionResponseType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         fims__QueryServiceDescriptionResponseType() { fims__QueryServiceDescriptionResponseType::soap_default(NULL); }
	virtual ~fims__QueryServiceDescriptionResponseType() { }
};
#endif

#ifndef SOAP_TYPE_fims__ListFilterType
#define SOAP_TYPE_fims__ListFilterType (105)
/* fims:ListFilterType */
class SOAP_CMAC fims__ListFilterType
{
public:
	time_t *fromDate;	/* optional element of type xsd:dateTime */
	time_t *toDate;	/* optional element of type xsd:dateTime */
	bool includeQueued;	/* required element of type xsd:boolean */
	bool includeActive;	/* required element of type xsd:boolean */
	bool includeFinished;	/* required element of type xsd:boolean */
	bool includeFailed;	/* required element of type xsd:boolean */
	std::wstring *maxNumberResults;	/* optional element of type xsd:nonNegativeInteger */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 105; } /* = unique type id SOAP_TYPE_fims__ListFilterType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         fims__ListFilterType() { fims__ListFilterType::soap_default(NULL); }
	virtual ~fims__ListFilterType() { }
};
#endif

#ifndef SOAP_TYPE_fims__FaultType
#define SOAP_TYPE_fims__FaultType (106)
/* fims:FaultType */
class SOAP_CMAC fims__FaultType
{
public:
	enum fims__ErrorCodeType code;	/* required element of type fims:ErrorCodeType */
	std::wstring *description;	/* optional element of type xsd:string */
	std::wstring *detail;	/* optional element of type xsd:string */
	std::vector<class fims__InnerFaultType * >innerFault;	/* optional element of type fims:InnerFaultType */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 106; } /* = unique type id SOAP_TYPE_fims__FaultType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         fims__FaultType() { fims__FaultType::soap_default(NULL); }
	virtual ~fims__FaultType() { }
};
#endif

#ifndef SOAP_TYPE_fims__InnerFaultType
#define SOAP_TYPE_fims__InnerFaultType (107)
/* fims:InnerFaultType */
class SOAP_CMAC fims__InnerFaultType
{
public:
	std::wstring code;	/* required element of type xsd:string */
	std::wstring *description;	/* optional element of type xsd:string */
	std::wstring *detail;	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 107; } /* = unique type id SOAP_TYPE_fims__InnerFaultType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         fims__InnerFaultType() { fims__InnerFaultType::soap_default(NULL); }
	virtual ~fims__InnerFaultType() { }
};
#endif

#ifndef SOAP_TYPE_fims__ResourcesType
#define SOAP_TYPE_fims__ResourcesType (108)
/* fims:ResourcesType */
class SOAP_CMAC fims__ResourcesType
{
public:
	std::vector<class fims__ResourceType * >resource;	/* required element of type fims:ResourceType */
	std::vector<char * >__any;
	char *__anyAttribute;	/* optional attribute */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 108; } /* = unique type id SOAP_TYPE_fims__ResourcesType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         fims__ResourcesType() { fims__ResourcesType::soap_default(NULL); }
	virtual ~fims__ResourcesType() { }
};
#endif

#ifndef SOAP_TYPE_fims__ProfilesType
#define SOAP_TYPE_fims__ProfilesType (109)
/* fims:ProfilesType */
class SOAP_CMAC fims__ProfilesType
{
public:
	std::vector<class fims__ProfileType * >profile;	/* required element of type fims:ProfileType */
	std::vector<char * >__any;
	char *__anyAttribute;	/* optional attribute */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 109; } /* = unique type id SOAP_TYPE_fims__ProfilesType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         fims__ProfilesType() { fims__ProfilesType::soap_default(NULL); }
	virtual ~fims__ProfilesType() { }
};
#endif

#ifndef SOAP_TYPE_fims__ServicesType
#define SOAP_TYPE_fims__ServicesType (110)
/* fims:ServicesType */
class SOAP_CMAC fims__ServicesType
{
public:
	std::vector<fims__ServiceType * >service;	/* required element of type fims:ServiceType */
	std::vector<char * >__any;
	char *__anyAttribute;	/* optional attribute */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 110; } /* = unique type id SOAP_TYPE_fims__ServicesType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         fims__ServicesType() { fims__ServicesType::soap_default(NULL); }
	virtual ~fims__ServicesType() { }
};
#endif

#ifndef SOAP_TYPE_fims__QueuesType
#define SOAP_TYPE_fims__QueuesType (111)
/* fims:QueuesType */
class SOAP_CMAC fims__QueuesType
{
public:
	std::vector<fims__QueueType * >queue;	/* required element of type fims:QueueType */
	std::vector<char * >__any;
	char *__anyAttribute;	/* optional attribute */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 111; } /* = unique type id SOAP_TYPE_fims__QueuesType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         fims__QueuesType() { fims__QueuesType::soap_default(NULL); }
	virtual ~fims__QueuesType() { }
};
#endif

#ifndef SOAP_TYPE_fims__JobsType
#define SOAP_TYPE_fims__JobsType (112)
/* fims:JobsType */
class SOAP_CMAC fims__JobsType
{
public:
	std::vector<fims__JobType * >job;	/* required element of type fims:JobType */
	std::vector<char * >__any;
	char *__anyAttribute;	/* optional attribute */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 112; } /* = unique type id SOAP_TYPE_fims__JobsType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         fims__JobsType() { fims__JobsType::soap_default(NULL); }
	virtual ~fims__JobsType() { }
};
#endif

#ifndef SOAP_TYPE_fims__VideoFormatsType
#define SOAP_TYPE_fims__VideoFormatsType (113)
/* fims:VideoFormatsType */
class SOAP_CMAC fims__VideoFormatsType
{
public:
	std::vector<fims__VideoFormatType * >videoFormat;	/* required element of type fims:VideoFormatType */
	std::vector<char * >__any;
	char *__anyAttribute;	/* optional attribute */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 113; } /* = unique type id SOAP_TYPE_fims__VideoFormatsType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         fims__VideoFormatsType() { fims__VideoFormatsType::soap_default(NULL); }
	virtual ~fims__VideoFormatsType() { }
};
#endif

#ifndef SOAP_TYPE_fims__AudioFormatsType
#define SOAP_TYPE_fims__AudioFormatsType (114)
/* fims:AudioFormatsType */
class SOAP_CMAC fims__AudioFormatsType
{
public:
	std::vector<fims__AudioFormatType * >audioFormat;	/* required element of type fims:AudioFormatType */
	std::vector<char * >__any;
	char *__anyAttribute;	/* optional attribute */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 114; } /* = unique type id SOAP_TYPE_fims__AudioFormatsType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         fims__AudioFormatsType() { fims__AudioFormatsType::soap_default(NULL); }
	virtual ~fims__AudioFormatsType() { }
};
#endif

#ifndef SOAP_TYPE_fims__ContainerFormatsType
#define SOAP_TYPE_fims__ContainerFormatsType (115)
/* fims:ContainerFormatsType */
class SOAP_CMAC fims__ContainerFormatsType
{
public:
	std::vector<fims__ContainerFormatType * >containerFormat;	/* required element of type fims:ContainerFormatType */
	std::vector<char * >__any;
	char *__anyAttribute;	/* optional attribute */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 115; } /* = unique type id SOAP_TYPE_fims__ContainerFormatsType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         fims__ContainerFormatsType() { fims__ContainerFormatsType::soap_default(NULL); }
	virtual ~fims__ContainerFormatsType() { }
};
#endif

#ifndef SOAP_TYPE_fims__DataFormatsType
#define SOAP_TYPE_fims__DataFormatsType (116)
/* fims:DataFormatsType */
class SOAP_CMAC fims__DataFormatsType
{
public:
	std::vector<class fims__DataFormatType * >dataFormat;	/* required element of type fims:DataFormatType */
	std::vector<char * >__any;
	char *__anyAttribute;	/* optional attribute */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 116; } /* = unique type id SOAP_TYPE_fims__DataFormatsType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         fims__DataFormatsType() { fims__DataFormatsType::soap_default(NULL); }
	virtual ~fims__DataFormatsType() { }
};
#endif

#ifndef SOAP_TYPE_fims__BMObjectsType
#define SOAP_TYPE_fims__BMObjectsType (117)
/* fims:BMObjectsType */
class SOAP_CMAC fims__BMObjectsType
{
public:
	std::vector<fims__BMObjectType * >bmObject;	/* required element of type fims:BMObjectType */
	std::vector<char * >__any;
	char *__anyAttribute;	/* optional attribute */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 117; } /* = unique type id SOAP_TYPE_fims__BMObjectsType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         fims__BMObjectsType() { fims__BMObjectsType::soap_default(NULL); }
	virtual ~fims__BMObjectsType() { }
};
#endif

#ifndef SOAP_TYPE_fims__BMContentsType
#define SOAP_TYPE_fims__BMContentsType (118)
/* fims:BMContentsType */
class SOAP_CMAC fims__BMContentsType
{
public:
	std::vector<class fims__BMContentType * >bmContent;	/* required element of type fims:BMContentType */
	std::vector<char * >__any;
	char *__anyAttribute;	/* optional attribute */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 118; } /* = unique type id SOAP_TYPE_fims__BMContentsType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         fims__BMContentsType() { fims__BMContentsType::soap_default(NULL); }
	virtual ~fims__BMContentsType() { }
};
#endif

#ifndef SOAP_TYPE_fims__BMContentFormatsType
#define SOAP_TYPE_fims__BMContentFormatsType (119)
/* fims:BMContentFormatsType */
class SOAP_CMAC fims__BMContentFormatsType
{
public:
	std::vector<class fims__BMContentFormatType * >bmContentFormat;	/* required element of type fims:BMContentFormatType */
	std::vector<char * >__any;
	char *__anyAttribute;	/* optional attribute */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 119; } /* = unique type id SOAP_TYPE_fims__BMContentFormatsType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         fims__BMContentFormatsType() { fims__BMContentFormatsType::soap_default(NULL); }
	virtual ~fims__BMContentFormatsType() { }
};
#endif

#ifndef SOAP_TYPE_fims__BMEssenceLocatorsType
#define SOAP_TYPE_fims__BMEssenceLocatorsType (120)
/* fims:BMEssenceLocatorsType */
class SOAP_CMAC fims__BMEssenceLocatorsType
{
public:
	std::vector<class fims__BMEssenceLocatorType * >bmEssenceLocator;	/* required element of type fims:BMEssenceLocatorType */
	std::vector<char * >__any;
	char *__anyAttribute;	/* optional attribute */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 120; } /* = unique type id SOAP_TYPE_fims__BMEssenceLocatorsType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         fims__BMEssenceLocatorsType() { fims__BMEssenceLocatorsType::soap_default(NULL); }
	virtual ~fims__BMEssenceLocatorsType() { }
};
#endif

#ifndef SOAP_TYPE_fims__DescriptionsType
#define SOAP_TYPE_fims__DescriptionsType (121)
/* fims:DescriptionsType */
class SOAP_CMAC fims__DescriptionsType
{
public:
	std::vector<class fims__DescriptionType * >description;	/* required element of type fims:DescriptionType */
	std::vector<char * >__any;
	char *__anyAttribute;	/* optional attribute */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 121; } /* = unique type id SOAP_TYPE_fims__DescriptionsType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         fims__DescriptionsType() { fims__DescriptionsType::soap_default(NULL); }
	virtual ~fims__DescriptionsType() { }
};
#endif

#ifndef SOAP_TYPE_fims__ResourceReferencesType
#define SOAP_TYPE_fims__ResourceReferencesType (122)
/* fims:ResourceReferencesType */
class SOAP_CMAC fims__ResourceReferencesType
{
public:
	std::vector<fims__ResourceReferenceType * >resourceReference;	/* required element of type fims:ResourceReferenceType */
	std::vector<char * >__any;
	char *__anyAttribute;	/* optional attribute */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 122; } /* = unique type id SOAP_TYPE_fims__ResourceReferencesType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         fims__ResourceReferencesType() { fims__ResourceReferencesType::soap_default(NULL); }
	virtual ~fims__ResourceReferencesType() { }
};
#endif

#ifndef SOAP_TYPE_fims__CustomValueType
#define SOAP_TYPE_fims__CustomValueType (123)
/* fims:CustomValueType */
class SOAP_CMAC fims__CustomValueType
{
public:
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 123; } /* = unique type id SOAP_TYPE_fims__CustomValueType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         fims__CustomValueType() { fims__CustomValueType::soap_default(NULL); }
	virtual ~fims__CustomValueType() { }
};
#endif

#ifndef SOAP_TYPE_fims__CustomValuesType
#define SOAP_TYPE_fims__CustomValuesType (124)
/* fims:CustomValuesType */
class SOAP_CMAC fims__CustomValuesType
{
public:
	std::vector<fims__CustomValueType * >customValue;	/* required element of type fims:CustomValueType */
	std::vector<char * >__any;
	char *__anyAttribute;	/* optional attribute */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 124; } /* = unique type id SOAP_TYPE_fims__CustomValuesType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         fims__CustomValuesType() { fims__CustomValuesType::soap_default(NULL); }
	virtual ~fims__CustomValuesType() { }
};
#endif

#ifndef SOAP_TYPE_fims__BMCustomStatusExtensionsType
#define SOAP_TYPE_fims__BMCustomStatusExtensionsType (126)
/* fims:BMCustomStatusExtensionsType */
class SOAP_CMAC fims__BMCustomStatusExtensionsType
{
public:
	std::vector<class fims__BMCustomStatusExtensionType * >bmCustomStatusExtension;	/* required element of type fims:BMCustomStatusExtensionType */
	std::vector<char * >__any;
	char *__anyAttribute;	/* optional attribute */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 126; } /* = unique type id SOAP_TYPE_fims__BMCustomStatusExtensionsType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         fims__BMCustomStatusExtensionsType() { fims__BMCustomStatusExtensionsType::soap_default(NULL); }
	virtual ~fims__BMCustomStatusExtensionsType() { }
};
#endif

#ifndef SOAP_TYPE_fims__BMContentStatusesType
#define SOAP_TYPE_fims__BMContentStatusesType (128)
/* fims:BMContentStatusesType */
class SOAP_CMAC fims__BMContentStatusesType
{
public:
	std::vector<class fims__BMContentStatusType * >bmContentStatus;	/* required element of type fims:BMContentStatusType */
	std::vector<char * >__any;
	char *__anyAttribute;	/* optional attribute */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 128; } /* = unique type id SOAP_TYPE_fims__BMContentStatusesType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         fims__BMContentStatusesType() { fims__BMContentStatusesType::soap_default(NULL); }
	virtual ~fims__BMContentStatusesType() { }
};
#endif

#ifndef SOAP_TYPE_fims__BMEssenceLocatorStatusesType
#define SOAP_TYPE_fims__BMEssenceLocatorStatusesType (130)
/* fims:BMEssenceLocatorStatusesType */
class SOAP_CMAC fims__BMEssenceLocatorStatusesType
{
public:
	std::vector<class fims__BMEssenceLocatorStatusType * >bmEssenceLocatorStatus;	/* required element of type fims:BMEssenceLocatorStatusType */
	std::vector<char * >__any;
	char *__anyAttribute;	/* optional attribute */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 130; } /* = unique type id SOAP_TYPE_fims__BMEssenceLocatorStatusesType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         fims__BMEssenceLocatorStatusesType() { fims__BMEssenceLocatorStatusesType::soap_default(NULL); }
	virtual ~fims__BMEssenceLocatorStatusesType() { }
};
#endif

#ifndef SOAP_TYPE_fims__CredentialType
#define SOAP_TYPE_fims__CredentialType (131)
/* fims:CredentialType */
class SOAP_CMAC fims__CredentialType
{
public:
	std::wstring *userName;	/* optional element of type xsd:string */
	std::wstring *password;	/* optional element of type xsd:string */
	std::wstring *sessionToken;	/* optional element of type xsd:string */
	fims__ExtensionGroup *ExtensionGroup;	/* optional element of type fims:ExtensionGroup */
	fims__ExtensionAttributes *ExtensionAttributes;	/* optional element of type fims:ExtensionAttributes */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 131; } /* = unique type id SOAP_TYPE_fims__CredentialType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         fims__CredentialType() { fims__CredentialType::soap_default(NULL); }
	virtual ~fims__CredentialType() { }
};
#endif

#ifndef SOAP_TYPE_fims__CredentialsType
#define SOAP_TYPE_fims__CredentialsType (132)
/* fims:CredentialsType */
class SOAP_CMAC fims__CredentialsType
{
public:
	std::vector<fims__CredentialType * >credential;	/* required element of type fims:CredentialType */
	std::vector<char * >__any;
	char *__anyAttribute;	/* optional attribute */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 132; } /* = unique type id SOAP_TYPE_fims__CredentialsType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         fims__CredentialsType() { fims__CredentialsType::soap_default(NULL); }
	virtual ~fims__CredentialsType() { }
};
#endif

#ifndef SOAP_TYPE_fims__LockTokensType
#define SOAP_TYPE_fims__LockTokensType (134)
/* fims:LockTokensType */
class SOAP_CMAC fims__LockTokensType
{
public:
	std::vector<class fims__LockTokenType * >lockToken;	/* required element of type fims:LockTokenType */
	std::vector<char * >__any;
	char *__anyAttribute;	/* optional attribute */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 134; } /* = unique type id SOAP_TYPE_fims__LockTokensType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         fims__LockTokensType() { fims__LockTokensType::soap_default(NULL); }
	virtual ~fims__LockTokensType() { }
};
#endif

#ifndef SOAP_TYPE_fims__SuperLockTokensType
#define SOAP_TYPE_fims__SuperLockTokensType (136)
/* fims:SuperLockTokensType */
class SOAP_CMAC fims__SuperLockTokensType
{
public:
	std::vector<class fims__SuperLockTokenType * >superLockToken;	/* required element of type fims:SuperLockTokenType */
	std::vector<char * >__any;
	char *__anyAttribute;	/* optional attribute */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 136; } /* = unique type id SOAP_TYPE_fims__SuperLockTokensType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         fims__SuperLockTokensType() { fims__SuperLockTokensType::soap_default(NULL); }
	virtual ~fims__SuperLockTokensType() { }
};
#endif

#ifndef SOAP_TYPE__fims__union_QueryExpressionType
#define SOAP_TYPE__fims__union_QueryExpressionType (288)
/* xsd:choice */
union _fims__union_QueryExpressionType
{
#define SOAP_UNION__fims__union_QueryExpressionType_parameter	(1)
	class fims__QueryParameterType *parameter;
#define SOAP_UNION__fims__union_QueryExpressionType_group	(2)
	class fims__QueryGroupType *group;
};
#endif

#ifndef SOAP_TYPE_fims__QueryExpressionType
#define SOAP_TYPE_fims__QueryExpressionType (137)
/* Choice: */
class SOAP_CMAC fims__QueryExpressionType
{
public:
	int __union_QueryExpressionType;	/* union discriminant (of union defined below) */
	union _fims__union_QueryExpressionType union_QueryExpressionType;	/* required element of type xsd:choice */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 137; } /* = unique type id SOAP_TYPE_fims__QueryExpressionType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         fims__QueryExpressionType() { fims__QueryExpressionType::soap_default(NULL); }
	virtual ~fims__QueryExpressionType() { }
};
#endif

#ifndef SOAP_TYPE_fims__QueryExpressionsType
#define SOAP_TYPE_fims__QueryExpressionsType (138)
/* fims:QueryExpressionsType */
class SOAP_CMAC fims__QueryExpressionsType
{
public:
	std::vector<fims__QueryExpressionType * >queryExpression;	/* required element of type fims:QueryExpressionType */
	std::vector<char * >__any;
	char *__anyAttribute;	/* optional attribute */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 138; } /* = unique type id SOAP_TYPE_fims__QueryExpressionsType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         fims__QueryExpressionsType() { fims__QueryExpressionsType::soap_default(NULL); }
	virtual ~fims__QueryExpressionsType() { }
};
#endif

#ifndef SOAP_TYPE_fims__CustomQueryParameterOperatorType
#define SOAP_TYPE_fims__CustomQueryParameterOperatorType (139)
/* fims:CustomQueryParameterOperatorType */
class SOAP_CMAC fims__CustomQueryParameterOperatorType
{
public:
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 139; } /* = unique type id SOAP_TYPE_fims__CustomQueryParameterOperatorType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         fims__CustomQueryParameterOperatorType() { fims__CustomQueryParameterOperatorType::soap_default(NULL); }
	virtual ~fims__CustomQueryParameterOperatorType() { }
};
#endif

#ifndef SOAP_TYPE_fims__CustomQueryParameterOperatorsType
#define SOAP_TYPE_fims__CustomQueryParameterOperatorsType (140)
/* fims:CustomQueryParameterOperatorsType */
class SOAP_CMAC fims__CustomQueryParameterOperatorsType
{
public:
	std::vector<fims__CustomQueryParameterOperatorType * >customQueryParameterOperator;	/* required element of type fims:CustomQueryParameterOperatorType */
	std::vector<char * >__any;
	char *__anyAttribute;	/* optional attribute */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 140; } /* = unique type id SOAP_TYPE_fims__CustomQueryParameterOperatorsType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         fims__CustomQueryParameterOperatorsType() { fims__CustomQueryParameterOperatorsType::soap_default(NULL); }
	virtual ~fims__CustomQueryParameterOperatorsType() { }
};
#endif

#ifndef SOAP_TYPE__fims__union_QueryParameterType
#define SOAP_TYPE__fims__union_QueryParameterType (294)
/* xsd:choice */
union _fims__union_QueryParameterType
{
#define SOAP_UNION__fims__union_QueryParameterType_value	(1)
	std::wstring *value;
#define SOAP_UNION__fims__union_QueryParameterType_customValue	(2)
	fims__CustomValueType *customValue;
};
#endif

#ifndef SOAP_TYPE__fims__union_QueryParameterType_
#define SOAP_TYPE__fims__union_QueryParameterType_ (295)
/* xsd:choice */
union _fims__union_QueryParameterType_
{
#define SOAP_UNION__fims__union_QueryParameterType__operator_	(1)
	enum fims__QueryParameterOperatorType operator_;
#define SOAP_UNION__fims__union_QueryParameterType__customOperator	(2)
	fims__CustomQueryParameterOperatorType *customOperator;
};
#endif

#ifndef SOAP_TYPE_fims__QueryParameterType
#define SOAP_TYPE_fims__QueryParameterType (141)
/* fims:QueryParameterType */
class SOAP_CMAC fims__QueryParameterType
{
public:
	std::wstring name;	/* required element of type xsd:string */
	bool *caseSensitive;	/* optional element of type xsd:boolean */
	int __union_QueryParameterType;	/* union discriminant (of union defined below) */
	union _fims__union_QueryParameterType union_QueryParameterType;	/* required element of type xsd:choice */
	int __union_QueryParameterType_;	/* union discriminant (of union defined below) */
	union _fims__union_QueryParameterType_ union_QueryParameterType_;	/* required element of type xsd:choice */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 141; } /* = unique type id SOAP_TYPE_fims__QueryParameterType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         fims__QueryParameterType() { fims__QueryParameterType::soap_default(NULL); }
	virtual ~fims__QueryParameterType() { }
};
#endif

#ifndef SOAP_TYPE_fims__QueryParametersType
#define SOAP_TYPE_fims__QueryParametersType (142)
/* fims:QueryParametersType */
class SOAP_CMAC fims__QueryParametersType
{
public:
	std::vector<fims__QueryParameterType * >queryParameter;	/* required element of type fims:QueryParameterType */
	std::vector<char * >__any;
	char *__anyAttribute;	/* optional attribute */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 142; } /* = unique type id SOAP_TYPE_fims__QueryParametersType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         fims__QueryParametersType() { fims__QueryParametersType::soap_default(NULL); }
	virtual ~fims__QueryParametersType() { }
};
#endif

#ifndef SOAP_TYPE_fims__CustomQueryGroupOperatorType
#define SOAP_TYPE_fims__CustomQueryGroupOperatorType (143)
/* fims:CustomQueryGroupOperatorType */
class SOAP_CMAC fims__CustomQueryGroupOperatorType
{
public:
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 143; } /* = unique type id SOAP_TYPE_fims__CustomQueryGroupOperatorType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         fims__CustomQueryGroupOperatorType() { fims__CustomQueryGroupOperatorType::soap_default(NULL); }
	virtual ~fims__CustomQueryGroupOperatorType() { }
};
#endif

#ifndef SOAP_TYPE_fims__CustomQueryGroupOperatorsType
#define SOAP_TYPE_fims__CustomQueryGroupOperatorsType (144)
/* fims:CustomQueryGroupOperatorsType */
class SOAP_CMAC fims__CustomQueryGroupOperatorsType
{
public:
	std::vector<fims__CustomQueryGroupOperatorType * >customQueryGroupOperator;	/* required element of type fims:CustomQueryGroupOperatorType */
	std::vector<char * >__any;
	char *__anyAttribute;	/* optional attribute */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 144; } /* = unique type id SOAP_TYPE_fims__CustomQueryGroupOperatorsType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         fims__CustomQueryGroupOperatorsType() { fims__CustomQueryGroupOperatorsType::soap_default(NULL); }
	virtual ~fims__CustomQueryGroupOperatorsType() { }
};
#endif

#ifndef SOAP_TYPE__fims__union_QueryGroupType
#define SOAP_TYPE__fims__union_QueryGroupType (301)
/* xsd:choice */
union _fims__union_QueryGroupType
{
#define SOAP_UNION__fims__union_QueryGroupType_operator_	(1)
	enum fims__QueryGroupOperatorType operator_;
#define SOAP_UNION__fims__union_QueryGroupType_customOperator	(2)
	fims__CustomQueryGroupOperatorType *customOperator;
};
#endif

#ifndef SOAP_TYPE_fims__QueryGroupType
#define SOAP_TYPE_fims__QueryGroupType (145)
/* fims:QueryGroupType */
class SOAP_CMAC fims__QueryGroupType
{
public:
	fims__QueryParametersType *parameters;	/* optional element of type fims:QueryParametersType */
	class fims__QueryGroupsType *groups;	/* optional element of type fims:QueryGroupsType */
	int __union_QueryGroupType;	/* union discriminant (of union defined below) */
	union _fims__union_QueryGroupType union_QueryGroupType;	/* required element of type xsd:choice */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 145; } /* = unique type id SOAP_TYPE_fims__QueryGroupType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         fims__QueryGroupType() { fims__QueryGroupType::soap_default(NULL); }
	virtual ~fims__QueryGroupType() { }
};
#endif

#ifndef SOAP_TYPE_fims__QueryGroupsType
#define SOAP_TYPE_fims__QueryGroupsType (146)
/* fims:QueryGroupsType */
class SOAP_CMAC fims__QueryGroupsType
{
public:
	std::vector<fims__QueryGroupType * >queryGroup;	/* required element of type fims:QueryGroupType */
	std::vector<char * >__any;
	char *__anyAttribute;	/* optional attribute */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 146; } /* = unique type id SOAP_TYPE_fims__QueryGroupsType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         fims__QueryGroupsType() { fims__QueryGroupsType::soap_default(NULL); }
	virtual ~fims__QueryGroupsType() { }
};
#endif

#ifndef SOAP_TYPE_fims__CustomEventTemplateType
#define SOAP_TYPE_fims__CustomEventTemplateType (147)
/* fims:CustomEventTemplateType */
class SOAP_CMAC fims__CustomEventTemplateType
{
public:
	std::wstring *templateID;	/* optional element of type fims:ResourceIDType */
	std::wstring name;	/* required element of type xsd:string */
	fims__QueryExpressionsType *parameters;	/* optional element of type fims:QueryExpressionsType */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 147; } /* = unique type id SOAP_TYPE_fims__CustomEventTemplateType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         fims__CustomEventTemplateType() { fims__CustomEventTemplateType::soap_default(NULL); }
	virtual ~fims__CustomEventTemplateType() { }
};
#endif

#ifndef SOAP_TYPE_fims__CustomEventTemplatesType
#define SOAP_TYPE_fims__CustomEventTemplatesType (148)
/* fims:CustomEventTemplatesType */
class SOAP_CMAC fims__CustomEventTemplatesType
{
public:
	std::vector<fims__CustomEventTemplateType * >customEventTemplate;	/* required element of type fims:CustomEventTemplateType */
	std::vector<char * >__any;
	char *__anyAttribute;	/* optional attribute */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 148; } /* = unique type id SOAP_TYPE_fims__CustomEventTemplatesType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         fims__CustomEventTemplatesType() { fims__CustomEventTemplatesType::soap_default(NULL); }
	virtual ~fims__CustomEventTemplatesType() { }
};
#endif

#ifndef SOAP_TYPE_fims__EventEnvelopeType
#define SOAP_TYPE_fims__EventEnvelopeType (149)
/* fims:EventEnvelopeType */
class SOAP_CMAC fims__EventEnvelopeType
{
public:
	time_t *timestamp;	/* optional element of type xsd:dateTime */
	enum fims__EventType *eventType;	/* optional element of type fims:EventType */
	enum fims__EventSubType *eventSubType;	/* optional element of type fims:EventSubType */
	enum fims__EventClassificationType *eventClassification;	/* optional element of type fims:EventClassificationType */
	class fims__EventPayloadType *eventPayload;	/* optional element of type fims:EventPayloadType */
	enum fims__CurrentVersion version;	/* required attribute */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 149; } /* = unique type id SOAP_TYPE_fims__EventEnvelopeType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         fims__EventEnvelopeType() { fims__EventEnvelopeType::soap_default(NULL); }
	virtual ~fims__EventEnvelopeType() { }
};
#endif

#ifndef SOAP_TYPE_fims__EventEnvelopesType
#define SOAP_TYPE_fims__EventEnvelopesType (150)
/* fims:EventEnvelopesType */
class SOAP_CMAC fims__EventEnvelopesType
{
public:
	std::vector<fims__EventEnvelopeType * >eventEnvelope;	/* required element of type fims:EventEnvelopeType */
	std::vector<char * >__any;
	char *__anyAttribute;	/* optional attribute */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 150; } /* = unique type id SOAP_TYPE_fims__EventEnvelopesType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         fims__EventEnvelopesType() { fims__EventEnvelopesType::soap_default(NULL); }
	virtual ~fims__EventEnvelopesType() { }
};
#endif

#ifndef SOAP_TYPE_fims__EventPayloadType
#define SOAP_TYPE_fims__EventPayloadType (151)
/* fims:EventPayloadType */
class SOAP_CMAC fims__EventPayloadType
{
public:
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 151; } /* = unique type id SOAP_TYPE_fims__EventPayloadType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         fims__EventPayloadType() { fims__EventPayloadType::soap_default(NULL); }
	virtual ~fims__EventPayloadType() { }
};
#endif

#ifndef SOAP_TYPE_fims__EventPayloadsType
#define SOAP_TYPE_fims__EventPayloadsType (152)
/* fims:EventPayloadsType */
class SOAP_CMAC fims__EventPayloadsType
{
public:
	std::vector<fims__EventPayloadType * >eventPayload;	/* required element of type fims:EventPayloadType */
	std::vector<char * >__any;
	char *__anyAttribute;	/* optional attribute */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 152; } /* = unique type id SOAP_TYPE_fims__EventPayloadsType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         fims__EventPayloadsType() { fims__EventPayloadsType::soap_default(NULL); }
	virtual ~fims__EventPayloadsType() { }
};
#endif

#ifndef SOAP_TYPE_fims__ContentEventsType
#define SOAP_TYPE_fims__ContentEventsType (154)
/* fims:ContentEventsType */
class SOAP_CMAC fims__ContentEventsType
{
public:
	std::vector<class fims__ContentEventType * >contentEvent;	/* required element of type fims:ContentEventType */
	std::vector<char * >__any;
	char *__anyAttribute;	/* optional attribute */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 154; } /* = unique type id SOAP_TYPE_fims__ContentEventsType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         fims__ContentEventsType() { fims__ContentEventsType::soap_default(NULL); }
	virtual ~fims__ContentEventsType() { }
};
#endif

#ifndef SOAP_TYPE_fims__ContentStatusEventsType
#define SOAP_TYPE_fims__ContentStatusEventsType (156)
/* fims:ContentStatusEventsType */
class SOAP_CMAC fims__ContentStatusEventsType
{
public:
	std::vector<class fims__ContentStatusEventType * >contentStatusEvent;	/* required element of type fims:ContentStatusEventType */
	std::vector<char * >__any;
	char *__anyAttribute;	/* optional attribute */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 156; } /* = unique type id SOAP_TYPE_fims__ContentStatusEventsType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         fims__ContentStatusEventsType() { fims__ContentStatusEventsType::soap_default(NULL); }
	virtual ~fims__ContentStatusEventsType() { }
};
#endif

#ifndef SOAP_TYPE_fims__ContentCustomEventsType
#define SOAP_TYPE_fims__ContentCustomEventsType (158)
/* fims:ContentCustomEventsType */
class SOAP_CMAC fims__ContentCustomEventsType
{
public:
	std::vector<class fims__ContentCustomEventType * >contentCustomEvent;	/* required element of type fims:ContentCustomEventType */
	std::vector<char * >__any;
	char *__anyAttribute;	/* optional attribute */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 158; } /* = unique type id SOAP_TYPE_fims__ContentCustomEventsType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         fims__ContentCustomEventsType() { fims__ContentCustomEventsType::soap_default(NULL); }
	virtual ~fims__ContentCustomEventsType() { }
};
#endif

#ifndef SOAP_TYPE_fims__SystemEventsType
#define SOAP_TYPE_fims__SystemEventsType (160)
/* fims:SystemEventsType */
class SOAP_CMAC fims__SystemEventsType
{
public:
	std::vector<class fims__SystemEventType * >systemEvent;	/* required element of type fims:SystemEventType */
	std::vector<char * >__any;
	char *__anyAttribute;	/* optional attribute */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 160; } /* = unique type id SOAP_TYPE_fims__SystemEventsType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         fims__SystemEventsType() { fims__SystemEventsType::soap_default(NULL); }
	virtual ~fims__SystemEventsType() { }
};
#endif

#ifndef SOAP_TYPE_fims__SystemExceptionEventsType
#define SOAP_TYPE_fims__SystemExceptionEventsType (162)
/* fims:SystemExceptionEventsType */
class SOAP_CMAC fims__SystemExceptionEventsType
{
public:
	std::vector<class fims__SystemExceptionEventType * >systemExceptionEvent;	/* required element of type fims:SystemExceptionEventType */
	std::vector<char * >__any;
	char *__anyAttribute;	/* optional attribute */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 162; } /* = unique type id SOAP_TYPE_fims__SystemExceptionEventsType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         fims__SystemExceptionEventsType() { fims__SystemExceptionEventsType::soap_default(NULL); }
	virtual ~fims__SystemExceptionEventsType() { }
};
#endif

#ifndef SOAP_TYPE_fims__SystemPerformanceEventsType
#define SOAP_TYPE_fims__SystemPerformanceEventsType (164)
/* fims:SystemPerformanceEventsType */
class SOAP_CMAC fims__SystemPerformanceEventsType
{
public:
	std::vector<class fims__SystemPerformanceEventType * >systemPerformanceEvent;	/* required element of type fims:SystemPerformanceEventType */
	std::vector<char * >__any;
	char *__anyAttribute;	/* optional attribute */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 164; } /* = unique type id SOAP_TYPE_fims__SystemPerformanceEventsType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         fims__SystemPerformanceEventsType() { fims__SystemPerformanceEventsType::soap_default(NULL); }
	virtual ~fims__SystemPerformanceEventsType() { }
};
#endif

#ifndef SOAP_TYPE__fims__formatCollection
#define SOAP_TYPE__fims__formatCollection (165)
/* fims:formatCollection */
class SOAP_CMAC _fims__formatCollection
{
public:
	fims__VideoFormatType *videoFormat;	/* optional element of type fims:VideoFormatType */
	fims__AudioFormatType *audioFormat;	/* optional element of type fims:AudioFormatType */
	fims__DataFormatType *dataFormat;	/* optional element of type fims:DataFormatType */
	fims__ContainerFormatType *containerFormat;	/* optional element of type fims:ContainerFormatType */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 165; } /* = unique type id SOAP_TYPE__fims__formatCollection */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _fims__formatCollection() { _fims__formatCollection::soap_default(NULL); }
	virtual ~_fims__formatCollection() { }
};
#endif

#ifndef SOAP_TYPE__fimstime__union_DurationType
#define SOAP_TYPE__fimstime__union_DurationType (329)
/* xsd:choice */
union _fimstime__union_DurationType
{
#define SOAP_UNION__fimstime__union_DurationType_timecode	(1)
	std::wstring *timecode;
#define SOAP_UNION__fimstime__union_DurationType_normalPlayTime	(2)
	LONG64 *normalPlayTime;
#define SOAP_UNION__fimstime__union_DurationType_editUnitNumber	(3)
	class fimstime__EditUnitNumberType *editUnitNumber;
};
#endif

#ifndef SOAP_TYPE_fimstime__DurationType
#define SOAP_TYPE_fimstime__DurationType (166)
/* Choice: */
class SOAP_CMAC fimstime__DurationType
{
public:
	int __union_DurationType;	/* union discriminant (of union defined below) */
	union _fimstime__union_DurationType union_DurationType;	/* required element of type xsd:choice */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 166; } /* = unique type id SOAP_TYPE_fimstime__DurationType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         fimstime__DurationType() { fimstime__DurationType::soap_default(NULL); }
	virtual ~fimstime__DurationType() { }
};
#endif

#ifndef SOAP_TYPE__fimstime__union_TimeType
#define SOAP_TYPE__fimstime__union_TimeType (332)
/* xsd:choice */
union _fimstime__union_TimeType
{
#define SOAP_UNION__fimstime__union_TimeType_timecode	(1)
	std::wstring *timecode;
#define SOAP_UNION__fimstime__union_TimeType_normalPlayTime	(2)
	std::wstring *normalPlayTime;
#define SOAP_UNION__fimstime__union_TimeType_editUnitNumber	(3)
	fimstime__EditUnitNumberType *editUnitNumber;
};
#endif

#ifndef SOAP_TYPE_fimstime__TimeType
#define SOAP_TYPE_fimstime__TimeType (167)
/* Choice: */
class SOAP_CMAC fimstime__TimeType
{
public:
	int __union_TimeType;	/* union discriminant (of union defined below) */
	union _fimstime__union_TimeType union_TimeType;	/* required element of type xsd:choice */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 167; } /* = unique type id SOAP_TYPE_fimstime__TimeType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         fimstime__TimeType() { fimstime__TimeType::soap_default(NULL); }
	virtual ~fimstime__TimeType() { }
};
#endif

#ifndef SOAP_TYPE_fimsdescription__bmContentDescriptionType
#define SOAP_TYPE_fimsdescription__bmContentDescriptionType (169)
/* fimsdescription:bmContentDescriptionType */
class SOAP_CMAC fimsdescription__bmContentDescriptionType
{
public:
	std::vector<class fimsdescription__textElementType * >title;	/* optional element of type fimsdescription:textElementType */
	std::vector<class fimsdescription__titleType * >alternativeTitle;	/* optional element of type fimsdescription:titleType */
	std::vector<class fimsdescription__entityType * >creator;	/* optional element of type fimsdescription:entityType */
	std::vector<class fimsdescription__subjectType * >subject;	/* optional element of type fimsdescription:subjectType */
	std::vector<class fimsdescription__descriptionType * >description;	/* optional element of type fimsdescription:descriptionType */
	std::vector<fimsdescription__entityType * >publisher;	/* optional element of type fimsdescription:entityType */
	std::vector<fimsdescription__entityType * >contributor;	/* optional element of type fimsdescription:entityType */
	std::vector<class fimsdescription__dateType * >date;	/* optional element of type fimsdescription:dateType */
	std::vector<class fimsdescription__typeType * >type;	/* optional element of type fimsdescription:typeType */
	std::vector<class fimsdescription__identifierType * >identifier;	/* optional element of type fimsdescription:identifierType */
	std::vector<class fimsdescription__languageType * >language;	/* optional element of type fimsdescription:languageType */
	std::vector<class fimsdescription__relationType * >relation;	/* optional element of type fimsdescription:relationType */
	std::vector<fimsdescription__relationType * >isVersionOf;	/* optional element of type fimsdescription:relationType */
	std::vector<fimsdescription__relationType * >hasVersion;	/* optional element of type fimsdescription:relationType */
	std::vector<fimsdescription__relationType * >isReplacedBy;	/* optional element of type fimsdescription:relationType */
	std::vector<fimsdescription__relationType * >replaces;	/* optional element of type fimsdescription:relationType */
	std::vector<fimsdescription__relationType * >isRequiredBy;	/* optional element of type fimsdescription:relationType */
	std::vector<fimsdescription__relationType * >requires;	/* optional element of type fimsdescription:relationType */
	std::vector<fimsdescription__relationType * >isPartOf;	/* optional element of type fimsdescription:relationType */
	std::vector<fimsdescription__relationType * >hasPart;	/* optional element of type fimsdescription:relationType */
	std::vector<fimsdescription__relationType * >isReferencedBy;	/* optional element of type fimsdescription:relationType */
	std::vector<fimsdescription__relationType * >references;	/* optional element of type fimsdescription:relationType */
	std::vector<fimsdescription__relationType * >isFormatOf;	/* optional element of type fimsdescription:relationType */
	std::vector<fimsdescription__relationType * >hasFormat;	/* optional element of type fimsdescription:relationType */
	std::vector<fimsdescription__relationType * >isEpisodeOf;	/* optional element of type fimsdescription:relationType */
	std::vector<fimsdescription__relationType * >isMemberOf;	/* optional element of type fimsdescription:relationType */
	std::vector<fimsdescription__relationType * >hasMembers;	/* optional element of type fimsdescription:relationType */
	std::vector<class fimsdescription__coverageType * >coverage;	/* optional element of type fimsdescription:coverageType */
	std::vector<class fimsdescription__rightsType * >rights;	/* optional element of type fimsdescription:rightsType */
	std::wstring *version;	/* optional element of type xsd:string */
	std::vector<class fimsdescription__partType * >part;	/* optional element of type fimsdescription:partType */
	std::wstring *xml__lang;	/* optional attribute */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 169; } /* = unique type id SOAP_TYPE_fimsdescription__bmContentDescriptionType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         fimsdescription__bmContentDescriptionType() { fimsdescription__bmContentDescriptionType::soap_default(NULL); }
	virtual ~fimsdescription__bmContentDescriptionType() { }
};
#endif

#ifndef SOAP_TYPE__fimsdescription__typeType_genre
#define SOAP_TYPE__fimsdescription__typeType_genre (360)
/* fimsdescription:typeType-genre */
class SOAP_CMAC _fimsdescription__typeType_genre
{
public:
	std::wstring *typeLabel;	/* optional attribute */
	std::wstring *typeDefinition;	/* optional attribute */
	std::wstring *typeLink;	/* optional attribute */
	std::wstring *typeLanguage;	/* optional attribute */
public:
	virtual int soap_type() const { return 360; } /* = unique type id SOAP_TYPE__fimsdescription__typeType_genre */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _fimsdescription__typeType_genre() { _fimsdescription__typeType_genre::soap_default(NULL); }
	virtual ~_fimsdescription__typeType_genre() { }
};
#endif

#ifndef SOAP_TYPE__fimsdescription__typeType_objectType
#define SOAP_TYPE__fimsdescription__typeType_objectType (363)
/* fimsdescription:typeType-objectType */
class SOAP_CMAC _fimsdescription__typeType_objectType
{
public:
	std::wstring *typeLabel;	/* optional attribute */
	std::wstring *typeDefinition;	/* optional attribute */
	std::wstring *typeLink;	/* optional attribute */
	std::wstring *typeLanguage;	/* optional attribute */
public:
	virtual int soap_type() const { return 363; } /* = unique type id SOAP_TYPE__fimsdescription__typeType_objectType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _fimsdescription__typeType_objectType() { _fimsdescription__typeType_objectType::soap_default(NULL); }
	virtual ~_fimsdescription__typeType_objectType() { }
};
#endif

#ifndef SOAP_TYPE__fimsdescription__typeType_targetAudience
#define SOAP_TYPE__fimsdescription__typeType_targetAudience (366)
/* fimsdescription:typeType-targetAudience */
class SOAP_CMAC _fimsdescription__typeType_targetAudience
{
public:
	std::wstring *typeLabel;	/* optional attribute */
	std::wstring *typeDefinition;	/* optional attribute */
	std::wstring *typeLink;	/* optional attribute */
	std::wstring *typeLanguage;	/* optional attribute */
public:
	virtual int soap_type() const { return 366; } /* = unique type id SOAP_TYPE__fimsdescription__typeType_targetAudience */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _fimsdescription__typeType_targetAudience() { _fimsdescription__typeType_targetAudience::soap_default(NULL); }
	virtual ~_fimsdescription__typeType_targetAudience() { }
};
#endif

#ifndef SOAP_TYPE_fimsdescription__typeType
#define SOAP_TYPE_fimsdescription__typeType (173)
/* fimsdescription:typeType */
class SOAP_CMAC fimsdescription__typeType
{
public:
	std::vector<_fimsdescription__typeType_genre >*genre;	/* optional element of type fimsdescription:typeType-genre */
	std::vector<_fimsdescription__typeType_objectType >*objectType;	/* optional element of type fimsdescription:typeType-objectType */
	std::vector<_fimsdescription__typeType_targetAudience >*targetAudience;	/* optional element of type fimsdescription:typeType-targetAudience */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 173; } /* = unique type id SOAP_TYPE_fimsdescription__typeType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         fimsdescription__typeType() { fimsdescription__typeType::soap_default(NULL); }
	virtual ~fimsdescription__typeType() { }
};
#endif

#ifndef SOAP_TYPE__fimsdescription__coverageType_temporal
#define SOAP_TYPE__fimsdescription__coverageType_temporal (369)
/* fimsdescription:coverageType-temporal */
class SOAP_CMAC _fimsdescription__coverageType_temporal
{
public:
	std::wstring *typeLabel;	/* optional attribute */
	std::wstring *typeDefinition;	/* optional attribute */
	std::wstring *typeLink;	/* optional attribute */
	std::wstring *typeLanguage;	/* optional attribute */
public:
	virtual int soap_type() const { return 369; } /* = unique type id SOAP_TYPE__fimsdescription__coverageType_temporal */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _fimsdescription__coverageType_temporal() { _fimsdescription__coverageType_temporal::soap_default(NULL); }
	virtual ~_fimsdescription__coverageType_temporal() { }
};
#endif

#ifndef SOAP_TYPE__fimsdescription__coverageType_spatial_locationName
#define SOAP_TYPE__fimsdescription__coverageType_spatial_locationName (372)
/* fimsdescription:coverageType-spatial-locationName */
class SOAP_CMAC _fimsdescription__coverageType_spatial_locationName
{
public:
	std::wstring *typeLabel;	/* optional attribute */
	std::wstring *typeDefinition;	/* optional attribute */
	std::wstring *typeLink;	/* optional attribute */
	std::wstring *typeLanguage;	/* optional attribute */
public:
	virtual int soap_type() const { return 372; } /* = unique type id SOAP_TYPE__fimsdescription__coverageType_spatial_locationName */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _fimsdescription__coverageType_spatial_locationName() { _fimsdescription__coverageType_spatial_locationName::soap_default(NULL); }
	virtual ~_fimsdescription__coverageType_spatial_locationName() { }
};
#endif

#ifndef SOAP_TYPE__fimsdescription__coverageType_spatial_coordinates
#define SOAP_TYPE__fimsdescription__coverageType_spatial_coordinates (373)
/* fimsdescription:coverageType-spatial-coordinates */
class SOAP_CMAC _fimsdescription__coverageType_spatial_coordinates
{
public:
	float posy;	/* required element of type xsd:float */
	float posx;	/* required element of type xsd:float */
	std::wstring *formatLabel;	/* optional attribute */
	std::wstring *formatDefinition;	/* optional attribute */
	std::wstring *formatLink;	/* optional attribute */
	std::wstring *formatLanguage;	/* optional attribute */
public:
	virtual int soap_type() const { return 373; } /* = unique type id SOAP_TYPE__fimsdescription__coverageType_spatial_coordinates */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _fimsdescription__coverageType_spatial_coordinates() { _fimsdescription__coverageType_spatial_coordinates::soap_default(NULL); }
	virtual ~_fimsdescription__coverageType_spatial_coordinates() { }
};
#endif

#ifndef SOAP_TYPE__fimsdescription__coverageType_spatial
#define SOAP_TYPE__fimsdescription__coverageType_spatial (371)
/* fimsdescription:coverageType-spatial */
class SOAP_CMAC _fimsdescription__coverageType_spatial
{
public:
	_fimsdescription__coverageType_spatial_locationName locationName;	/* required element of type fimsdescription:coverageType-spatial-locationName */
	_fimsdescription__coverageType_spatial_coordinates *coordinates;	/* optional element of type fimsdescription:coverageType-spatial-coordinates */
public:
	virtual int soap_type() const { return 371; } /* = unique type id SOAP_TYPE__fimsdescription__coverageType_spatial */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _fimsdescription__coverageType_spatial() { _fimsdescription__coverageType_spatial::soap_default(NULL); }
	virtual ~_fimsdescription__coverageType_spatial() { }
};
#endif

#ifndef SOAP_TYPE_fimsdescription__coverageType
#define SOAP_TYPE_fimsdescription__coverageType (175)
/* fimsdescription:coverageType */
class SOAP_CMAC fimsdescription__coverageType
{
public:
	_fimsdescription__coverageType_temporal *temporal;	/* optional element of type fimsdescription:coverageType-temporal */
	_fimsdescription__coverageType_spatial *spatial;	/* optional element of type fimsdescription:coverageType-spatial */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 175; } /* = unique type id SOAP_TYPE_fimsdescription__coverageType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         fimsdescription__coverageType() { fimsdescription__coverageType::soap_default(NULL); }
	virtual ~fimsdescription__coverageType() { }
};
#endif

#ifndef SOAP_TYPE_fimsdescription__rightsType
#define SOAP_TYPE_fimsdescription__rightsType (176)
/* fimsdescription:rightsType */
class SOAP_CMAC fimsdescription__rightsType
{
public:
	std::vector<fimsdescription__textElementType * >rightsExpression;	/* optional element of type fimsdescription:textElementType */
	std::wstring *rightsLink;	/* optional element of type xsd:anyURI */
	fimsdescription__entityType *rightsHolder;	/* optional element of type fimsdescription:entityType */
	fimsdescription__textElementType *exploitationIssues;	/* optional element of type fimsdescription:textElementType */
	fimsdescription__coverageType *coverage;	/* optional element of type fimsdescription:coverageType */
	bool *rightsClearanceFlag;	/* optional element of type xsd:boolean */
	std::vector<fimsdescription__textElementType * >disclaimer;	/* optional element of type fimsdescription:textElementType */
	std::vector<fimsdescription__identifierType * >rightsId;	/* optional element of type fimsdescription:identifierType */
	std::vector<class fimsdescription__contactDetailsType * >contactDetails;	/* optional element of type fimsdescription:contactDetailsType */
	std::wstring *typeLabel;	/* optional attribute */
	std::wstring *typeDefinition;	/* optional attribute */
	std::wstring *typeLink;	/* optional attribute */
	std::wstring *typeLanguage;	/* optional attribute */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 176; } /* = unique type id SOAP_TYPE_fimsdescription__rightsType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         fimsdescription__rightsType() { fimsdescription__rightsType::soap_default(NULL); }
	virtual ~fimsdescription__rightsType() { }
};
#endif

#ifndef SOAP_TYPE__fimsdescription__dateType_created
#define SOAP_TYPE__fimsdescription__dateType_created (379)
/* fimsdescription:dateType-created */
class SOAP_CMAC _fimsdescription__dateType_created
{
public:
	std::wstring *startYear;	/* optional attribute */
	std::wstring *startDate;	/* optional attribute */
	std::wstring *startTime;	/* optional attribute */
	std::wstring *endYear;	/* optional attribute */
	std::wstring *endDate;	/* optional attribute */
	std::wstring *endTime;	/* optional attribute */
	std::wstring *period;	/* optional attribute */
public:
	virtual int soap_type() const { return 379; } /* = unique type id SOAP_TYPE__fimsdescription__dateType_created */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _fimsdescription__dateType_created() { _fimsdescription__dateType_created::soap_default(NULL); }
	virtual ~_fimsdescription__dateType_created() { }
};
#endif

#ifndef SOAP_TYPE__fimsdescription__dateType_modified
#define SOAP_TYPE__fimsdescription__dateType_modified (383)
/* fimsdescription:dateType-modified */
class SOAP_CMAC _fimsdescription__dateType_modified
{
public:
	std::wstring *startYear;	/* optional attribute */
	std::wstring *startDate;	/* optional attribute */
	std::wstring *startTime;	/* optional attribute */
	std::wstring *endYear;	/* optional attribute */
	std::wstring *endDate;	/* optional attribute */
	std::wstring *endTime;	/* optional attribute */
	std::wstring *period;	/* optional attribute */
public:
	virtual int soap_type() const { return 383; } /* = unique type id SOAP_TYPE__fimsdescription__dateType_modified */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _fimsdescription__dateType_modified() { _fimsdescription__dateType_modified::soap_default(NULL); }
	virtual ~_fimsdescription__dateType_modified() { }
};
#endif

#ifndef SOAP_TYPE__fimsdescription__dateType_issued
#define SOAP_TYPE__fimsdescription__dateType_issued (385)
/* fimsdescription:dateType-issued */
class SOAP_CMAC _fimsdescription__dateType_issued
{
public:
	std::wstring *startYear;	/* optional attribute */
	std::wstring *startDate;	/* optional attribute */
	std::wstring *startTime;	/* optional attribute */
	std::wstring *endYear;	/* optional attribute */
	std::wstring *endDate;	/* optional attribute */
	std::wstring *endTime;	/* optional attribute */
	std::wstring *period;	/* optional attribute */
public:
	virtual int soap_type() const { return 385; } /* = unique type id SOAP_TYPE__fimsdescription__dateType_issued */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _fimsdescription__dateType_issued() { _fimsdescription__dateType_issued::soap_default(NULL); }
	virtual ~_fimsdescription__dateType_issued() { }
};
#endif

#ifndef SOAP_TYPE__fimsdescription__dateType_alternative
#define SOAP_TYPE__fimsdescription__dateType_alternative (387)
/* fimsdescription:dateType-alternative */
class SOAP_CMAC _fimsdescription__dateType_alternative
{
public:
	std::wstring *startYear;	/* optional attribute */
	std::wstring *startDate;	/* optional attribute */
	std::wstring *startTime;	/* optional attribute */
	std::wstring *endYear;	/* optional attribute */
	std::wstring *endDate;	/* optional attribute */
	std::wstring *endTime;	/* optional attribute */
	std::wstring *period;	/* optional attribute */
	std::wstring *typeLabel;	/* optional attribute */
	std::wstring *typeDefinition;	/* optional attribute */
	std::wstring *typeLink;	/* optional attribute */
	std::wstring *typeLanguage;	/* optional attribute */
public:
	virtual int soap_type() const { return 387; } /* = unique type id SOAP_TYPE__fimsdescription__dateType_alternative */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _fimsdescription__dateType_alternative() { _fimsdescription__dateType_alternative::soap_default(NULL); }
	virtual ~_fimsdescription__dateType_alternative() { }
};
#endif

#ifndef SOAP_TYPE_fimsdescription__dateType
#define SOAP_TYPE_fimsdescription__dateType (178)
/* fimsdescription:dateType */
class SOAP_CMAC fimsdescription__dateType
{
public:
	_fimsdescription__dateType_created *created;	/* optional element of type fimsdescription:dateType-created */
	_fimsdescription__dateType_modified *modified;	/* optional element of type fimsdescription:dateType-modified */
	_fimsdescription__dateType_issued *issued;	/* optional element of type fimsdescription:dateType-issued */
	_fimsdescription__dateType_alternative *alternative;	/* optional element of type fimsdescription:dateType-alternative */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 178; } /* = unique type id SOAP_TYPE_fimsdescription__dateType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         fimsdescription__dateType() { fimsdescription__dateType::soap_default(NULL); }
	virtual ~fimsdescription__dateType() { }
};
#endif

#ifndef SOAP_TYPE__fimsdescription__entityType_role
#define SOAP_TYPE__fimsdescription__entityType_role (391)
/* fimsdescription:entityType-role */
class SOAP_CMAC _fimsdescription__entityType_role
{
public:
	std::wstring *typeLabel;	/* optional attribute */
	std::wstring *typeDefinition;	/* optional attribute */
	std::wstring *typeLink;	/* optional attribute */
	std::wstring *typeLanguage;	/* optional attribute */
public:
	virtual int soap_type() const { return 391; } /* = unique type id SOAP_TYPE__fimsdescription__entityType_role */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _fimsdescription__entityType_role() { _fimsdescription__entityType_role::soap_default(NULL); }
	virtual ~_fimsdescription__entityType_role() { }
};
#endif

#ifndef SOAP_TYPE_fimsdescription__entityType
#define SOAP_TYPE_fimsdescription__entityType (179)
/* fimsdescription:entityType */
class SOAP_CMAC fimsdescription__entityType
{
public:
	std::vector<fimsdescription__contactDetailsType * >contactDetails;	/* optional element of type fimsdescription:contactDetailsType */
	std::vector<class fimsdescription__organisationDetailsType * >organisationDetails;	/* optional element of type fimsdescription:organisationDetailsType */
	std::vector<_fimsdescription__entityType_role >*role;	/* optional element of type fimsdescription:entityType-role */
	std::wstring *entityId;	/* optional attribute */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 179; } /* = unique type id SOAP_TYPE_fimsdescription__entityType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         fimsdescription__entityType() { fimsdescription__entityType::soap_default(NULL); }
	virtual ~fimsdescription__entityType() { }
};
#endif

#ifndef SOAP_TYPE_fimsdescription__contactDetailsType
#define SOAP_TYPE_fimsdescription__contactDetailsType (180)
/* fimsdescription:contactDetailsType */
class SOAP_CMAC fimsdescription__contactDetailsType
{
public:
	std::wstring *name;	/* optional element of type xsd:string */
	std::wstring *givenName;	/* optional element of type xsd:string */
	std::wstring *familyName;	/* optional element of type xsd:string */
	std::vector<std::wstring >otherGivenName;	/* optional element of type xsd:string */
	std::wstring *suffix;	/* optional element of type xsd:string */
	std::wstring *salutation;	/* optional element of type xsd:string */
	std::vector<fimsdescription__textElementType * >username;	/* optional element of type fimsdescription:textElementType */
	fimsdescription__textElementType *occupation;	/* optional element of type fimsdescription:textElementType */
	std::vector<class fimsdescription__detailsType * >details;	/* optional element of type fimsdescription:detailsType */
	std::vector<fimsdescription__textElementType * >stageName;	/* optional element of type fimsdescription:textElementType */
	std::vector<fimsdescription__entityType * >relatedContacts;	/* optional element of type fimsdescription:entityType */
	std::wstring *contactId;	/* optional attribute */
	std::wstring *typeLabel;	/* optional attribute */
	std::wstring *typeDefinition;	/* optional attribute */
	std::wstring *typeLink;	/* optional attribute */
	std::wstring *typeLanguage;	/* optional attribute */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 180; } /* = unique type id SOAP_TYPE_fimsdescription__contactDetailsType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         fimsdescription__contactDetailsType() { fimsdescription__contactDetailsType::soap_default(NULL); }
	virtual ~fimsdescription__contactDetailsType() { }
};
#endif

#ifndef SOAP_TYPE__fimsdescription__organisationDetailsType_organisationDepartment
#define SOAP_TYPE__fimsdescription__organisationDetailsType_organisationDepartment (397)
/* fimsdescription:organisationDetailsType-organisationDepartment */
class SOAP_CMAC _fimsdescription__organisationDetailsType_organisationDepartment
{
public:
	std::wstring *departmentId;	/* optional attribute */
public:
	virtual int soap_type() const { return 397; } /* = unique type id SOAP_TYPE__fimsdescription__organisationDetailsType_organisationDepartment */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _fimsdescription__organisationDetailsType_organisationDepartment() { _fimsdescription__organisationDetailsType_organisationDepartment::soap_default(NULL); }
	virtual ~_fimsdescription__organisationDetailsType_organisationDepartment() { }
};
#endif

#ifndef SOAP_TYPE_fimsdescription__organisationDetailsType
#define SOAP_TYPE_fimsdescription__organisationDetailsType (181)
/* fimsdescription:organisationDetailsType */
class SOAP_CMAC fimsdescription__organisationDetailsType
{
public:
	std::vector<fimsdescription__textElementType * >organisationName;	/* optional element of type fimsdescription:textElementType */
	std::vector<std::wstring >organisationCode;	/* optional element of type xsd:anyURI */
	_fimsdescription__organisationDetailsType_organisationDepartment *organisationDepartment;	/* optional element of type fimsdescription:organisationDetailsType-organisationDepartment */
	std::vector<fimsdescription__detailsType * >details;	/* optional element of type fimsdescription:detailsType */
	std::vector<fimsdescription__entityType * >contacts;	/* optional element of type fimsdescription:entityType */
	std::wstring *organisationId;	/* optional attribute */
	std::wstring *typeLabel;	/* optional attribute */
	std::wstring *typeDefinition;	/* optional attribute */
	std::wstring *typeLink;	/* optional attribute */
	std::wstring *typeLanguage;	/* optional attribute */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 181; } /* = unique type id SOAP_TYPE_fimsdescription__organisationDetailsType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         fimsdescription__organisationDetailsType() { fimsdescription__organisationDetailsType::soap_default(NULL); }
	virtual ~fimsdescription__organisationDetailsType() { }
};
#endif

#ifndef SOAP_TYPE_fimsdescription__detailsType
#define SOAP_TYPE_fimsdescription__detailsType (182)
/* fimsdescription:detailsType */
class SOAP_CMAC fimsdescription__detailsType
{
public:
	std::vector<std::wstring >emailAddress;	/* optional element of type xsd:string */
	std::wstring *webAddress;	/* optional element of type xsd:string */
	class fimsdescription__addressType *address;	/* optional element of type fimsdescription:addressType */
	std::wstring *telephoneNumber;	/* optional element of type xsd:string */
	std::wstring *mobileTelephoneNumber;	/* optional element of type xsd:string */
	std::wstring *typeLabel;	/* optional attribute */
	std::wstring *typeDefinition;	/* optional attribute */
	std::wstring *typeLink;	/* optional attribute */
	std::wstring *typeLanguage;	/* optional attribute */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 182; } /* = unique type id SOAP_TYPE_fimsdescription__detailsType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         fimsdescription__detailsType() { fimsdescription__detailsType::soap_default(NULL); }
	virtual ~fimsdescription__detailsType() { }
};
#endif

#ifndef SOAP_TYPE__fimsdescription__addressType_country
#define SOAP_TYPE__fimsdescription__addressType_country (400)
/* fimsdescription:addressType-country */
class SOAP_CMAC _fimsdescription__addressType_country
{
public:
	std::wstring *typeLabel;	/* optional attribute */
	std::wstring *typeDefinition;	/* optional attribute */
	std::wstring *typeLink;	/* optional attribute */
	std::wstring *typeLanguage;	/* optional attribute */
public:
	virtual int soap_type() const { return 400; } /* = unique type id SOAP_TYPE__fimsdescription__addressType_country */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _fimsdescription__addressType_country() { _fimsdescription__addressType_country::soap_default(NULL); }
	virtual ~_fimsdescription__addressType_country() { }
};
#endif

#ifndef SOAP_TYPE_fimsdescription__addressType
#define SOAP_TYPE_fimsdescription__addressType (183)
/* fimsdescription:addressType */
class SOAP_CMAC fimsdescription__addressType
{
public:
	std::vector<fimsdescription__textElementType * >addressLine;	/* optional element of type fimsdescription:textElementType */
	fimsdescription__textElementType *addressTownCity;	/* optional element of type fimsdescription:textElementType */
	fimsdescription__textElementType *addressCountyState;	/* optional element of type fimsdescription:textElementType */
	std::wstring *addressDeliveryCode;	/* optional element of type xsd:string */
	_fimsdescription__addressType_country *country;	/* optional element of type fimsdescription:addressType-country */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 183; } /* = unique type id SOAP_TYPE_fimsdescription__addressType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         fimsdescription__addressType() { fimsdescription__addressType::soap_default(NULL); }
	virtual ~fimsdescription__addressType() { }
};
#endif

#ifndef SOAP_TYPE_fimsdescription__languageType
#define SOAP_TYPE_fimsdescription__languageType (184)
/* fimsdescription:languageType */
class SOAP_CMAC fimsdescription__languageType
{
public:
	std::wstring *xml__lang;	/* optional attribute */
	std::wstring *typeLabel;	/* optional attribute */
	std::wstring *typeDefinition;	/* optional attribute */
	std::wstring *typeLink;	/* optional attribute */
	std::wstring *typeLanguage;	/* optional attribute */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 184; } /* = unique type id SOAP_TYPE_fimsdescription__languageType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         fimsdescription__languageType() { fimsdescription__languageType::soap_default(NULL); }
	virtual ~fimsdescription__languageType() { }
};
#endif

#ifndef SOAP_TYPE_fimsdescription__relationType
#define SOAP_TYPE_fimsdescription__relationType (185)
/* fimsdescription:relationType */
class SOAP_CMAC fimsdescription__relationType
{
public:
	fimsdescription__identifierType *relationIdentifier;	/* required element of type fimsdescription:identifierType */
	std::wstring relationLink;	/* required element of type xsd:anyURI */
	std::wstring *runningOrderNumber;	/* optional attribute */
	std::wstring *totalNumberOfGroupMembers;	/* optional attribute */
	bool *orderedGroupFlag;	/* optional attribute */
	std::wstring *note;	/* optional attribute */
	std::wstring *typeLabel;	/* optional attribute */
	std::wstring *typeDefinition;	/* optional attribute */
	std::wstring *typeLink;	/* optional attribute */
	std::wstring *typeLanguage;	/* optional attribute */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 185; } /* = unique type id SOAP_TYPE_fimsdescription__relationType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         fimsdescription__relationType() { fimsdescription__relationType::soap_default(NULL); }
	virtual ~fimsdescription__relationType() { }
};
#endif

#ifndef SOAP_TYPE_edlprovider__EdlCreateRequestType
#define SOAP_TYPE_edlprovider__EdlCreateRequestType (35)
/* edlprovider:EdlCreateRequestType */
class SOAP_CMAC edlprovider__EdlCreateRequestType : public edlprovider__EdlCreateRequestBaseType
{
public:
	class fims__RationalType *edlFramesPerSecond;	/* required element of type fims:RationalType */
public:
	virtual int soap_type() const { return 35; } /* = unique type id SOAP_TYPE_edlprovider__EdlCreateRequestType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         edlprovider__EdlCreateRequestType() { edlprovider__EdlCreateRequestType::soap_default(NULL); }
	virtual ~edlprovider__EdlCreateRequestType() { }
};
#endif

#ifndef SOAP_TYPE_edlprovider__EdlCreateRequestDoubleType
#define SOAP_TYPE_edlprovider__EdlCreateRequestDoubleType (36)
/* edlprovider:EdlCreateRequestDoubleType */
class SOAP_CMAC edlprovider__EdlCreateRequestDoubleType : public edlprovider__EdlCreateRequestBaseType
{
public:
	double edlFramesPerSecond;	/* required element of type xsd:double */
public:
	virtual int soap_type() const { return 36; } /* = unique type id SOAP_TYPE_edlprovider__EdlCreateRequestDoubleType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         edlprovider__EdlCreateRequestDoubleType() { edlprovider__EdlCreateRequestDoubleType::soap_default(NULL); }
	virtual ~edlprovider__EdlCreateRequestDoubleType() { }
};
#endif

#ifndef SOAP_TYPE_edlprovider__EdlProviderFaultType
#define SOAP_TYPE_edlprovider__EdlProviderFaultType (39)
/* edlprovider:EdlProviderFaultType */
class SOAP_CMAC edlprovider__EdlProviderFaultType : public fims__FaultType
{
public:
	enum edlprovider__EdlProviderErrorCodeType *extendedCode;	/* optional element of type edlprovider:EdlProviderErrorCodeType */
public:
	virtual int soap_type() const { return 39; } /* = unique type id SOAP_TYPE_edlprovider__EdlProviderFaultType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         edlprovider__EdlProviderFaultType() { edlprovider__EdlProviderFaultType::soap_default(NULL); }
	virtual ~edlprovider__EdlProviderFaultType() { }
};
#endif

#ifndef SOAP_TYPE_fims__ResourceType
#define SOAP_TYPE_fims__ResourceType (44)
/* fims:ResourceType */
class SOAP_CMAC fims__ResourceType : public fims__ResourceReferenceType
{
public:
	time_t *resourceCreationDate;	/* optional element of type xsd:dateTime */
	time_t *resourceModifiedDate;	/* optional element of type xsd:dateTime */
	bool *serviceGeneratedElement;	/* optional element of type xsd:boolean */
	bool *isFullyPopulated;	/* optional element of type xsd:boolean */
	fims__AsyncEndpointType *notifyAt;	/* optional element of type fims:AsyncEndpointType */
	fims__ExtensionGroup *ExtensionGroup;	/* optional element of type fims:ExtensionGroup */
	fims__ExtensionAttributes *ExtensionAttributes;	/* optional element of type fims:ExtensionAttributes */
public:
	virtual int soap_type() const { return 44; } /* = unique type id SOAP_TYPE_fims__ResourceType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         fims__ResourceType() { fims__ResourceType::soap_default(NULL); }
	virtual ~fims__ResourceType() { }
};
#endif

#ifndef SOAP_TYPE_fims__CaptioningFormatType
#define SOAP_TYPE_fims__CaptioningFormatType (55)
/* Primitive fims:CaptioningFormatType schema type: */
class SOAP_CMAC fims__CaptioningFormatType
{
public:
	std::wstring __item;
	std::wstring *captioningSourceUri;	/* optional attribute */
	std::wstring *language;	/* optional attribute */
	std::wstring *formatLabel;	/* optional attribute */
	std::wstring *formatDefinition;	/* optional attribute */
	std::wstring *formatLink;	/* optional attribute */
	char *__anyAttribute;	/* optional attribute */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 55; } /* = unique type id SOAP_TYPE_fims__CaptioningFormatType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         fims__CaptioningFormatType() { fims__CaptioningFormatType::soap_default(NULL); }
	virtual ~fims__CaptioningFormatType() { }
};
#endif

#ifndef SOAP_TYPE_fims__TechnicalAttributeType
#define SOAP_TYPE_fims__TechnicalAttributeType (71)
/* Primitive fims:TechnicalAttributeType schema type: */
class SOAP_CMAC fims__TechnicalAttributeType
{
public:
	std::wstring __item;
	std::wstring *typeLabel;	/* optional attribute */
	std::wstring *typeDefinition;	/* optional attribute */
	std::wstring *typeLink;	/* optional attribute */
	std::wstring *formatLabel;	/* optional attribute */
	std::wstring *formatDefinition;	/* optional attribute */
	std::wstring *formatLink;	/* optional attribute */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 71; } /* = unique type id SOAP_TYPE_fims__TechnicalAttributeType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         fims__TechnicalAttributeType() { fims__TechnicalAttributeType::soap_default(NULL); }
	virtual ~fims__TechnicalAttributeType() { }
};
#endif

#ifndef SOAP_TYPE_fims__LengthType
#define SOAP_TYPE_fims__LengthType (72)
/* Primitive fims:LengthType schema type: */
class SOAP_CMAC fims__LengthType
{
public:
	std::wstring __item;
	std::wstring *unit;	/* optional attribute */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 72; } /* = unique type id SOAP_TYPE_fims__LengthType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         fims__LengthType() { fims__LengthType::soap_default(NULL); }
	virtual ~fims__LengthType() { }
};
#endif

#ifndef SOAP_TYPE_fims__RationalType
#define SOAP_TYPE_fims__RationalType (73)
/* Primitive fims:RationalType schema type: */
class SOAP_CMAC fims__RationalType
{
public:
	LONG64 __item;
	std::wstring numerator;	/* required attribute */
	std::wstring denominator;	/* required attribute */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 73; } /* = unique type id SOAP_TYPE_fims__RationalType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         fims__RationalType() { fims__RationalType::soap_default(NULL); }
	virtual ~fims__RationalType() { }
};
#endif

#ifndef SOAP_TYPE_fims__ProcessedInfoByBytesType
#define SOAP_TYPE_fims__ProcessedInfoByBytesType (76)
/* fims:ProcessedInfoByBytesType */
class SOAP_CMAC fims__ProcessedInfoByBytesType : public fims__ProcessedInfoType
{
public:
	ULONG64 processedBytesCount;	/* required element of type xsd:unsignedLong */
public:
	virtual int soap_type() const { return 76; } /* = unique type id SOAP_TYPE_fims__ProcessedInfoByBytesType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         fims__ProcessedInfoByBytesType() { fims__ProcessedInfoByBytesType::soap_default(NULL); }
	virtual ~fims__ProcessedInfoByBytesType() { }
};
#endif

#ifndef SOAP_TYPE_fims__ProcessedInfoByFramesType
#define SOAP_TYPE_fims__ProcessedInfoByFramesType (77)
/* fims:ProcessedInfoByFramesType */
class SOAP_CMAC fims__ProcessedInfoByFramesType : public fims__ProcessedInfoType
{
public:
	std::wstring processedFramesCount;	/* required element of type xsd:nonNegativeInteger */
public:
	virtual int soap_type() const { return 77; } /* = unique type id SOAP_TYPE_fims__ProcessedInfoByFramesType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         fims__ProcessedInfoByFramesType() { fims__ProcessedInfoByFramesType::soap_default(NULL); }
	virtual ~fims__ProcessedInfoByFramesType() { }
};
#endif

#ifndef SOAP_TYPE_fims__StartProcessByNoWaitType
#define SOAP_TYPE_fims__StartProcessByNoWaitType (81)
/* fims:StartProcessByNoWaitType */
class SOAP_CMAC fims__StartProcessByNoWaitType : public fims__StartProcessType
{
public:
	time_t *actualStartTime;	/* optional element of type xsd:dateTime */
	fimstime__TimeType *actualStartMark;	/* optional element of type fimstime:TimeType */
public:
	virtual int soap_type() const { return 81; } /* = unique type id SOAP_TYPE_fims__StartProcessByNoWaitType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         fims__StartProcessByNoWaitType() { fims__StartProcessByNoWaitType::soap_default(NULL); }
	virtual ~fims__StartProcessByNoWaitType() { }
};
#endif

#ifndef SOAP_TYPE_fims__StartProcessByTimeType
#define SOAP_TYPE_fims__StartProcessByTimeType (82)
/* fims:StartProcessByTimeType */
class SOAP_CMAC fims__StartProcessByTimeType : public fims__StartProcessType
{
public:
	time_t time;	/* required element of type xsd:dateTime */
public:
	virtual int soap_type() const { return 82; } /* = unique type id SOAP_TYPE_fims__StartProcessByTimeType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         fims__StartProcessByTimeType() { fims__StartProcessByTimeType::soap_default(NULL); }
	virtual ~fims__StartProcessByTimeType() { }
};
#endif

#ifndef SOAP_TYPE_fims__StartProcessByTimeMarkType
#define SOAP_TYPE_fims__StartProcessByTimeMarkType (83)
/* fims:StartProcessByTimeMarkType */
class SOAP_CMAC fims__StartProcessByTimeMarkType : public fims__StartProcessType
{
public:
	fimstime__TimeType *timeMark;	/* required element of type fimstime:TimeType */
public:
	virtual int soap_type() const { return 83; } /* = unique type id SOAP_TYPE_fims__StartProcessByTimeMarkType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         fims__StartProcessByTimeMarkType() { fims__StartProcessByTimeMarkType::soap_default(NULL); }
	virtual ~fims__StartProcessByTimeMarkType() { }
};
#endif

#ifndef SOAP_TYPE_fims__StartProcessByServiceDefinedTimeType
#define SOAP_TYPE_fims__StartProcessByServiceDefinedTimeType (84)
/* fims:StartProcessByServiceDefinedTimeType */
class SOAP_CMAC fims__StartProcessByServiceDefinedTimeType : public fims__StartProcessType
{
public:
	time_t *actualStartTime;	/* optional element of type xsd:dateTime */
	fimstime__TimeType *actualStartMark;	/* optional element of type fimstime:TimeType */
public:
	virtual int soap_type() const { return 84; } /* = unique type id SOAP_TYPE_fims__StartProcessByServiceDefinedTimeType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         fims__StartProcessByServiceDefinedTimeType() { fims__StartProcessByServiceDefinedTimeType::soap_default(NULL); }
	virtual ~fims__StartProcessByServiceDefinedTimeType() { }
};
#endif

#ifndef SOAP_TYPE_fims__StopProcessByTimeType
#define SOAP_TYPE_fims__StopProcessByTimeType (86)
/* fims:StopProcessByTimeType */
class SOAP_CMAC fims__StopProcessByTimeType : public fims__StopProcessType
{
public:
	time_t time;	/* required element of type xsd:dateTime */
public:
	virtual int soap_type() const { return 86; } /* = unique type id SOAP_TYPE_fims__StopProcessByTimeType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         fims__StopProcessByTimeType() { fims__StopProcessByTimeType::soap_default(NULL); }
	virtual ~fims__StopProcessByTimeType() { }
};
#endif

#ifndef SOAP_TYPE_fims__StopProcessByDurationType
#define SOAP_TYPE_fims__StopProcessByDurationType (87)
/* fims:StopProcessByDurationType */
class SOAP_CMAC fims__StopProcessByDurationType : public fims__StopProcessType
{
public:
	fimstime__DurationType *duration;	/* required element of type fimstime:DurationType */
public:
	virtual int soap_type() const { return 87; } /* = unique type id SOAP_TYPE_fims__StopProcessByDurationType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         fims__StopProcessByDurationType() { fims__StopProcessByDurationType::soap_default(NULL); }
	virtual ~fims__StopProcessByDurationType() { }
};
#endif

#ifndef SOAP_TYPE_fims__StopProcessByTimeMarkType
#define SOAP_TYPE_fims__StopProcessByTimeMarkType (88)
/* fims:StopProcessByTimeMarkType */
class SOAP_CMAC fims__StopProcessByTimeMarkType : public fims__StopProcessType
{
public:
	fimstime__TimeType *timeMark;	/* required element of type fimstime:TimeType */
public:
	virtual int soap_type() const { return 88; } /* = unique type id SOAP_TYPE_fims__StopProcessByTimeMarkType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         fims__StopProcessByTimeMarkType() { fims__StopProcessByTimeMarkType::soap_default(NULL); }
	virtual ~fims__StopProcessByTimeMarkType() { }
};
#endif

#ifndef SOAP_TYPE_fims__StopProcessByServiceDefinedTimeType
#define SOAP_TYPE_fims__StopProcessByServiceDefinedTimeType (89)
/* fims:StopProcessByServiceDefinedTimeType */
class SOAP_CMAC fims__StopProcessByServiceDefinedTimeType : public fims__StopProcessType
{
public:
	time_t *actualStopTime;	/* optional element of type xsd:dateTime */
	fimstime__TimeType *actualStopMark;	/* optional element of type fimstime:TimeType */
public:
	virtual int soap_type() const { return 89; } /* = unique type id SOAP_TYPE_fims__StopProcessByServiceDefinedTimeType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         fims__StopProcessByServiceDefinedTimeType() { fims__StopProcessByServiceDefinedTimeType::soap_default(NULL); }
	virtual ~fims__StopProcessByServiceDefinedTimeType() { }
};
#endif

#ifndef SOAP_TYPE_fims__StopProcessByOpenEndType
#define SOAP_TYPE_fims__StopProcessByOpenEndType (90)
/* fims:StopProcessByOpenEndType */
class SOAP_CMAC fims__StopProcessByOpenEndType : public fims__StopProcessType
{
public:
	time_t *actualStopTime;	/* optional element of type xsd:dateTime */
	fimstime__TimeType *actualStopMark;	/* optional element of type fimstime:TimeType */
public:
	virtual int soap_type() const { return 90; } /* = unique type id SOAP_TYPE_fims__StopProcessByOpenEndType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         fims__StopProcessByOpenEndType() { fims__StopProcessByOpenEndType::soap_default(NULL); }
	virtual ~fims__StopProcessByOpenEndType() { }
};
#endif

#ifndef SOAP_TYPE_fims__StartJobByNoWaitType
#define SOAP_TYPE_fims__StartJobByNoWaitType (92)
/* fims:StartJobByNoWaitType */
class SOAP_CMAC fims__StartJobByNoWaitType : public fims__StartJobType
{
public:
	virtual int soap_type() const { return 92; } /* = unique type id SOAP_TYPE_fims__StartJobByNoWaitType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         fims__StartJobByNoWaitType() { fims__StartJobByNoWaitType::soap_default(NULL); }
	virtual ~fims__StartJobByNoWaitType() { }
};
#endif

#ifndef SOAP_TYPE_fims__StartJobByTimeType
#define SOAP_TYPE_fims__StartJobByTimeType (93)
/* fims:StartJobByTimeType */
class SOAP_CMAC fims__StartJobByTimeType : public fims__StartJobType
{
public:
	time_t time;	/* required element of type xsd:dateTime */
public:
	virtual int soap_type() const { return 93; } /* = unique type id SOAP_TYPE_fims__StartJobByTimeType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         fims__StartJobByTimeType() { fims__StartJobByTimeType::soap_default(NULL); }
	virtual ~fims__StartJobByTimeType() { }
};
#endif

#ifndef SOAP_TYPE_fims__StartJobByLatestType
#define SOAP_TYPE_fims__StartJobByLatestType (94)
/* fims:StartJobByLatestType */
class SOAP_CMAC fims__StartJobByLatestType : public fims__StartJobType
{
public:
	virtual int soap_type() const { return 94; } /* = unique type id SOAP_TYPE_fims__StartJobByLatestType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         fims__StartJobByLatestType() { fims__StartJobByLatestType::soap_default(NULL); }
	virtual ~fims__StartJobByLatestType() { }
};
#endif

#ifndef SOAP_TYPE_fims__QueryJobRequestByIDType
#define SOAP_TYPE_fims__QueryJobRequestByIDType (100)
/* fims:QueryJobRequestByIDType */
class SOAP_CMAC fims__QueryJobRequestByIDType : public fims__QueryJobRequestType
{
public:
	std::vector<std::wstring >jobID;	/* required element of type fims:UID */
public:
	virtual int soap_type() const { return 100; } /* = unique type id SOAP_TYPE_fims__QueryJobRequestByIDType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         fims__QueryJobRequestByIDType() { fims__QueryJobRequestByIDType::soap_default(NULL); }
	virtual ~fims__QueryJobRequestByIDType() { }
};
#endif

#ifndef SOAP_TYPE_fims__QueryJobRequestByFilterType
#define SOAP_TYPE_fims__QueryJobRequestByFilterType (101)
/* fims:QueryJobRequestByFilterType */
class SOAP_CMAC fims__QueryJobRequestByFilterType : public fims__QueryJobRequestType
{
public:
	fims__ListFilterType *listFilter;	/* required element of type fims:ListFilterType */
public:
	virtual int soap_type() const { return 101; } /* = unique type id SOAP_TYPE_fims__QueryJobRequestByFilterType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         fims__QueryJobRequestByFilterType() { fims__QueryJobRequestByFilterType::soap_default(NULL); }
	virtual ~fims__QueryJobRequestByFilterType() { }
};
#endif

#ifndef SOAP_TYPE_fims__ContentEventType
#define SOAP_TYPE_fims__ContentEventType (153)
/* fims:ContentEventType */
class SOAP_CMAC fims__ContentEventType : public fims__EventPayloadType
{
public:
	fims__ResourceReferenceType *targetResourceReference;	/* optional element of type fims:ResourceReferenceType */
	fims__ExtensionGroup *ExtensionGroup;	/* optional element of type fims:ExtensionGroup */
public:
	virtual int soap_type() const { return 153; } /* = unique type id SOAP_TYPE_fims__ContentEventType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         fims__ContentEventType() { fims__ContentEventType::soap_default(NULL); }
	virtual ~fims__ContentEventType() { }
};
#endif

#ifndef SOAP_TYPE_fims__SystemEventType
#define SOAP_TYPE_fims__SystemEventType (159)
/* fims:SystemEventType */
class SOAP_CMAC fims__SystemEventType : public fims__EventPayloadType
{
public:
	virtual int soap_type() const { return 159; } /* = unique type id SOAP_TYPE_fims__SystemEventType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         fims__SystemEventType() { fims__SystemEventType::soap_default(NULL); }
	virtual ~fims__SystemEventType() { }
};
#endif

#ifndef SOAP_TYPE_fimstime__EditUnitNumberType
#define SOAP_TYPE_fimstime__EditUnitNumberType (168)
/* Primitive fimstime:EditUnitNumberType schema type: */
class SOAP_CMAC fimstime__EditUnitNumberType
{
public:
	LONG64 __item;
	std::wstring editRate;	/* required attribute */
	std::wstring factorNumerator;	/* required attribute */
	std::wstring factorDenominator;	/* required attribute */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 168; } /* = unique type id SOAP_TYPE_fimstime__EditUnitNumberType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         fimstime__EditUnitNumberType() { fimstime__EditUnitNumberType::soap_default(NULL); }
	virtual ~fimstime__EditUnitNumberType() { }
};
#endif

#ifndef SOAP_TYPE_fimsdescription__identifierType
#define SOAP_TYPE_fimsdescription__identifierType (171)
/* Primitive fimsdescription:identifierType schema type: */
class SOAP_CMAC fimsdescription__identifierType
{
public:
	std::wstring __item;
	std::wstring *typeLabel;	/* optional attribute */
	std::wstring *typeDefinition;	/* optional attribute */
	std::wstring *typeLink;	/* optional attribute */
	std::wstring *typeLanguage;	/* optional attribute */
	std::wstring *formatLabel;	/* optional attribute */
	std::wstring *formatDefinition;	/* optional attribute */
	std::wstring *formatLink;	/* optional attribute */
	std::wstring *formatLanguage;	/* optional attribute */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 171; } /* = unique type id SOAP_TYPE_fimsdescription__identifierType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         fimsdescription__identifierType() { fimsdescription__identifierType::soap_default(NULL); }
	virtual ~fimsdescription__identifierType() { }
};
#endif

#ifndef SOAP_TYPE_fimsdescription__textElementType
#define SOAP_TYPE_fimsdescription__textElementType (177)
/* Primitive fimsdescription:textElementType schema type: */
class SOAP_CMAC fimsdescription__textElementType
{
public:
	std::wstring __item;
	std::wstring *xml__lang;	/* optional attribute */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 177; } /* = unique type id SOAP_TYPE_fimsdescription__textElementType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         fimsdescription__textElementType() { fimsdescription__textElementType::soap_default(NULL); }
	virtual ~fimsdescription__textElementType() { }
};
#endif

#ifndef SOAP_TYPE_fimsdescription__partType
#define SOAP_TYPE_fimsdescription__partType (186)
/* fimsdescription:partType */
class SOAP_CMAC fimsdescription__partType : public fimsdescription__bmContentDescriptionType
{
public:
	fimstime__TimeType *partStartTime;	/* optional element of type fimstime:TimeType */
	fimstime__DurationType *partDuration;	/* optional element of type fimstime:DurationType */
	std::wstring *partId;	/* optional attribute */
	std::wstring *partName;	/* optional attribute */
	std::wstring *partDefinition;	/* optional attribute */
	std::wstring *partNumber;	/* optional attribute */
	std::wstring *partTotalNumber;	/* optional attribute */
	std::wstring *typeLabel;	/* optional attribute */
	std::wstring *typeDefinition;	/* optional attribute */
	std::wstring *typeLink;	/* optional attribute */
	std::wstring *typeLanguage;	/* optional attribute */
public:
	virtual int soap_type() const { return 186; } /* = unique type id SOAP_TYPE_fimsdescription__partType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         fimsdescription__partType() { fimsdescription__partType::soap_default(NULL); }
	virtual ~fimsdescription__partType() { }
};
#endif

#ifndef SOAP_TYPE__fims__ServiceType_serviceDescription
#define SOAP_TYPE__fims__ServiceType_serviceDescription (412)
/* fims:ServiceType-serviceDescription */
class SOAP_CMAC _fims__ServiceType_serviceDescription
{
public:
	std::vector<char * >__any;
public:
	virtual int soap_type() const { return 412; } /* = unique type id SOAP_TYPE__fims__ServiceType_serviceDescription */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _fims__ServiceType_serviceDescription() { _fims__ServiceType_serviceDescription::soap_default(NULL); }
	virtual ~_fims__ServiceType_serviceDescription() { }
};
#endif

#ifndef SOAP_TYPE_fims__ServiceType
#define SOAP_TYPE_fims__ServiceType (47)
/* fims:ServiceType */
class SOAP_CMAC fims__ServiceType : public fims__ResourceType
{
public:
	std::wstring *providerName;	/* optional element of type xsd:string */
	std::wstring *providerEndPoint;	/* optional element of type xsd:anyURI */
	_fims__ServiceType_serviceDescription *serviceDescription;	/* optional element of type fims:ServiceType-serviceDescription */
public:
	virtual int soap_type() const { return 47; } /* = unique type id SOAP_TYPE_fims__ServiceType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         fims__ServiceType() { fims__ServiceType::soap_default(NULL); }
	virtual ~fims__ServiceType() { }
};
#endif

#ifndef SOAP_TYPE_fims__ProfileType
#define SOAP_TYPE_fims__ProfileType (48)
/* fims:ProfileType */
class SOAP_CMAC fims__ProfileType : public fims__ResourceType
{
public:
	fims__ServiceType *service;	/* optional element of type fims:ServiceType */
	std::wstring *name;	/* optional attribute */
	std::wstring *description;	/* optional attribute */
public:
	virtual int soap_type() const { return 48; } /* = unique type id SOAP_TYPE_fims__ProfileType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         fims__ProfileType() { fims__ProfileType::soap_default(NULL); }
	virtual ~fims__ProfileType() { }
};
#endif

#ifndef SOAP_TYPE_fims__QueueType
#define SOAP_TYPE_fims__QueueType (49)
/* fims:QueueType */
class SOAP_CMAC fims__QueueType : public fims__ResourceType
{
public:
	enum fims__QueueStatusType *status;	/* optional element of type fims:QueueStatusType */
	std::wstring *statusDescription;	/* optional element of type xsd:string */
	std::wstring *length;	/* optional element of type xsd:nonNegativeInteger */
	bool *availability;	/* optional element of type xsd:boolean */
	LONG64 *estimatedTotalCompletionDuration;	/* optional element of type xsd:duration */
	fims__JobsType *jobs;	/* optional element of type fims:JobsType */
public:
	virtual int soap_type() const { return 49; } /* = unique type id SOAP_TYPE_fims__QueueType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         fims__QueueType() { fims__QueueType::soap_default(NULL); }
	virtual ~fims__QueueType() { }
};
#endif

#ifndef SOAP_TYPE_fims__JobType
#define SOAP_TYPE_fims__JobType (50)
/* fims:JobType */
class SOAP_CMAC fims__JobType : public fims__ResourceType
{
public:
	enum fims__JobStatusType *status;	/* optional element of type fims:JobStatusType */
	std::wstring *statusDescription;	/* optional element of type xsd:string */
	std::wstring *serviceProviderJobID;	/* optional element of type xsd:string */
	fims__QueueType *queueReference;	/* optional element of type fims:QueueType */
	fims__JobsType *tasks;	/* optional element of type fims:JobsType */
	std::wstring *operationName;	/* optional element of type xsd:string */
	fims__BMObjectsType *bmObjects;	/* optional element of type fims:BMObjectsType */
	enum fims__PriorityType *priority;	/* optional element of type fims:PriorityType */
	fims__StartJobType *startJob;	/* optional element of type fims:StartJobType */
	time_t *finishBefore;	/* optional element of type xsd:dateTime */
	LONG64 *estimatedCompletionDuration;	/* optional element of type xsd:duration */
	std::wstring *currentQueuePosition;	/* optional element of type xsd:nonNegativeInteger */
	time_t *jobStartedTime;	/* optional element of type xsd:dateTime */
	LONG64 *jobElapsedTime;	/* optional element of type xsd:duration */
	time_t *jobCompletedTime;	/* optional element of type xsd:dateTime */
	fims__ProcessedInfoType *processed;	/* optional element of type fims:ProcessedInfoType */
public:
	virtual int soap_type() const { return 50; } /* = unique type id SOAP_TYPE_fims__JobType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         fims__JobType() { fims__JobType::soap_default(NULL); }
	virtual ~fims__JobType() { }
};
#endif

#ifndef SOAP_TYPE_fims__FormatType
#define SOAP_TYPE_fims__FormatType (51)
/* fims:FormatType */
class SOAP_CMAC fims__FormatType : public fims__ResourceType
{
public:
	std::vector<fims__TechnicalAttributeType * >technicalAttribute;	/* optional element of type fims:TechnicalAttributeType */
public:
	virtual int soap_type() const { return 51; } /* = unique type id SOAP_TYPE_fims__FormatType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         fims__FormatType() { fims__FormatType::soap_default(NULL); }
	virtual ~fims__FormatType() { }
};
#endif

#ifndef SOAP_TYPE_fims__BMObjectType
#define SOAP_TYPE_fims__BMObjectType (60)
/* fims:BMObjectType */
class SOAP_CMAC fims__BMObjectType : public fims__ResourceType
{
public:
	fims__BMContentsType *bmContents;	/* optional element of type fims:BMContentsType */
public:
	virtual int soap_type() const { return 60; } /* = unique type id SOAP_TYPE_fims__BMObjectType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         fims__BMObjectType() { fims__BMObjectType::soap_default(NULL); }
	virtual ~fims__BMObjectType() { }
};
#endif

#ifndef SOAP_TYPE_fims__BMContentType
#define SOAP_TYPE_fims__BMContentType (61)
/* fims:BMContentType */
class SOAP_CMAC fims__BMContentType : public fims__ResourceType
{
public:
	fims__BMContentFormatsType *bmContentFormats;	/* optional element of type fims:BMContentFormatsType */
	fims__DescriptionsType *descriptions;	/* optional element of type fims:DescriptionsType */
	fims__BMContentStatusType *status;	/* optional element of type fims:BMContentStatusType */
public:
	virtual int soap_type() const { return 61; } /* = unique type id SOAP_TYPE_fims__BMContentType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         fims__BMContentType() { fims__BMContentType::soap_default(NULL); }
	virtual ~fims__BMContentType() { }
};
#endif

#ifndef SOAP_TYPE_fims__DescriptionType
#define SOAP_TYPE_fims__DescriptionType (62)
/* fims:DescriptionType */
class SOAP_CMAC fims__DescriptionType : public fims__ResourceType
{
public:
	fimsdescription__bmContentDescriptionType *fimsdescription__bmContentDescription;	/* optional element of type fimsdescription:bmContentDescriptionType */
public:
	virtual int soap_type() const { return 62; } /* = unique type id SOAP_TYPE_fims__DescriptionType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         fims__DescriptionType() { fims__DescriptionType::soap_default(NULL); }
	virtual ~fims__DescriptionType() { }
};
#endif

#ifndef SOAP_TYPE__fims__BMContentFormatType_mimeType
#define SOAP_TYPE__fims__BMContentFormatType_mimeType (429)
/* Primitive fims:BMContentFormatType-mimeType schema type: */
class SOAP_CMAC _fims__BMContentFormatType_mimeType
{
public:
	std::wstring __item;
	std::wstring *typeLabel;	/* optional attribute */
	std::wstring *typeDefinition;	/* optional attribute */
	std::wstring *typeLink;	/* optional attribute */
public:
	virtual int soap_type() const { return 429; } /* = unique type id SOAP_TYPE__fims__BMContentFormatType_mimeType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _fims__BMContentFormatType_mimeType() { _fims__BMContentFormatType_mimeType::soap_default(NULL); }
	virtual ~_fims__BMContentFormatType_mimeType() { }
};
#endif

#ifndef SOAP_TYPE_fims__BMContentFormatType
#define SOAP_TYPE_fims__BMContentFormatType (63)
/* fims:BMContentFormatType */
class SOAP_CMAC fims__BMContentFormatType : public fims__ResourceType
{
public:
	fims__BMEssenceLocatorsType *bmEssenceLocators;	/* optional element of type fims:BMEssenceLocatorsType */
	_fims__formatCollection *formatCollection;	/* optional element of type fims:formatCollection */
	fimstime__DurationType *duration;	/* optional element of type fimstime:DurationType */
	fims__HashType *hash;	/* optional element of type fims:HashType */
	ULONG64 *packageSize;	/* optional element of type xsd:unsignedLong */
	_fims__BMContentFormatType_mimeType *mimeType;	/* optional element of type fims:BMContentFormatType-mimeType */
public:
	virtual int soap_type() const { return 63; } /* = unique type id SOAP_TYPE_fims__BMContentFormatType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         fims__BMContentFormatType() { fims__BMContentFormatType::soap_default(NULL); }
	virtual ~fims__BMContentFormatType() { }
};
#endif

#ifndef SOAP_TYPE__fims__BMEssenceLocatorType_containerMimeType
#define SOAP_TYPE__fims__BMEssenceLocatorType_containerMimeType (432)
/* Primitive fims:BMEssenceLocatorType-containerMimeType schema type: */
class SOAP_CMAC _fims__BMEssenceLocatorType_containerMimeType
{
public:
	std::wstring __item;
	std::wstring *typeLabel;	/* optional attribute */
	std::wstring *typeDefinition;	/* optional attribute */
	std::wstring *typeLink;	/* optional attribute */
public:
	virtual int soap_type() const { return 432; } /* = unique type id SOAP_TYPE__fims__BMEssenceLocatorType_containerMimeType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _fims__BMEssenceLocatorType_containerMimeType() { _fims__BMEssenceLocatorType_containerMimeType::soap_default(NULL); }
	virtual ~_fims__BMEssenceLocatorType_containerMimeType() { }
};
#endif

#ifndef SOAP_TYPE_fims__BMEssenceLocatorType
#define SOAP_TYPE_fims__BMEssenceLocatorType (64)
/* fims:BMEssenceLocatorType */
class SOAP_CMAC fims__BMEssenceLocatorType : public fims__ResourceType
{
public:
	class fims__StorageType *storageType;	/* optional element of type fims:StorageType */
	std::wstring *locatorInfo;	/* optional element of type xsd:string */
	_fims__BMEssenceLocatorType_containerMimeType *containerMimeType;	/* optional element of type fims:BMEssenceLocatorType-containerMimeType */
	fims__BMEssenceLocatorStatusType *status;	/* optional element of type fims:BMEssenceLocatorStatusType */
public:
	virtual int soap_type() const { return 64; } /* = unique type id SOAP_TYPE_fims__BMEssenceLocatorType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         fims__BMEssenceLocatorType() { fims__BMEssenceLocatorType::soap_default(NULL); }
	virtual ~fims__BMEssenceLocatorType() { }
};
#endif

#ifndef SOAP_TYPE_fims__StorageType
#define SOAP_TYPE_fims__StorageType (78)
/* Primitive fims:StorageType schema type: */
class SOAP_CMAC fims__StorageType
{
public:
	enum fims__StorageTypes __item;
	std::wstring *typeLabel;	/* optional attribute */
	std::wstring *typeDefinition;	/* optional attribute */
	std::wstring *typeLink;	/* optional attribute */
	char *__anyAttribute;	/* optional attribute */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 78; } /* = unique type id SOAP_TYPE_fims__StorageType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         fims__StorageType() { fims__StorageType::soap_default(NULL); }
	virtual ~fims__StorageType() { }
};
#endif

#ifndef SOAP_TYPE_fims__HashFunctionType
#define SOAP_TYPE_fims__HashFunctionType (79)
/* Primitive fims:HashFunctionType schema type: */
class SOAP_CMAC fims__HashFunctionType
{
public:
	enum fims__HashFunctionTypes __item;
	std::wstring *typeLabel;	/* optional attribute */
	std::wstring *typeDefinition;	/* optional attribute */
	std::wstring *typeLink;	/* optional attribute */
	char *__anyAttribute;	/* optional attribute */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 79; } /* = unique type id SOAP_TYPE_fims__HashFunctionType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         fims__HashFunctionType() { fims__HashFunctionType::soap_default(NULL); }
	virtual ~fims__HashFunctionType() { }
};
#endif

#ifndef SOAP_TYPE_fims__BMCustomStatusExtensionType
#define SOAP_TYPE_fims__BMCustomStatusExtensionType (125)
/* fims:BMCustomStatusExtensionType */
class SOAP_CMAC fims__BMCustomStatusExtensionType : public fims__ResourceType
{
public:
	std::wstring code;	/* required element of type xsd:string */
	std::wstring *description;	/* optional element of type xsd:string */
public:
	virtual int soap_type() const { return 125; } /* = unique type id SOAP_TYPE_fims__BMCustomStatusExtensionType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         fims__BMCustomStatusExtensionType() { fims__BMCustomStatusExtensionType::soap_default(NULL); }
	virtual ~fims__BMCustomStatusExtensionType() { }
};
#endif

#ifndef SOAP_TYPE_fims__BMContentStatusType
#define SOAP_TYPE_fims__BMContentStatusType (127)
/* fims:BMContentStatusType */
class SOAP_CMAC fims__BMContentStatusType : public fims__ResourceType
{
public:
	enum fims__BMStatusType status;	/* required element of type fims:BMStatusType */
	fims__BMCustomStatusExtensionType *subStatus;	/* optional element of type fims:BMCustomStatusExtensionType */
public:
	virtual int soap_type() const { return 127; } /* = unique type id SOAP_TYPE_fims__BMContentStatusType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         fims__BMContentStatusType() { fims__BMContentStatusType::soap_default(NULL); }
	virtual ~fims__BMContentStatusType() { }
};
#endif

#ifndef SOAP_TYPE_fims__BMEssenceLocatorStatusType
#define SOAP_TYPE_fims__BMEssenceLocatorStatusType (129)
/* fims:BMEssenceLocatorStatusType */
class SOAP_CMAC fims__BMEssenceLocatorStatusType : public fims__ResourceType
{
public:
	enum fims__BMStatusType status;	/* required element of type fims:BMStatusType */
	fims__BMCustomStatusExtensionType *subStatus;	/* optional element of type fims:BMCustomStatusExtensionType */
public:
	virtual int soap_type() const { return 129; } /* = unique type id SOAP_TYPE_fims__BMEssenceLocatorStatusType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         fims__BMEssenceLocatorStatusType() { fims__BMEssenceLocatorStatusType::soap_default(NULL); }
	virtual ~fims__BMEssenceLocatorStatusType() { }
};
#endif

#ifndef SOAP_TYPE_fims__LockTokenType
#define SOAP_TYPE_fims__LockTokenType (133)
/* fims:LockTokenType */
class SOAP_CMAC fims__LockTokenType : public fims__ResourceType
{
public:
	std::wstring *userName;	/* optional element of type xsd:string */
	time_t *expiration;	/* optional element of type xsd:dateTime */
	fims__ResourceReferencesType *resourceReferences;	/* optional element of type fims:ResourceReferencesType */
public:
	virtual int soap_type() const { return 133; } /* = unique type id SOAP_TYPE_fims__LockTokenType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         fims__LockTokenType() { fims__LockTokenType::soap_default(NULL); }
	virtual ~fims__LockTokenType() { }
};
#endif

#ifndef SOAP_TYPE_fims__SuperLockTokenType
#define SOAP_TYPE_fims__SuperLockTokenType (135)
/* fims:SuperLockTokenType */
class SOAP_CMAC fims__SuperLockTokenType : public fims__ResourceType
{
public:
	std::wstring *userName;	/* optional element of type xsd:string */
public:
	virtual int soap_type() const { return 135; } /* = unique type id SOAP_TYPE_fims__SuperLockTokenType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         fims__SuperLockTokenType() { fims__SuperLockTokenType::soap_default(NULL); }
	virtual ~fims__SuperLockTokenType() { }
};
#endif

#ifndef SOAP_TYPE_fims__ContentStatusEventType
#define SOAP_TYPE_fims__ContentStatusEventType (155)
/* fims:ContentStatusEventType */
class SOAP_CMAC fims__ContentStatusEventType : public fims__ContentEventType
{
public:
	virtual int soap_type() const { return 155; } /* = unique type id SOAP_TYPE_fims__ContentStatusEventType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         fims__ContentStatusEventType() { fims__ContentStatusEventType::soap_default(NULL); }
	virtual ~fims__ContentStatusEventType() { }
};
#endif

#ifndef SOAP_TYPE_fims__ContentCustomEventType
#define SOAP_TYPE_fims__ContentCustomEventType (157)
/* fims:ContentCustomEventType */
class SOAP_CMAC fims__ContentCustomEventType : public fims__ContentEventType
{
public:
	std::wstring *templateID;	/* optional element of type fims:ResourceIDType */
	fims__CustomEventTemplateType *customEventTemplate;	/* optional element of type fims:CustomEventTemplateType */
public:
	virtual int soap_type() const { return 157; } /* = unique type id SOAP_TYPE_fims__ContentCustomEventType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         fims__ContentCustomEventType() { fims__ContentCustomEventType::soap_default(NULL); }
	virtual ~fims__ContentCustomEventType() { }
};
#endif

#ifndef SOAP_TYPE_fims__SystemExceptionEventType
#define SOAP_TYPE_fims__SystemExceptionEventType (161)
/* fims:SystemExceptionEventType */
class SOAP_CMAC fims__SystemExceptionEventType : public fims__SystemEventType
{
public:
	std::wstring *errorCode;	/* optional element of type xsd:string */
	std::wstring *errorTitle;	/* optional element of type xsd:string */
	std::wstring *errorDescription;	/* optional element of type xsd:string */
	time_t *errorDateTime;	/* optional element of type xsd:dateTime */
public:
	virtual int soap_type() const { return 161; } /* = unique type id SOAP_TYPE_fims__SystemExceptionEventType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         fims__SystemExceptionEventType() { fims__SystemExceptionEventType::soap_default(NULL); }
	virtual ~fims__SystemExceptionEventType() { }
};
#endif

#ifndef SOAP_TYPE_fims__SystemPerformanceEventType
#define SOAP_TYPE_fims__SystemPerformanceEventType (163)
/* fims:SystemPerformanceEventType */
class SOAP_CMAC fims__SystemPerformanceEventType : public fims__SystemEventType
{
public:
	std::wstring *TBD;	/* optional element of type xsd:string */
public:
	virtual int soap_type() const { return 163; } /* = unique type id SOAP_TYPE_fims__SystemPerformanceEventType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         fims__SystemPerformanceEventType() { fims__SystemPerformanceEventType::soap_default(NULL); }
	virtual ~fims__SystemPerformanceEventType() { }
};
#endif

#ifndef SOAP_TYPE_fimsdescription__titleType
#define SOAP_TYPE_fimsdescription__titleType (170)
/* Primitive fimsdescription:titleType schema type: */
class SOAP_CMAC fimsdescription__titleType : public fimsdescription__textElementType
{
public:
	std::wstring *typeLabel;	/* optional attribute */
	std::wstring *typeDefinition;	/* optional attribute */
	std::wstring *typeLink;	/* optional attribute */
	std::wstring *typeLanguage;	/* optional attribute */
public:
	virtual int soap_type() const { return 170; } /* = unique type id SOAP_TYPE_fimsdescription__titleType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         fimsdescription__titleType() { fimsdescription__titleType::soap_default(NULL); }
	virtual ~fimsdescription__titleType() { }
};
#endif

#ifndef SOAP_TYPE_fimsdescription__subjectType
#define SOAP_TYPE_fimsdescription__subjectType (172)
/* Primitive fimsdescription:subjectType schema type: */
class SOAP_CMAC fimsdescription__subjectType : public fimsdescription__textElementType
{
public:
	std::wstring *typeLabel;	/* optional attribute */
	std::wstring *typeDefinition;	/* optional attribute */
	std::wstring *typeLink;	/* optional attribute */
	std::wstring *typeLanguage;	/* optional attribute */
public:
	virtual int soap_type() const { return 172; } /* = unique type id SOAP_TYPE_fimsdescription__subjectType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         fimsdescription__subjectType() { fimsdescription__subjectType::soap_default(NULL); }
	virtual ~fimsdescription__subjectType() { }
};
#endif

#ifndef SOAP_TYPE_fimsdescription__descriptionType
#define SOAP_TYPE_fimsdescription__descriptionType (174)
/* Primitive fimsdescription:descriptionType schema type: */
class SOAP_CMAC fimsdescription__descriptionType : public fimsdescription__textElementType
{
public:
	std::wstring *typeLabel;	/* optional attribute */
	std::wstring *typeDefinition;	/* optional attribute */
	std::wstring *typeLink;	/* optional attribute */
	std::wstring *typeLanguage;	/* optional attribute */
public:
	virtual int soap_type() const { return 174; } /* = unique type id SOAP_TYPE_fimsdescription__descriptionType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         fimsdescription__descriptionType() { fimsdescription__descriptionType::soap_default(NULL); }
	virtual ~fimsdescription__descriptionType() { }
};
#endif

#ifndef SOAP_TYPE_fims__VideoFormatType
#define SOAP_TYPE_fims__VideoFormatType (52)
/* fims:VideoFormatType */
class SOAP_CMAC fims__VideoFormatType : public fims__FormatType
{
public:
	fims__LengthType *displayWidth;	/* optional element of type fims:LengthType */
	fims__LengthType *displayHeight;	/* optional element of type fims:LengthType */
	fims__RationalType *frameRate;	/* optional element of type fims:RationalType */
	fims__RationalType *aspectRatio;	/* optional element of type fims:RationalType */
	fims__CodecType *videoEncoding;	/* optional element of type fims:CodecType */
	std::vector<fims__BMTrackType * >videoTrack;	/* optional element of type fims:BMTrackType */
	std::wstring *bitRate;	/* optional element of type xsd:nonNegativeInteger */
	enum fims__BitRateModeType *bitRateMode;	/* optional element of type fims:BitRateModeType */
	std::wstring *lines;	/* optional element of type xsd:nonNegativeInteger */
	enum fims__ScanningFormatType *scanningFormat;	/* optional element of type fims:ScanningFormatType */
	enum fims__ScanningOrderType *scanningOrder;	/* optional element of type fims:ScanningOrderType */
	bool *noiseFilter;	/* optional element of type xsd:boolean */
public:
	virtual int soap_type() const { return 52; } /* = unique type id SOAP_TYPE_fims__VideoFormatType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         fims__VideoFormatType() { fims__VideoFormatType::soap_default(NULL); }
	virtual ~fims__VideoFormatType() { }
};
#endif

#ifndef SOAP_TYPE__fims__AudioFormatType_trackConfiguration
#define SOAP_TYPE__fims__AudioFormatType_trackConfiguration (443)
/* fims:AudioFormatType-trackConfiguration */
class SOAP_CMAC _fims__AudioFormatType_trackConfiguration
{
public:
	std::wstring *typeLabel;	/* optional attribute */
	std::wstring *typeDefinition;	/* optional attribute */
	std::wstring *typeLink;	/* optional attribute */
public:
	virtual int soap_type() const { return 443; } /* = unique type id SOAP_TYPE__fims__AudioFormatType_trackConfiguration */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _fims__AudioFormatType_trackConfiguration() { _fims__AudioFormatType_trackConfiguration::soap_default(NULL); }
	virtual ~_fims__AudioFormatType_trackConfiguration() { }
};
#endif

#ifndef SOAP_TYPE_fims__AudioFormatType
#define SOAP_TYPE_fims__AudioFormatType (53)
/* fims:AudioFormatType */
class SOAP_CMAC fims__AudioFormatType : public fims__FormatType
{
public:
	std::wstring *samplingRate;	/* optional element of type xsd:decimal */
	fims__CodecType *audioEncoding;	/* optional element of type fims:CodecType */
	_fims__AudioFormatType_trackConfiguration *trackConfiguration;	/* optional element of type fims:AudioFormatType-trackConfiguration */
	std::vector<fims__BMTrackType * >audioTrack;	/* optional element of type fims:BMTrackType */
	std::wstring *channels;	/* optional element of type xsd:nonNegativeInteger */
	std::wstring *bitRate;	/* optional element of type xsd:nonNegativeInteger */
	enum fims__BitRateModeType *bitRateMode;	/* optional element of type fims:BitRateModeType */
	std::wstring *sampleSize;	/* optional element of type xsd:nonNegativeInteger */
	enum fims__AudioSampleType *sampleType;	/* optional element of type fims:AudioSampleType */
public:
	virtual int soap_type() const { return 53; } /* = unique type id SOAP_TYPE_fims__AudioFormatType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         fims__AudioFormatType() { fims__AudioFormatType::soap_default(NULL); }
	virtual ~fims__AudioFormatType() { }
};
#endif

#ifndef SOAP_TYPE_fims__DataFormatType
#define SOAP_TYPE_fims__DataFormatType (54)
/* fims:DataFormatType */
class SOAP_CMAC fims__DataFormatType : public fims__FormatType
{
public:
	std::vector<fims__CaptioningFormatType * >captioningFormat;	/* optional element of type fims:CaptioningFormatType */
	std::vector<fims__AncillaryDataFormatType * >ancillaryDataFormat;	/* optional element of type fims:AncillaryDataFormatType */
public:
	virtual int soap_type() const { return 54; } /* = unique type id SOAP_TYPE_fims__DataFormatType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         fims__DataFormatType() { fims__DataFormatType::soap_default(NULL); }
	virtual ~fims__DataFormatType() { }
};
#endif

#ifndef SOAP_TYPE__fims__ContainerFormatType_containerFormat
#define SOAP_TYPE__fims__ContainerFormatType_containerFormat (450)
/* Primitive fims:ContainerFormatType-containerFormat schema type: */
class SOAP_CMAC _fims__ContainerFormatType_containerFormat
{
public:
	std::wstring __item;
	std::wstring *formatLabel;	/* optional attribute */
	std::wstring *formatDefinition;	/* optional attribute */
	std::wstring *formatLink;	/* optional attribute */
public:
	virtual int soap_type() const { return 450; } /* = unique type id SOAP_TYPE__fims__ContainerFormatType_containerFormat */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _fims__ContainerFormatType_containerFormat() { _fims__ContainerFormatType_containerFormat::soap_default(NULL); }
	virtual ~_fims__ContainerFormatType_containerFormat() { }
};
#endif

#ifndef SOAP_TYPE_fims__ContainerFormatType
#define SOAP_TYPE_fims__ContainerFormatType (57)
/* fims:ContainerFormatType */
class SOAP_CMAC fims__ContainerFormatType : public fims__FormatType
{
public:
	_fims__ContainerFormatType_containerFormat *containerFormat;	/* optional element of type fims:ContainerFormatType-containerFormat */
public:
	virtual int soap_type() const { return 57; } /* = unique type id SOAP_TYPE_fims__ContainerFormatType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         fims__ContainerFormatType() { fims__ContainerFormatType::soap_default(NULL); }
	virtual ~fims__ContainerFormatType() { }
};
#endif

#ifndef SOAP_TYPE_fims__SimpleFileLocatorType
#define SOAP_TYPE_fims__SimpleFileLocatorType (65)
/* fims:SimpleFileLocatorType */
class SOAP_CMAC fims__SimpleFileLocatorType : public fims__BMEssenceLocatorType
{
public:
	std::wstring *file;	/* optional element of type xsd:anyURI */
public:
	virtual int soap_type() const { return 65; } /* = unique type id SOAP_TYPE_fims__SimpleFileLocatorType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         fims__SimpleFileLocatorType() { fims__SimpleFileLocatorType::soap_default(NULL); }
	virtual ~fims__SimpleFileLocatorType() { }
};
#endif

#ifndef SOAP_TYPE_fims__ListFileLocatorType
#define SOAP_TYPE_fims__ListFileLocatorType (66)
/* fims:ListFileLocatorType */
class SOAP_CMAC fims__ListFileLocatorType : public fims__BMEssenceLocatorType
{
public:
	std::vector<std::wstring >file;	/* optional element of type xsd:anyURI */
public:
	virtual int soap_type() const { return 66; } /* = unique type id SOAP_TYPE_fims__ListFileLocatorType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         fims__ListFileLocatorType() { fims__ListFileLocatorType::soap_default(NULL); }
	virtual ~fims__ListFileLocatorType() { }
};
#endif

#ifndef SOAP_TYPE_fims__FolderLocatorType
#define SOAP_TYPE_fims__FolderLocatorType (67)
/* fims:FolderLocatorType */
class SOAP_CMAC fims__FolderLocatorType : public fims__BMEssenceLocatorType
{
public:
	std::wstring *folder;	/* optional element of type xsd:anyURI */
public:
	virtual int soap_type() const { return 67; } /* = unique type id SOAP_TYPE_fims__FolderLocatorType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         fims__FolderLocatorType() { fims__FolderLocatorType::soap_default(NULL); }
	virtual ~fims__FolderLocatorType() { }
};
#endif

#ifndef SOAP_TYPE_fims__EssencePlaceholderLocatorType
#define SOAP_TYPE_fims__EssencePlaceholderLocatorType (68)
/* fims:EssencePlaceholderLocatorType */
class SOAP_CMAC fims__EssencePlaceholderLocatorType : public fims__BMEssenceLocatorType
{
public:
	virtual int soap_type() const { return 68; } /* = unique type id SOAP_TYPE_fims__EssencePlaceholderLocatorType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         fims__EssencePlaceholderLocatorType() { fims__EssencePlaceholderLocatorType::soap_default(NULL); }
	virtual ~fims__EssencePlaceholderLocatorType() { }
};
#endif

#ifndef WITH_NOGLOBAL

#ifndef SOAP_TYPE_SOAP_ENV__Detail
#define SOAP_TYPE_SOAP_ENV__Detail (452)
/* SOAP-ENV:Detail */
struct SOAP_ENV__Detail
{
public:
	edlprovider__EdlProviderFaultType *edlprovider__edlProviderFault;	/* optional element of type edlprovider:EdlProviderFaultType */
	int __type;	/* any type of element <fault> (defined below) */
	void *fault;	/* transient */
	char *__any;
public:
	int soap_type() const { return 452; } /* = unique type id SOAP_TYPE_SOAP_ENV__Detail */
};
#endif

#endif

#ifndef SOAP_TYPE___edlprovider__getInstalledEdls
#define SOAP_TYPE___edlprovider__getInstalledEdls (458)
/* Operation wrapper: */
struct __edlprovider__getInstalledEdls
{
public:
	int soap_type() const { return 458; } /* = unique type id SOAP_TYPE___edlprovider__getInstalledEdls */
#ifdef WITH_NOEMPTYSTRUCT
private:
	char dummy;	/* dummy member to enable compilation */
#endif
};
#endif

#ifndef SOAP_TYPE___edlprovider__getEdl
#define SOAP_TYPE___edlprovider__getEdl (462)
/* Operation wrapper: */
struct __edlprovider__getEdl
{
public:
	edlprovider__EdlCreateRequestType *edlprovider__getEdlRequest;	/* optional element of type edlprovider:EdlCreateRequestType */
public:
	int soap_type() const { return 462; } /* = unique type id SOAP_TYPE___edlprovider__getEdl */
};
#endif

#ifndef SOAP_TYPE___edlprovider__getEdlDouble
#define SOAP_TYPE___edlprovider__getEdlDouble (465)
/* Operation wrapper: */
struct __edlprovider__getEdlDouble
{
public:
	edlprovider__EdlCreateRequestDoubleType *edlprovider__getEdlDoubleRequest;	/* optional element of type edlprovider:EdlCreateRequestDoubleType */
public:
	int soap_type() const { return 465; } /* = unique type id SOAP_TYPE___edlprovider__getEdlDouble */
};
#endif

#ifndef WITH_NOGLOBAL

#ifndef SOAP_TYPE_SOAP_ENV__Header
#define SOAP_TYPE_SOAP_ENV__Header (466)
/* SOAP Header: */
struct SOAP_ENV__Header
{
public:
	int soap_type() const { return 466; } /* = unique type id SOAP_TYPE_SOAP_ENV__Header */
#ifdef WITH_NOEMPTYSTRUCT
private:
	char dummy;	/* dummy member to enable compilation */
#endif
};
#endif

#endif

#ifndef WITH_NOGLOBAL

#ifndef SOAP_TYPE_SOAP_ENV__Code
#define SOAP_TYPE_SOAP_ENV__Code (467)
/* SOAP Fault Code: */
struct SOAP_ENV__Code
{
public:
	char *SOAP_ENV__Value;	/* optional element of type xsd:QName */
	struct SOAP_ENV__Code *SOAP_ENV__Subcode;	/* optional element of type SOAP-ENV:Code */
public:
	int soap_type() const { return 467; } /* = unique type id SOAP_TYPE_SOAP_ENV__Code */
};
#endif

#endif

#ifndef WITH_NOGLOBAL

#ifndef SOAP_TYPE_SOAP_ENV__Reason
#define SOAP_TYPE_SOAP_ENV__Reason (469)
/* SOAP-ENV:Reason */
struct SOAP_ENV__Reason
{
public:
	char *SOAP_ENV__Text;	/* optional element of type xsd:string */
public:
	int soap_type() const { return 469; } /* = unique type id SOAP_TYPE_SOAP_ENV__Reason */
};
#endif

#endif

#ifndef WITH_NOGLOBAL

#ifndef SOAP_TYPE_SOAP_ENV__Fault
#define SOAP_TYPE_SOAP_ENV__Fault (470)
/* SOAP Fault: */
struct SOAP_ENV__Fault
{
public:
	char *faultcode;	/* optional element of type xsd:QName */
	char *faultstring;	/* optional element of type xsd:string */
	char *faultactor;	/* optional element of type xsd:string */
	struct SOAP_ENV__Detail *detail;	/* optional element of type SOAP-ENV:Detail */
	struct SOAP_ENV__Code *SOAP_ENV__Code;	/* optional element of type SOAP-ENV:Code */
	struct SOAP_ENV__Reason *SOAP_ENV__Reason;	/* optional element of type SOAP-ENV:Reason */
	char *SOAP_ENV__Node;	/* optional element of type xsd:string */
	char *SOAP_ENV__Role;	/* optional element of type xsd:string */
	struct SOAP_ENV__Detail *SOAP_ENV__Detail;	/* optional element of type SOAP-ENV:Detail */
public:
	int soap_type() const { return 470; } /* = unique type id SOAP_TYPE_SOAP_ENV__Fault */
};
#endif

#endif

/******************************************************************************\
 *                                                                            *
 * Typedefs                                                                   *
 *                                                                            *
\******************************************************************************/

#ifndef SOAP_TYPE__QName
#define SOAP_TYPE__QName (5)
typedef char *_QName;
#endif

#ifndef SOAP_TYPE__XML
#define SOAP_TYPE__XML (6)
typedef char *_XML;
#endif

#ifndef SOAP_TYPE_xsd__NMTOKEN
#define SOAP_TYPE_xsd__NMTOKEN (19)
typedef std::wstring xsd__NMTOKEN;
#endif

#ifndef SOAP_TYPE_xsd__anyURI
#define SOAP_TYPE_xsd__anyURI (20)
typedef std::wstring xsd__anyURI;
#endif

#ifndef SOAP_TYPE_xsd__date
#define SOAP_TYPE_xsd__date (21)
typedef std::wstring xsd__date;
#endif

#ifndef SOAP_TYPE_xsd__decimal
#define SOAP_TYPE_xsd__decimal (22)
typedef std::wstring xsd__decimal;
#endif

#ifndef SOAP_TYPE_xsd__gYear
#define SOAP_TYPE_xsd__gYear (23)
typedef std::wstring xsd__gYear;
#endif

#ifndef SOAP_TYPE_xsd__integer
#define SOAP_TYPE_xsd__integer (24)
typedef std::wstring xsd__integer;
#endif

#ifndef SOAP_TYPE_xsd__language
#define SOAP_TYPE_xsd__language (25)
typedef std::wstring xsd__language;
#endif

#ifndef SOAP_TYPE_xsd__nonNegativeInteger
#define SOAP_TYPE_xsd__nonNegativeInteger (26)
typedef std::wstring xsd__nonNegativeInteger;
#endif

#ifndef SOAP_TYPE_xsd__positiveInteger
#define SOAP_TYPE_xsd__positiveInteger (27)
typedef std::wstring xsd__positiveInteger;
#endif

#ifndef SOAP_TYPE_xsd__time
#define SOAP_TYPE_xsd__time (28)
typedef std::wstring xsd__time;
#endif

#ifndef SOAP_TYPE__xml__lang
#define SOAP_TYPE__xml__lang (29)
typedef std::wstring _xml__lang;
#endif

#ifndef SOAP_TYPE_fims__UID
#define SOAP_TYPE_fims__UID (189)
typedef std::wstring fims__UID;
#endif

#ifndef SOAP_TYPE_fims__RevisionIDType
#define SOAP_TYPE_fims__RevisionIDType (190)
typedef std::wstring fims__RevisionIDType;
#endif

#ifndef SOAP_TYPE_fimstime__Timecode
#define SOAP_TYPE_fimstime__Timecode (211)
typedef std::wstring fimstime__Timecode;
#endif

#ifndef SOAP_TYPE_fimstime__TimecodeDuration
#define SOAP_TYPE_fimstime__TimecodeDuration (212)
typedef std::wstring fimstime__TimecodeDuration;
#endif

#ifndef SOAP_TYPE_fims__ResourceIDType
#define SOAP_TYPE_fims__ResourceIDType (213)
typedef std::wstring fims__ResourceIDType;
#endif


/******************************************************************************\
 *                                                                            *
 * Externals                                                                  *
 *                                                                            *
\******************************************************************************/


#endif

/* End of EDLProviderStub.h */
