/* EDLProviderC.cpp
   Generated by gSOAP 2.8.18 from D:\Sandbox\EdlProvider\Soap\gsoap\src\EDLProviderInterface.h

Copyright(C) 2000-2014, Robert van Engelen, Genivia Inc. All Rights Reserved.
The generated code is released under one of the following licenses:
GPL or Genivia's license for commercial use.
This program is released under the GPL with the additional exemption that
compiling, linking, and/or using OpenSSL is allowed.
*/

#if defined(__BORLANDC__)
#pragma option push -w-8060
#pragma option push -w-8004
#endif

#include "EDLProviderH.h"

SOAP_SOURCE_STAMP("@(#) EDLProviderC.cpp ver 2.8.18 2014-09-27 20:47:45 GMT")


#ifndef WITH_NOGLOBAL

SOAP_FMAC3 int SOAP_FMAC4 soap_getheader(struct soap *soap)
{
	soap->part = SOAP_IN_HEADER;
	soap->header = soap_in_SOAP_ENV__Header(soap, "SOAP-ENV:Header", soap->header, NULL);
	soap->part = SOAP_END_HEADER;
	return soap->header == NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_putheader(struct soap *soap)
{
	if (soap->version && soap->header)
	{	soap->part = SOAP_IN_HEADER;
		if (soap_out_SOAP_ENV__Header(soap, "SOAP-ENV:Header", 0, soap->header, NULL))
			return soap->error;
		soap->part = SOAP_END_HEADER;
	}
	return SOAP_OK;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serializeheader(struct soap *soap)
{
	if (soap->version && soap->header)
		soap_serialize_SOAP_ENV__Header(soap, soap->header);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_header(struct soap *soap)
{
	if (soap->header == NULL)
	{	if ((soap->header = soap_new_SOAP_ENV__Header(soap, -1)))
			soap_default_SOAP_ENV__Header(soap, soap->header);
	}
}

SOAP_FMAC3 void SOAP_FMAC4 soap_fault(struct soap *soap)
{
	if (soap->fault == NULL)
	{	soap->fault = soap_new_SOAP_ENV__Fault(soap, -1);
		if (soap->fault == NULL)
			return;
		soap_default_SOAP_ENV__Fault(soap, soap->fault);
	}
	if (soap->version == 2 && !soap->fault->SOAP_ENV__Code)
	{	soap->fault->SOAP_ENV__Code = soap_new_SOAP_ENV__Code(soap, -1);
		soap_default_SOAP_ENV__Code(soap, soap->fault->SOAP_ENV__Code);
	}
	if (soap->version == 2 && !soap->fault->SOAP_ENV__Reason)
	{	soap->fault->SOAP_ENV__Reason = soap_new_SOAP_ENV__Reason(soap, -1);
		soap_default_SOAP_ENV__Reason(soap, soap->fault->SOAP_ENV__Reason);
	}
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serializefault(struct soap *soap)
{
	soap_fault(soap);
	if (soap->fault)
		soap_serialize_SOAP_ENV__Fault(soap, soap->fault);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_putfault(struct soap *soap)
{
	if (soap->fault)
		return soap_put_SOAP_ENV__Fault(soap, soap->fault, "SOAP-ENV:Fault", NULL);
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_getfault(struct soap *soap)
{
	return (soap->fault = soap_get_SOAP_ENV__Fault(soap, NULL, "SOAP-ENV:Fault", NULL)) == NULL;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultcode(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2 && soap->fault->SOAP_ENV__Code)
		return (const char**)(void*)&soap->fault->SOAP_ENV__Code->SOAP_ENV__Value;
	return (const char**)(void*)&soap->fault->faultcode;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultsubcode(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2)
	{	if (soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode == NULL)
		{	soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode = soap_new_SOAP_ENV__Code(soap, -1);
			soap_default_SOAP_ENV__Code(soap, soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode);
		}
		return (const char**)(void*)&soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode->SOAP_ENV__Value;
	}
	return (const char**)(void*)&soap->fault->faultcode;
}

SOAP_FMAC3 const char * SOAP_FMAC4 soap_check_faultsubcode(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2)
	{	if (soap->fault->SOAP_ENV__Code && soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode && soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode)
			return soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode->SOAP_ENV__Value;
		return NULL;
	}
	return soap->fault->faultcode;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultstring(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2)
		return (const char**)(void*)&soap->fault->SOAP_ENV__Reason->SOAP_ENV__Text;
	return (const char**)(void*)&soap->fault->faultstring;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultdetail(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2)
	{	if (soap->fault->SOAP_ENV__Detail == NULL)
		{	soap->fault->SOAP_ENV__Detail = soap_new_SOAP_ENV__Detail(soap, -1);
			soap_default_SOAP_ENV__Detail(soap, soap->fault->SOAP_ENV__Detail);
		}
		return (const char**)(void*)&soap->fault->SOAP_ENV__Detail->__any;
	}
	if (soap->fault->detail == NULL)
	{	soap->fault->detail = soap_new_SOAP_ENV__Detail(soap, -1);
		soap_default_SOAP_ENV__Detail(soap, soap->fault->detail);
	}
	return (const char**)(void*)&soap->fault->detail->__any;
}

SOAP_FMAC3 const char * SOAP_FMAC4 soap_check_faultdetail(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2 && soap->fault->SOAP_ENV__Detail)
		return soap->fault->SOAP_ENV__Detail->__any;
	if (soap->fault->detail)
		return soap->fault->detail->__any;
	return NULL;
}

#endif

#ifndef WITH_NOIDREF
SOAP_FMAC3 int SOAP_FMAC4 soap_getindependent(struct soap *soap)
{
	int t;
	if (soap->version == 1)
	{	for (;;)
		{	if (!soap_getelement(soap, &t))
				if (soap->error || soap_ignore_element(soap))
					break;
		}
	}
	if (soap->error == SOAP_NO_TAG || soap->error == SOAP_EOF)
		soap->error = SOAP_OK;
	return soap->error;
}
#endif

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void * SOAP_FMAC4 soap_getelement(struct soap *soap, int *type)
{	(void)type;
	if (soap_peek_element(soap))
		return NULL;
#ifndef WITH_NOIDREF
	if (!*soap->id || !(*type = soap_lookup_type(soap, soap->id)))
		*type = soap_lookup_type(soap, soap->href);
	switch (*type)
	{
	case SOAP_TYPE_byte:
		return soap_in_byte(soap, NULL, NULL, "xsd:byte");
	case SOAP_TYPE_int:
		return soap_in_int(soap, NULL, NULL, "xsd:int");
	case SOAP_TYPE_LONG64:
		return soap_in_LONG64(soap, NULL, NULL, "xsd:long");
	case SOAP_TYPE_xsd__duration:
		return soap_in_xsd__duration(soap, NULL, NULL, "xsd:duration");
	case SOAP_TYPE_float:
		return soap_in_float(soap, NULL, NULL, "xsd:float");
	case SOAP_TYPE_double:
		return soap_in_double(soap, NULL, NULL, "xsd:double");
	case SOAP_TYPE_unsignedByte:
		return soap_in_unsignedByte(soap, NULL, NULL, "xsd:unsignedByte");
	case SOAP_TYPE_unsignedInt:
		return soap_in_unsignedInt(soap, NULL, NULL, "xsd:unsignedInt");
	case SOAP_TYPE_unsignedLONG64:
		return soap_in_unsignedLONG64(soap, NULL, NULL, "xsd:unsignedLong");
	case SOAP_TYPE_time:
		return soap_in_time(soap, NULL, NULL, "xsd:dateTime");
	case SOAP_TYPE_bool:
		return soap_in_bool(soap, NULL, NULL, "xsd:boolean");
	case SOAP_TYPE__fims__QueryServiceDescriptionRequestType_responseType:
		return soap_in__fims__QueryServiceDescriptionRequestType_responseType(soap, NULL, NULL, "fims:QueryServiceDescriptionRequestType-responseType");
	case SOAP_TYPE_fims__EventClassificationType:
		return soap_in_fims__EventClassificationType(soap, NULL, NULL, "fims:EventClassificationType");
	case SOAP_TYPE_fims__EventSubType:
		return soap_in_fims__EventSubType(soap, NULL, NULL, "fims:EventSubType");
	case SOAP_TYPE_fims__EventType:
		return soap_in_fims__EventType(soap, NULL, NULL, "fims:EventType");
	case SOAP_TYPE_fims__QueryParameterOperatorType:
		return soap_in_fims__QueryParameterOperatorType(soap, NULL, NULL, "fims:QueryParameterOperatorType");
	case SOAP_TYPE_fims__QueryGroupOperatorType:
		return soap_in_fims__QueryGroupOperatorType(soap, NULL, NULL, "fims:QueryGroupOperatorType");
	case SOAP_TYPE_fims__BMStatusType:
		return soap_in_fims__BMStatusType(soap, NULL, NULL, "fims:BMStatusType");
	case SOAP_TYPE_fims__DataTypeType:
		return soap_in_fims__DataTypeType(soap, NULL, NULL, "fims:DataTypeType");
	case SOAP_TYPE_fims__JobInfoSelectionType:
		return soap_in_fims__JobInfoSelectionType(soap, NULL, NULL, "fims:JobInfoSelectionType");
	case SOAP_TYPE_fims__ErrorCodeType:
		return soap_in_fims__ErrorCodeType(soap, NULL, NULL, "fims:ErrorCodeType");
	case SOAP_TYPE_fims__BitRateModeType:
		return soap_in_fims__BitRateModeType(soap, NULL, NULL, "fims:BitRateModeType");
	case SOAP_TYPE_fims__ScanningOrderType:
		return soap_in_fims__ScanningOrderType(soap, NULL, NULL, "fims:ScanningOrderType");
	case SOAP_TYPE_fims__ScanningFormatType:
		return soap_in_fims__ScanningFormatType(soap, NULL, NULL, "fims:ScanningFormatType");
	case SOAP_TYPE_fims__AudioSampleType:
		return soap_in_fims__AudioSampleType(soap, NULL, NULL, "fims:AudioSampleType");
	case SOAP_TYPE_fims__JobStatusType:
		return soap_in_fims__JobStatusType(soap, NULL, NULL, "fims:JobStatusType");
	case SOAP_TYPE_fims__HashFunctionTypes:
		return soap_in_fims__HashFunctionTypes(soap, NULL, NULL, "fims:HashFunctionTypes");
	case SOAP_TYPE_fims__JobCommandType:
		return soap_in_fims__JobCommandType(soap, NULL, NULL, "fims:JobCommandType");
	case SOAP_TYPE_fims__QueueCommandType:
		return soap_in_fims__QueueCommandType(soap, NULL, NULL, "fims:QueueCommandType");
	case SOAP_TYPE_fims__StorageTypes:
		return soap_in_fims__StorageTypes(soap, NULL, NULL, "fims:StorageTypes");
	case SOAP_TYPE_fims__PriorityType:
		return soap_in_fims__PriorityType(soap, NULL, NULL, "fims:PriorityType");
	case SOAP_TYPE_fims__QueueStatusType:
		return soap_in_fims__QueueStatusType(soap, NULL, NULL, "fims:QueueStatusType");
	case SOAP_TYPE_fims__CurrentVersion:
		return soap_in_fims__CurrentVersion(soap, NULL, NULL, "fims:CurrentVersion");
	case SOAP_TYPE_edlprovider__EdlProviderErrorCodeType:
		return soap_in_edlprovider__EdlProviderErrorCodeType(soap, NULL, NULL, "edlprovider:EdlProviderErrorCodeType");
	case SOAP_TYPE_fims__ResourceIDType:
		return soap_in_fims__ResourceIDType(soap, NULL, NULL, "fims:ResourceIDType");
	case SOAP_TYPE_fimstime__TimecodeDuration:
		return soap_in_fimstime__TimecodeDuration(soap, NULL, NULL, "fimstime:TimecodeDuration");
	case SOAP_TYPE_fimstime__Timecode:
		return soap_in_fimstime__Timecode(soap, NULL, NULL, "fimstime:Timecode");
	case SOAP_TYPE_fims__RevisionIDType:
		return soap_in_fims__RevisionIDType(soap, NULL, NULL, "fims:RevisionIDType");
	case SOAP_TYPE_fims__UID:
		return soap_in_fims__UID(soap, NULL, NULL, "fims:UID");
	case SOAP_TYPE_fimsdescription__partType:
		return soap_in_fimsdescription__partType(soap, NULL, NULL, "fimsdescription:partType");
	case SOAP_TYPE_fimsdescription__relationType:
		return soap_in_fimsdescription__relationType(soap, NULL, NULL, "fimsdescription:relationType");
	case SOAP_TYPE_fimsdescription__languageType:
		return soap_in_fimsdescription__languageType(soap, NULL, NULL, "fimsdescription:languageType");
	case SOAP_TYPE_fimsdescription__addressType:
		return soap_in_fimsdescription__addressType(soap, NULL, NULL, "fimsdescription:addressType");
	case SOAP_TYPE_fimsdescription__detailsType:
		return soap_in_fimsdescription__detailsType(soap, NULL, NULL, "fimsdescription:detailsType");
	case SOAP_TYPE_fimsdescription__organisationDetailsType:
		return soap_in_fimsdescription__organisationDetailsType(soap, NULL, NULL, "fimsdescription:organisationDetailsType");
	case SOAP_TYPE_fimsdescription__contactDetailsType:
		return soap_in_fimsdescription__contactDetailsType(soap, NULL, NULL, "fimsdescription:contactDetailsType");
	case SOAP_TYPE_fimsdescription__entityType:
		return soap_in_fimsdescription__entityType(soap, NULL, NULL, "fimsdescription:entityType");
	case SOAP_TYPE_fimsdescription__dateType:
		return soap_in_fimsdescription__dateType(soap, NULL, NULL, "fimsdescription:dateType");
	case SOAP_TYPE_fimsdescription__textElementType:
		return soap_in_fimsdescription__textElementType(soap, NULL, NULL, "fimsdescription:textElementType");
	case SOAP_TYPE_fimsdescription__rightsType:
		return soap_in_fimsdescription__rightsType(soap, NULL, NULL, "fimsdescription:rightsType");
	case SOAP_TYPE_fimsdescription__coverageType:
		return soap_in_fimsdescription__coverageType(soap, NULL, NULL, "fimsdescription:coverageType");
	case SOAP_TYPE_fimsdescription__descriptionType:
		return soap_in_fimsdescription__descriptionType(soap, NULL, NULL, "fimsdescription:descriptionType");
	case SOAP_TYPE_fimsdescription__typeType:
		return soap_in_fimsdescription__typeType(soap, NULL, NULL, "fimsdescription:typeType");
	case SOAP_TYPE_fimsdescription__subjectType:
		return soap_in_fimsdescription__subjectType(soap, NULL, NULL, "fimsdescription:subjectType");
	case SOAP_TYPE_fimsdescription__identifierType:
		return soap_in_fimsdescription__identifierType(soap, NULL, NULL, "fimsdescription:identifierType");
	case SOAP_TYPE_fimsdescription__titleType:
		return soap_in_fimsdescription__titleType(soap, NULL, NULL, "fimsdescription:titleType");
	case SOAP_TYPE_fimsdescription__bmContentDescriptionType:
		return soap_in_fimsdescription__bmContentDescriptionType(soap, NULL, NULL, "fimsdescription:bmContentDescriptionType");
	case SOAP_TYPE_fimstime__EditUnitNumberType:
		return soap_in_fimstime__EditUnitNumberType(soap, NULL, NULL, "fimstime:EditUnitNumberType");
	case SOAP_TYPE_fimstime__TimeType:
		return soap_in_fimstime__TimeType(soap, NULL, NULL, "fimstime:TimeType");
	case SOAP_TYPE_fimstime__DurationType:
		return soap_in_fimstime__DurationType(soap, NULL, NULL, "fimstime:DurationType");
	case SOAP_TYPE_fims__SystemPerformanceEventsType:
		return soap_in_fims__SystemPerformanceEventsType(soap, NULL, NULL, "fims:SystemPerformanceEventsType");
	case SOAP_TYPE_fims__SystemPerformanceEventType:
		return soap_in_fims__SystemPerformanceEventType(soap, NULL, NULL, "fims:SystemPerformanceEventType");
	case SOAP_TYPE_fims__SystemExceptionEventsType:
		return soap_in_fims__SystemExceptionEventsType(soap, NULL, NULL, "fims:SystemExceptionEventsType");
	case SOAP_TYPE_fims__SystemExceptionEventType:
		return soap_in_fims__SystemExceptionEventType(soap, NULL, NULL, "fims:SystemExceptionEventType");
	case SOAP_TYPE_fims__SystemEventsType:
		return soap_in_fims__SystemEventsType(soap, NULL, NULL, "fims:SystemEventsType");
	case SOAP_TYPE_fims__SystemEventType:
		return soap_in_fims__SystemEventType(soap, NULL, NULL, "fims:SystemEventType");
	case SOAP_TYPE_fims__ContentCustomEventsType:
		return soap_in_fims__ContentCustomEventsType(soap, NULL, NULL, "fims:ContentCustomEventsType");
	case SOAP_TYPE_fims__ContentCustomEventType:
		return soap_in_fims__ContentCustomEventType(soap, NULL, NULL, "fims:ContentCustomEventType");
	case SOAP_TYPE_fims__ContentStatusEventsType:
		return soap_in_fims__ContentStatusEventsType(soap, NULL, NULL, "fims:ContentStatusEventsType");
	case SOAP_TYPE_fims__ContentStatusEventType:
		return soap_in_fims__ContentStatusEventType(soap, NULL, NULL, "fims:ContentStatusEventType");
	case SOAP_TYPE_fims__ContentEventsType:
		return soap_in_fims__ContentEventsType(soap, NULL, NULL, "fims:ContentEventsType");
	case SOAP_TYPE_fims__ContentEventType:
		return soap_in_fims__ContentEventType(soap, NULL, NULL, "fims:ContentEventType");
	case SOAP_TYPE_fims__EventPayloadsType:
		return soap_in_fims__EventPayloadsType(soap, NULL, NULL, "fims:EventPayloadsType");
	case SOAP_TYPE_fims__EventPayloadType:
		return soap_in_fims__EventPayloadType(soap, NULL, NULL, "fims:EventPayloadType");
	case SOAP_TYPE_fims__EventEnvelopesType:
		return soap_in_fims__EventEnvelopesType(soap, NULL, NULL, "fims:EventEnvelopesType");
	case SOAP_TYPE_fims__EventEnvelopeType:
		return soap_in_fims__EventEnvelopeType(soap, NULL, NULL, "fims:EventEnvelopeType");
	case SOAP_TYPE_fims__CustomEventTemplatesType:
		return soap_in_fims__CustomEventTemplatesType(soap, NULL, NULL, "fims:CustomEventTemplatesType");
	case SOAP_TYPE_fims__CustomEventTemplateType:
		return soap_in_fims__CustomEventTemplateType(soap, NULL, NULL, "fims:CustomEventTemplateType");
	case SOAP_TYPE_fims__QueryGroupsType:
		return soap_in_fims__QueryGroupsType(soap, NULL, NULL, "fims:QueryGroupsType");
	case SOAP_TYPE_fims__QueryGroupType:
		return soap_in_fims__QueryGroupType(soap, NULL, NULL, "fims:QueryGroupType");
	case SOAP_TYPE_fims__CustomQueryGroupOperatorsType:
		return soap_in_fims__CustomQueryGroupOperatorsType(soap, NULL, NULL, "fims:CustomQueryGroupOperatorsType");
	case SOAP_TYPE_fims__CustomQueryGroupOperatorType:
		return soap_in_fims__CustomQueryGroupOperatorType(soap, NULL, NULL, "fims:CustomQueryGroupOperatorType");
	case SOAP_TYPE_fims__QueryParametersType:
		return soap_in_fims__QueryParametersType(soap, NULL, NULL, "fims:QueryParametersType");
	case SOAP_TYPE_fims__QueryParameterType:
		return soap_in_fims__QueryParameterType(soap, NULL, NULL, "fims:QueryParameterType");
	case SOAP_TYPE_fims__CustomQueryParameterOperatorsType:
		return soap_in_fims__CustomQueryParameterOperatorsType(soap, NULL, NULL, "fims:CustomQueryParameterOperatorsType");
	case SOAP_TYPE_fims__CustomQueryParameterOperatorType:
		return soap_in_fims__CustomQueryParameterOperatorType(soap, NULL, NULL, "fims:CustomQueryParameterOperatorType");
	case SOAP_TYPE_fims__QueryExpressionsType:
		return soap_in_fims__QueryExpressionsType(soap, NULL, NULL, "fims:QueryExpressionsType");
	case SOAP_TYPE_fims__QueryExpressionType:
		return soap_in_fims__QueryExpressionType(soap, NULL, NULL, "fims:QueryExpressionType");
	case SOAP_TYPE_fims__SuperLockTokensType:
		return soap_in_fims__SuperLockTokensType(soap, NULL, NULL, "fims:SuperLockTokensType");
	case SOAP_TYPE_fims__SuperLockTokenType:
		return soap_in_fims__SuperLockTokenType(soap, NULL, NULL, "fims:SuperLockTokenType");
	case SOAP_TYPE_fims__LockTokensType:
		return soap_in_fims__LockTokensType(soap, NULL, NULL, "fims:LockTokensType");
	case SOAP_TYPE_fims__LockTokenType:
		return soap_in_fims__LockTokenType(soap, NULL, NULL, "fims:LockTokenType");
	case SOAP_TYPE_fims__CredentialsType:
		return soap_in_fims__CredentialsType(soap, NULL, NULL, "fims:CredentialsType");
	case SOAP_TYPE_fims__CredentialType:
		return soap_in_fims__CredentialType(soap, NULL, NULL, "fims:CredentialType");
	case SOAP_TYPE_fims__BMEssenceLocatorStatusesType:
		return soap_in_fims__BMEssenceLocatorStatusesType(soap, NULL, NULL, "fims:BMEssenceLocatorStatusesType");
	case SOAP_TYPE_fims__BMEssenceLocatorStatusType:
		return soap_in_fims__BMEssenceLocatorStatusType(soap, NULL, NULL, "fims:BMEssenceLocatorStatusType");
	case SOAP_TYPE_fims__BMContentStatusesType:
		return soap_in_fims__BMContentStatusesType(soap, NULL, NULL, "fims:BMContentStatusesType");
	case SOAP_TYPE_fims__BMContentStatusType:
		return soap_in_fims__BMContentStatusType(soap, NULL, NULL, "fims:BMContentStatusType");
	case SOAP_TYPE_fims__BMCustomStatusExtensionsType:
		return soap_in_fims__BMCustomStatusExtensionsType(soap, NULL, NULL, "fims:BMCustomStatusExtensionsType");
	case SOAP_TYPE_fims__BMCustomStatusExtensionType:
		return soap_in_fims__BMCustomStatusExtensionType(soap, NULL, NULL, "fims:BMCustomStatusExtensionType");
	case SOAP_TYPE_fims__CustomValuesType:
		return soap_in_fims__CustomValuesType(soap, NULL, NULL, "fims:CustomValuesType");
	case SOAP_TYPE_fims__CustomValueType:
		return soap_in_fims__CustomValueType(soap, NULL, NULL, "fims:CustomValueType");
	case SOAP_TYPE_fims__ResourceReferencesType:
		return soap_in_fims__ResourceReferencesType(soap, NULL, NULL, "fims:ResourceReferencesType");
	case SOAP_TYPE_fims__DescriptionsType:
		return soap_in_fims__DescriptionsType(soap, NULL, NULL, "fims:DescriptionsType");
	case SOAP_TYPE_fims__BMEssenceLocatorsType:
		return soap_in_fims__BMEssenceLocatorsType(soap, NULL, NULL, "fims:BMEssenceLocatorsType");
	case SOAP_TYPE_fims__BMContentFormatsType:
		return soap_in_fims__BMContentFormatsType(soap, NULL, NULL, "fims:BMContentFormatsType");
	case SOAP_TYPE_fims__BMContentsType:
		return soap_in_fims__BMContentsType(soap, NULL, NULL, "fims:BMContentsType");
	case SOAP_TYPE_fims__BMObjectsType:
		return soap_in_fims__BMObjectsType(soap, NULL, NULL, "fims:BMObjectsType");
	case SOAP_TYPE_fims__DataFormatsType:
		return soap_in_fims__DataFormatsType(soap, NULL, NULL, "fims:DataFormatsType");
	case SOAP_TYPE_fims__ContainerFormatsType:
		return soap_in_fims__ContainerFormatsType(soap, NULL, NULL, "fims:ContainerFormatsType");
	case SOAP_TYPE_fims__AudioFormatsType:
		return soap_in_fims__AudioFormatsType(soap, NULL, NULL, "fims:AudioFormatsType");
	case SOAP_TYPE_fims__VideoFormatsType:
		return soap_in_fims__VideoFormatsType(soap, NULL, NULL, "fims:VideoFormatsType");
	case SOAP_TYPE_fims__JobsType:
		return soap_in_fims__JobsType(soap, NULL, NULL, "fims:JobsType");
	case SOAP_TYPE_fims__QueuesType:
		return soap_in_fims__QueuesType(soap, NULL, NULL, "fims:QueuesType");
	case SOAP_TYPE_fims__ServicesType:
		return soap_in_fims__ServicesType(soap, NULL, NULL, "fims:ServicesType");
	case SOAP_TYPE_fims__ProfilesType:
		return soap_in_fims__ProfilesType(soap, NULL, NULL, "fims:ProfilesType");
	case SOAP_TYPE_fims__ResourcesType:
		return soap_in_fims__ResourcesType(soap, NULL, NULL, "fims:ResourcesType");
	case SOAP_TYPE_fims__InnerFaultType:
		return soap_in_fims__InnerFaultType(soap, NULL, NULL, "fims:InnerFaultType");
	case SOAP_TYPE_fims__FaultType:
		return soap_in_fims__FaultType(soap, NULL, NULL, "fims:FaultType");
	case SOAP_TYPE_fims__ListFilterType:
		return soap_in_fims__ListFilterType(soap, NULL, NULL, "fims:ListFilterType");
	case SOAP_TYPE_fims__QueryServiceDescriptionResponseType:
		return soap_in_fims__QueryServiceDescriptionResponseType(soap, NULL, NULL, "fims:QueryServiceDescriptionResponseType");
	case SOAP_TYPE_fims__QueryServiceDescriptionRequestType:
		return soap_in_fims__QueryServiceDescriptionRequestType(soap, NULL, NULL, "fims:QueryServiceDescriptionRequestType");
	case SOAP_TYPE_fims__QueryJobResponseType:
		return soap_in_fims__QueryJobResponseType(soap, NULL, NULL, "fims:QueryJobResponseType");
	case SOAP_TYPE_fims__QueryJobRequestByFilterType:
		return soap_in_fims__QueryJobRequestByFilterType(soap, NULL, NULL, "fims:QueryJobRequestByFilterType");
	case SOAP_TYPE_fims__QueryJobRequestByIDType:
		return soap_in_fims__QueryJobRequestByIDType(soap, NULL, NULL, "fims:QueryJobRequestByIDType");
	case SOAP_TYPE_fims__QueryJobRequestType:
		return soap_in_fims__QueryJobRequestType(soap, NULL, NULL, "fims:QueryJobRequestType");
	case SOAP_TYPE_fims__ManageQueueResponseType:
		return soap_in_fims__ManageQueueResponseType(soap, NULL, NULL, "fims:ManageQueueResponseType");
	case SOAP_TYPE_fims__ManageQueueRequestType:
		return soap_in_fims__ManageQueueRequestType(soap, NULL, NULL, "fims:ManageQueueRequestType");
	case SOAP_TYPE_fims__ManageJobResponseType:
		return soap_in_fims__ManageJobResponseType(soap, NULL, NULL, "fims:ManageJobResponseType");
	case SOAP_TYPE_fims__ManageJobRequestType:
		return soap_in_fims__ManageJobRequestType(soap, NULL, NULL, "fims:ManageJobRequestType");
	case SOAP_TYPE_fims__StartJobByLatestType:
		return soap_in_fims__StartJobByLatestType(soap, NULL, NULL, "fims:StartJobByLatestType");
	case SOAP_TYPE_fims__StartJobByTimeType:
		return soap_in_fims__StartJobByTimeType(soap, NULL, NULL, "fims:StartJobByTimeType");
	case SOAP_TYPE_fims__StartJobByNoWaitType:
		return soap_in_fims__StartJobByNoWaitType(soap, NULL, NULL, "fims:StartJobByNoWaitType");
	case SOAP_TYPE_fims__StartJobType:
		return soap_in_fims__StartJobType(soap, NULL, NULL, "fims:StartJobType");
	case SOAP_TYPE_fims__StopProcessByOpenEndType:
		return soap_in_fims__StopProcessByOpenEndType(soap, NULL, NULL, "fims:StopProcessByOpenEndType");
	case SOAP_TYPE_fims__StopProcessByServiceDefinedTimeType:
		return soap_in_fims__StopProcessByServiceDefinedTimeType(soap, NULL, NULL, "fims:StopProcessByServiceDefinedTimeType");
	case SOAP_TYPE_fims__StopProcessByTimeMarkType:
		return soap_in_fims__StopProcessByTimeMarkType(soap, NULL, NULL, "fims:StopProcessByTimeMarkType");
	case SOAP_TYPE_fims__StopProcessByDurationType:
		return soap_in_fims__StopProcessByDurationType(soap, NULL, NULL, "fims:StopProcessByDurationType");
	case SOAP_TYPE_fims__StopProcessByTimeType:
		return soap_in_fims__StopProcessByTimeType(soap, NULL, NULL, "fims:StopProcessByTimeType");
	case SOAP_TYPE_fims__StopProcessType:
		return soap_in_fims__StopProcessType(soap, NULL, NULL, "fims:StopProcessType");
	case SOAP_TYPE_fims__StartProcessByServiceDefinedTimeType:
		return soap_in_fims__StartProcessByServiceDefinedTimeType(soap, NULL, NULL, "fims:StartProcessByServiceDefinedTimeType");
	case SOAP_TYPE_fims__StartProcessByTimeMarkType:
		return soap_in_fims__StartProcessByTimeMarkType(soap, NULL, NULL, "fims:StartProcessByTimeMarkType");
	case SOAP_TYPE_fims__StartProcessByTimeType:
		return soap_in_fims__StartProcessByTimeType(soap, NULL, NULL, "fims:StartProcessByTimeType");
	case SOAP_TYPE_fims__StartProcessByNoWaitType:
		return soap_in_fims__StartProcessByNoWaitType(soap, NULL, NULL, "fims:StartProcessByNoWaitType");
	case SOAP_TYPE_fims__StartProcessType:
		return soap_in_fims__StartProcessType(soap, NULL, NULL, "fims:StartProcessType");
	case SOAP_TYPE_fims__HashFunctionType:
		return soap_in_fims__HashFunctionType(soap, NULL, NULL, "fims:HashFunctionType");
	case SOAP_TYPE_fims__StorageType:
		return soap_in_fims__StorageType(soap, NULL, NULL, "fims:StorageType");
	case SOAP_TYPE_fims__ProcessedInfoByFramesType:
		return soap_in_fims__ProcessedInfoByFramesType(soap, NULL, NULL, "fims:ProcessedInfoByFramesType");
	case SOAP_TYPE_fims__ProcessedInfoByBytesType:
		return soap_in_fims__ProcessedInfoByBytesType(soap, NULL, NULL, "fims:ProcessedInfoByBytesType");
	case SOAP_TYPE_fims__ProcessedInfoType:
		return soap_in_fims__ProcessedInfoType(soap, NULL, NULL, "fims:ProcessedInfoType");
	case SOAP_TYPE_fims__HashType:
		return soap_in_fims__HashType(soap, NULL, NULL, "fims:HashType");
	case SOAP_TYPE_fims__RationalType:
		return soap_in_fims__RationalType(soap, NULL, NULL, "fims:RationalType");
	case SOAP_TYPE_fims__LengthType:
		return soap_in_fims__LengthType(soap, NULL, NULL, "fims:LengthType");
	case SOAP_TYPE_fims__TechnicalAttributeType:
		return soap_in_fims__TechnicalAttributeType(soap, NULL, NULL, "fims:TechnicalAttributeType");
	case SOAP_TYPE_fims__TransformAtomType:
		return soap_in_fims__TransformAtomType(soap, NULL, NULL, "fims:TransformAtomType");
	case SOAP_TYPE_fims__TransferAtomType:
		return soap_in_fims__TransferAtomType(soap, NULL, NULL, "fims:TransferAtomType");
	case SOAP_TYPE_fims__EssencePlaceholderLocatorType:
		return soap_in_fims__EssencePlaceholderLocatorType(soap, NULL, NULL, "fims:EssencePlaceholderLocatorType");
	case SOAP_TYPE_fims__FolderLocatorType:
		return soap_in_fims__FolderLocatorType(soap, NULL, NULL, "fims:FolderLocatorType");
	case SOAP_TYPE_fims__ListFileLocatorType:
		return soap_in_fims__ListFileLocatorType(soap, NULL, NULL, "fims:ListFileLocatorType");
	case SOAP_TYPE_fims__SimpleFileLocatorType:
		return soap_in_fims__SimpleFileLocatorType(soap, NULL, NULL, "fims:SimpleFileLocatorType");
	case SOAP_TYPE_fims__BMEssenceLocatorType:
		return soap_in_fims__BMEssenceLocatorType(soap, NULL, NULL, "fims:BMEssenceLocatorType");
	case SOAP_TYPE_fims__BMContentFormatType:
		return soap_in_fims__BMContentFormatType(soap, NULL, NULL, "fims:BMContentFormatType");
	case SOAP_TYPE_fims__DescriptionType:
		return soap_in_fims__DescriptionType(soap, NULL, NULL, "fims:DescriptionType");
	case SOAP_TYPE_fims__BMContentType:
		return soap_in_fims__BMContentType(soap, NULL, NULL, "fims:BMContentType");
	case SOAP_TYPE_fims__BMObjectType:
		return soap_in_fims__BMObjectType(soap, NULL, NULL, "fims:BMObjectType");
	case SOAP_TYPE_fims__CodecType:
		return soap_in_fims__CodecType(soap, NULL, NULL, "fims:CodecType");
	case SOAP_TYPE_fims__BMTrackType:
		return soap_in_fims__BMTrackType(soap, NULL, NULL, "fims:BMTrackType");
	case SOAP_TYPE_fims__ContainerFormatType:
		return soap_in_fims__ContainerFormatType(soap, NULL, NULL, "fims:ContainerFormatType");
	case SOAP_TYPE_fims__AncillaryDataFormatType:
		return soap_in_fims__AncillaryDataFormatType(soap, NULL, NULL, "fims:AncillaryDataFormatType");
	case SOAP_TYPE_fims__CaptioningFormatType:
		return soap_in_fims__CaptioningFormatType(soap, NULL, NULL, "fims:CaptioningFormatType");
	case SOAP_TYPE_fims__DataFormatType:
		return soap_in_fims__DataFormatType(soap, NULL, NULL, "fims:DataFormatType");
	case SOAP_TYPE_fims__AudioFormatType:
		return soap_in_fims__AudioFormatType(soap, NULL, NULL, "fims:AudioFormatType");
	case SOAP_TYPE_fims__VideoFormatType:
		return soap_in_fims__VideoFormatType(soap, NULL, NULL, "fims:VideoFormatType");
	case SOAP_TYPE_fims__FormatType:
		return soap_in_fims__FormatType(soap, NULL, NULL, "fims:FormatType");
	case SOAP_TYPE_fims__JobType:
		return soap_in_fims__JobType(soap, NULL, NULL, "fims:JobType");
	case SOAP_TYPE_fims__QueueType:
		return soap_in_fims__QueueType(soap, NULL, NULL, "fims:QueueType");
	case SOAP_TYPE_fims__ProfileType:
		return soap_in_fims__ProfileType(soap, NULL, NULL, "fims:ProfileType");
	case SOAP_TYPE_fims__ServiceType:
		return soap_in_fims__ServiceType(soap, NULL, NULL, "fims:ServiceType");
	case SOAP_TYPE_fims__AsyncEndpointType:
		return soap_in_fims__AsyncEndpointType(soap, NULL, NULL, "fims:AsyncEndpointType");
	case SOAP_TYPE_fims__ExtensionBaseType:
		return soap_in_fims__ExtensionBaseType(soap, NULL, NULL, "fims:ExtensionBaseType");
	case SOAP_TYPE_fims__ResourceType:
		return soap_in_fims__ResourceType(soap, NULL, NULL, "fims:ResourceType");
	case SOAP_TYPE_fims__ResourceReferenceType:
		return soap_in_fims__ResourceReferenceType(soap, NULL, NULL, "fims:ResourceReferenceType");
	case SOAP_TYPE_fims__ExtensionAttributes:
		return soap_in_fims__ExtensionAttributes(soap, NULL, NULL, "fims:ExtensionAttributes");
	case SOAP_TYPE_fims__ExtensionGroup:
		return soap_in_fims__ExtensionGroup(soap, NULL, NULL, "fims:ExtensionGroup");
	case SOAP_TYPE_edlprovider__EdlProviderFaultType:
		return soap_in_edlprovider__EdlProviderFaultType(soap, NULL, NULL, "edlprovider:EdlProviderFaultType");
	case SOAP_TYPE_edlprovider__InstalledEdlsResponseType:
		return soap_in_edlprovider__InstalledEdlsResponseType(soap, NULL, NULL, "edlprovider:InstalledEdlsResponseType");
	case SOAP_TYPE_edlprovider__EdlCreateResponseType:
		return soap_in_edlprovider__EdlCreateResponseType(soap, NULL, NULL, "edlprovider:EdlCreateResponseType");
	case SOAP_TYPE_edlprovider__EdlCreateRequestDoubleType:
		return soap_in_edlprovider__EdlCreateRequestDoubleType(soap, NULL, NULL, "edlprovider:EdlCreateRequestDoubleType");
	case SOAP_TYPE_edlprovider__EdlCreateRequestType:
		return soap_in_edlprovider__EdlCreateRequestType(soap, NULL, NULL, "edlprovider:EdlCreateRequestType");
	case SOAP_TYPE_edlprovider__EdlCreateRequestBaseType:
		return soap_in_edlprovider__EdlCreateRequestBaseType(soap, NULL, NULL, "edlprovider:EdlCreateRequestBaseType");
	case SOAP_TYPE_edlprovider__MapItemType:
		return soap_in_edlprovider__MapItemType(soap, NULL, NULL, "edlprovider:MapItemType");
	case SOAP_TYPE_edlprovider__ClipType:
		return soap_in_edlprovider__ClipType(soap, NULL, NULL, "edlprovider:ClipType");
	case SOAP_TYPE_edlprovider__ArrayOfClips:
		return soap_in_edlprovider__ArrayOfClips(soap, NULL, NULL, "edlprovider:ArrayOfClips");
	case SOAP_TYPE_edlprovider__ArrayOfstring:
		return soap_in_edlprovider__ArrayOfstring(soap, NULL, NULL, "edlprovider:ArrayOfstring");
	case SOAP_TYPE_xsd__time:
		return soap_in_xsd__time(soap, NULL, NULL, "xsd:time");
	case SOAP_TYPE_xsd__positiveInteger:
		return soap_in_xsd__positiveInteger(soap, NULL, NULL, "xsd:positiveInteger");
	case SOAP_TYPE_xsd__nonNegativeInteger:
		return soap_in_xsd__nonNegativeInteger(soap, NULL, NULL, "xsd:nonNegativeInteger");
	case SOAP_TYPE_xsd__language:
		return soap_in_xsd__language(soap, NULL, NULL, "xsd:language");
	case SOAP_TYPE_xsd__integer:
		return soap_in_xsd__integer(soap, NULL, NULL, "xsd:integer");
	case SOAP_TYPE_xsd__gYear:
		return soap_in_xsd__gYear(soap, NULL, NULL, "xsd:gYear");
	case SOAP_TYPE_xsd__decimal:
		return soap_in_xsd__decimal(soap, NULL, NULL, "xsd:decimal");
	case SOAP_TYPE_xsd__date:
		return soap_in_xsd__date(soap, NULL, NULL, "xsd:date");
	case SOAP_TYPE_xsd__anyURI:
		return soap_in_xsd__anyURI(soap, NULL, NULL, "xsd:anyURI");
	case SOAP_TYPE_xsd__NMTOKEN:
		return soap_in_xsd__NMTOKEN(soap, NULL, NULL, "xsd:NMTOKEN");
	case SOAP_TYPE_std__wstring:
		return soap_in_std__wstring(soap, NULL, NULL, "xsd:string");
	case SOAP_TYPE_xsd__hexBinary:
		return soap_in_xsd__hexBinary(soap, NULL, NULL, "xsd:hexBinary");
	case SOAP_TYPE_xsd__base64Binary:
		return soap_in_xsd__base64Binary(soap, NULL, NULL, "xsd:base64Binary");
	case SOAP_TYPE_PointerToedlprovider__EdlCreateRequestDoubleType:
		return soap_in_PointerToedlprovider__EdlCreateRequestDoubleType(soap, NULL, NULL, "edlprovider:EdlCreateRequestDoubleType");
	case SOAP_TYPE_PointerToedlprovider__EdlCreateRequestType:
		return soap_in_PointerToedlprovider__EdlCreateRequestType(soap, NULL, NULL, "edlprovider:EdlCreateRequestType");
	case SOAP_TYPE_PointerToedlprovider__EdlProviderFaultType:
		return soap_in_PointerToedlprovider__EdlProviderFaultType(soap, NULL, NULL, "edlprovider:EdlProviderFaultType");
	case SOAP_TYPE_PointerTo_fims__ContainerFormatType_containerFormat:
		return soap_in_PointerTo_fims__ContainerFormatType_containerFormat(soap, NULL, NULL, "fims:ContainerFormatType-containerFormat");
	case SOAP_TYPE_PointerTofims__AncillaryDataFormatType:
		return soap_in_PointerTofims__AncillaryDataFormatType(soap, NULL, NULL, "fims:AncillaryDataFormatType");
	case SOAP_TYPE_PointerTofims__CaptioningFormatType:
		return soap_in_PointerTofims__CaptioningFormatType(soap, NULL, NULL, "fims:CaptioningFormatType");
	case SOAP_TYPE_PointerTofims__AudioSampleType:
		return soap_in_PointerTofims__AudioSampleType(soap, NULL, NULL, "fims:AudioSampleType");
	case SOAP_TYPE_PointerTo_fims__AudioFormatType_trackConfiguration:
		return soap_in_PointerTo_fims__AudioFormatType_trackConfiguration(soap, NULL, NULL, "fims:AudioFormatType-trackConfiguration");
	case SOAP_TYPE_PointerToxsd__decimal:
		return soap_in_PointerToxsd__decimal(soap, NULL, NULL, "xsd:decimal");
	case SOAP_TYPE_PointerTofims__ScanningOrderType:
		return soap_in_PointerTofims__ScanningOrderType(soap, NULL, NULL, "fims:ScanningOrderType");
	case SOAP_TYPE_PointerTofims__ScanningFormatType:
		return soap_in_PointerTofims__ScanningFormatType(soap, NULL, NULL, "fims:ScanningFormatType");
	case SOAP_TYPE_PointerTofims__BitRateModeType:
		return soap_in_PointerTofims__BitRateModeType(soap, NULL, NULL, "fims:BitRateModeType");
	case SOAP_TYPE_PointerTofims__BMTrackType:
		return soap_in_PointerTofims__BMTrackType(soap, NULL, NULL, "fims:BMTrackType");
	case SOAP_TYPE_PointerTofims__CodecType:
		return soap_in_PointerTofims__CodecType(soap, NULL, NULL, "fims:CodecType");
	case SOAP_TYPE_PointerTofims__LengthType:
		return soap_in_PointerTofims__LengthType(soap, NULL, NULL, "fims:LengthType");
	case SOAP_TYPE_PointerTofims__ResourceReferencesType:
		return soap_in_PointerTofims__ResourceReferencesType(soap, NULL, NULL, "fims:ResourceReferencesType");
	case SOAP_TYPE_PointerTo_fims__BMEssenceLocatorType_containerMimeType:
		return soap_in_PointerTo_fims__BMEssenceLocatorType_containerMimeType(soap, NULL, NULL, "fims:BMEssenceLocatorType-containerMimeType");
	case SOAP_TYPE_PointerTofims__StorageType:
		return soap_in_PointerTofims__StorageType(soap, NULL, NULL, "fims:StorageType");
	case SOAP_TYPE_PointerTo_fims__BMContentFormatType_mimeType:
		return soap_in_PointerTo_fims__BMContentFormatType_mimeType(soap, NULL, NULL, "fims:BMContentFormatType-mimeType");
	case SOAP_TYPE_PointerTounsignedLONG64:
		return soap_in_PointerTounsignedLONG64(soap, NULL, NULL, "xsd:unsignedLong");
	case SOAP_TYPE_PointerTofims__HashType:
		return soap_in_PointerTofims__HashType(soap, NULL, NULL, "fims:HashType");
	case SOAP_TYPE_PointerTo_fims__formatCollection:
		return soap_in_PointerTo_fims__formatCollection(soap, NULL, NULL, "fims:formatCollection");
	case SOAP_TYPE_PointerTofims__BMEssenceLocatorsType:
		return soap_in_PointerTofims__BMEssenceLocatorsType(soap, NULL, NULL, "fims:BMEssenceLocatorsType");
	case SOAP_TYPE_PointerTofimsdescription__bmContentDescriptionType:
		return soap_in_PointerTofimsdescription__bmContentDescriptionType(soap, NULL, NULL, "fimsdescription:bmContentDescriptionType");
	case SOAP_TYPE_PointerTofims__DescriptionsType:
		return soap_in_PointerTofims__DescriptionsType(soap, NULL, NULL, "fims:DescriptionsType");
	case SOAP_TYPE_PointerTofims__BMContentFormatsType:
		return soap_in_PointerTofims__BMContentFormatsType(soap, NULL, NULL, "fims:BMContentFormatsType");
	case SOAP_TYPE_PointerTofims__BMContentsType:
		return soap_in_PointerTofims__BMContentsType(soap, NULL, NULL, "fims:BMContentsType");
	case SOAP_TYPE_PointerTofims__TechnicalAttributeType:
		return soap_in_PointerTofims__TechnicalAttributeType(soap, NULL, NULL, "fims:TechnicalAttributeType");
	case SOAP_TYPE_PointerTofims__ProcessedInfoType:
		return soap_in_PointerTofims__ProcessedInfoType(soap, NULL, NULL, "fims:ProcessedInfoType");
	case SOAP_TYPE_PointerTofims__StartJobType:
		return soap_in_PointerTofims__StartJobType(soap, NULL, NULL, "fims:StartJobType");
	case SOAP_TYPE_PointerTofims__BMObjectsType:
		return soap_in_PointerTofims__BMObjectsType(soap, NULL, NULL, "fims:BMObjectsType");
	case SOAP_TYPE_PointerTofims__JobStatusType:
		return soap_in_PointerTofims__JobStatusType(soap, NULL, NULL, "fims:JobStatusType");
	case SOAP_TYPE_PointerTofims__QueueStatusType:
		return soap_in_PointerTofims__QueueStatusType(soap, NULL, NULL, "fims:QueueStatusType");
	case SOAP_TYPE_PointerTo_fims__ServiceType_serviceDescription:
		return soap_in_PointerTo_fims__ServiceType_serviceDescription(soap, NULL, NULL, "fims:ServiceType-serviceDescription");
	case SOAP_TYPE_PointerToxsd__NMTOKEN:
		return soap_in_PointerToxsd__NMTOKEN(soap, NULL, NULL, "xsd:NMTOKEN");
	case SOAP_TYPE_PointerTofims__ListFilterType:
		return soap_in_PointerTofims__ListFilterType(soap, NULL, NULL, "fims:ListFilterType");
	case SOAP_TYPE_PointerTofimstime__DurationType:
		return soap_in_PointerTofimstime__DurationType(soap, NULL, NULL, "fimstime:DurationType");
	case SOAP_TYPE_PointerTofims__AsyncEndpointType:
		return soap_in_PointerTofims__AsyncEndpointType(soap, NULL, NULL, "fims:AsyncEndpointType");
	case SOAP_TYPE_PointerToedlprovider__EdlProviderErrorCodeType:
		return soap_in_PointerToedlprovider__EdlProviderErrorCodeType(soap, NULL, NULL, "edlprovider:EdlProviderErrorCodeType");
	case SOAP_TYPE_PointerTofims__RationalType:
		return soap_in_PointerTofims__RationalType(soap, NULL, NULL, "fims:RationalType");
	case SOAP_TYPE_PointerTo_fimsdescription__addressType_country:
		return soap_in_PointerTo_fimsdescription__addressType_country(soap, NULL, NULL, "fimsdescription:addressType-country");
	case SOAP_TYPE_PointerTofimsdescription__addressType:
		return soap_in_PointerTofimsdescription__addressType(soap, NULL, NULL, "fimsdescription:addressType");
	case SOAP_TYPE_PointerTo_fimsdescription__organisationDetailsType_organisationDepartment:
		return soap_in_PointerTo_fimsdescription__organisationDetailsType_organisationDepartment(soap, NULL, NULL, "fimsdescription:organisationDetailsType-organisationDepartment");
	case SOAP_TYPE_PointerTofimsdescription__detailsType:
		return soap_in_PointerTofimsdescription__detailsType(soap, NULL, NULL, "fimsdescription:detailsType");
	case SOAP_TYPE_PointerTofimsdescription__organisationDetailsType:
		return soap_in_PointerTofimsdescription__organisationDetailsType(soap, NULL, NULL, "fimsdescription:organisationDetailsType");
	case SOAP_TYPE_PointerTo_fimsdescription__dateType_alternative:
		return soap_in_PointerTo_fimsdescription__dateType_alternative(soap, NULL, NULL, "fimsdescription:dateType-alternative");
	case SOAP_TYPE_PointerTo_fimsdescription__dateType_issued:
		return soap_in_PointerTo_fimsdescription__dateType_issued(soap, NULL, NULL, "fimsdescription:dateType-issued");
	case SOAP_TYPE_PointerTo_fimsdescription__dateType_modified:
		return soap_in_PointerTo_fimsdescription__dateType_modified(soap, NULL, NULL, "fimsdescription:dateType-modified");
	case SOAP_TYPE_PointerTo_fimsdescription__dateType_created:
		return soap_in_PointerTo_fimsdescription__dateType_created(soap, NULL, NULL, "fimsdescription:dateType-created");
	case SOAP_TYPE_PointerToxsd__date:
		return soap_in_PointerToxsd__date(soap, NULL, NULL, "xsd:date");
	case SOAP_TYPE_PointerToxsd__gYear:
		return soap_in_PointerToxsd__gYear(soap, NULL, NULL, "xsd:gYear");
	case SOAP_TYPE_PointerTofimsdescription__contactDetailsType:
		return soap_in_PointerTofimsdescription__contactDetailsType(soap, NULL, NULL, "fimsdescription:contactDetailsType");
	case SOAP_TYPE_PointerTo_fimsdescription__coverageType_spatial:
		return soap_in_PointerTo_fimsdescription__coverageType_spatial(soap, NULL, NULL, "fimsdescription:coverageType-spatial");
	case SOAP_TYPE_PointerTo_fimsdescription__coverageType_spatial_coordinates:
		return soap_in_PointerTo_fimsdescription__coverageType_spatial_coordinates(soap, NULL, NULL, "fimsdescription:coverageType-spatial-coordinates");
	case SOAP_TYPE_PointerTo_fimsdescription__coverageType_temporal:
		return soap_in_PointerTo_fimsdescription__coverageType_temporal(soap, NULL, NULL, "fimsdescription:coverageType-temporal");
	case SOAP_TYPE_PointerTo_xml__lang:
		return soap_in_PointerTo_xml__lang(soap, NULL, NULL, "xml:lang");
	case SOAP_TYPE_PointerTofimsdescription__partType:
		return soap_in_PointerTofimsdescription__partType(soap, NULL, NULL, "fimsdescription:partType");
	case SOAP_TYPE_PointerTofimsdescription__rightsType:
		return soap_in_PointerTofimsdescription__rightsType(soap, NULL, NULL, "fimsdescription:rightsType");
	case SOAP_TYPE_PointerTofimsdescription__coverageType:
		return soap_in_PointerTofimsdescription__coverageType(soap, NULL, NULL, "fimsdescription:coverageType");
	case SOAP_TYPE_PointerTofimsdescription__relationType:
		return soap_in_PointerTofimsdescription__relationType(soap, NULL, NULL, "fimsdescription:relationType");
	case SOAP_TYPE_PointerTofimsdescription__languageType:
		return soap_in_PointerTofimsdescription__languageType(soap, NULL, NULL, "fimsdescription:languageType");
	case SOAP_TYPE_PointerTofimsdescription__identifierType:
		return soap_in_PointerTofimsdescription__identifierType(soap, NULL, NULL, "fimsdescription:identifierType");
	case SOAP_TYPE_PointerTofimsdescription__typeType:
		return soap_in_PointerTofimsdescription__typeType(soap, NULL, NULL, "fimsdescription:typeType");
	case SOAP_TYPE_PointerTofimsdescription__dateType:
		return soap_in_PointerTofimsdescription__dateType(soap, NULL, NULL, "fimsdescription:dateType");
	case SOAP_TYPE_PointerTofimsdescription__descriptionType:
		return soap_in_PointerTofimsdescription__descriptionType(soap, NULL, NULL, "fimsdescription:descriptionType");
	case SOAP_TYPE_PointerTofimsdescription__subjectType:
		return soap_in_PointerTofimsdescription__subjectType(soap, NULL, NULL, "fimsdescription:subjectType");
	case SOAP_TYPE_PointerTofimsdescription__entityType:
		return soap_in_PointerTofimsdescription__entityType(soap, NULL, NULL, "fimsdescription:entityType");
	case SOAP_TYPE_PointerTofimsdescription__titleType:
		return soap_in_PointerTofimsdescription__titleType(soap, NULL, NULL, "fimsdescription:titleType");
	case SOAP_TYPE_PointerTofimsdescription__textElementType:
		return soap_in_PointerTofimsdescription__textElementType(soap, NULL, NULL, "fimsdescription:textElementType");
	case SOAP_TYPE_PointerToxsd__time:
		return soap_in_PointerToxsd__time(soap, NULL, NULL, "xsd:time");
	case SOAP_TYPE_PointerTofimstime__Timecode:
		return soap_in_PointerTofimstime__Timecode(soap, NULL, NULL, "fimstime:Timecode");
	case SOAP_TYPE_PointerTofimstime__EditUnitNumberType:
		return soap_in_PointerTofimstime__EditUnitNumberType(soap, NULL, NULL, "fimstime:EditUnitNumberType");
	case SOAP_TYPE_PointerToxsd__duration:
		return soap_in_PointerToxsd__duration(soap, NULL, NULL, "xsd:duration");
	case SOAP_TYPE_PointerTofimstime__TimecodeDuration:
		return soap_in_PointerTofimstime__TimecodeDuration(soap, NULL, NULL, "fimstime:TimecodeDuration");
	case SOAP_TYPE_PointerTofims__SystemPerformanceEventType:
		return soap_in_PointerTofims__SystemPerformanceEventType(soap, NULL, NULL, "fims:SystemPerformanceEventType");
	case SOAP_TYPE_PointerTofims__SystemExceptionEventType:
		return soap_in_PointerTofims__SystemExceptionEventType(soap, NULL, NULL, "fims:SystemExceptionEventType");
	case SOAP_TYPE_PointerTofims__SystemEventType:
		return soap_in_PointerTofims__SystemEventType(soap, NULL, NULL, "fims:SystemEventType");
	case SOAP_TYPE_PointerTofims__ContentCustomEventType:
		return soap_in_PointerTofims__ContentCustomEventType(soap, NULL, NULL, "fims:ContentCustomEventType");
	case SOAP_TYPE_PointerTofims__ContentStatusEventType:
		return soap_in_PointerTofims__ContentStatusEventType(soap, NULL, NULL, "fims:ContentStatusEventType");
	case SOAP_TYPE_PointerTofims__ContentEventType:
		return soap_in_PointerTofims__ContentEventType(soap, NULL, NULL, "fims:ContentEventType");
	case SOAP_TYPE_PointerTofims__EventEnvelopeType:
		return soap_in_PointerTofims__EventEnvelopeType(soap, NULL, NULL, "fims:EventEnvelopeType");
	case SOAP_TYPE_PointerTofims__EventPayloadType:
		return soap_in_PointerTofims__EventPayloadType(soap, NULL, NULL, "fims:EventPayloadType");
	case SOAP_TYPE_PointerTofims__EventClassificationType:
		return soap_in_PointerTofims__EventClassificationType(soap, NULL, NULL, "fims:EventClassificationType");
	case SOAP_TYPE_PointerTofims__EventSubType:
		return soap_in_PointerTofims__EventSubType(soap, NULL, NULL, "fims:EventSubType");
	case SOAP_TYPE_PointerTofims__EventType:
		return soap_in_PointerTofims__EventType(soap, NULL, NULL, "fims:EventType");
	case SOAP_TYPE_PointerTofims__CustomEventTemplateType:
		return soap_in_PointerTofims__CustomEventTemplateType(soap, NULL, NULL, "fims:CustomEventTemplateType");
	case SOAP_TYPE_PointerTofims__QueryExpressionsType:
		return soap_in_PointerTofims__QueryExpressionsType(soap, NULL, NULL, "fims:QueryExpressionsType");
	case SOAP_TYPE_PointerTofims__ResourceIDType:
		return soap_in_PointerTofims__ResourceIDType(soap, NULL, NULL, "fims:ResourceIDType");
	case SOAP_TYPE_PointerTofims__QueryGroupsType:
		return soap_in_PointerTofims__QueryGroupsType(soap, NULL, NULL, "fims:QueryGroupsType");
	case SOAP_TYPE_PointerTofims__QueryParametersType:
		return soap_in_PointerTofims__QueryParametersType(soap, NULL, NULL, "fims:QueryParametersType");
	case SOAP_TYPE_PointerTofims__CustomQueryGroupOperatorType:
		return soap_in_PointerTofims__CustomQueryGroupOperatorType(soap, NULL, NULL, "fims:CustomQueryGroupOperatorType");
	case SOAP_TYPE_PointerTobool:
		return soap_in_PointerTobool(soap, NULL, NULL, "xsd:boolean");
	case SOAP_TYPE_PointerTofims__CustomQueryParameterOperatorType:
		return soap_in_PointerTofims__CustomQueryParameterOperatorType(soap, NULL, NULL, "fims:CustomQueryParameterOperatorType");
	case SOAP_TYPE_PointerTofims__QueryExpressionType:
		return soap_in_PointerTofims__QueryExpressionType(soap, NULL, NULL, "fims:QueryExpressionType");
	case SOAP_TYPE_PointerTofims__QueryGroupType:
		return soap_in_PointerTofims__QueryGroupType(soap, NULL, NULL, "fims:QueryGroupType");
	case SOAP_TYPE_PointerTofims__QueryParameterType:
		return soap_in_PointerTofims__QueryParameterType(soap, NULL, NULL, "fims:QueryParameterType");
	case SOAP_TYPE_PointerTofims__SuperLockTokenType:
		return soap_in_PointerTofims__SuperLockTokenType(soap, NULL, NULL, "fims:SuperLockTokenType");
	case SOAP_TYPE_PointerTofims__LockTokenType:
		return soap_in_PointerTofims__LockTokenType(soap, NULL, NULL, "fims:LockTokenType");
	case SOAP_TYPE_PointerTofims__CredentialType:
		return soap_in_PointerTofims__CredentialType(soap, NULL, NULL, "fims:CredentialType");
	case SOAP_TYPE_PointerTofims__BMEssenceLocatorStatusType:
		return soap_in_PointerTofims__BMEssenceLocatorStatusType(soap, NULL, NULL, "fims:BMEssenceLocatorStatusType");
	case SOAP_TYPE_PointerTofims__BMContentStatusType:
		return soap_in_PointerTofims__BMContentStatusType(soap, NULL, NULL, "fims:BMContentStatusType");
	case SOAP_TYPE_PointerTofims__BMCustomStatusExtensionType:
		return soap_in_PointerTofims__BMCustomStatusExtensionType(soap, NULL, NULL, "fims:BMCustomStatusExtensionType");
	case SOAP_TYPE_PointerTofims__CustomValueType:
		return soap_in_PointerTofims__CustomValueType(soap, NULL, NULL, "fims:CustomValueType");
	case SOAP_TYPE_PointerTofims__ResourceReferenceType:
		return soap_in_PointerTofims__ResourceReferenceType(soap, NULL, NULL, "fims:ResourceReferenceType");
	case SOAP_TYPE_PointerTofims__DescriptionType:
		return soap_in_PointerTofims__DescriptionType(soap, NULL, NULL, "fims:DescriptionType");
	case SOAP_TYPE_PointerTofims__BMEssenceLocatorType:
		return soap_in_PointerTofims__BMEssenceLocatorType(soap, NULL, NULL, "fims:BMEssenceLocatorType");
	case SOAP_TYPE_PointerTofims__BMContentFormatType:
		return soap_in_PointerTofims__BMContentFormatType(soap, NULL, NULL, "fims:BMContentFormatType");
	case SOAP_TYPE_PointerTofims__BMContentType:
		return soap_in_PointerTofims__BMContentType(soap, NULL, NULL, "fims:BMContentType");
	case SOAP_TYPE_PointerTofims__DataFormatType:
		return soap_in_PointerTofims__DataFormatType(soap, NULL, NULL, "fims:DataFormatType");
	case SOAP_TYPE_PointerTofims__ProfileType:
		return soap_in_PointerTofims__ProfileType(soap, NULL, NULL, "fims:ProfileType");
	case SOAP_TYPE_PointerTofims__ResourceType:
		return soap_in_PointerTofims__ResourceType(soap, NULL, NULL, "fims:ResourceType");
	case SOAP_TYPE_PointerTofims__InnerFaultType:
		return soap_in_PointerTofims__InnerFaultType(soap, NULL, NULL, "fims:InnerFaultType");
	case SOAP_TYPE_PointerTotime:
		return soap_in_PointerTotime(soap, NULL, NULL, "xsd:dateTime");
	case SOAP_TYPE_PointerTofims__ServiceType:
		return soap_in_PointerTofims__ServiceType(soap, NULL, NULL, "fims:ServiceType");
	case SOAP_TYPE_PointerToxsd__nonNegativeInteger:
		return soap_in_PointerToxsd__nonNegativeInteger(soap, NULL, NULL, "xsd:nonNegativeInteger");
	case SOAP_TYPE_PointerTofims__JobsType:
		return soap_in_PointerTofims__JobsType(soap, NULL, NULL, "fims:JobsType");
	case SOAP_TYPE_PointerTofims__QueueType:
		return soap_in_PointerTofims__QueueType(soap, NULL, NULL, "fims:QueueType");
	case SOAP_TYPE_PointerTofims__JobType:
		return soap_in_PointerTofims__JobType(soap, NULL, NULL, "fims:JobType");
	case SOAP_TYPE_PointerTofims__PriorityType:
		return soap_in_PointerTofims__PriorityType(soap, NULL, NULL, "fims:PriorityType");
	case SOAP_TYPE_PointerTofims__HashFunctionType:
		return soap_in_PointerTofims__HashFunctionType(soap, NULL, NULL, "fims:HashFunctionType");
	case SOAP_TYPE_PointerTofims__ContainerFormatType:
		return soap_in_PointerTofims__ContainerFormatType(soap, NULL, NULL, "fims:ContainerFormatType");
	case SOAP_TYPE_PointerTofims__AudioFormatType:
		return soap_in_PointerTofims__AudioFormatType(soap, NULL, NULL, "fims:AudioFormatType");
	case SOAP_TYPE_PointerTofims__VideoFormatType:
		return soap_in_PointerTofims__VideoFormatType(soap, NULL, NULL, "fims:VideoFormatType");
	case SOAP_TYPE_PointerToxsd__language:
		return soap_in_PointerToxsd__language(soap, NULL, NULL, "xsd:language");
	case SOAP_TYPE_PointerTofims__UID:
		return soap_in_PointerTofims__UID(soap, NULL, NULL, "fims:UID");
	case SOAP_TYPE_PointerToxsd__integer:
		return soap_in_PointerToxsd__integer(soap, NULL, NULL, "xsd:integer");
	case SOAP_TYPE_PointerTofims__ExtensionAttributes:
		return soap_in_PointerTofims__ExtensionAttributes(soap, NULL, NULL, "fims:ExtensionAttributes");
	case SOAP_TYPE_PointerTofims__ExtensionGroup:
		return soap_in_PointerTofims__ExtensionGroup(soap, NULL, NULL, "fims:ExtensionGroup");
	case SOAP_TYPE_PointerToxsd__anyURI:
		return soap_in_PointerToxsd__anyURI(soap, NULL, NULL, "xsd:anyURI");
	case SOAP_TYPE_PointerTofims__RevisionIDType:
		return soap_in_PointerTofims__RevisionIDType(soap, NULL, NULL, "fims:RevisionIDType");
	case SOAP_TYPE_PointerToedlprovider__MapItemType:
		return soap_in_PointerToedlprovider__MapItemType(soap, NULL, NULL, "edlprovider:MapItemType");
	case SOAP_TYPE_PointerTo_edlprovider__Map:
		return soap_in_PointerTo_edlprovider__Map(soap, NULL, NULL, "edlprovider:Map");
	case SOAP_TYPE_PointerToxsd__base64Binary:
		return soap_in_PointerToxsd__base64Binary(soap, NULL, NULL, "xsd:base64Binary");
	case SOAP_TYPE_PointerTostd__wstring:
		return soap_in_PointerTostd__wstring(soap, NULL, NULL, "xsd:string");
	case SOAP_TYPE_PointerToedlprovider__ArrayOfClips:
		return soap_in_PointerToedlprovider__ArrayOfClips(soap, NULL, NULL, "edlprovider:ArrayOfClips");
	case SOAP_TYPE_PointerTofims__BMObjectType:
		return soap_in_PointerTofims__BMObjectType(soap, NULL, NULL, "fims:BMObjectType");
	case SOAP_TYPE_PointerTofimstime__TimeType:
		return soap_in_PointerTofimstime__TimeType(soap, NULL, NULL, "fimstime:TimeType");
	case SOAP_TYPE_PointerToedlprovider__ClipType:
		return soap_in_PointerToedlprovider__ClipType(soap, NULL, NULL, "edlprovider:ClipType");
	case SOAP_TYPE_PointerTounsignedByte:
		return soap_in_PointerTounsignedByte(soap, NULL, NULL, "xsd:unsignedByte");
	case SOAP_TYPE__QName:
	{	char **s;
		s = soap_in__QName(soap, NULL, NULL, "xsd:QName");
		return s ? *s : NULL;
	}
	case SOAP_TYPE_string:
	{	char **s;
		s = soap_in_string(soap, NULL, NULL, "xsd:string");
		return s ? *s : NULL;
	}
	default:
#else
	*type = 0;
#endif
	{	const char *t = soap->type;
		if (!*t)
			t = soap->tag;
		if (!soap_match_tag(soap, t, "fims:ResourceIDType"))
		{	*type = SOAP_TYPE_fims__ResourceIDType;
			return soap_in_fims__ResourceIDType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "fimstime:TimecodeDuration"))
		{	*type = SOAP_TYPE_fimstime__TimecodeDuration;
			return soap_in_fimstime__TimecodeDuration(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "fimstime:Timecode"))
		{	*type = SOAP_TYPE_fimstime__Timecode;
			return soap_in_fimstime__Timecode(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "fims:RevisionIDType"))
		{	*type = SOAP_TYPE_fims__RevisionIDType;
			return soap_in_fims__RevisionIDType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "fims:UID"))
		{	*type = SOAP_TYPE_fims__UID;
			return soap_in_fims__UID(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "fimsdescription:partType"))
		{	*type = SOAP_TYPE_fimsdescription__partType;
			return soap_in_fimsdescription__partType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "fimsdescription:relationType"))
		{	*type = SOAP_TYPE_fimsdescription__relationType;
			return soap_in_fimsdescription__relationType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "fimsdescription:languageType"))
		{	*type = SOAP_TYPE_fimsdescription__languageType;
			return soap_in_fimsdescription__languageType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "fimsdescription:addressType"))
		{	*type = SOAP_TYPE_fimsdescription__addressType;
			return soap_in_fimsdescription__addressType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "fimsdescription:detailsType"))
		{	*type = SOAP_TYPE_fimsdescription__detailsType;
			return soap_in_fimsdescription__detailsType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "fimsdescription:organisationDetailsType"))
		{	*type = SOAP_TYPE_fimsdescription__organisationDetailsType;
			return soap_in_fimsdescription__organisationDetailsType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "fimsdescription:contactDetailsType"))
		{	*type = SOAP_TYPE_fimsdescription__contactDetailsType;
			return soap_in_fimsdescription__contactDetailsType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "fimsdescription:entityType"))
		{	*type = SOAP_TYPE_fimsdescription__entityType;
			return soap_in_fimsdescription__entityType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "fimsdescription:dateType"))
		{	*type = SOAP_TYPE_fimsdescription__dateType;
			return soap_in_fimsdescription__dateType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "fimsdescription:textElementType"))
		{	*type = SOAP_TYPE_fimsdescription__textElementType;
			return soap_in_fimsdescription__textElementType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "fimsdescription:rightsType"))
		{	*type = SOAP_TYPE_fimsdescription__rightsType;
			return soap_in_fimsdescription__rightsType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "fimsdescription:coverageType"))
		{	*type = SOAP_TYPE_fimsdescription__coverageType;
			return soap_in_fimsdescription__coverageType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "fimsdescription:descriptionType"))
		{	*type = SOAP_TYPE_fimsdescription__descriptionType;
			return soap_in_fimsdescription__descriptionType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "fimsdescription:typeType"))
		{	*type = SOAP_TYPE_fimsdescription__typeType;
			return soap_in_fimsdescription__typeType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "fimsdescription:subjectType"))
		{	*type = SOAP_TYPE_fimsdescription__subjectType;
			return soap_in_fimsdescription__subjectType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "fimsdescription:identifierType"))
		{	*type = SOAP_TYPE_fimsdescription__identifierType;
			return soap_in_fimsdescription__identifierType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "fimsdescription:titleType"))
		{	*type = SOAP_TYPE_fimsdescription__titleType;
			return soap_in_fimsdescription__titleType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "fimsdescription:bmContentDescriptionType"))
		{	*type = SOAP_TYPE_fimsdescription__bmContentDescriptionType;
			return soap_in_fimsdescription__bmContentDescriptionType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "fimstime:EditUnitNumberType"))
		{	*type = SOAP_TYPE_fimstime__EditUnitNumberType;
			return soap_in_fimstime__EditUnitNumberType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "fimstime:TimeType"))
		{	*type = SOAP_TYPE_fimstime__TimeType;
			return soap_in_fimstime__TimeType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "fimstime:DurationType"))
		{	*type = SOAP_TYPE_fimstime__DurationType;
			return soap_in_fimstime__DurationType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "fims:SystemPerformanceEventsType"))
		{	*type = SOAP_TYPE_fims__SystemPerformanceEventsType;
			return soap_in_fims__SystemPerformanceEventsType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "fims:SystemPerformanceEventType"))
		{	*type = SOAP_TYPE_fims__SystemPerformanceEventType;
			return soap_in_fims__SystemPerformanceEventType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "fims:SystemExceptionEventsType"))
		{	*type = SOAP_TYPE_fims__SystemExceptionEventsType;
			return soap_in_fims__SystemExceptionEventsType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "fims:SystemExceptionEventType"))
		{	*type = SOAP_TYPE_fims__SystemExceptionEventType;
			return soap_in_fims__SystemExceptionEventType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "fims:SystemEventsType"))
		{	*type = SOAP_TYPE_fims__SystemEventsType;
			return soap_in_fims__SystemEventsType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "fims:SystemEventType"))
		{	*type = SOAP_TYPE_fims__SystemEventType;
			return soap_in_fims__SystemEventType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "fims:ContentCustomEventsType"))
		{	*type = SOAP_TYPE_fims__ContentCustomEventsType;
			return soap_in_fims__ContentCustomEventsType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "fims:ContentCustomEventType"))
		{	*type = SOAP_TYPE_fims__ContentCustomEventType;
			return soap_in_fims__ContentCustomEventType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "fims:ContentStatusEventsType"))
		{	*type = SOAP_TYPE_fims__ContentStatusEventsType;
			return soap_in_fims__ContentStatusEventsType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "fims:ContentStatusEventType"))
		{	*type = SOAP_TYPE_fims__ContentStatusEventType;
			return soap_in_fims__ContentStatusEventType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "fims:ContentEventsType"))
		{	*type = SOAP_TYPE_fims__ContentEventsType;
			return soap_in_fims__ContentEventsType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "fims:ContentEventType"))
		{	*type = SOAP_TYPE_fims__ContentEventType;
			return soap_in_fims__ContentEventType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "fims:EventPayloadsType"))
		{	*type = SOAP_TYPE_fims__EventPayloadsType;
			return soap_in_fims__EventPayloadsType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "fims:EventPayloadType"))
		{	*type = SOAP_TYPE_fims__EventPayloadType;
			return soap_in_fims__EventPayloadType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "fims:EventEnvelopesType"))
		{	*type = SOAP_TYPE_fims__EventEnvelopesType;
			return soap_in_fims__EventEnvelopesType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "fims:EventEnvelopeType"))
		{	*type = SOAP_TYPE_fims__EventEnvelopeType;
			return soap_in_fims__EventEnvelopeType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "fims:CustomEventTemplatesType"))
		{	*type = SOAP_TYPE_fims__CustomEventTemplatesType;
			return soap_in_fims__CustomEventTemplatesType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "fims:CustomEventTemplateType"))
		{	*type = SOAP_TYPE_fims__CustomEventTemplateType;
			return soap_in_fims__CustomEventTemplateType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "fims:QueryGroupsType"))
		{	*type = SOAP_TYPE_fims__QueryGroupsType;
			return soap_in_fims__QueryGroupsType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "fims:QueryGroupType"))
		{	*type = SOAP_TYPE_fims__QueryGroupType;
			return soap_in_fims__QueryGroupType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "fims:CustomQueryGroupOperatorsType"))
		{	*type = SOAP_TYPE_fims__CustomQueryGroupOperatorsType;
			return soap_in_fims__CustomQueryGroupOperatorsType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "fims:CustomQueryGroupOperatorType"))
		{	*type = SOAP_TYPE_fims__CustomQueryGroupOperatorType;
			return soap_in_fims__CustomQueryGroupOperatorType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "fims:QueryParametersType"))
		{	*type = SOAP_TYPE_fims__QueryParametersType;
			return soap_in_fims__QueryParametersType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "fims:QueryParameterType"))
		{	*type = SOAP_TYPE_fims__QueryParameterType;
			return soap_in_fims__QueryParameterType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "fims:CustomQueryParameterOperatorsType"))
		{	*type = SOAP_TYPE_fims__CustomQueryParameterOperatorsType;
			return soap_in_fims__CustomQueryParameterOperatorsType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "fims:CustomQueryParameterOperatorType"))
		{	*type = SOAP_TYPE_fims__CustomQueryParameterOperatorType;
			return soap_in_fims__CustomQueryParameterOperatorType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "fims:QueryExpressionsType"))
		{	*type = SOAP_TYPE_fims__QueryExpressionsType;
			return soap_in_fims__QueryExpressionsType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "fims:QueryExpressionType"))
		{	*type = SOAP_TYPE_fims__QueryExpressionType;
			return soap_in_fims__QueryExpressionType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "fims:SuperLockTokensType"))
		{	*type = SOAP_TYPE_fims__SuperLockTokensType;
			return soap_in_fims__SuperLockTokensType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "fims:SuperLockTokenType"))
		{	*type = SOAP_TYPE_fims__SuperLockTokenType;
			return soap_in_fims__SuperLockTokenType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "fims:LockTokensType"))
		{	*type = SOAP_TYPE_fims__LockTokensType;
			return soap_in_fims__LockTokensType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "fims:LockTokenType"))
		{	*type = SOAP_TYPE_fims__LockTokenType;
			return soap_in_fims__LockTokenType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "fims:CredentialsType"))
		{	*type = SOAP_TYPE_fims__CredentialsType;
			return soap_in_fims__CredentialsType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "fims:CredentialType"))
		{	*type = SOAP_TYPE_fims__CredentialType;
			return soap_in_fims__CredentialType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "fims:BMEssenceLocatorStatusesType"))
		{	*type = SOAP_TYPE_fims__BMEssenceLocatorStatusesType;
			return soap_in_fims__BMEssenceLocatorStatusesType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "fims:BMEssenceLocatorStatusType"))
		{	*type = SOAP_TYPE_fims__BMEssenceLocatorStatusType;
			return soap_in_fims__BMEssenceLocatorStatusType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "fims:BMContentStatusesType"))
		{	*type = SOAP_TYPE_fims__BMContentStatusesType;
			return soap_in_fims__BMContentStatusesType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "fims:BMContentStatusType"))
		{	*type = SOAP_TYPE_fims__BMContentStatusType;
			return soap_in_fims__BMContentStatusType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "fims:BMCustomStatusExtensionsType"))
		{	*type = SOAP_TYPE_fims__BMCustomStatusExtensionsType;
			return soap_in_fims__BMCustomStatusExtensionsType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "fims:BMCustomStatusExtensionType"))
		{	*type = SOAP_TYPE_fims__BMCustomStatusExtensionType;
			return soap_in_fims__BMCustomStatusExtensionType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "fims:CustomValuesType"))
		{	*type = SOAP_TYPE_fims__CustomValuesType;
			return soap_in_fims__CustomValuesType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "fims:CustomValueType"))
		{	*type = SOAP_TYPE_fims__CustomValueType;
			return soap_in_fims__CustomValueType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "fims:ResourceReferencesType"))
		{	*type = SOAP_TYPE_fims__ResourceReferencesType;
			return soap_in_fims__ResourceReferencesType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "fims:DescriptionsType"))
		{	*type = SOAP_TYPE_fims__DescriptionsType;
			return soap_in_fims__DescriptionsType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "fims:BMEssenceLocatorsType"))
		{	*type = SOAP_TYPE_fims__BMEssenceLocatorsType;
			return soap_in_fims__BMEssenceLocatorsType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "fims:BMContentFormatsType"))
		{	*type = SOAP_TYPE_fims__BMContentFormatsType;
			return soap_in_fims__BMContentFormatsType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "fims:BMContentsType"))
		{	*type = SOAP_TYPE_fims__BMContentsType;
			return soap_in_fims__BMContentsType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "fims:BMObjectsType"))
		{	*type = SOAP_TYPE_fims__BMObjectsType;
			return soap_in_fims__BMObjectsType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "fims:DataFormatsType"))
		{	*type = SOAP_TYPE_fims__DataFormatsType;
			return soap_in_fims__DataFormatsType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "fims:ContainerFormatsType"))
		{	*type = SOAP_TYPE_fims__ContainerFormatsType;
			return soap_in_fims__ContainerFormatsType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "fims:AudioFormatsType"))
		{	*type = SOAP_TYPE_fims__AudioFormatsType;
			return soap_in_fims__AudioFormatsType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "fims:VideoFormatsType"))
		{	*type = SOAP_TYPE_fims__VideoFormatsType;
			return soap_in_fims__VideoFormatsType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "fims:JobsType"))
		{	*type = SOAP_TYPE_fims__JobsType;
			return soap_in_fims__JobsType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "fims:QueuesType"))
		{	*type = SOAP_TYPE_fims__QueuesType;
			return soap_in_fims__QueuesType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "fims:ServicesType"))
		{	*type = SOAP_TYPE_fims__ServicesType;
			return soap_in_fims__ServicesType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "fims:ProfilesType"))
		{	*type = SOAP_TYPE_fims__ProfilesType;
			return soap_in_fims__ProfilesType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "fims:ResourcesType"))
		{	*type = SOAP_TYPE_fims__ResourcesType;
			return soap_in_fims__ResourcesType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "fims:InnerFaultType"))
		{	*type = SOAP_TYPE_fims__InnerFaultType;
			return soap_in_fims__InnerFaultType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "fims:FaultType"))
		{	*type = SOAP_TYPE_fims__FaultType;
			return soap_in_fims__FaultType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "fims:ListFilterType"))
		{	*type = SOAP_TYPE_fims__ListFilterType;
			return soap_in_fims__ListFilterType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "fims:QueryServiceDescriptionResponseType"))
		{	*type = SOAP_TYPE_fims__QueryServiceDescriptionResponseType;
			return soap_in_fims__QueryServiceDescriptionResponseType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "fims:QueryServiceDescriptionRequestType"))
		{	*type = SOAP_TYPE_fims__QueryServiceDescriptionRequestType;
			return soap_in_fims__QueryServiceDescriptionRequestType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "fims:QueryJobResponseType"))
		{	*type = SOAP_TYPE_fims__QueryJobResponseType;
			return soap_in_fims__QueryJobResponseType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "fims:QueryJobRequestByFilterType"))
		{	*type = SOAP_TYPE_fims__QueryJobRequestByFilterType;
			return soap_in_fims__QueryJobRequestByFilterType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "fims:QueryJobRequestByIDType"))
		{	*type = SOAP_TYPE_fims__QueryJobRequestByIDType;
			return soap_in_fims__QueryJobRequestByIDType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "fims:QueryJobRequestType"))
		{	*type = SOAP_TYPE_fims__QueryJobRequestType;
			return soap_in_fims__QueryJobRequestType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "fims:ManageQueueResponseType"))
		{	*type = SOAP_TYPE_fims__ManageQueueResponseType;
			return soap_in_fims__ManageQueueResponseType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "fims:ManageQueueRequestType"))
		{	*type = SOAP_TYPE_fims__ManageQueueRequestType;
			return soap_in_fims__ManageQueueRequestType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "fims:ManageJobResponseType"))
		{	*type = SOAP_TYPE_fims__ManageJobResponseType;
			return soap_in_fims__ManageJobResponseType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "fims:ManageJobRequestType"))
		{	*type = SOAP_TYPE_fims__ManageJobRequestType;
			return soap_in_fims__ManageJobRequestType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "fims:StartJobByLatestType"))
		{	*type = SOAP_TYPE_fims__StartJobByLatestType;
			return soap_in_fims__StartJobByLatestType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "fims:StartJobByTimeType"))
		{	*type = SOAP_TYPE_fims__StartJobByTimeType;
			return soap_in_fims__StartJobByTimeType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "fims:StartJobByNoWaitType"))
		{	*type = SOAP_TYPE_fims__StartJobByNoWaitType;
			return soap_in_fims__StartJobByNoWaitType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "fims:StartJobType"))
		{	*type = SOAP_TYPE_fims__StartJobType;
			return soap_in_fims__StartJobType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "fims:StopProcessByOpenEndType"))
		{	*type = SOAP_TYPE_fims__StopProcessByOpenEndType;
			return soap_in_fims__StopProcessByOpenEndType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "fims:StopProcessByServiceDefinedTimeType"))
		{	*type = SOAP_TYPE_fims__StopProcessByServiceDefinedTimeType;
			return soap_in_fims__StopProcessByServiceDefinedTimeType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "fims:StopProcessByTimeMarkType"))
		{	*type = SOAP_TYPE_fims__StopProcessByTimeMarkType;
			return soap_in_fims__StopProcessByTimeMarkType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "fims:StopProcessByDurationType"))
		{	*type = SOAP_TYPE_fims__StopProcessByDurationType;
			return soap_in_fims__StopProcessByDurationType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "fims:StopProcessByTimeType"))
		{	*type = SOAP_TYPE_fims__StopProcessByTimeType;
			return soap_in_fims__StopProcessByTimeType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "fims:StopProcessType"))
		{	*type = SOAP_TYPE_fims__StopProcessType;
			return soap_in_fims__StopProcessType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "fims:StartProcessByServiceDefinedTimeType"))
		{	*type = SOAP_TYPE_fims__StartProcessByServiceDefinedTimeType;
			return soap_in_fims__StartProcessByServiceDefinedTimeType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "fims:StartProcessByTimeMarkType"))
		{	*type = SOAP_TYPE_fims__StartProcessByTimeMarkType;
			return soap_in_fims__StartProcessByTimeMarkType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "fims:StartProcessByTimeType"))
		{	*type = SOAP_TYPE_fims__StartProcessByTimeType;
			return soap_in_fims__StartProcessByTimeType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "fims:StartProcessByNoWaitType"))
		{	*type = SOAP_TYPE_fims__StartProcessByNoWaitType;
			return soap_in_fims__StartProcessByNoWaitType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "fims:StartProcessType"))
		{	*type = SOAP_TYPE_fims__StartProcessType;
			return soap_in_fims__StartProcessType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "fims:HashFunctionType"))
		{	*type = SOAP_TYPE_fims__HashFunctionType;
			return soap_in_fims__HashFunctionType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "fims:StorageType"))
		{	*type = SOAP_TYPE_fims__StorageType;
			return soap_in_fims__StorageType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "fims:ProcessedInfoByFramesType"))
		{	*type = SOAP_TYPE_fims__ProcessedInfoByFramesType;
			return soap_in_fims__ProcessedInfoByFramesType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "fims:ProcessedInfoByBytesType"))
		{	*type = SOAP_TYPE_fims__ProcessedInfoByBytesType;
			return soap_in_fims__ProcessedInfoByBytesType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "fims:ProcessedInfoType"))
		{	*type = SOAP_TYPE_fims__ProcessedInfoType;
			return soap_in_fims__ProcessedInfoType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "fims:HashType"))
		{	*type = SOAP_TYPE_fims__HashType;
			return soap_in_fims__HashType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "fims:RationalType"))
		{	*type = SOAP_TYPE_fims__RationalType;
			return soap_in_fims__RationalType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "fims:LengthType"))
		{	*type = SOAP_TYPE_fims__LengthType;
			return soap_in_fims__LengthType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "fims:TechnicalAttributeType"))
		{	*type = SOAP_TYPE_fims__TechnicalAttributeType;
			return soap_in_fims__TechnicalAttributeType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "fims:TransformAtomType"))
		{	*type = SOAP_TYPE_fims__TransformAtomType;
			return soap_in_fims__TransformAtomType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "fims:TransferAtomType"))
		{	*type = SOAP_TYPE_fims__TransferAtomType;
			return soap_in_fims__TransferAtomType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "fims:EssencePlaceholderLocatorType"))
		{	*type = SOAP_TYPE_fims__EssencePlaceholderLocatorType;
			return soap_in_fims__EssencePlaceholderLocatorType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "fims:FolderLocatorType"))
		{	*type = SOAP_TYPE_fims__FolderLocatorType;
			return soap_in_fims__FolderLocatorType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "fims:ListFileLocatorType"))
		{	*type = SOAP_TYPE_fims__ListFileLocatorType;
			return soap_in_fims__ListFileLocatorType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "fims:SimpleFileLocatorType"))
		{	*type = SOAP_TYPE_fims__SimpleFileLocatorType;
			return soap_in_fims__SimpleFileLocatorType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "fims:BMEssenceLocatorType"))
		{	*type = SOAP_TYPE_fims__BMEssenceLocatorType;
			return soap_in_fims__BMEssenceLocatorType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "fims:BMContentFormatType"))
		{	*type = SOAP_TYPE_fims__BMContentFormatType;
			return soap_in_fims__BMContentFormatType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "fims:DescriptionType"))
		{	*type = SOAP_TYPE_fims__DescriptionType;
			return soap_in_fims__DescriptionType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "fims:BMContentType"))
		{	*type = SOAP_TYPE_fims__BMContentType;
			return soap_in_fims__BMContentType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "fims:BMObjectType"))
		{	*type = SOAP_TYPE_fims__BMObjectType;
			return soap_in_fims__BMObjectType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "fims:CodecType"))
		{	*type = SOAP_TYPE_fims__CodecType;
			return soap_in_fims__CodecType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "fims:BMTrackType"))
		{	*type = SOAP_TYPE_fims__BMTrackType;
			return soap_in_fims__BMTrackType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "fims:ContainerFormatType"))
		{	*type = SOAP_TYPE_fims__ContainerFormatType;
			return soap_in_fims__ContainerFormatType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "fims:AncillaryDataFormatType"))
		{	*type = SOAP_TYPE_fims__AncillaryDataFormatType;
			return soap_in_fims__AncillaryDataFormatType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "fims:CaptioningFormatType"))
		{	*type = SOAP_TYPE_fims__CaptioningFormatType;
			return soap_in_fims__CaptioningFormatType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "fims:DataFormatType"))
		{	*type = SOAP_TYPE_fims__DataFormatType;
			return soap_in_fims__DataFormatType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "fims:AudioFormatType"))
		{	*type = SOAP_TYPE_fims__AudioFormatType;
			return soap_in_fims__AudioFormatType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "fims:VideoFormatType"))
		{	*type = SOAP_TYPE_fims__VideoFormatType;
			return soap_in_fims__VideoFormatType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "fims:FormatType"))
		{	*type = SOAP_TYPE_fims__FormatType;
			return soap_in_fims__FormatType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "fims:JobType"))
		{	*type = SOAP_TYPE_fims__JobType;
			return soap_in_fims__JobType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "fims:QueueType"))
		{	*type = SOAP_TYPE_fims__QueueType;
			return soap_in_fims__QueueType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "fims:ProfileType"))
		{	*type = SOAP_TYPE_fims__ProfileType;
			return soap_in_fims__ProfileType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "fims:ServiceType"))
		{	*type = SOAP_TYPE_fims__ServiceType;
			return soap_in_fims__ServiceType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "fims:AsyncEndpointType"))
		{	*type = SOAP_TYPE_fims__AsyncEndpointType;
			return soap_in_fims__AsyncEndpointType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "fims:ExtensionBaseType"))
		{	*type = SOAP_TYPE_fims__ExtensionBaseType;
			return soap_in_fims__ExtensionBaseType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "fims:ResourceType"))
		{	*type = SOAP_TYPE_fims__ResourceType;
			return soap_in_fims__ResourceType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "fims:ResourceReferenceType"))
		{	*type = SOAP_TYPE_fims__ResourceReferenceType;
			return soap_in_fims__ResourceReferenceType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "fims:ExtensionAttributes"))
		{	*type = SOAP_TYPE_fims__ExtensionAttributes;
			return soap_in_fims__ExtensionAttributes(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "fims:ExtensionGroup"))
		{	*type = SOAP_TYPE_fims__ExtensionGroup;
			return soap_in_fims__ExtensionGroup(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "edlprovider:EdlProviderFaultType"))
		{	*type = SOAP_TYPE_edlprovider__EdlProviderFaultType;
			return soap_in_edlprovider__EdlProviderFaultType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "edlprovider:InstalledEdlsResponseType"))
		{	*type = SOAP_TYPE_edlprovider__InstalledEdlsResponseType;
			return soap_in_edlprovider__InstalledEdlsResponseType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "edlprovider:EdlCreateResponseType"))
		{	*type = SOAP_TYPE_edlprovider__EdlCreateResponseType;
			return soap_in_edlprovider__EdlCreateResponseType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "edlprovider:EdlCreateRequestDoubleType"))
		{	*type = SOAP_TYPE_edlprovider__EdlCreateRequestDoubleType;
			return soap_in_edlprovider__EdlCreateRequestDoubleType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "edlprovider:EdlCreateRequestType"))
		{	*type = SOAP_TYPE_edlprovider__EdlCreateRequestType;
			return soap_in_edlprovider__EdlCreateRequestType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "edlprovider:EdlCreateRequestBaseType"))
		{	*type = SOAP_TYPE_edlprovider__EdlCreateRequestBaseType;
			return soap_in_edlprovider__EdlCreateRequestBaseType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "edlprovider:MapItemType"))
		{	*type = SOAP_TYPE_edlprovider__MapItemType;
			return soap_in_edlprovider__MapItemType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "edlprovider:ClipType"))
		{	*type = SOAP_TYPE_edlprovider__ClipType;
			return soap_in_edlprovider__ClipType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "edlprovider:ArrayOfClips"))
		{	*type = SOAP_TYPE_edlprovider__ArrayOfClips;
			return soap_in_edlprovider__ArrayOfClips(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "edlprovider:ArrayOfstring"))
		{	*type = SOAP_TYPE_edlprovider__ArrayOfstring;
			return soap_in_edlprovider__ArrayOfstring(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:time"))
		{	*type = SOAP_TYPE_xsd__time;
			return soap_in_xsd__time(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:positiveInteger"))
		{	*type = SOAP_TYPE_xsd__positiveInteger;
			return soap_in_xsd__positiveInteger(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:nonNegativeInteger"))
		{	*type = SOAP_TYPE_xsd__nonNegativeInteger;
			return soap_in_xsd__nonNegativeInteger(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:language"))
		{	*type = SOAP_TYPE_xsd__language;
			return soap_in_xsd__language(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:integer"))
		{	*type = SOAP_TYPE_xsd__integer;
			return soap_in_xsd__integer(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:gYear"))
		{	*type = SOAP_TYPE_xsd__gYear;
			return soap_in_xsd__gYear(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:decimal"))
		{	*type = SOAP_TYPE_xsd__decimal;
			return soap_in_xsd__decimal(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:date"))
		{	*type = SOAP_TYPE_xsd__date;
			return soap_in_xsd__date(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:anyURI"))
		{	*type = SOAP_TYPE_xsd__anyURI;
			return soap_in_xsd__anyURI(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:NMTOKEN"))
		{	*type = SOAP_TYPE_xsd__NMTOKEN;
			return soap_in_xsd__NMTOKEN(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:string"))
		{	*type = SOAP_TYPE_std__wstring;
			return soap_in_std__wstring(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:hexBinary"))
		{	*type = SOAP_TYPE_xsd__hexBinary;
			return soap_in_xsd__hexBinary(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:base64Binary"))
		{	*type = SOAP_TYPE_xsd__base64Binary;
			return soap_in_xsd__base64Binary(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:byte"))
		{	*type = SOAP_TYPE_byte;
			return soap_in_byte(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:int"))
		{	*type = SOAP_TYPE_int;
			return soap_in_int(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:long"))
		{	*type = SOAP_TYPE_LONG64;
			return soap_in_LONG64(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:duration"))
		{	*type = SOAP_TYPE_xsd__duration;
			return soap_in_xsd__duration(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:float"))
		{	*type = SOAP_TYPE_float;
			return soap_in_float(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:double"))
		{	*type = SOAP_TYPE_double;
			return soap_in_double(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:unsignedByte"))
		{	*type = SOAP_TYPE_unsignedByte;
			return soap_in_unsignedByte(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:unsignedInt"))
		{	*type = SOAP_TYPE_unsignedInt;
			return soap_in_unsignedInt(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:unsignedLong"))
		{	*type = SOAP_TYPE_unsignedLONG64;
			return soap_in_unsignedLONG64(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:dateTime"))
		{	*type = SOAP_TYPE_time;
			return soap_in_time(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:boolean"))
		{	*type = SOAP_TYPE_bool;
			return soap_in_bool(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "fims:QueryServiceDescriptionRequestType-responseType"))
		{	*type = SOAP_TYPE__fims__QueryServiceDescriptionRequestType_responseType;
			return soap_in__fims__QueryServiceDescriptionRequestType_responseType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "fims:EventClassificationType"))
		{	*type = SOAP_TYPE_fims__EventClassificationType;
			return soap_in_fims__EventClassificationType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "fims:EventSubType"))
		{	*type = SOAP_TYPE_fims__EventSubType;
			return soap_in_fims__EventSubType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "fims:EventType"))
		{	*type = SOAP_TYPE_fims__EventType;
			return soap_in_fims__EventType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "fims:QueryParameterOperatorType"))
		{	*type = SOAP_TYPE_fims__QueryParameterOperatorType;
			return soap_in_fims__QueryParameterOperatorType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "fims:QueryGroupOperatorType"))
		{	*type = SOAP_TYPE_fims__QueryGroupOperatorType;
			return soap_in_fims__QueryGroupOperatorType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "fims:BMStatusType"))
		{	*type = SOAP_TYPE_fims__BMStatusType;
			return soap_in_fims__BMStatusType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "fims:DataTypeType"))
		{	*type = SOAP_TYPE_fims__DataTypeType;
			return soap_in_fims__DataTypeType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "fims:JobInfoSelectionType"))
		{	*type = SOAP_TYPE_fims__JobInfoSelectionType;
			return soap_in_fims__JobInfoSelectionType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "fims:ErrorCodeType"))
		{	*type = SOAP_TYPE_fims__ErrorCodeType;
			return soap_in_fims__ErrorCodeType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "fims:BitRateModeType"))
		{	*type = SOAP_TYPE_fims__BitRateModeType;
			return soap_in_fims__BitRateModeType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "fims:ScanningOrderType"))
		{	*type = SOAP_TYPE_fims__ScanningOrderType;
			return soap_in_fims__ScanningOrderType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "fims:ScanningFormatType"))
		{	*type = SOAP_TYPE_fims__ScanningFormatType;
			return soap_in_fims__ScanningFormatType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "fims:AudioSampleType"))
		{	*type = SOAP_TYPE_fims__AudioSampleType;
			return soap_in_fims__AudioSampleType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "fims:JobStatusType"))
		{	*type = SOAP_TYPE_fims__JobStatusType;
			return soap_in_fims__JobStatusType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "fims:HashFunctionTypes"))
		{	*type = SOAP_TYPE_fims__HashFunctionTypes;
			return soap_in_fims__HashFunctionTypes(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "fims:JobCommandType"))
		{	*type = SOAP_TYPE_fims__JobCommandType;
			return soap_in_fims__JobCommandType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "fims:QueueCommandType"))
		{	*type = SOAP_TYPE_fims__QueueCommandType;
			return soap_in_fims__QueueCommandType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "fims:StorageTypes"))
		{	*type = SOAP_TYPE_fims__StorageTypes;
			return soap_in_fims__StorageTypes(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "fims:PriorityType"))
		{	*type = SOAP_TYPE_fims__PriorityType;
			return soap_in_fims__PriorityType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "fims:QueueStatusType"))
		{	*type = SOAP_TYPE_fims__QueueStatusType;
			return soap_in_fims__QueueStatusType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "fims:CurrentVersion"))
		{	*type = SOAP_TYPE_fims__CurrentVersion;
			return soap_in_fims__CurrentVersion(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "edlprovider:EdlProviderErrorCodeType"))
		{	*type = SOAP_TYPE_edlprovider__EdlProviderErrorCodeType;
			return soap_in_edlprovider__EdlProviderErrorCodeType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:QName"))
		{	char **s;
			*type = SOAP_TYPE__QName;
			s = soap_in__QName(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
		if (!soap_match_tag(soap, t, "xsd:string"))
		{	char **s;
			*type = SOAP_TYPE_string;
			s = soap_in_string(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
		t = soap->tag;
		if (!soap_match_tag(soap, t, "fims:ContainerFormatType-containerFormat"))
		{	*type = SOAP_TYPE__fims__ContainerFormatType_containerFormat;
			return soap_in__fims__ContainerFormatType_containerFormat(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "fims:AudioFormatType-trackConfiguration"))
		{	*type = SOAP_TYPE__fims__AudioFormatType_trackConfiguration;
			return soap_in__fims__AudioFormatType_trackConfiguration(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "fims:BMEssenceLocatorType-containerMimeType"))
		{	*type = SOAP_TYPE__fims__BMEssenceLocatorType_containerMimeType;
			return soap_in__fims__BMEssenceLocatorType_containerMimeType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "fims:BMContentFormatType-mimeType"))
		{	*type = SOAP_TYPE__fims__BMContentFormatType_mimeType;
			return soap_in__fims__BMContentFormatType_mimeType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "fims:ServiceType-serviceDescription"))
		{	*type = SOAP_TYPE__fims__ServiceType_serviceDescription;
			return soap_in__fims__ServiceType_serviceDescription(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "fimsdescription:addressType-country"))
		{	*type = SOAP_TYPE__fimsdescription__addressType_country;
			return soap_in__fimsdescription__addressType_country(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "fimsdescription:organisationDetailsType-organisationDepartment"))
		{	*type = SOAP_TYPE__fimsdescription__organisationDetailsType_organisationDepartment;
			return soap_in__fimsdescription__organisationDetailsType_organisationDepartment(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "fimsdescription:entityType-role"))
		{	*type = SOAP_TYPE__fimsdescription__entityType_role;
			return soap_in__fimsdescription__entityType_role(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "fimsdescription:dateType-alternative"))
		{	*type = SOAP_TYPE__fimsdescription__dateType_alternative;
			return soap_in__fimsdescription__dateType_alternative(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "fimsdescription:dateType-issued"))
		{	*type = SOAP_TYPE__fimsdescription__dateType_issued;
			return soap_in__fimsdescription__dateType_issued(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "fimsdescription:dateType-modified"))
		{	*type = SOAP_TYPE__fimsdescription__dateType_modified;
			return soap_in__fimsdescription__dateType_modified(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "fimsdescription:dateType-created"))
		{	*type = SOAP_TYPE__fimsdescription__dateType_created;
			return soap_in__fimsdescription__dateType_created(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "fimsdescription:coverageType-spatial-coordinates"))
		{	*type = SOAP_TYPE__fimsdescription__coverageType_spatial_coordinates;
			return soap_in__fimsdescription__coverageType_spatial_coordinates(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "fimsdescription:coverageType-spatial-locationName"))
		{	*type = SOAP_TYPE__fimsdescription__coverageType_spatial_locationName;
			return soap_in__fimsdescription__coverageType_spatial_locationName(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "fimsdescription:coverageType-spatial"))
		{	*type = SOAP_TYPE__fimsdescription__coverageType_spatial;
			return soap_in__fimsdescription__coverageType_spatial(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "fimsdescription:coverageType-temporal"))
		{	*type = SOAP_TYPE__fimsdescription__coverageType_temporal;
			return soap_in__fimsdescription__coverageType_temporal(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "fimsdescription:typeType-targetAudience"))
		{	*type = SOAP_TYPE__fimsdescription__typeType_targetAudience;
			return soap_in__fimsdescription__typeType_targetAudience(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "fimsdescription:typeType-objectType"))
		{	*type = SOAP_TYPE__fimsdescription__typeType_objectType;
			return soap_in__fimsdescription__typeType_objectType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "fimsdescription:typeType-genre"))
		{	*type = SOAP_TYPE__fimsdescription__typeType_genre;
			return soap_in__fimsdescription__typeType_genre(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "fims:formatCollection"))
		{	*type = SOAP_TYPE__fims__formatCollection;
			return soap_in__fims__formatCollection(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "edlprovider:Map"))
		{	*type = SOAP_TYPE__edlprovider__Map;
			return soap_in__edlprovider__Map(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xml:lang"))
		{	*type = SOAP_TYPE__xml__lang;
			return soap_in__xml__lang(soap, NULL, NULL, NULL);
		}
#ifndef WITH_NOIDREF
	}
#endif
	}
	soap->error = SOAP_TAG_MISMATCH;
	return NULL;
}

#ifdef __cplusplus
}
#endif

SOAP_FMAC3 int SOAP_FMAC4 soap_ignore_element(struct soap *soap)
{
	if (!soap_peek_element(soap))
	{	int t;
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Unexpected element '%s' in input (level = %u, %d)\n", soap->tag, soap->level, soap->body));
		if (soap->mustUnderstand && !soap->other)
			return soap->error = SOAP_MUSTUNDERSTAND;
		if (((soap->mode & SOAP_XML_STRICT) && soap->part != SOAP_IN_HEADER) || !soap_match_tag(soap, soap->tag, "SOAP-ENV:"))
		{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "REJECTING element '%s'\n", soap->tag));
			return soap->error = SOAP_TAG_MISMATCH;
		}
		if (!*soap->id || !soap_getelement(soap, &t))
		{	soap->peeked = 0;
			if (soap->fignore)
				soap->error = soap->fignore(soap, soap->tag);
			else
				soap->error = SOAP_OK;
			DBGLOG(TEST, if (!soap->error) SOAP_MESSAGE(fdebug, "IGNORING element '%s'\n", soap->tag));
			if (!soap->error && soap->body)
			{	soap->level++;
				while (!soap_ignore_element(soap))
					;
				if (soap->error == SOAP_NO_TAG)
					soap->error = soap_element_end_in(soap, NULL);
			}
		}
	}
	return soap->error;
}

#ifndef WITH_NOIDREF
SOAP_FMAC3 int SOAP_FMAC4 soap_putindependent(struct soap *soap)
{
	int i;
	struct soap_plist *pp;
	if (soap->version == 1 && soap->encodingStyle && !(soap->mode & (SOAP_XML_TREE | SOAP_XML_GRAPH)))
		for (i = 0; i < SOAP_PTRHASH; i++)
			for (pp = soap->pht[i]; pp; pp = pp->next)
				if (pp->mark1 == 2 || pp->mark2 == 2)
					if (soap_putelement(soap, pp->ptr, SOAP_MULTIREFTAG, pp->id, pp->type))
						return soap->error;
	return SOAP_OK;
}
#endif

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 int SOAP_FMAC4 soap_putelement(struct soap *soap, const void *ptr, const char *tag, int id, int type)
{	(void)tag;
	switch (type)
	{
	case SOAP_TYPE_byte:
		return soap_out_byte(soap, tag, id, (const char *)ptr, "xsd:byte");
	case SOAP_TYPE_int:
		return soap_out_int(soap, tag, id, (const int *)ptr, "xsd:int");
	case SOAP_TYPE_LONG64:
		return soap_out_LONG64(soap, tag, id, (const LONG64 *)ptr, "xsd:long");
	case SOAP_TYPE_xsd__duration:
		return soap_out_xsd__duration(soap, tag, id, (const LONG64 *)ptr, "xsd:duration");
	case SOAP_TYPE_float:
		return soap_out_float(soap, tag, id, (const float *)ptr, "xsd:float");
	case SOAP_TYPE_double:
		return soap_out_double(soap, tag, id, (const double *)ptr, "xsd:double");
	case SOAP_TYPE_unsignedByte:
		return soap_out_unsignedByte(soap, tag, id, (const unsigned char *)ptr, "xsd:unsignedByte");
	case SOAP_TYPE_unsignedInt:
		return soap_out_unsignedInt(soap, tag, id, (const unsigned int *)ptr, "xsd:unsignedInt");
	case SOAP_TYPE_unsignedLONG64:
		return soap_out_unsignedLONG64(soap, tag, id, (const ULONG64 *)ptr, "xsd:unsignedLong");
	case SOAP_TYPE_time:
		return soap_out_time(soap, tag, id, (const time_t *)ptr, "xsd:dateTime");
	case SOAP_TYPE_bool:
		return soap_out_bool(soap, tag, id, (const bool *)ptr, "xsd:boolean");
	case SOAP_TYPE__fims__QueryServiceDescriptionRequestType_responseType:
		return soap_out__fims__QueryServiceDescriptionRequestType_responseType(soap, tag, id, (const enum _fims__QueryServiceDescriptionRequestType_responseType *)ptr, "fims:QueryServiceDescriptionRequestType-responseType");
	case SOAP_TYPE_fims__EventClassificationType:
		return soap_out_fims__EventClassificationType(soap, tag, id, (const enum fims__EventClassificationType *)ptr, "fims:EventClassificationType");
	case SOAP_TYPE_fims__EventSubType:
		return soap_out_fims__EventSubType(soap, tag, id, (const enum fims__EventSubType *)ptr, "fims:EventSubType");
	case SOAP_TYPE_fims__EventType:
		return soap_out_fims__EventType(soap, tag, id, (const enum fims__EventType *)ptr, "fims:EventType");
	case SOAP_TYPE_fims__QueryParameterOperatorType:
		return soap_out_fims__QueryParameterOperatorType(soap, tag, id, (const enum fims__QueryParameterOperatorType *)ptr, "fims:QueryParameterOperatorType");
	case SOAP_TYPE_fims__QueryGroupOperatorType:
		return soap_out_fims__QueryGroupOperatorType(soap, tag, id, (const enum fims__QueryGroupOperatorType *)ptr, "fims:QueryGroupOperatorType");
	case SOAP_TYPE_fims__BMStatusType:
		return soap_out_fims__BMStatusType(soap, tag, id, (const enum fims__BMStatusType *)ptr, "fims:BMStatusType");
	case SOAP_TYPE_fims__DataTypeType:
		return soap_out_fims__DataTypeType(soap, tag, id, (const enum fims__DataTypeType *)ptr, "fims:DataTypeType");
	case SOAP_TYPE_fims__JobInfoSelectionType:
		return soap_out_fims__JobInfoSelectionType(soap, tag, id, (const enum fims__JobInfoSelectionType *)ptr, "fims:JobInfoSelectionType");
	case SOAP_TYPE_fims__ErrorCodeType:
		return soap_out_fims__ErrorCodeType(soap, tag, id, (const enum fims__ErrorCodeType *)ptr, "fims:ErrorCodeType");
	case SOAP_TYPE_fims__BitRateModeType:
		return soap_out_fims__BitRateModeType(soap, tag, id, (const enum fims__BitRateModeType *)ptr, "fims:BitRateModeType");
	case SOAP_TYPE_fims__ScanningOrderType:
		return soap_out_fims__ScanningOrderType(soap, tag, id, (const enum fims__ScanningOrderType *)ptr, "fims:ScanningOrderType");
	case SOAP_TYPE_fims__ScanningFormatType:
		return soap_out_fims__ScanningFormatType(soap, tag, id, (const enum fims__ScanningFormatType *)ptr, "fims:ScanningFormatType");
	case SOAP_TYPE_fims__AudioSampleType:
		return soap_out_fims__AudioSampleType(soap, tag, id, (const enum fims__AudioSampleType *)ptr, "fims:AudioSampleType");
	case SOAP_TYPE_fims__JobStatusType:
		return soap_out_fims__JobStatusType(soap, tag, id, (const enum fims__JobStatusType *)ptr, "fims:JobStatusType");
	case SOAP_TYPE_fims__HashFunctionTypes:
		return soap_out_fims__HashFunctionTypes(soap, tag, id, (const enum fims__HashFunctionTypes *)ptr, "fims:HashFunctionTypes");
	case SOAP_TYPE_fims__JobCommandType:
		return soap_out_fims__JobCommandType(soap, tag, id, (const enum fims__JobCommandType *)ptr, "fims:JobCommandType");
	case SOAP_TYPE_fims__QueueCommandType:
		return soap_out_fims__QueueCommandType(soap, tag, id, (const enum fims__QueueCommandType *)ptr, "fims:QueueCommandType");
	case SOAP_TYPE_fims__StorageTypes:
		return soap_out_fims__StorageTypes(soap, tag, id, (const enum fims__StorageTypes *)ptr, "fims:StorageTypes");
	case SOAP_TYPE_fims__PriorityType:
		return soap_out_fims__PriorityType(soap, tag, id, (const enum fims__PriorityType *)ptr, "fims:PriorityType");
	case SOAP_TYPE_fims__QueueStatusType:
		return soap_out_fims__QueueStatusType(soap, tag, id, (const enum fims__QueueStatusType *)ptr, "fims:QueueStatusType");
	case SOAP_TYPE_fims__CurrentVersion:
		return soap_out_fims__CurrentVersion(soap, tag, id, (const enum fims__CurrentVersion *)ptr, "fims:CurrentVersion");
	case SOAP_TYPE_edlprovider__EdlProviderErrorCodeType:
		return soap_out_edlprovider__EdlProviderErrorCodeType(soap, tag, id, (const enum edlprovider__EdlProviderErrorCodeType *)ptr, "edlprovider:EdlProviderErrorCodeType");
	case SOAP_TYPE__fims__ContainerFormatType_containerFormat:
		return ((_fims__ContainerFormatType_containerFormat *)ptr)->soap_out(soap, "fims:ContainerFormatType-containerFormat", id, NULL);
	case SOAP_TYPE__fims__AudioFormatType_trackConfiguration:
		return ((_fims__AudioFormatType_trackConfiguration *)ptr)->soap_out(soap, "fims:AudioFormatType-trackConfiguration", id, NULL);
	case SOAP_TYPE__fims__BMEssenceLocatorType_containerMimeType:
		return ((_fims__BMEssenceLocatorType_containerMimeType *)ptr)->soap_out(soap, "fims:BMEssenceLocatorType-containerMimeType", id, NULL);
	case SOAP_TYPE__fims__BMContentFormatType_mimeType:
		return ((_fims__BMContentFormatType_mimeType *)ptr)->soap_out(soap, "fims:BMContentFormatType-mimeType", id, NULL);
	case SOAP_TYPE__fims__ServiceType_serviceDescription:
		return ((_fims__ServiceType_serviceDescription *)ptr)->soap_out(soap, "fims:ServiceType-serviceDescription", id, NULL);
	case SOAP_TYPE__fimsdescription__addressType_country:
		return ((_fimsdescription__addressType_country *)ptr)->soap_out(soap, "fimsdescription:addressType-country", id, NULL);
	case SOAP_TYPE__fimsdescription__organisationDetailsType_organisationDepartment:
		return ((_fimsdescription__organisationDetailsType_organisationDepartment *)ptr)->soap_out(soap, "fimsdescription:organisationDetailsType-organisationDepartment", id, NULL);
	case SOAP_TYPE__fimsdescription__entityType_role:
		return ((_fimsdescription__entityType_role *)ptr)->soap_out(soap, "fimsdescription:entityType-role", id, NULL);
	case SOAP_TYPE__fimsdescription__dateType_alternative:
		return ((_fimsdescription__dateType_alternative *)ptr)->soap_out(soap, "fimsdescription:dateType-alternative", id, NULL);
	case SOAP_TYPE__fimsdescription__dateType_issued:
		return ((_fimsdescription__dateType_issued *)ptr)->soap_out(soap, "fimsdescription:dateType-issued", id, NULL);
	case SOAP_TYPE__fimsdescription__dateType_modified:
		return ((_fimsdescription__dateType_modified *)ptr)->soap_out(soap, "fimsdescription:dateType-modified", id, NULL);
	case SOAP_TYPE__fimsdescription__dateType_created:
		return ((_fimsdescription__dateType_created *)ptr)->soap_out(soap, "fimsdescription:dateType-created", id, NULL);
	case SOAP_TYPE__fimsdescription__coverageType_spatial_coordinates:
		return ((_fimsdescription__coverageType_spatial_coordinates *)ptr)->soap_out(soap, "fimsdescription:coverageType-spatial-coordinates", id, NULL);
	case SOAP_TYPE__fimsdescription__coverageType_spatial_locationName:
		return ((_fimsdescription__coverageType_spatial_locationName *)ptr)->soap_out(soap, "fimsdescription:coverageType-spatial-locationName", id, NULL);
	case SOAP_TYPE__fimsdescription__coverageType_spatial:
		return ((_fimsdescription__coverageType_spatial *)ptr)->soap_out(soap, "fimsdescription:coverageType-spatial", id, NULL);
	case SOAP_TYPE__fimsdescription__coverageType_temporal:
		return ((_fimsdescription__coverageType_temporal *)ptr)->soap_out(soap, "fimsdescription:coverageType-temporal", id, NULL);
	case SOAP_TYPE__fimsdescription__typeType_targetAudience:
		return ((_fimsdescription__typeType_targetAudience *)ptr)->soap_out(soap, "fimsdescription:typeType-targetAudience", id, NULL);
	case SOAP_TYPE__fimsdescription__typeType_objectType:
		return ((_fimsdescription__typeType_objectType *)ptr)->soap_out(soap, "fimsdescription:typeType-objectType", id, NULL);
	case SOAP_TYPE__fimsdescription__typeType_genre:
		return ((_fimsdescription__typeType_genre *)ptr)->soap_out(soap, "fimsdescription:typeType-genre", id, NULL);
	case SOAP_TYPE_fims__ResourceIDType:
		return soap_out_fims__ResourceIDType(soap, tag, id, (const std::wstring *)ptr, "fims:ResourceIDType");
	case SOAP_TYPE_fimstime__TimecodeDuration:
		return soap_out_fimstime__TimecodeDuration(soap, tag, id, (const std::wstring *)ptr, "fimstime:TimecodeDuration");
	case SOAP_TYPE_fimstime__Timecode:
		return soap_out_fimstime__Timecode(soap, tag, id, (const std::wstring *)ptr, "fimstime:Timecode");
	case SOAP_TYPE_fims__RevisionIDType:
		return soap_out_fims__RevisionIDType(soap, tag, id, (const std::wstring *)ptr, "fims:RevisionIDType");
	case SOAP_TYPE_fims__UID:
		return soap_out_fims__UID(soap, tag, id, (const std::wstring *)ptr, "fims:UID");
	case SOAP_TYPE_fimsdescription__partType:
		return ((fimsdescription__partType *)ptr)->soap_out(soap, tag, id, "fimsdescription:partType");
	case SOAP_TYPE_fimsdescription__relationType:
		return ((fimsdescription__relationType *)ptr)->soap_out(soap, tag, id, "fimsdescription:relationType");
	case SOAP_TYPE_fimsdescription__languageType:
		return ((fimsdescription__languageType *)ptr)->soap_out(soap, tag, id, "fimsdescription:languageType");
	case SOAP_TYPE_fimsdescription__addressType:
		return ((fimsdescription__addressType *)ptr)->soap_out(soap, tag, id, "fimsdescription:addressType");
	case SOAP_TYPE_fimsdescription__detailsType:
		return ((fimsdescription__detailsType *)ptr)->soap_out(soap, tag, id, "fimsdescription:detailsType");
	case SOAP_TYPE_fimsdescription__organisationDetailsType:
		return ((fimsdescription__organisationDetailsType *)ptr)->soap_out(soap, tag, id, "fimsdescription:organisationDetailsType");
	case SOAP_TYPE_fimsdescription__contactDetailsType:
		return ((fimsdescription__contactDetailsType *)ptr)->soap_out(soap, tag, id, "fimsdescription:contactDetailsType");
	case SOAP_TYPE_fimsdescription__entityType:
		return ((fimsdescription__entityType *)ptr)->soap_out(soap, tag, id, "fimsdescription:entityType");
	case SOAP_TYPE_fimsdescription__dateType:
		return ((fimsdescription__dateType *)ptr)->soap_out(soap, tag, id, "fimsdescription:dateType");
	case SOAP_TYPE_fimsdescription__textElementType:
		return ((fimsdescription__textElementType *)ptr)->soap_out(soap, tag, id, "fimsdescription:textElementType");
	case SOAP_TYPE_fimsdescription__rightsType:
		return ((fimsdescription__rightsType *)ptr)->soap_out(soap, tag, id, "fimsdescription:rightsType");
	case SOAP_TYPE_fimsdescription__coverageType:
		return ((fimsdescription__coverageType *)ptr)->soap_out(soap, tag, id, "fimsdescription:coverageType");
	case SOAP_TYPE_fimsdescription__descriptionType:
		return ((fimsdescription__descriptionType *)ptr)->soap_out(soap, tag, id, "fimsdescription:descriptionType");
	case SOAP_TYPE_fimsdescription__typeType:
		return ((fimsdescription__typeType *)ptr)->soap_out(soap, tag, id, "fimsdescription:typeType");
	case SOAP_TYPE_fimsdescription__subjectType:
		return ((fimsdescription__subjectType *)ptr)->soap_out(soap, tag, id, "fimsdescription:subjectType");
	case SOAP_TYPE_fimsdescription__identifierType:
		return ((fimsdescription__identifierType *)ptr)->soap_out(soap, tag, id, "fimsdescription:identifierType");
	case SOAP_TYPE_fimsdescription__titleType:
		return ((fimsdescription__titleType *)ptr)->soap_out(soap, tag, id, "fimsdescription:titleType");
	case SOAP_TYPE_fimsdescription__bmContentDescriptionType:
		return ((fimsdescription__bmContentDescriptionType *)ptr)->soap_out(soap, tag, id, "fimsdescription:bmContentDescriptionType");
	case SOAP_TYPE_fimstime__EditUnitNumberType:
		return ((fimstime__EditUnitNumberType *)ptr)->soap_out(soap, tag, id, "fimstime:EditUnitNumberType");
	case SOAP_TYPE_fimstime__TimeType:
		return ((fimstime__TimeType *)ptr)->soap_out(soap, tag, id, "fimstime:TimeType");
	case SOAP_TYPE_fimstime__DurationType:
		return ((fimstime__DurationType *)ptr)->soap_out(soap, tag, id, "fimstime:DurationType");
	case SOAP_TYPE__fims__formatCollection:
		return ((_fims__formatCollection *)ptr)->soap_out(soap, "fims:formatCollection", id, NULL);
	case SOAP_TYPE_fims__SystemPerformanceEventsType:
		return ((fims__SystemPerformanceEventsType *)ptr)->soap_out(soap, tag, id, "fims:SystemPerformanceEventsType");
	case SOAP_TYPE_fims__SystemPerformanceEventType:
		return ((fims__SystemPerformanceEventType *)ptr)->soap_out(soap, tag, id, "fims:SystemPerformanceEventType");
	case SOAP_TYPE_fims__SystemExceptionEventsType:
		return ((fims__SystemExceptionEventsType *)ptr)->soap_out(soap, tag, id, "fims:SystemExceptionEventsType");
	case SOAP_TYPE_fims__SystemExceptionEventType:
		return ((fims__SystemExceptionEventType *)ptr)->soap_out(soap, tag, id, "fims:SystemExceptionEventType");
	case SOAP_TYPE_fims__SystemEventsType:
		return ((fims__SystemEventsType *)ptr)->soap_out(soap, tag, id, "fims:SystemEventsType");
	case SOAP_TYPE_fims__SystemEventType:
		return ((fims__SystemEventType *)ptr)->soap_out(soap, tag, id, "fims:SystemEventType");
	case SOAP_TYPE_fims__ContentCustomEventsType:
		return ((fims__ContentCustomEventsType *)ptr)->soap_out(soap, tag, id, "fims:ContentCustomEventsType");
	case SOAP_TYPE_fims__ContentCustomEventType:
		return ((fims__ContentCustomEventType *)ptr)->soap_out(soap, tag, id, "fims:ContentCustomEventType");
	case SOAP_TYPE_fims__ContentStatusEventsType:
		return ((fims__ContentStatusEventsType *)ptr)->soap_out(soap, tag, id, "fims:ContentStatusEventsType");
	case SOAP_TYPE_fims__ContentStatusEventType:
		return ((fims__ContentStatusEventType *)ptr)->soap_out(soap, tag, id, "fims:ContentStatusEventType");
	case SOAP_TYPE_fims__ContentEventsType:
		return ((fims__ContentEventsType *)ptr)->soap_out(soap, tag, id, "fims:ContentEventsType");
	case SOAP_TYPE_fims__ContentEventType:
		return ((fims__ContentEventType *)ptr)->soap_out(soap, tag, id, "fims:ContentEventType");
	case SOAP_TYPE_fims__EventPayloadsType:
		return ((fims__EventPayloadsType *)ptr)->soap_out(soap, tag, id, "fims:EventPayloadsType");
	case SOAP_TYPE_fims__EventPayloadType:
		return ((fims__EventPayloadType *)ptr)->soap_out(soap, tag, id, "fims:EventPayloadType");
	case SOAP_TYPE_fims__EventEnvelopesType:
		return ((fims__EventEnvelopesType *)ptr)->soap_out(soap, tag, id, "fims:EventEnvelopesType");
	case SOAP_TYPE_fims__EventEnvelopeType:
		return ((fims__EventEnvelopeType *)ptr)->soap_out(soap, tag, id, "fims:EventEnvelopeType");
	case SOAP_TYPE_fims__CustomEventTemplatesType:
		return ((fims__CustomEventTemplatesType *)ptr)->soap_out(soap, tag, id, "fims:CustomEventTemplatesType");
	case SOAP_TYPE_fims__CustomEventTemplateType:
		return ((fims__CustomEventTemplateType *)ptr)->soap_out(soap, tag, id, "fims:CustomEventTemplateType");
	case SOAP_TYPE_fims__QueryGroupsType:
		return ((fims__QueryGroupsType *)ptr)->soap_out(soap, tag, id, "fims:QueryGroupsType");
	case SOAP_TYPE_fims__QueryGroupType:
		return ((fims__QueryGroupType *)ptr)->soap_out(soap, tag, id, "fims:QueryGroupType");
	case SOAP_TYPE_fims__CustomQueryGroupOperatorsType:
		return ((fims__CustomQueryGroupOperatorsType *)ptr)->soap_out(soap, tag, id, "fims:CustomQueryGroupOperatorsType");
	case SOAP_TYPE_fims__CustomQueryGroupOperatorType:
		return ((fims__CustomQueryGroupOperatorType *)ptr)->soap_out(soap, tag, id, "fims:CustomQueryGroupOperatorType");
	case SOAP_TYPE_fims__QueryParametersType:
		return ((fims__QueryParametersType *)ptr)->soap_out(soap, tag, id, "fims:QueryParametersType");
	case SOAP_TYPE_fims__QueryParameterType:
		return ((fims__QueryParameterType *)ptr)->soap_out(soap, tag, id, "fims:QueryParameterType");
	case SOAP_TYPE_fims__CustomQueryParameterOperatorsType:
		return ((fims__CustomQueryParameterOperatorsType *)ptr)->soap_out(soap, tag, id, "fims:CustomQueryParameterOperatorsType");
	case SOAP_TYPE_fims__CustomQueryParameterOperatorType:
		return ((fims__CustomQueryParameterOperatorType *)ptr)->soap_out(soap, tag, id, "fims:CustomQueryParameterOperatorType");
	case SOAP_TYPE_fims__QueryExpressionsType:
		return ((fims__QueryExpressionsType *)ptr)->soap_out(soap, tag, id, "fims:QueryExpressionsType");
	case SOAP_TYPE_fims__QueryExpressionType:
		return ((fims__QueryExpressionType *)ptr)->soap_out(soap, tag, id, "fims:QueryExpressionType");
	case SOAP_TYPE_fims__SuperLockTokensType:
		return ((fims__SuperLockTokensType *)ptr)->soap_out(soap, tag, id, "fims:SuperLockTokensType");
	case SOAP_TYPE_fims__SuperLockTokenType:
		return ((fims__SuperLockTokenType *)ptr)->soap_out(soap, tag, id, "fims:SuperLockTokenType");
	case SOAP_TYPE_fims__LockTokensType:
		return ((fims__LockTokensType *)ptr)->soap_out(soap, tag, id, "fims:LockTokensType");
	case SOAP_TYPE_fims__LockTokenType:
		return ((fims__LockTokenType *)ptr)->soap_out(soap, tag, id, "fims:LockTokenType");
	case SOAP_TYPE_fims__CredentialsType:
		return ((fims__CredentialsType *)ptr)->soap_out(soap, tag, id, "fims:CredentialsType");
	case SOAP_TYPE_fims__CredentialType:
		return ((fims__CredentialType *)ptr)->soap_out(soap, tag, id, "fims:CredentialType");
	case SOAP_TYPE_fims__BMEssenceLocatorStatusesType:
		return ((fims__BMEssenceLocatorStatusesType *)ptr)->soap_out(soap, tag, id, "fims:BMEssenceLocatorStatusesType");
	case SOAP_TYPE_fims__BMEssenceLocatorStatusType:
		return ((fims__BMEssenceLocatorStatusType *)ptr)->soap_out(soap, tag, id, "fims:BMEssenceLocatorStatusType");
	case SOAP_TYPE_fims__BMContentStatusesType:
		return ((fims__BMContentStatusesType *)ptr)->soap_out(soap, tag, id, "fims:BMContentStatusesType");
	case SOAP_TYPE_fims__BMContentStatusType:
		return ((fims__BMContentStatusType *)ptr)->soap_out(soap, tag, id, "fims:BMContentStatusType");
	case SOAP_TYPE_fims__BMCustomStatusExtensionsType:
		return ((fims__BMCustomStatusExtensionsType *)ptr)->soap_out(soap, tag, id, "fims:BMCustomStatusExtensionsType");
	case SOAP_TYPE_fims__BMCustomStatusExtensionType:
		return ((fims__BMCustomStatusExtensionType *)ptr)->soap_out(soap, tag, id, "fims:BMCustomStatusExtensionType");
	case SOAP_TYPE_fims__CustomValuesType:
		return ((fims__CustomValuesType *)ptr)->soap_out(soap, tag, id, "fims:CustomValuesType");
	case SOAP_TYPE_fims__CustomValueType:
		return ((fims__CustomValueType *)ptr)->soap_out(soap, tag, id, "fims:CustomValueType");
	case SOAP_TYPE_fims__ResourceReferencesType:
		return ((fims__ResourceReferencesType *)ptr)->soap_out(soap, tag, id, "fims:ResourceReferencesType");
	case SOAP_TYPE_fims__DescriptionsType:
		return ((fims__DescriptionsType *)ptr)->soap_out(soap, tag, id, "fims:DescriptionsType");
	case SOAP_TYPE_fims__BMEssenceLocatorsType:
		return ((fims__BMEssenceLocatorsType *)ptr)->soap_out(soap, tag, id, "fims:BMEssenceLocatorsType");
	case SOAP_TYPE_fims__BMContentFormatsType:
		return ((fims__BMContentFormatsType *)ptr)->soap_out(soap, tag, id, "fims:BMContentFormatsType");
	case SOAP_TYPE_fims__BMContentsType:
		return ((fims__BMContentsType *)ptr)->soap_out(soap, tag, id, "fims:BMContentsType");
	case SOAP_TYPE_fims__BMObjectsType:
		return ((fims__BMObjectsType *)ptr)->soap_out(soap, tag, id, "fims:BMObjectsType");
	case SOAP_TYPE_fims__DataFormatsType:
		return ((fims__DataFormatsType *)ptr)->soap_out(soap, tag, id, "fims:DataFormatsType");
	case SOAP_TYPE_fims__ContainerFormatsType:
		return ((fims__ContainerFormatsType *)ptr)->soap_out(soap, tag, id, "fims:ContainerFormatsType");
	case SOAP_TYPE_fims__AudioFormatsType:
		return ((fims__AudioFormatsType *)ptr)->soap_out(soap, tag, id, "fims:AudioFormatsType");
	case SOAP_TYPE_fims__VideoFormatsType:
		return ((fims__VideoFormatsType *)ptr)->soap_out(soap, tag, id, "fims:VideoFormatsType");
	case SOAP_TYPE_fims__JobsType:
		return ((fims__JobsType *)ptr)->soap_out(soap, tag, id, "fims:JobsType");
	case SOAP_TYPE_fims__QueuesType:
		return ((fims__QueuesType *)ptr)->soap_out(soap, tag, id, "fims:QueuesType");
	case SOAP_TYPE_fims__ServicesType:
		return ((fims__ServicesType *)ptr)->soap_out(soap, tag, id, "fims:ServicesType");
	case SOAP_TYPE_fims__ProfilesType:
		return ((fims__ProfilesType *)ptr)->soap_out(soap, tag, id, "fims:ProfilesType");
	case SOAP_TYPE_fims__ResourcesType:
		return ((fims__ResourcesType *)ptr)->soap_out(soap, tag, id, "fims:ResourcesType");
	case SOAP_TYPE_fims__InnerFaultType:
		return ((fims__InnerFaultType *)ptr)->soap_out(soap, tag, id, "fims:InnerFaultType");
	case SOAP_TYPE_fims__FaultType:
		return ((fims__FaultType *)ptr)->soap_out(soap, tag, id, "fims:FaultType");
	case SOAP_TYPE_fims__ListFilterType:
		return ((fims__ListFilterType *)ptr)->soap_out(soap, tag, id, "fims:ListFilterType");
	case SOAP_TYPE_fims__QueryServiceDescriptionResponseType:
		return ((fims__QueryServiceDescriptionResponseType *)ptr)->soap_out(soap, tag, id, "fims:QueryServiceDescriptionResponseType");
	case SOAP_TYPE_fims__QueryServiceDescriptionRequestType:
		return ((fims__QueryServiceDescriptionRequestType *)ptr)->soap_out(soap, tag, id, "fims:QueryServiceDescriptionRequestType");
	case SOAP_TYPE_fims__QueryJobResponseType:
		return ((fims__QueryJobResponseType *)ptr)->soap_out(soap, tag, id, "fims:QueryJobResponseType");
	case SOAP_TYPE_fims__QueryJobRequestByFilterType:
		return ((fims__QueryJobRequestByFilterType *)ptr)->soap_out(soap, tag, id, "fims:QueryJobRequestByFilterType");
	case SOAP_TYPE_fims__QueryJobRequestByIDType:
		return ((fims__QueryJobRequestByIDType *)ptr)->soap_out(soap, tag, id, "fims:QueryJobRequestByIDType");
	case SOAP_TYPE_fims__QueryJobRequestType:
		return ((fims__QueryJobRequestType *)ptr)->soap_out(soap, tag, id, "fims:QueryJobRequestType");
	case SOAP_TYPE_fims__ManageQueueResponseType:
		return ((fims__ManageQueueResponseType *)ptr)->soap_out(soap, tag, id, "fims:ManageQueueResponseType");
	case SOAP_TYPE_fims__ManageQueueRequestType:
		return ((fims__ManageQueueRequestType *)ptr)->soap_out(soap, tag, id, "fims:ManageQueueRequestType");
	case SOAP_TYPE_fims__ManageJobResponseType:
		return ((fims__ManageJobResponseType *)ptr)->soap_out(soap, tag, id, "fims:ManageJobResponseType");
	case SOAP_TYPE_fims__ManageJobRequestType:
		return ((fims__ManageJobRequestType *)ptr)->soap_out(soap, tag, id, "fims:ManageJobRequestType");
	case SOAP_TYPE_fims__StartJobByLatestType:
		return ((fims__StartJobByLatestType *)ptr)->soap_out(soap, tag, id, "fims:StartJobByLatestType");
	case SOAP_TYPE_fims__StartJobByTimeType:
		return ((fims__StartJobByTimeType *)ptr)->soap_out(soap, tag, id, "fims:StartJobByTimeType");
	case SOAP_TYPE_fims__StartJobByNoWaitType:
		return ((fims__StartJobByNoWaitType *)ptr)->soap_out(soap, tag, id, "fims:StartJobByNoWaitType");
	case SOAP_TYPE_fims__StartJobType:
		return ((fims__StartJobType *)ptr)->soap_out(soap, tag, id, "fims:StartJobType");
	case SOAP_TYPE_fims__StopProcessByOpenEndType:
		return ((fims__StopProcessByOpenEndType *)ptr)->soap_out(soap, tag, id, "fims:StopProcessByOpenEndType");
	case SOAP_TYPE_fims__StopProcessByServiceDefinedTimeType:
		return ((fims__StopProcessByServiceDefinedTimeType *)ptr)->soap_out(soap, tag, id, "fims:StopProcessByServiceDefinedTimeType");
	case SOAP_TYPE_fims__StopProcessByTimeMarkType:
		return ((fims__StopProcessByTimeMarkType *)ptr)->soap_out(soap, tag, id, "fims:StopProcessByTimeMarkType");
	case SOAP_TYPE_fims__StopProcessByDurationType:
		return ((fims__StopProcessByDurationType *)ptr)->soap_out(soap, tag, id, "fims:StopProcessByDurationType");
	case SOAP_TYPE_fims__StopProcessByTimeType:
		return ((fims__StopProcessByTimeType *)ptr)->soap_out(soap, tag, id, "fims:StopProcessByTimeType");
	case SOAP_TYPE_fims__StopProcessType:
		return ((fims__StopProcessType *)ptr)->soap_out(soap, tag, id, "fims:StopProcessType");
	case SOAP_TYPE_fims__StartProcessByServiceDefinedTimeType:
		return ((fims__StartProcessByServiceDefinedTimeType *)ptr)->soap_out(soap, tag, id, "fims:StartProcessByServiceDefinedTimeType");
	case SOAP_TYPE_fims__StartProcessByTimeMarkType:
		return ((fims__StartProcessByTimeMarkType *)ptr)->soap_out(soap, tag, id, "fims:StartProcessByTimeMarkType");
	case SOAP_TYPE_fims__StartProcessByTimeType:
		return ((fims__StartProcessByTimeType *)ptr)->soap_out(soap, tag, id, "fims:StartProcessByTimeType");
	case SOAP_TYPE_fims__StartProcessByNoWaitType:
		return ((fims__StartProcessByNoWaitType *)ptr)->soap_out(soap, tag, id, "fims:StartProcessByNoWaitType");
	case SOAP_TYPE_fims__StartProcessType:
		return ((fims__StartProcessType *)ptr)->soap_out(soap, tag, id, "fims:StartProcessType");
	case SOAP_TYPE_fims__HashFunctionType:
		return ((fims__HashFunctionType *)ptr)->soap_out(soap, tag, id, "fims:HashFunctionType");
	case SOAP_TYPE_fims__StorageType:
		return ((fims__StorageType *)ptr)->soap_out(soap, tag, id, "fims:StorageType");
	case SOAP_TYPE_fims__ProcessedInfoByFramesType:
		return ((fims__ProcessedInfoByFramesType *)ptr)->soap_out(soap, tag, id, "fims:ProcessedInfoByFramesType");
	case SOAP_TYPE_fims__ProcessedInfoByBytesType:
		return ((fims__ProcessedInfoByBytesType *)ptr)->soap_out(soap, tag, id, "fims:ProcessedInfoByBytesType");
	case SOAP_TYPE_fims__ProcessedInfoType:
		return ((fims__ProcessedInfoType *)ptr)->soap_out(soap, tag, id, "fims:ProcessedInfoType");
	case SOAP_TYPE_fims__HashType:
		return ((fims__HashType *)ptr)->soap_out(soap, tag, id, "fims:HashType");
	case SOAP_TYPE_fims__RationalType:
		return ((fims__RationalType *)ptr)->soap_out(soap, tag, id, "fims:RationalType");
	case SOAP_TYPE_fims__LengthType:
		return ((fims__LengthType *)ptr)->soap_out(soap, tag, id, "fims:LengthType");
	case SOAP_TYPE_fims__TechnicalAttributeType:
		return ((fims__TechnicalAttributeType *)ptr)->soap_out(soap, tag, id, "fims:TechnicalAttributeType");
	case SOAP_TYPE_fims__TransformAtomType:
		return ((fims__TransformAtomType *)ptr)->soap_out(soap, tag, id, "fims:TransformAtomType");
	case SOAP_TYPE_fims__TransferAtomType:
		return ((fims__TransferAtomType *)ptr)->soap_out(soap, tag, id, "fims:TransferAtomType");
	case SOAP_TYPE_fims__EssencePlaceholderLocatorType:
		return ((fims__EssencePlaceholderLocatorType *)ptr)->soap_out(soap, tag, id, "fims:EssencePlaceholderLocatorType");
	case SOAP_TYPE_fims__FolderLocatorType:
		return ((fims__FolderLocatorType *)ptr)->soap_out(soap, tag, id, "fims:FolderLocatorType");
	case SOAP_TYPE_fims__ListFileLocatorType:
		return ((fims__ListFileLocatorType *)ptr)->soap_out(soap, tag, id, "fims:ListFileLocatorType");
	case SOAP_TYPE_fims__SimpleFileLocatorType:
		return ((fims__SimpleFileLocatorType *)ptr)->soap_out(soap, tag, id, "fims:SimpleFileLocatorType");
	case SOAP_TYPE_fims__BMEssenceLocatorType:
		return ((fims__BMEssenceLocatorType *)ptr)->soap_out(soap, tag, id, "fims:BMEssenceLocatorType");
	case SOAP_TYPE_fims__BMContentFormatType:
		return ((fims__BMContentFormatType *)ptr)->soap_out(soap, tag, id, "fims:BMContentFormatType");
	case SOAP_TYPE_fims__DescriptionType:
		return ((fims__DescriptionType *)ptr)->soap_out(soap, tag, id, "fims:DescriptionType");
	case SOAP_TYPE_fims__BMContentType:
		return ((fims__BMContentType *)ptr)->soap_out(soap, tag, id, "fims:BMContentType");
	case SOAP_TYPE_fims__BMObjectType:
		return ((fims__BMObjectType *)ptr)->soap_out(soap, tag, id, "fims:BMObjectType");
	case SOAP_TYPE_fims__CodecType:
		return ((fims__CodecType *)ptr)->soap_out(soap, tag, id, "fims:CodecType");
	case SOAP_TYPE_fims__BMTrackType:
		return ((fims__BMTrackType *)ptr)->soap_out(soap, tag, id, "fims:BMTrackType");
	case SOAP_TYPE_fims__ContainerFormatType:
		return ((fims__ContainerFormatType *)ptr)->soap_out(soap, tag, id, "fims:ContainerFormatType");
	case SOAP_TYPE_fims__AncillaryDataFormatType:
		return ((fims__AncillaryDataFormatType *)ptr)->soap_out(soap, tag, id, "fims:AncillaryDataFormatType");
	case SOAP_TYPE_fims__CaptioningFormatType:
		return ((fims__CaptioningFormatType *)ptr)->soap_out(soap, tag, id, "fims:CaptioningFormatType");
	case SOAP_TYPE_fims__DataFormatType:
		return ((fims__DataFormatType *)ptr)->soap_out(soap, tag, id, "fims:DataFormatType");
	case SOAP_TYPE_fims__AudioFormatType:
		return ((fims__AudioFormatType *)ptr)->soap_out(soap, tag, id, "fims:AudioFormatType");
	case SOAP_TYPE_fims__VideoFormatType:
		return ((fims__VideoFormatType *)ptr)->soap_out(soap, tag, id, "fims:VideoFormatType");
	case SOAP_TYPE_fims__FormatType:
		return ((fims__FormatType *)ptr)->soap_out(soap, tag, id, "fims:FormatType");
	case SOAP_TYPE_fims__JobType:
		return ((fims__JobType *)ptr)->soap_out(soap, tag, id, "fims:JobType");
	case SOAP_TYPE_fims__QueueType:
		return ((fims__QueueType *)ptr)->soap_out(soap, tag, id, "fims:QueueType");
	case SOAP_TYPE_fims__ProfileType:
		return ((fims__ProfileType *)ptr)->soap_out(soap, tag, id, "fims:ProfileType");
	case SOAP_TYPE_fims__ServiceType:
		return ((fims__ServiceType *)ptr)->soap_out(soap, tag, id, "fims:ServiceType");
	case SOAP_TYPE_fims__AsyncEndpointType:
		return ((fims__AsyncEndpointType *)ptr)->soap_out(soap, tag, id, "fims:AsyncEndpointType");
	case SOAP_TYPE_fims__ExtensionBaseType:
		return ((fims__ExtensionBaseType *)ptr)->soap_out(soap, tag, id, "fims:ExtensionBaseType");
	case SOAP_TYPE_fims__ResourceType:
		return ((fims__ResourceType *)ptr)->soap_out(soap, tag, id, "fims:ResourceType");
	case SOAP_TYPE_fims__ResourceReferenceType:
		return ((fims__ResourceReferenceType *)ptr)->soap_out(soap, tag, id, "fims:ResourceReferenceType");
	case SOAP_TYPE_fims__ExtensionAttributes:
		return ((fims__ExtensionAttributes *)ptr)->soap_out(soap, tag, id, "fims:ExtensionAttributes");
	case SOAP_TYPE_fims__ExtensionGroup:
		return ((fims__ExtensionGroup *)ptr)->soap_out(soap, tag, id, "fims:ExtensionGroup");
	case SOAP_TYPE__edlprovider__Map:
		return ((_edlprovider__Map *)ptr)->soap_out(soap, "edlprovider:Map", id, NULL);
	case SOAP_TYPE_edlprovider__EdlProviderFaultType:
		return ((edlprovider__EdlProviderFaultType *)ptr)->soap_out(soap, tag, id, "edlprovider:EdlProviderFaultType");
	case SOAP_TYPE_edlprovider__InstalledEdlsResponseType:
		return ((edlprovider__InstalledEdlsResponseType *)ptr)->soap_out(soap, tag, id, "edlprovider:InstalledEdlsResponseType");
	case SOAP_TYPE_edlprovider__EdlCreateResponseType:
		return ((edlprovider__EdlCreateResponseType *)ptr)->soap_out(soap, tag, id, "edlprovider:EdlCreateResponseType");
	case SOAP_TYPE_edlprovider__EdlCreateRequestDoubleType:
		return ((edlprovider__EdlCreateRequestDoubleType *)ptr)->soap_out(soap, tag, id, "edlprovider:EdlCreateRequestDoubleType");
	case SOAP_TYPE_edlprovider__EdlCreateRequestType:
		return ((edlprovider__EdlCreateRequestType *)ptr)->soap_out(soap, tag, id, "edlprovider:EdlCreateRequestType");
	case SOAP_TYPE_edlprovider__EdlCreateRequestBaseType:
		return ((edlprovider__EdlCreateRequestBaseType *)ptr)->soap_out(soap, tag, id, "edlprovider:EdlCreateRequestBaseType");
	case SOAP_TYPE_edlprovider__MapItemType:
		return ((edlprovider__MapItemType *)ptr)->soap_out(soap, tag, id, "edlprovider:MapItemType");
	case SOAP_TYPE_edlprovider__ClipType:
		return ((edlprovider__ClipType *)ptr)->soap_out(soap, tag, id, "edlprovider:ClipType");
	case SOAP_TYPE_edlprovider__ArrayOfClips:
		return ((edlprovider__ArrayOfClips *)ptr)->soap_out(soap, tag, id, "edlprovider:ArrayOfClips");
	case SOAP_TYPE_edlprovider__ArrayOfstring:
		return ((edlprovider__ArrayOfstring *)ptr)->soap_out(soap, tag, id, "edlprovider:ArrayOfstring");
	case SOAP_TYPE__xml__lang:
		return soap_out__xml__lang(soap, "xml:lang", id, (const std::wstring *)ptr, NULL);
	case SOAP_TYPE_xsd__time:
		return soap_out_xsd__time(soap, tag, id, (const std::wstring *)ptr, "xsd:time");
	case SOAP_TYPE_xsd__positiveInteger:
		return soap_out_xsd__positiveInteger(soap, tag, id, (const std::wstring *)ptr, "xsd:positiveInteger");
	case SOAP_TYPE_xsd__nonNegativeInteger:
		return soap_out_xsd__nonNegativeInteger(soap, tag, id, (const std::wstring *)ptr, "xsd:nonNegativeInteger");
	case SOAP_TYPE_xsd__language:
		return soap_out_xsd__language(soap, tag, id, (const std::wstring *)ptr, "xsd:language");
	case SOAP_TYPE_xsd__integer:
		return soap_out_xsd__integer(soap, tag, id, (const std::wstring *)ptr, "xsd:integer");
	case SOAP_TYPE_xsd__gYear:
		return soap_out_xsd__gYear(soap, tag, id, (const std::wstring *)ptr, "xsd:gYear");
	case SOAP_TYPE_xsd__decimal:
		return soap_out_xsd__decimal(soap, tag, id, (const std::wstring *)ptr, "xsd:decimal");
	case SOAP_TYPE_xsd__date:
		return soap_out_xsd__date(soap, tag, id, (const std::wstring *)ptr, "xsd:date");
	case SOAP_TYPE_xsd__anyURI:
		return soap_out_xsd__anyURI(soap, tag, id, (const std::wstring *)ptr, "xsd:anyURI");
	case SOAP_TYPE_xsd__NMTOKEN:
		return soap_out_xsd__NMTOKEN(soap, tag, id, (const std::wstring *)ptr, "xsd:NMTOKEN");
	case SOAP_TYPE_std__wstring:
		return soap_out_std__wstring(soap, tag, id, (const std::wstring *)ptr, "xsd:string");
	case SOAP_TYPE_xsd__hexBinary:
		return ((xsd__hexBinary *)ptr)->soap_out(soap, tag, id, "xsd:hexBinary");
	case SOAP_TYPE_xsd__base64Binary:
		return ((xsd__base64Binary *)ptr)->soap_out(soap, tag, id, "xsd:base64Binary");
	case SOAP_TYPE_PointerToedlprovider__EdlCreateRequestDoubleType:
		return soap_out_PointerToedlprovider__EdlCreateRequestDoubleType(soap, tag, id, (edlprovider__EdlCreateRequestDoubleType *const*)ptr, "edlprovider:EdlCreateRequestDoubleType");
	case SOAP_TYPE_PointerToedlprovider__EdlCreateRequestType:
		return soap_out_PointerToedlprovider__EdlCreateRequestType(soap, tag, id, (edlprovider__EdlCreateRequestType *const*)ptr, "edlprovider:EdlCreateRequestType");
	case SOAP_TYPE_PointerToedlprovider__EdlProviderFaultType:
		return soap_out_PointerToedlprovider__EdlProviderFaultType(soap, tag, id, (edlprovider__EdlProviderFaultType *const*)ptr, "edlprovider:EdlProviderFaultType");
	case SOAP_TYPE_PointerTo_fims__ContainerFormatType_containerFormat:
		return soap_out_PointerTo_fims__ContainerFormatType_containerFormat(soap, tag, id, (_fims__ContainerFormatType_containerFormat *const*)ptr, "fims:ContainerFormatType-containerFormat");
	case SOAP_TYPE_PointerTofims__AncillaryDataFormatType:
		return soap_out_PointerTofims__AncillaryDataFormatType(soap, tag, id, (fims__AncillaryDataFormatType *const*)ptr, "fims:AncillaryDataFormatType");
	case SOAP_TYPE_PointerTofims__CaptioningFormatType:
		return soap_out_PointerTofims__CaptioningFormatType(soap, tag, id, (fims__CaptioningFormatType *const*)ptr, "fims:CaptioningFormatType");
	case SOAP_TYPE_PointerTofims__AudioSampleType:
		return soap_out_PointerTofims__AudioSampleType(soap, tag, id, (enum fims__AudioSampleType *const*)ptr, "fims:AudioSampleType");
	case SOAP_TYPE_PointerTo_fims__AudioFormatType_trackConfiguration:
		return soap_out_PointerTo_fims__AudioFormatType_trackConfiguration(soap, tag, id, (_fims__AudioFormatType_trackConfiguration *const*)ptr, "fims:AudioFormatType-trackConfiguration");
	case SOAP_TYPE_PointerToxsd__decimal:
		return soap_out_PointerToxsd__decimal(soap, tag, id, (std::wstring *const*)ptr, "xsd:decimal");
	case SOAP_TYPE_PointerTofims__ScanningOrderType:
		return soap_out_PointerTofims__ScanningOrderType(soap, tag, id, (enum fims__ScanningOrderType *const*)ptr, "fims:ScanningOrderType");
	case SOAP_TYPE_PointerTofims__ScanningFormatType:
		return soap_out_PointerTofims__ScanningFormatType(soap, tag, id, (enum fims__ScanningFormatType *const*)ptr, "fims:ScanningFormatType");
	case SOAP_TYPE_PointerTofims__BitRateModeType:
		return soap_out_PointerTofims__BitRateModeType(soap, tag, id, (enum fims__BitRateModeType *const*)ptr, "fims:BitRateModeType");
	case SOAP_TYPE_PointerTofims__BMTrackType:
		return soap_out_PointerTofims__BMTrackType(soap, tag, id, (fims__BMTrackType *const*)ptr, "fims:BMTrackType");
	case SOAP_TYPE_PointerTofims__CodecType:
		return soap_out_PointerTofims__CodecType(soap, tag, id, (fims__CodecType *const*)ptr, "fims:CodecType");
	case SOAP_TYPE_PointerTofims__LengthType:
		return soap_out_PointerTofims__LengthType(soap, tag, id, (fims__LengthType *const*)ptr, "fims:LengthType");
	case SOAP_TYPE_PointerTofims__ResourceReferencesType:
		return soap_out_PointerTofims__ResourceReferencesType(soap, tag, id, (fims__ResourceReferencesType *const*)ptr, "fims:ResourceReferencesType");
	case SOAP_TYPE_PointerTo_fims__BMEssenceLocatorType_containerMimeType:
		return soap_out_PointerTo_fims__BMEssenceLocatorType_containerMimeType(soap, tag, id, (_fims__BMEssenceLocatorType_containerMimeType *const*)ptr, "fims:BMEssenceLocatorType-containerMimeType");
	case SOAP_TYPE_PointerTofims__StorageType:
		return soap_out_PointerTofims__StorageType(soap, tag, id, (fims__StorageType *const*)ptr, "fims:StorageType");
	case SOAP_TYPE_PointerTo_fims__BMContentFormatType_mimeType:
		return soap_out_PointerTo_fims__BMContentFormatType_mimeType(soap, tag, id, (_fims__BMContentFormatType_mimeType *const*)ptr, "fims:BMContentFormatType-mimeType");
	case SOAP_TYPE_PointerTounsignedLONG64:
		return soap_out_PointerTounsignedLONG64(soap, tag, id, (ULONG64 *const*)ptr, "xsd:unsignedLong");
	case SOAP_TYPE_PointerTofims__HashType:
		return soap_out_PointerTofims__HashType(soap, tag, id, (fims__HashType *const*)ptr, "fims:HashType");
	case SOAP_TYPE_PointerTo_fims__formatCollection:
		return soap_out_PointerTo_fims__formatCollection(soap, tag, id, (_fims__formatCollection *const*)ptr, "fims:formatCollection");
	case SOAP_TYPE_PointerTofims__BMEssenceLocatorsType:
		return soap_out_PointerTofims__BMEssenceLocatorsType(soap, tag, id, (fims__BMEssenceLocatorsType *const*)ptr, "fims:BMEssenceLocatorsType");
	case SOAP_TYPE_PointerTofimsdescription__bmContentDescriptionType:
		return soap_out_PointerTofimsdescription__bmContentDescriptionType(soap, tag, id, (fimsdescription__bmContentDescriptionType *const*)ptr, "fimsdescription:bmContentDescriptionType");
	case SOAP_TYPE_PointerTofims__DescriptionsType:
		return soap_out_PointerTofims__DescriptionsType(soap, tag, id, (fims__DescriptionsType *const*)ptr, "fims:DescriptionsType");
	case SOAP_TYPE_PointerTofims__BMContentFormatsType:
		return soap_out_PointerTofims__BMContentFormatsType(soap, tag, id, (fims__BMContentFormatsType *const*)ptr, "fims:BMContentFormatsType");
	case SOAP_TYPE_PointerTofims__BMContentsType:
		return soap_out_PointerTofims__BMContentsType(soap, tag, id, (fims__BMContentsType *const*)ptr, "fims:BMContentsType");
	case SOAP_TYPE_PointerTofims__TechnicalAttributeType:
		return soap_out_PointerTofims__TechnicalAttributeType(soap, tag, id, (fims__TechnicalAttributeType *const*)ptr, "fims:TechnicalAttributeType");
	case SOAP_TYPE_PointerTofims__ProcessedInfoType:
		return soap_out_PointerTofims__ProcessedInfoType(soap, tag, id, (fims__ProcessedInfoType *const*)ptr, "fims:ProcessedInfoType");
	case SOAP_TYPE_PointerTofims__StartJobType:
		return soap_out_PointerTofims__StartJobType(soap, tag, id, (fims__StartJobType *const*)ptr, "fims:StartJobType");
	case SOAP_TYPE_PointerTofims__BMObjectsType:
		return soap_out_PointerTofims__BMObjectsType(soap, tag, id, (fims__BMObjectsType *const*)ptr, "fims:BMObjectsType");
	case SOAP_TYPE_PointerTofims__JobStatusType:
		return soap_out_PointerTofims__JobStatusType(soap, tag, id, (enum fims__JobStatusType *const*)ptr, "fims:JobStatusType");
	case SOAP_TYPE_PointerTofims__QueueStatusType:
		return soap_out_PointerTofims__QueueStatusType(soap, tag, id, (enum fims__QueueStatusType *const*)ptr, "fims:QueueStatusType");
	case SOAP_TYPE_PointerTo_fims__ServiceType_serviceDescription:
		return soap_out_PointerTo_fims__ServiceType_serviceDescription(soap, tag, id, (_fims__ServiceType_serviceDescription *const*)ptr, "fims:ServiceType-serviceDescription");
	case SOAP_TYPE_PointerToxsd__NMTOKEN:
		return soap_out_PointerToxsd__NMTOKEN(soap, tag, id, (std::wstring *const*)ptr, "xsd:NMTOKEN");
	case SOAP_TYPE_PointerTofims__ListFilterType:
		return soap_out_PointerTofims__ListFilterType(soap, tag, id, (fims__ListFilterType *const*)ptr, "fims:ListFilterType");
	case SOAP_TYPE_PointerTofimstime__DurationType:
		return soap_out_PointerTofimstime__DurationType(soap, tag, id, (fimstime__DurationType *const*)ptr, "fimstime:DurationType");
	case SOAP_TYPE_PointerTofims__AsyncEndpointType:
		return soap_out_PointerTofims__AsyncEndpointType(soap, tag, id, (fims__AsyncEndpointType *const*)ptr, "fims:AsyncEndpointType");
	case SOAP_TYPE_PointerToedlprovider__EdlProviderErrorCodeType:
		return soap_out_PointerToedlprovider__EdlProviderErrorCodeType(soap, tag, id, (enum edlprovider__EdlProviderErrorCodeType *const*)ptr, "edlprovider:EdlProviderErrorCodeType");
	case SOAP_TYPE_PointerTofims__RationalType:
		return soap_out_PointerTofims__RationalType(soap, tag, id, (fims__RationalType *const*)ptr, "fims:RationalType");
	case SOAP_TYPE_PointerTo_fimsdescription__addressType_country:
		return soap_out_PointerTo_fimsdescription__addressType_country(soap, tag, id, (_fimsdescription__addressType_country *const*)ptr, "fimsdescription:addressType-country");
	case SOAP_TYPE_PointerTofimsdescription__addressType:
		return soap_out_PointerTofimsdescription__addressType(soap, tag, id, (fimsdescription__addressType *const*)ptr, "fimsdescription:addressType");
	case SOAP_TYPE_PointerTo_fimsdescription__organisationDetailsType_organisationDepartment:
		return soap_out_PointerTo_fimsdescription__organisationDetailsType_organisationDepartment(soap, tag, id, (_fimsdescription__organisationDetailsType_organisationDepartment *const*)ptr, "fimsdescription:organisationDetailsType-organisationDepartment");
	case SOAP_TYPE_PointerTofimsdescription__detailsType:
		return soap_out_PointerTofimsdescription__detailsType(soap, tag, id, (fimsdescription__detailsType *const*)ptr, "fimsdescription:detailsType");
	case SOAP_TYPE_PointerTofimsdescription__organisationDetailsType:
		return soap_out_PointerTofimsdescription__organisationDetailsType(soap, tag, id, (fimsdescription__organisationDetailsType *const*)ptr, "fimsdescription:organisationDetailsType");
	case SOAP_TYPE_PointerTo_fimsdescription__dateType_alternative:
		return soap_out_PointerTo_fimsdescription__dateType_alternative(soap, tag, id, (_fimsdescription__dateType_alternative *const*)ptr, "fimsdescription:dateType-alternative");
	case SOAP_TYPE_PointerTo_fimsdescription__dateType_issued:
		return soap_out_PointerTo_fimsdescription__dateType_issued(soap, tag, id, (_fimsdescription__dateType_issued *const*)ptr, "fimsdescription:dateType-issued");
	case SOAP_TYPE_PointerTo_fimsdescription__dateType_modified:
		return soap_out_PointerTo_fimsdescription__dateType_modified(soap, tag, id, (_fimsdescription__dateType_modified *const*)ptr, "fimsdescription:dateType-modified");
	case SOAP_TYPE_PointerTo_fimsdescription__dateType_created:
		return soap_out_PointerTo_fimsdescription__dateType_created(soap, tag, id, (_fimsdescription__dateType_created *const*)ptr, "fimsdescription:dateType-created");
	case SOAP_TYPE_PointerToxsd__date:
		return soap_out_PointerToxsd__date(soap, tag, id, (std::wstring *const*)ptr, "xsd:date");
	case SOAP_TYPE_PointerToxsd__gYear:
		return soap_out_PointerToxsd__gYear(soap, tag, id, (std::wstring *const*)ptr, "xsd:gYear");
	case SOAP_TYPE_PointerTofimsdescription__contactDetailsType:
		return soap_out_PointerTofimsdescription__contactDetailsType(soap, tag, id, (fimsdescription__contactDetailsType *const*)ptr, "fimsdescription:contactDetailsType");
	case SOAP_TYPE_PointerTo_fimsdescription__coverageType_spatial:
		return soap_out_PointerTo_fimsdescription__coverageType_spatial(soap, tag, id, (_fimsdescription__coverageType_spatial *const*)ptr, "fimsdescription:coverageType-spatial");
	case SOAP_TYPE_PointerTo_fimsdescription__coverageType_spatial_coordinates:
		return soap_out_PointerTo_fimsdescription__coverageType_spatial_coordinates(soap, tag, id, (_fimsdescription__coverageType_spatial_coordinates *const*)ptr, "fimsdescription:coverageType-spatial-coordinates");
	case SOAP_TYPE_PointerTo_fimsdescription__coverageType_temporal:
		return soap_out_PointerTo_fimsdescription__coverageType_temporal(soap, tag, id, (_fimsdescription__coverageType_temporal *const*)ptr, "fimsdescription:coverageType-temporal");
	case SOAP_TYPE_PointerTo_xml__lang:
		return soap_out_PointerTo_xml__lang(soap, tag, id, (std::wstring *const*)ptr, "xml:lang");
	case SOAP_TYPE_PointerTofimsdescription__partType:
		return soap_out_PointerTofimsdescription__partType(soap, tag, id, (fimsdescription__partType *const*)ptr, "fimsdescription:partType");
	case SOAP_TYPE_PointerTofimsdescription__rightsType:
		return soap_out_PointerTofimsdescription__rightsType(soap, tag, id, (fimsdescription__rightsType *const*)ptr, "fimsdescription:rightsType");
	case SOAP_TYPE_PointerTofimsdescription__coverageType:
		return soap_out_PointerTofimsdescription__coverageType(soap, tag, id, (fimsdescription__coverageType *const*)ptr, "fimsdescription:coverageType");
	case SOAP_TYPE_PointerTofimsdescription__relationType:
		return soap_out_PointerTofimsdescription__relationType(soap, tag, id, (fimsdescription__relationType *const*)ptr, "fimsdescription:relationType");
	case SOAP_TYPE_PointerTofimsdescription__languageType:
		return soap_out_PointerTofimsdescription__languageType(soap, tag, id, (fimsdescription__languageType *const*)ptr, "fimsdescription:languageType");
	case SOAP_TYPE_PointerTofimsdescription__identifierType:
		return soap_out_PointerTofimsdescription__identifierType(soap, tag, id, (fimsdescription__identifierType *const*)ptr, "fimsdescription:identifierType");
	case SOAP_TYPE_PointerTofimsdescription__typeType:
		return soap_out_PointerTofimsdescription__typeType(soap, tag, id, (fimsdescription__typeType *const*)ptr, "fimsdescription:typeType");
	case SOAP_TYPE_PointerTofimsdescription__dateType:
		return soap_out_PointerTofimsdescription__dateType(soap, tag, id, (fimsdescription__dateType *const*)ptr, "fimsdescription:dateType");
	case SOAP_TYPE_PointerTofimsdescription__descriptionType:
		return soap_out_PointerTofimsdescription__descriptionType(soap, tag, id, (fimsdescription__descriptionType *const*)ptr, "fimsdescription:descriptionType");
	case SOAP_TYPE_PointerTofimsdescription__subjectType:
		return soap_out_PointerTofimsdescription__subjectType(soap, tag, id, (fimsdescription__subjectType *const*)ptr, "fimsdescription:subjectType");
	case SOAP_TYPE_PointerTofimsdescription__entityType:
		return soap_out_PointerTofimsdescription__entityType(soap, tag, id, (fimsdescription__entityType *const*)ptr, "fimsdescription:entityType");
	case SOAP_TYPE_PointerTofimsdescription__titleType:
		return soap_out_PointerTofimsdescription__titleType(soap, tag, id, (fimsdescription__titleType *const*)ptr, "fimsdescription:titleType");
	case SOAP_TYPE_PointerTofimsdescription__textElementType:
		return soap_out_PointerTofimsdescription__textElementType(soap, tag, id, (fimsdescription__textElementType *const*)ptr, "fimsdescription:textElementType");
	case SOAP_TYPE_PointerToxsd__time:
		return soap_out_PointerToxsd__time(soap, tag, id, (std::wstring *const*)ptr, "xsd:time");
	case SOAP_TYPE_PointerTofimstime__Timecode:
		return soap_out_PointerTofimstime__Timecode(soap, tag, id, (std::wstring *const*)ptr, "fimstime:Timecode");
	case SOAP_TYPE_PointerTofimstime__EditUnitNumberType:
		return soap_out_PointerTofimstime__EditUnitNumberType(soap, tag, id, (fimstime__EditUnitNumberType *const*)ptr, "fimstime:EditUnitNumberType");
	case SOAP_TYPE_PointerToxsd__duration:
		return soap_out_PointerToxsd__duration(soap, tag, id, (LONG64 *const*)ptr, "xsd:duration");
	case SOAP_TYPE_PointerTofimstime__TimecodeDuration:
		return soap_out_PointerTofimstime__TimecodeDuration(soap, tag, id, (std::wstring *const*)ptr, "fimstime:TimecodeDuration");
	case SOAP_TYPE_PointerTofims__SystemPerformanceEventType:
		return soap_out_PointerTofims__SystemPerformanceEventType(soap, tag, id, (fims__SystemPerformanceEventType *const*)ptr, "fims:SystemPerformanceEventType");
	case SOAP_TYPE_PointerTofims__SystemExceptionEventType:
		return soap_out_PointerTofims__SystemExceptionEventType(soap, tag, id, (fims__SystemExceptionEventType *const*)ptr, "fims:SystemExceptionEventType");
	case SOAP_TYPE_PointerTofims__SystemEventType:
		return soap_out_PointerTofims__SystemEventType(soap, tag, id, (fims__SystemEventType *const*)ptr, "fims:SystemEventType");
	case SOAP_TYPE_PointerTofims__ContentCustomEventType:
		return soap_out_PointerTofims__ContentCustomEventType(soap, tag, id, (fims__ContentCustomEventType *const*)ptr, "fims:ContentCustomEventType");
	case SOAP_TYPE_PointerTofims__ContentStatusEventType:
		return soap_out_PointerTofims__ContentStatusEventType(soap, tag, id, (fims__ContentStatusEventType *const*)ptr, "fims:ContentStatusEventType");
	case SOAP_TYPE_PointerTofims__ContentEventType:
		return soap_out_PointerTofims__ContentEventType(soap, tag, id, (fims__ContentEventType *const*)ptr, "fims:ContentEventType");
	case SOAP_TYPE_PointerTofims__EventEnvelopeType:
		return soap_out_PointerTofims__EventEnvelopeType(soap, tag, id, (fims__EventEnvelopeType *const*)ptr, "fims:EventEnvelopeType");
	case SOAP_TYPE_PointerTofims__EventPayloadType:
		return soap_out_PointerTofims__EventPayloadType(soap, tag, id, (fims__EventPayloadType *const*)ptr, "fims:EventPayloadType");
	case SOAP_TYPE_PointerTofims__EventClassificationType:
		return soap_out_PointerTofims__EventClassificationType(soap, tag, id, (enum fims__EventClassificationType *const*)ptr, "fims:EventClassificationType");
	case SOAP_TYPE_PointerTofims__EventSubType:
		return soap_out_PointerTofims__EventSubType(soap, tag, id, (enum fims__EventSubType *const*)ptr, "fims:EventSubType");
	case SOAP_TYPE_PointerTofims__EventType:
		return soap_out_PointerTofims__EventType(soap, tag, id, (enum fims__EventType *const*)ptr, "fims:EventType");
	case SOAP_TYPE_PointerTofims__CustomEventTemplateType:
		return soap_out_PointerTofims__CustomEventTemplateType(soap, tag, id, (fims__CustomEventTemplateType *const*)ptr, "fims:CustomEventTemplateType");
	case SOAP_TYPE_PointerTofims__QueryExpressionsType:
		return soap_out_PointerTofims__QueryExpressionsType(soap, tag, id, (fims__QueryExpressionsType *const*)ptr, "fims:QueryExpressionsType");
	case SOAP_TYPE_PointerTofims__ResourceIDType:
		return soap_out_PointerTofims__ResourceIDType(soap, tag, id, (std::wstring *const*)ptr, "fims:ResourceIDType");
	case SOAP_TYPE_PointerTofims__QueryGroupsType:
		return soap_out_PointerTofims__QueryGroupsType(soap, tag, id, (fims__QueryGroupsType *const*)ptr, "fims:QueryGroupsType");
	case SOAP_TYPE_PointerTofims__QueryParametersType:
		return soap_out_PointerTofims__QueryParametersType(soap, tag, id, (fims__QueryParametersType *const*)ptr, "fims:QueryParametersType");
	case SOAP_TYPE_PointerTofims__CustomQueryGroupOperatorType:
		return soap_out_PointerTofims__CustomQueryGroupOperatorType(soap, tag, id, (fims__CustomQueryGroupOperatorType *const*)ptr, "fims:CustomQueryGroupOperatorType");
	case SOAP_TYPE_PointerTobool:
		return soap_out_PointerTobool(soap, tag, id, (bool *const*)ptr, "xsd:boolean");
	case SOAP_TYPE_PointerTofims__CustomQueryParameterOperatorType:
		return soap_out_PointerTofims__CustomQueryParameterOperatorType(soap, tag, id, (fims__CustomQueryParameterOperatorType *const*)ptr, "fims:CustomQueryParameterOperatorType");
	case SOAP_TYPE_PointerTofims__QueryExpressionType:
		return soap_out_PointerTofims__QueryExpressionType(soap, tag, id, (fims__QueryExpressionType *const*)ptr, "fims:QueryExpressionType");
	case SOAP_TYPE_PointerTofims__QueryGroupType:
		return soap_out_PointerTofims__QueryGroupType(soap, tag, id, (fims__QueryGroupType *const*)ptr, "fims:QueryGroupType");
	case SOAP_TYPE_PointerTofims__QueryParameterType:
		return soap_out_PointerTofims__QueryParameterType(soap, tag, id, (fims__QueryParameterType *const*)ptr, "fims:QueryParameterType");
	case SOAP_TYPE_PointerTofims__SuperLockTokenType:
		return soap_out_PointerTofims__SuperLockTokenType(soap, tag, id, (fims__SuperLockTokenType *const*)ptr, "fims:SuperLockTokenType");
	case SOAP_TYPE_PointerTofims__LockTokenType:
		return soap_out_PointerTofims__LockTokenType(soap, tag, id, (fims__LockTokenType *const*)ptr, "fims:LockTokenType");
	case SOAP_TYPE_PointerTofims__CredentialType:
		return soap_out_PointerTofims__CredentialType(soap, tag, id, (fims__CredentialType *const*)ptr, "fims:CredentialType");
	case SOAP_TYPE_PointerTofims__BMEssenceLocatorStatusType:
		return soap_out_PointerTofims__BMEssenceLocatorStatusType(soap, tag, id, (fims__BMEssenceLocatorStatusType *const*)ptr, "fims:BMEssenceLocatorStatusType");
	case SOAP_TYPE_PointerTofims__BMContentStatusType:
		return soap_out_PointerTofims__BMContentStatusType(soap, tag, id, (fims__BMContentStatusType *const*)ptr, "fims:BMContentStatusType");
	case SOAP_TYPE_PointerTofims__BMCustomStatusExtensionType:
		return soap_out_PointerTofims__BMCustomStatusExtensionType(soap, tag, id, (fims__BMCustomStatusExtensionType *const*)ptr, "fims:BMCustomStatusExtensionType");
	case SOAP_TYPE_PointerTofims__CustomValueType:
		return soap_out_PointerTofims__CustomValueType(soap, tag, id, (fims__CustomValueType *const*)ptr, "fims:CustomValueType");
	case SOAP_TYPE_PointerTofims__ResourceReferenceType:
		return soap_out_PointerTofims__ResourceReferenceType(soap, tag, id, (fims__ResourceReferenceType *const*)ptr, "fims:ResourceReferenceType");
	case SOAP_TYPE_PointerTofims__DescriptionType:
		return soap_out_PointerTofims__DescriptionType(soap, tag, id, (fims__DescriptionType *const*)ptr, "fims:DescriptionType");
	case SOAP_TYPE_PointerTofims__BMEssenceLocatorType:
		return soap_out_PointerTofims__BMEssenceLocatorType(soap, tag, id, (fims__BMEssenceLocatorType *const*)ptr, "fims:BMEssenceLocatorType");
	case SOAP_TYPE_PointerTofims__BMContentFormatType:
		return soap_out_PointerTofims__BMContentFormatType(soap, tag, id, (fims__BMContentFormatType *const*)ptr, "fims:BMContentFormatType");
	case SOAP_TYPE_PointerTofims__BMContentType:
		return soap_out_PointerTofims__BMContentType(soap, tag, id, (fims__BMContentType *const*)ptr, "fims:BMContentType");
	case SOAP_TYPE_PointerTofims__DataFormatType:
		return soap_out_PointerTofims__DataFormatType(soap, tag, id, (fims__DataFormatType *const*)ptr, "fims:DataFormatType");
	case SOAP_TYPE_PointerTofims__ProfileType:
		return soap_out_PointerTofims__ProfileType(soap, tag, id, (fims__ProfileType *const*)ptr, "fims:ProfileType");
	case SOAP_TYPE_PointerTofims__ResourceType:
		return soap_out_PointerTofims__ResourceType(soap, tag, id, (fims__ResourceType *const*)ptr, "fims:ResourceType");
	case SOAP_TYPE_PointerTofims__InnerFaultType:
		return soap_out_PointerTofims__InnerFaultType(soap, tag, id, (fims__InnerFaultType *const*)ptr, "fims:InnerFaultType");
	case SOAP_TYPE_PointerTotime:
		return soap_out_PointerTotime(soap, tag, id, (time_t *const*)ptr, "xsd:dateTime");
	case SOAP_TYPE_PointerTofims__ServiceType:
		return soap_out_PointerTofims__ServiceType(soap, tag, id, (fims__ServiceType *const*)ptr, "fims:ServiceType");
	case SOAP_TYPE_PointerToxsd__nonNegativeInteger:
		return soap_out_PointerToxsd__nonNegativeInteger(soap, tag, id, (std::wstring *const*)ptr, "xsd:nonNegativeInteger");
	case SOAP_TYPE_PointerTofims__JobsType:
		return soap_out_PointerTofims__JobsType(soap, tag, id, (fims__JobsType *const*)ptr, "fims:JobsType");
	case SOAP_TYPE_PointerTofims__QueueType:
		return soap_out_PointerTofims__QueueType(soap, tag, id, (fims__QueueType *const*)ptr, "fims:QueueType");
	case SOAP_TYPE_PointerTofims__JobType:
		return soap_out_PointerTofims__JobType(soap, tag, id, (fims__JobType *const*)ptr, "fims:JobType");
	case SOAP_TYPE_PointerTofims__PriorityType:
		return soap_out_PointerTofims__PriorityType(soap, tag, id, (enum fims__PriorityType *const*)ptr, "fims:PriorityType");
	case SOAP_TYPE_PointerTofims__HashFunctionType:
		return soap_out_PointerTofims__HashFunctionType(soap, tag, id, (fims__HashFunctionType *const*)ptr, "fims:HashFunctionType");
	case SOAP_TYPE_PointerTofims__ContainerFormatType:
		return soap_out_PointerTofims__ContainerFormatType(soap, tag, id, (fims__ContainerFormatType *const*)ptr, "fims:ContainerFormatType");
	case SOAP_TYPE_PointerTofims__AudioFormatType:
		return soap_out_PointerTofims__AudioFormatType(soap, tag, id, (fims__AudioFormatType *const*)ptr, "fims:AudioFormatType");
	case SOAP_TYPE_PointerTofims__VideoFormatType:
		return soap_out_PointerTofims__VideoFormatType(soap, tag, id, (fims__VideoFormatType *const*)ptr, "fims:VideoFormatType");
	case SOAP_TYPE_PointerToxsd__language:
		return soap_out_PointerToxsd__language(soap, tag, id, (std::wstring *const*)ptr, "xsd:language");
	case SOAP_TYPE_PointerTofims__UID:
		return soap_out_PointerTofims__UID(soap, tag, id, (std::wstring *const*)ptr, "fims:UID");
	case SOAP_TYPE_PointerToxsd__integer:
		return soap_out_PointerToxsd__integer(soap, tag, id, (std::wstring *const*)ptr, "xsd:integer");
	case SOAP_TYPE_PointerTofims__ExtensionAttributes:
		return soap_out_PointerTofims__ExtensionAttributes(soap, tag, id, (fims__ExtensionAttributes *const*)ptr, "fims:ExtensionAttributes");
	case SOAP_TYPE_PointerTofims__ExtensionGroup:
		return soap_out_PointerTofims__ExtensionGroup(soap, tag, id, (fims__ExtensionGroup *const*)ptr, "fims:ExtensionGroup");
	case SOAP_TYPE_PointerToxsd__anyURI:
		return soap_out_PointerToxsd__anyURI(soap, tag, id, (std::wstring *const*)ptr, "xsd:anyURI");
	case SOAP_TYPE_PointerTofims__RevisionIDType:
		return soap_out_PointerTofims__RevisionIDType(soap, tag, id, (std::wstring *const*)ptr, "fims:RevisionIDType");
	case SOAP_TYPE_PointerToedlprovider__MapItemType:
		return soap_out_PointerToedlprovider__MapItemType(soap, tag, id, (edlprovider__MapItemType *const*)ptr, "edlprovider:MapItemType");
	case SOAP_TYPE_PointerTo_edlprovider__Map:
		return soap_out_PointerTo_edlprovider__Map(soap, tag, id, (_edlprovider__Map *const*)ptr, "edlprovider:Map");
	case SOAP_TYPE_PointerToxsd__base64Binary:
		return soap_out_PointerToxsd__base64Binary(soap, tag, id, (xsd__base64Binary *const*)ptr, "xsd:base64Binary");
	case SOAP_TYPE_PointerTostd__wstring:
		return soap_out_PointerTostd__wstring(soap, tag, id, (std::wstring *const*)ptr, "xsd:string");
	case SOAP_TYPE_PointerToedlprovider__ArrayOfClips:
		return soap_out_PointerToedlprovider__ArrayOfClips(soap, tag, id, (edlprovider__ArrayOfClips *const*)ptr, "edlprovider:ArrayOfClips");
	case SOAP_TYPE_PointerTofims__BMObjectType:
		return soap_out_PointerTofims__BMObjectType(soap, tag, id, (fims__BMObjectType *const*)ptr, "fims:BMObjectType");
	case SOAP_TYPE_PointerTofimstime__TimeType:
		return soap_out_PointerTofimstime__TimeType(soap, tag, id, (fimstime__TimeType *const*)ptr, "fimstime:TimeType");
	case SOAP_TYPE_PointerToedlprovider__ClipType:
		return soap_out_PointerToedlprovider__ClipType(soap, tag, id, (edlprovider__ClipType *const*)ptr, "edlprovider:ClipType");
	case SOAP_TYPE_PointerTounsignedByte:
		return soap_out_PointerTounsignedByte(soap, tag, id, (unsigned char *const*)ptr, "xsd:unsignedByte");
	case SOAP_TYPE__QName:
		return soap_out_string(soap, tag, id, (char*const*)(void*)&ptr, "xsd:QName");
	case SOAP_TYPE_string:
		return soap_out_string(soap, tag, id, (char*const*)(void*)&ptr, "xsd:string");
	}
	return SOAP_OK;
}

#ifdef __cplusplus
}
#endif

#ifndef WITH_NOIDREF

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_markelement(struct soap *soap, const void *ptr, int type)
{
	(void)soap; (void)ptr; (void)type; /* appease -Wall -Werror */
	switch (type)
	{
	case SOAP_TYPE__fims__ContainerFormatType_containerFormat:
		((_fims__ContainerFormatType_containerFormat *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__fims__AudioFormatType_trackConfiguration:
		((_fims__AudioFormatType_trackConfiguration *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__fims__BMEssenceLocatorType_containerMimeType:
		((_fims__BMEssenceLocatorType_containerMimeType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__fims__BMContentFormatType_mimeType:
		((_fims__BMContentFormatType_mimeType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__fims__ServiceType_serviceDescription:
		((_fims__ServiceType_serviceDescription *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__fimsdescription__addressType_country:
		((_fimsdescription__addressType_country *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__fimsdescription__organisationDetailsType_organisationDepartment:
		((_fimsdescription__organisationDetailsType_organisationDepartment *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__fimsdescription__entityType_role:
		((_fimsdescription__entityType_role *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__fimsdescription__dateType_alternative:
		((_fimsdescription__dateType_alternative *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__fimsdescription__dateType_issued:
		((_fimsdescription__dateType_issued *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__fimsdescription__dateType_modified:
		((_fimsdescription__dateType_modified *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__fimsdescription__dateType_created:
		((_fimsdescription__dateType_created *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__fimsdescription__coverageType_spatial_coordinates:
		((_fimsdescription__coverageType_spatial_coordinates *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__fimsdescription__coverageType_spatial_locationName:
		((_fimsdescription__coverageType_spatial_locationName *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__fimsdescription__coverageType_spatial:
		((_fimsdescription__coverageType_spatial *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__fimsdescription__coverageType_temporal:
		((_fimsdescription__coverageType_temporal *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__fimsdescription__typeType_targetAudience:
		((_fimsdescription__typeType_targetAudience *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__fimsdescription__typeType_objectType:
		((_fimsdescription__typeType_objectType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__fimsdescription__typeType_genre:
		((_fimsdescription__typeType_genre *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_fims__ResourceIDType:
		soap_serialize_fims__ResourceIDType(soap, (const std::wstring *)ptr);
		break;
	case SOAP_TYPE_fimstime__TimecodeDuration:
		soap_serialize_fimstime__TimecodeDuration(soap, (const std::wstring *)ptr);
		break;
	case SOAP_TYPE_fimstime__Timecode:
		soap_serialize_fimstime__Timecode(soap, (const std::wstring *)ptr);
		break;
	case SOAP_TYPE_fims__RevisionIDType:
		soap_serialize_fims__RevisionIDType(soap, (const std::wstring *)ptr);
		break;
	case SOAP_TYPE_fims__UID:
		soap_serialize_fims__UID(soap, (const std::wstring *)ptr);
		break;
	case SOAP_TYPE_fimsdescription__partType:
		((fimsdescription__partType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_fimsdescription__relationType:
		((fimsdescription__relationType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_fimsdescription__languageType:
		((fimsdescription__languageType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_fimsdescription__addressType:
		((fimsdescription__addressType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_fimsdescription__detailsType:
		((fimsdescription__detailsType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_fimsdescription__organisationDetailsType:
		((fimsdescription__organisationDetailsType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_fimsdescription__contactDetailsType:
		((fimsdescription__contactDetailsType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_fimsdescription__entityType:
		((fimsdescription__entityType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_fimsdescription__dateType:
		((fimsdescription__dateType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_fimsdescription__textElementType:
		((fimsdescription__textElementType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_fimsdescription__rightsType:
		((fimsdescription__rightsType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_fimsdescription__coverageType:
		((fimsdescription__coverageType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_fimsdescription__descriptionType:
		((fimsdescription__descriptionType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_fimsdescription__typeType:
		((fimsdescription__typeType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_fimsdescription__subjectType:
		((fimsdescription__subjectType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_fimsdescription__identifierType:
		((fimsdescription__identifierType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_fimsdescription__titleType:
		((fimsdescription__titleType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_fimsdescription__bmContentDescriptionType:
		((fimsdescription__bmContentDescriptionType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_fimstime__EditUnitNumberType:
		((fimstime__EditUnitNumberType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_fimstime__TimeType:
		((fimstime__TimeType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_fimstime__DurationType:
		((fimstime__DurationType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__fims__formatCollection:
		((_fims__formatCollection *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_fims__SystemPerformanceEventsType:
		((fims__SystemPerformanceEventsType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_fims__SystemPerformanceEventType:
		((fims__SystemPerformanceEventType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_fims__SystemExceptionEventsType:
		((fims__SystemExceptionEventsType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_fims__SystemExceptionEventType:
		((fims__SystemExceptionEventType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_fims__SystemEventsType:
		((fims__SystemEventsType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_fims__SystemEventType:
		((fims__SystemEventType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_fims__ContentCustomEventsType:
		((fims__ContentCustomEventsType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_fims__ContentCustomEventType:
		((fims__ContentCustomEventType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_fims__ContentStatusEventsType:
		((fims__ContentStatusEventsType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_fims__ContentStatusEventType:
		((fims__ContentStatusEventType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_fims__ContentEventsType:
		((fims__ContentEventsType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_fims__ContentEventType:
		((fims__ContentEventType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_fims__EventPayloadsType:
		((fims__EventPayloadsType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_fims__EventPayloadType:
		((fims__EventPayloadType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_fims__EventEnvelopesType:
		((fims__EventEnvelopesType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_fims__EventEnvelopeType:
		((fims__EventEnvelopeType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_fims__CustomEventTemplatesType:
		((fims__CustomEventTemplatesType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_fims__CustomEventTemplateType:
		((fims__CustomEventTemplateType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_fims__QueryGroupsType:
		((fims__QueryGroupsType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_fims__QueryGroupType:
		((fims__QueryGroupType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_fims__CustomQueryGroupOperatorsType:
		((fims__CustomQueryGroupOperatorsType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_fims__CustomQueryGroupOperatorType:
		((fims__CustomQueryGroupOperatorType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_fims__QueryParametersType:
		((fims__QueryParametersType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_fims__QueryParameterType:
		((fims__QueryParameterType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_fims__CustomQueryParameterOperatorsType:
		((fims__CustomQueryParameterOperatorsType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_fims__CustomQueryParameterOperatorType:
		((fims__CustomQueryParameterOperatorType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_fims__QueryExpressionsType:
		((fims__QueryExpressionsType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_fims__QueryExpressionType:
		((fims__QueryExpressionType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_fims__SuperLockTokensType:
		((fims__SuperLockTokensType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_fims__SuperLockTokenType:
		((fims__SuperLockTokenType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_fims__LockTokensType:
		((fims__LockTokensType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_fims__LockTokenType:
		((fims__LockTokenType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_fims__CredentialsType:
		((fims__CredentialsType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_fims__CredentialType:
		((fims__CredentialType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_fims__BMEssenceLocatorStatusesType:
		((fims__BMEssenceLocatorStatusesType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_fims__BMEssenceLocatorStatusType:
		((fims__BMEssenceLocatorStatusType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_fims__BMContentStatusesType:
		((fims__BMContentStatusesType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_fims__BMContentStatusType:
		((fims__BMContentStatusType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_fims__BMCustomStatusExtensionsType:
		((fims__BMCustomStatusExtensionsType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_fims__BMCustomStatusExtensionType:
		((fims__BMCustomStatusExtensionType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_fims__CustomValuesType:
		((fims__CustomValuesType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_fims__CustomValueType:
		((fims__CustomValueType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_fims__ResourceReferencesType:
		((fims__ResourceReferencesType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_fims__DescriptionsType:
		((fims__DescriptionsType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_fims__BMEssenceLocatorsType:
		((fims__BMEssenceLocatorsType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_fims__BMContentFormatsType:
		((fims__BMContentFormatsType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_fims__BMContentsType:
		((fims__BMContentsType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_fims__BMObjectsType:
		((fims__BMObjectsType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_fims__DataFormatsType:
		((fims__DataFormatsType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_fims__ContainerFormatsType:
		((fims__ContainerFormatsType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_fims__AudioFormatsType:
		((fims__AudioFormatsType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_fims__VideoFormatsType:
		((fims__VideoFormatsType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_fims__JobsType:
		((fims__JobsType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_fims__QueuesType:
		((fims__QueuesType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_fims__ServicesType:
		((fims__ServicesType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_fims__ProfilesType:
		((fims__ProfilesType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_fims__ResourcesType:
		((fims__ResourcesType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_fims__InnerFaultType:
		((fims__InnerFaultType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_fims__FaultType:
		((fims__FaultType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_fims__ListFilterType:
		((fims__ListFilterType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_fims__QueryServiceDescriptionResponseType:
		((fims__QueryServiceDescriptionResponseType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_fims__QueryServiceDescriptionRequestType:
		((fims__QueryServiceDescriptionRequestType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_fims__QueryJobResponseType:
		((fims__QueryJobResponseType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_fims__QueryJobRequestByFilterType:
		((fims__QueryJobRequestByFilterType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_fims__QueryJobRequestByIDType:
		((fims__QueryJobRequestByIDType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_fims__QueryJobRequestType:
		((fims__QueryJobRequestType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_fims__ManageQueueResponseType:
		((fims__ManageQueueResponseType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_fims__ManageQueueRequestType:
		((fims__ManageQueueRequestType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_fims__ManageJobResponseType:
		((fims__ManageJobResponseType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_fims__ManageJobRequestType:
		((fims__ManageJobRequestType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_fims__StartJobByLatestType:
		((fims__StartJobByLatestType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_fims__StartJobByTimeType:
		((fims__StartJobByTimeType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_fims__StartJobByNoWaitType:
		((fims__StartJobByNoWaitType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_fims__StartJobType:
		((fims__StartJobType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_fims__StopProcessByOpenEndType:
		((fims__StopProcessByOpenEndType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_fims__StopProcessByServiceDefinedTimeType:
		((fims__StopProcessByServiceDefinedTimeType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_fims__StopProcessByTimeMarkType:
		((fims__StopProcessByTimeMarkType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_fims__StopProcessByDurationType:
		((fims__StopProcessByDurationType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_fims__StopProcessByTimeType:
		((fims__StopProcessByTimeType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_fims__StopProcessType:
		((fims__StopProcessType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_fims__StartProcessByServiceDefinedTimeType:
		((fims__StartProcessByServiceDefinedTimeType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_fims__StartProcessByTimeMarkType:
		((fims__StartProcessByTimeMarkType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_fims__StartProcessByTimeType:
		((fims__StartProcessByTimeType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_fims__StartProcessByNoWaitType:
		((fims__StartProcessByNoWaitType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_fims__StartProcessType:
		((fims__StartProcessType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_fims__HashFunctionType:
		((fims__HashFunctionType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_fims__StorageType:
		((fims__StorageType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_fims__ProcessedInfoByFramesType:
		((fims__ProcessedInfoByFramesType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_fims__ProcessedInfoByBytesType:
		((fims__ProcessedInfoByBytesType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_fims__ProcessedInfoType:
		((fims__ProcessedInfoType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_fims__HashType:
		((fims__HashType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_fims__RationalType:
		((fims__RationalType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_fims__LengthType:
		((fims__LengthType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_fims__TechnicalAttributeType:
		((fims__TechnicalAttributeType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_fims__TransformAtomType:
		((fims__TransformAtomType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_fims__TransferAtomType:
		((fims__TransferAtomType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_fims__EssencePlaceholderLocatorType:
		((fims__EssencePlaceholderLocatorType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_fims__FolderLocatorType:
		((fims__FolderLocatorType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_fims__ListFileLocatorType:
		((fims__ListFileLocatorType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_fims__SimpleFileLocatorType:
		((fims__SimpleFileLocatorType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_fims__BMEssenceLocatorType:
		((fims__BMEssenceLocatorType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_fims__BMContentFormatType:
		((fims__BMContentFormatType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_fims__DescriptionType:
		((fims__DescriptionType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_fims__BMContentType:
		((fims__BMContentType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_fims__BMObjectType:
		((fims__BMObjectType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_fims__CodecType:
		((fims__CodecType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_fims__BMTrackType:
		((fims__BMTrackType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_fims__ContainerFormatType:
		((fims__ContainerFormatType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_fims__AncillaryDataFormatType:
		((fims__AncillaryDataFormatType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_fims__CaptioningFormatType:
		((fims__CaptioningFormatType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_fims__DataFormatType:
		((fims__DataFormatType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_fims__AudioFormatType:
		((fims__AudioFormatType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_fims__VideoFormatType:
		((fims__VideoFormatType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_fims__FormatType:
		((fims__FormatType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_fims__JobType:
		((fims__JobType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_fims__QueueType:
		((fims__QueueType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_fims__ProfileType:
		((fims__ProfileType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_fims__ServiceType:
		((fims__ServiceType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_fims__AsyncEndpointType:
		((fims__AsyncEndpointType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_fims__ExtensionBaseType:
		((fims__ExtensionBaseType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_fims__ResourceType:
		((fims__ResourceType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_fims__ResourceReferenceType:
		((fims__ResourceReferenceType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_fims__ExtensionAttributes:
		((fims__ExtensionAttributes *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_fims__ExtensionGroup:
		((fims__ExtensionGroup *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__edlprovider__Map:
		((_edlprovider__Map *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_edlprovider__EdlProviderFaultType:
		((edlprovider__EdlProviderFaultType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_edlprovider__InstalledEdlsResponseType:
		((edlprovider__InstalledEdlsResponseType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_edlprovider__EdlCreateResponseType:
		((edlprovider__EdlCreateResponseType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_edlprovider__EdlCreateRequestDoubleType:
		((edlprovider__EdlCreateRequestDoubleType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_edlprovider__EdlCreateRequestType:
		((edlprovider__EdlCreateRequestType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_edlprovider__EdlCreateRequestBaseType:
		((edlprovider__EdlCreateRequestBaseType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_edlprovider__MapItemType:
		((edlprovider__MapItemType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_edlprovider__ClipType:
		((edlprovider__ClipType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_edlprovider__ArrayOfClips:
		((edlprovider__ArrayOfClips *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_edlprovider__ArrayOfstring:
		((edlprovider__ArrayOfstring *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__xml__lang:
		soap_serialize__xml__lang(soap, (const std::wstring *)ptr);
		break;
	case SOAP_TYPE_xsd__time:
		soap_serialize_xsd__time(soap, (const std::wstring *)ptr);
		break;
	case SOAP_TYPE_xsd__positiveInteger:
		soap_serialize_xsd__positiveInteger(soap, (const std::wstring *)ptr);
		break;
	case SOAP_TYPE_xsd__nonNegativeInteger:
		soap_serialize_xsd__nonNegativeInteger(soap, (const std::wstring *)ptr);
		break;
	case SOAP_TYPE_xsd__language:
		soap_serialize_xsd__language(soap, (const std::wstring *)ptr);
		break;
	case SOAP_TYPE_xsd__integer:
		soap_serialize_xsd__integer(soap, (const std::wstring *)ptr);
		break;
	case SOAP_TYPE_xsd__gYear:
		soap_serialize_xsd__gYear(soap, (const std::wstring *)ptr);
		break;
	case SOAP_TYPE_xsd__decimal:
		soap_serialize_xsd__decimal(soap, (const std::wstring *)ptr);
		break;
	case SOAP_TYPE_xsd__date:
		soap_serialize_xsd__date(soap, (const std::wstring *)ptr);
		break;
	case SOAP_TYPE_xsd__anyURI:
		soap_serialize_xsd__anyURI(soap, (const std::wstring *)ptr);
		break;
	case SOAP_TYPE_xsd__NMTOKEN:
		soap_serialize_xsd__NMTOKEN(soap, (const std::wstring *)ptr);
		break;
	case SOAP_TYPE_std__wstring:
		soap_serialize_std__wstring(soap, (const std::wstring *)ptr);
		break;
	case SOAP_TYPE_xsd__hexBinary:
		((xsd__hexBinary *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_xsd__base64Binary:
		((xsd__base64Binary *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE___edlprovider__getEdlDouble:
		soap_serialize___edlprovider__getEdlDouble(soap, (const struct __edlprovider__getEdlDouble *)ptr);
		break;
	case SOAP_TYPE___edlprovider__getEdl:
		soap_serialize___edlprovider__getEdl(soap, (const struct __edlprovider__getEdl *)ptr);
		break;
	case SOAP_TYPE___edlprovider__getInstalledEdls:
		soap_serialize___edlprovider__getInstalledEdls(soap, (const struct __edlprovider__getInstalledEdls *)ptr);
		break;
	case SOAP_TYPE_PointerToedlprovider__EdlCreateRequestDoubleType:
		soap_serialize_PointerToedlprovider__EdlCreateRequestDoubleType(soap, (edlprovider__EdlCreateRequestDoubleType *const*)ptr);
		break;
	case SOAP_TYPE_PointerToedlprovider__EdlCreateRequestType:
		soap_serialize_PointerToedlprovider__EdlCreateRequestType(soap, (edlprovider__EdlCreateRequestType *const*)ptr);
		break;
	case SOAP_TYPE_PointerToedlprovider__EdlProviderFaultType:
		soap_serialize_PointerToedlprovider__EdlProviderFaultType(soap, (edlprovider__EdlProviderFaultType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_fims__ContainerFormatType_containerFormat:
		soap_serialize_PointerTo_fims__ContainerFormatType_containerFormat(soap, (_fims__ContainerFormatType_containerFormat *const*)ptr);
		break;
	case SOAP_TYPE_PointerTofims__AncillaryDataFormatType:
		soap_serialize_PointerTofims__AncillaryDataFormatType(soap, (fims__AncillaryDataFormatType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTofims__CaptioningFormatType:
		soap_serialize_PointerTofims__CaptioningFormatType(soap, (fims__CaptioningFormatType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTofims__AudioSampleType:
		soap_serialize_PointerTofims__AudioSampleType(soap, (enum fims__AudioSampleType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_fims__AudioFormatType_trackConfiguration:
		soap_serialize_PointerTo_fims__AudioFormatType_trackConfiguration(soap, (_fims__AudioFormatType_trackConfiguration *const*)ptr);
		break;
	case SOAP_TYPE_PointerToxsd__decimal:
		soap_serialize_PointerToxsd__decimal(soap, (std::wstring *const*)ptr);
		break;
	case SOAP_TYPE_PointerTofims__ScanningOrderType:
		soap_serialize_PointerTofims__ScanningOrderType(soap, (enum fims__ScanningOrderType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTofims__ScanningFormatType:
		soap_serialize_PointerTofims__ScanningFormatType(soap, (enum fims__ScanningFormatType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTofims__BitRateModeType:
		soap_serialize_PointerTofims__BitRateModeType(soap, (enum fims__BitRateModeType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTofims__BMTrackType:
		soap_serialize_PointerTofims__BMTrackType(soap, (fims__BMTrackType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTofims__CodecType:
		soap_serialize_PointerTofims__CodecType(soap, (fims__CodecType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTofims__LengthType:
		soap_serialize_PointerTofims__LengthType(soap, (fims__LengthType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTofims__ResourceReferencesType:
		soap_serialize_PointerTofims__ResourceReferencesType(soap, (fims__ResourceReferencesType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_fims__BMEssenceLocatorType_containerMimeType:
		soap_serialize_PointerTo_fims__BMEssenceLocatorType_containerMimeType(soap, (_fims__BMEssenceLocatorType_containerMimeType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTofims__StorageType:
		soap_serialize_PointerTofims__StorageType(soap, (fims__StorageType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_fims__BMContentFormatType_mimeType:
		soap_serialize_PointerTo_fims__BMContentFormatType_mimeType(soap, (_fims__BMContentFormatType_mimeType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTounsignedLONG64:
		soap_serialize_PointerTounsignedLONG64(soap, (ULONG64 *const*)ptr);
		break;
	case SOAP_TYPE_PointerTofims__HashType:
		soap_serialize_PointerTofims__HashType(soap, (fims__HashType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_fims__formatCollection:
		soap_serialize_PointerTo_fims__formatCollection(soap, (_fims__formatCollection *const*)ptr);
		break;
	case SOAP_TYPE_PointerTofims__BMEssenceLocatorsType:
		soap_serialize_PointerTofims__BMEssenceLocatorsType(soap, (fims__BMEssenceLocatorsType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTofimsdescription__bmContentDescriptionType:
		soap_serialize_PointerTofimsdescription__bmContentDescriptionType(soap, (fimsdescription__bmContentDescriptionType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTofims__DescriptionsType:
		soap_serialize_PointerTofims__DescriptionsType(soap, (fims__DescriptionsType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTofims__BMContentFormatsType:
		soap_serialize_PointerTofims__BMContentFormatsType(soap, (fims__BMContentFormatsType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTofims__BMContentsType:
		soap_serialize_PointerTofims__BMContentsType(soap, (fims__BMContentsType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTofims__TechnicalAttributeType:
		soap_serialize_PointerTofims__TechnicalAttributeType(soap, (fims__TechnicalAttributeType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTofims__ProcessedInfoType:
		soap_serialize_PointerTofims__ProcessedInfoType(soap, (fims__ProcessedInfoType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTofims__StartJobType:
		soap_serialize_PointerTofims__StartJobType(soap, (fims__StartJobType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTofims__BMObjectsType:
		soap_serialize_PointerTofims__BMObjectsType(soap, (fims__BMObjectsType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTofims__JobStatusType:
		soap_serialize_PointerTofims__JobStatusType(soap, (enum fims__JobStatusType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTofims__QueueStatusType:
		soap_serialize_PointerTofims__QueueStatusType(soap, (enum fims__QueueStatusType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_fims__ServiceType_serviceDescription:
		soap_serialize_PointerTo_fims__ServiceType_serviceDescription(soap, (_fims__ServiceType_serviceDescription *const*)ptr);
		break;
	case SOAP_TYPE_PointerToxsd__NMTOKEN:
		soap_serialize_PointerToxsd__NMTOKEN(soap, (std::wstring *const*)ptr);
		break;
	case SOAP_TYPE_PointerTofims__ListFilterType:
		soap_serialize_PointerTofims__ListFilterType(soap, (fims__ListFilterType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTofimstime__DurationType:
		soap_serialize_PointerTofimstime__DurationType(soap, (fimstime__DurationType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTofims__AsyncEndpointType:
		soap_serialize_PointerTofims__AsyncEndpointType(soap, (fims__AsyncEndpointType *const*)ptr);
		break;
	case SOAP_TYPE_PointerToedlprovider__EdlProviderErrorCodeType:
		soap_serialize_PointerToedlprovider__EdlProviderErrorCodeType(soap, (enum edlprovider__EdlProviderErrorCodeType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTofims__RationalType:
		soap_serialize_PointerTofims__RationalType(soap, (fims__RationalType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_fimsdescription__addressType_country:
		soap_serialize_PointerTo_fimsdescription__addressType_country(soap, (_fimsdescription__addressType_country *const*)ptr);
		break;
	case SOAP_TYPE_PointerTofimsdescription__addressType:
		soap_serialize_PointerTofimsdescription__addressType(soap, (fimsdescription__addressType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_fimsdescription__organisationDetailsType_organisationDepartment:
		soap_serialize_PointerTo_fimsdescription__organisationDetailsType_organisationDepartment(soap, (_fimsdescription__organisationDetailsType_organisationDepartment *const*)ptr);
		break;
	case SOAP_TYPE_PointerTofimsdescription__detailsType:
		soap_serialize_PointerTofimsdescription__detailsType(soap, (fimsdescription__detailsType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTofimsdescription__organisationDetailsType:
		soap_serialize_PointerTofimsdescription__organisationDetailsType(soap, (fimsdescription__organisationDetailsType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_fimsdescription__dateType_alternative:
		soap_serialize_PointerTo_fimsdescription__dateType_alternative(soap, (_fimsdescription__dateType_alternative *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_fimsdescription__dateType_issued:
		soap_serialize_PointerTo_fimsdescription__dateType_issued(soap, (_fimsdescription__dateType_issued *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_fimsdescription__dateType_modified:
		soap_serialize_PointerTo_fimsdescription__dateType_modified(soap, (_fimsdescription__dateType_modified *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_fimsdescription__dateType_created:
		soap_serialize_PointerTo_fimsdescription__dateType_created(soap, (_fimsdescription__dateType_created *const*)ptr);
		break;
	case SOAP_TYPE_PointerToxsd__date:
		soap_serialize_PointerToxsd__date(soap, (std::wstring *const*)ptr);
		break;
	case SOAP_TYPE_PointerToxsd__gYear:
		soap_serialize_PointerToxsd__gYear(soap, (std::wstring *const*)ptr);
		break;
	case SOAP_TYPE_PointerTofimsdescription__contactDetailsType:
		soap_serialize_PointerTofimsdescription__contactDetailsType(soap, (fimsdescription__contactDetailsType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_fimsdescription__coverageType_spatial:
		soap_serialize_PointerTo_fimsdescription__coverageType_spatial(soap, (_fimsdescription__coverageType_spatial *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_fimsdescription__coverageType_spatial_coordinates:
		soap_serialize_PointerTo_fimsdescription__coverageType_spatial_coordinates(soap, (_fimsdescription__coverageType_spatial_coordinates *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_fimsdescription__coverageType_temporal:
		soap_serialize_PointerTo_fimsdescription__coverageType_temporal(soap, (_fimsdescription__coverageType_temporal *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_xml__lang:
		soap_serialize_PointerTo_xml__lang(soap, (std::wstring *const*)ptr);
		break;
	case SOAP_TYPE_PointerTofimsdescription__partType:
		soap_serialize_PointerTofimsdescription__partType(soap, (fimsdescription__partType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTofimsdescription__rightsType:
		soap_serialize_PointerTofimsdescription__rightsType(soap, (fimsdescription__rightsType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTofimsdescription__coverageType:
		soap_serialize_PointerTofimsdescription__coverageType(soap, (fimsdescription__coverageType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTofimsdescription__relationType:
		soap_serialize_PointerTofimsdescription__relationType(soap, (fimsdescription__relationType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTofimsdescription__languageType:
		soap_serialize_PointerTofimsdescription__languageType(soap, (fimsdescription__languageType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTofimsdescription__identifierType:
		soap_serialize_PointerTofimsdescription__identifierType(soap, (fimsdescription__identifierType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTofimsdescription__typeType:
		soap_serialize_PointerTofimsdescription__typeType(soap, (fimsdescription__typeType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTofimsdescription__dateType:
		soap_serialize_PointerTofimsdescription__dateType(soap, (fimsdescription__dateType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTofimsdescription__descriptionType:
		soap_serialize_PointerTofimsdescription__descriptionType(soap, (fimsdescription__descriptionType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTofimsdescription__subjectType:
		soap_serialize_PointerTofimsdescription__subjectType(soap, (fimsdescription__subjectType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTofimsdescription__entityType:
		soap_serialize_PointerTofimsdescription__entityType(soap, (fimsdescription__entityType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTofimsdescription__titleType:
		soap_serialize_PointerTofimsdescription__titleType(soap, (fimsdescription__titleType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTofimsdescription__textElementType:
		soap_serialize_PointerTofimsdescription__textElementType(soap, (fimsdescription__textElementType *const*)ptr);
		break;
	case SOAP_TYPE_PointerToxsd__time:
		soap_serialize_PointerToxsd__time(soap, (std::wstring *const*)ptr);
		break;
	case SOAP_TYPE_PointerTofimstime__Timecode:
		soap_serialize_PointerTofimstime__Timecode(soap, (std::wstring *const*)ptr);
		break;
	case SOAP_TYPE_PointerTofimstime__EditUnitNumberType:
		soap_serialize_PointerTofimstime__EditUnitNumberType(soap, (fimstime__EditUnitNumberType *const*)ptr);
		break;
	case SOAP_TYPE_PointerToxsd__duration:
		soap_serialize_PointerToxsd__duration(soap, (LONG64 *const*)ptr);
		break;
	case SOAP_TYPE_PointerTofimstime__TimecodeDuration:
		soap_serialize_PointerTofimstime__TimecodeDuration(soap, (std::wstring *const*)ptr);
		break;
	case SOAP_TYPE_PointerTofims__SystemPerformanceEventType:
		soap_serialize_PointerTofims__SystemPerformanceEventType(soap, (fims__SystemPerformanceEventType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTofims__SystemExceptionEventType:
		soap_serialize_PointerTofims__SystemExceptionEventType(soap, (fims__SystemExceptionEventType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTofims__SystemEventType:
		soap_serialize_PointerTofims__SystemEventType(soap, (fims__SystemEventType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTofims__ContentCustomEventType:
		soap_serialize_PointerTofims__ContentCustomEventType(soap, (fims__ContentCustomEventType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTofims__ContentStatusEventType:
		soap_serialize_PointerTofims__ContentStatusEventType(soap, (fims__ContentStatusEventType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTofims__ContentEventType:
		soap_serialize_PointerTofims__ContentEventType(soap, (fims__ContentEventType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTofims__EventEnvelopeType:
		soap_serialize_PointerTofims__EventEnvelopeType(soap, (fims__EventEnvelopeType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTofims__EventPayloadType:
		soap_serialize_PointerTofims__EventPayloadType(soap, (fims__EventPayloadType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTofims__EventClassificationType:
		soap_serialize_PointerTofims__EventClassificationType(soap, (enum fims__EventClassificationType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTofims__EventSubType:
		soap_serialize_PointerTofims__EventSubType(soap, (enum fims__EventSubType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTofims__EventType:
		soap_serialize_PointerTofims__EventType(soap, (enum fims__EventType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTofims__CustomEventTemplateType:
		soap_serialize_PointerTofims__CustomEventTemplateType(soap, (fims__CustomEventTemplateType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTofims__QueryExpressionsType:
		soap_serialize_PointerTofims__QueryExpressionsType(soap, (fims__QueryExpressionsType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTofims__ResourceIDType:
		soap_serialize_PointerTofims__ResourceIDType(soap, (std::wstring *const*)ptr);
		break;
	case SOAP_TYPE_PointerTofims__QueryGroupsType:
		soap_serialize_PointerTofims__QueryGroupsType(soap, (fims__QueryGroupsType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTofims__QueryParametersType:
		soap_serialize_PointerTofims__QueryParametersType(soap, (fims__QueryParametersType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTofims__CustomQueryGroupOperatorType:
		soap_serialize_PointerTofims__CustomQueryGroupOperatorType(soap, (fims__CustomQueryGroupOperatorType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTobool:
		soap_serialize_PointerTobool(soap, (bool *const*)ptr);
		break;
	case SOAP_TYPE_PointerTofims__CustomQueryParameterOperatorType:
		soap_serialize_PointerTofims__CustomQueryParameterOperatorType(soap, (fims__CustomQueryParameterOperatorType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTofims__QueryExpressionType:
		soap_serialize_PointerTofims__QueryExpressionType(soap, (fims__QueryExpressionType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTofims__QueryGroupType:
		soap_serialize_PointerTofims__QueryGroupType(soap, (fims__QueryGroupType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTofims__QueryParameterType:
		soap_serialize_PointerTofims__QueryParameterType(soap, (fims__QueryParameterType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTofims__SuperLockTokenType:
		soap_serialize_PointerTofims__SuperLockTokenType(soap, (fims__SuperLockTokenType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTofims__LockTokenType:
		soap_serialize_PointerTofims__LockTokenType(soap, (fims__LockTokenType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTofims__CredentialType:
		soap_serialize_PointerTofims__CredentialType(soap, (fims__CredentialType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTofims__BMEssenceLocatorStatusType:
		soap_serialize_PointerTofims__BMEssenceLocatorStatusType(soap, (fims__BMEssenceLocatorStatusType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTofims__BMContentStatusType:
		soap_serialize_PointerTofims__BMContentStatusType(soap, (fims__BMContentStatusType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTofims__BMCustomStatusExtensionType:
		soap_serialize_PointerTofims__BMCustomStatusExtensionType(soap, (fims__BMCustomStatusExtensionType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTofims__CustomValueType:
		soap_serialize_PointerTofims__CustomValueType(soap, (fims__CustomValueType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTofims__ResourceReferenceType:
		soap_serialize_PointerTofims__ResourceReferenceType(soap, (fims__ResourceReferenceType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTofims__DescriptionType:
		soap_serialize_PointerTofims__DescriptionType(soap, (fims__DescriptionType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTofims__BMEssenceLocatorType:
		soap_serialize_PointerTofims__BMEssenceLocatorType(soap, (fims__BMEssenceLocatorType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTofims__BMContentFormatType:
		soap_serialize_PointerTofims__BMContentFormatType(soap, (fims__BMContentFormatType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTofims__BMContentType:
		soap_serialize_PointerTofims__BMContentType(soap, (fims__BMContentType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTofims__DataFormatType:
		soap_serialize_PointerTofims__DataFormatType(soap, (fims__DataFormatType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTofims__ProfileType:
		soap_serialize_PointerTofims__ProfileType(soap, (fims__ProfileType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTofims__ResourceType:
		soap_serialize_PointerTofims__ResourceType(soap, (fims__ResourceType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTofims__InnerFaultType:
		soap_serialize_PointerTofims__InnerFaultType(soap, (fims__InnerFaultType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTotime:
		soap_serialize_PointerTotime(soap, (time_t *const*)ptr);
		break;
	case SOAP_TYPE_PointerTofims__ServiceType:
		soap_serialize_PointerTofims__ServiceType(soap, (fims__ServiceType *const*)ptr);
		break;
	case SOAP_TYPE_PointerToxsd__nonNegativeInteger:
		soap_serialize_PointerToxsd__nonNegativeInteger(soap, (std::wstring *const*)ptr);
		break;
	case SOAP_TYPE_PointerTofims__JobsType:
		soap_serialize_PointerTofims__JobsType(soap, (fims__JobsType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTofims__QueueType:
		soap_serialize_PointerTofims__QueueType(soap, (fims__QueueType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTofims__JobType:
		soap_serialize_PointerTofims__JobType(soap, (fims__JobType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTofims__PriorityType:
		soap_serialize_PointerTofims__PriorityType(soap, (enum fims__PriorityType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTofims__HashFunctionType:
		soap_serialize_PointerTofims__HashFunctionType(soap, (fims__HashFunctionType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTofims__ContainerFormatType:
		soap_serialize_PointerTofims__ContainerFormatType(soap, (fims__ContainerFormatType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTofims__AudioFormatType:
		soap_serialize_PointerTofims__AudioFormatType(soap, (fims__AudioFormatType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTofims__VideoFormatType:
		soap_serialize_PointerTofims__VideoFormatType(soap, (fims__VideoFormatType *const*)ptr);
		break;
	case SOAP_TYPE_PointerToxsd__language:
		soap_serialize_PointerToxsd__language(soap, (std::wstring *const*)ptr);
		break;
	case SOAP_TYPE_PointerTofims__UID:
		soap_serialize_PointerTofims__UID(soap, (std::wstring *const*)ptr);
		break;
	case SOAP_TYPE_PointerToxsd__integer:
		soap_serialize_PointerToxsd__integer(soap, (std::wstring *const*)ptr);
		break;
	case SOAP_TYPE_PointerTofims__ExtensionAttributes:
		soap_serialize_PointerTofims__ExtensionAttributes(soap, (fims__ExtensionAttributes *const*)ptr);
		break;
	case SOAP_TYPE_PointerTofims__ExtensionGroup:
		soap_serialize_PointerTofims__ExtensionGroup(soap, (fims__ExtensionGroup *const*)ptr);
		break;
	case SOAP_TYPE_PointerToxsd__anyURI:
		soap_serialize_PointerToxsd__anyURI(soap, (std::wstring *const*)ptr);
		break;
	case SOAP_TYPE_PointerTofims__RevisionIDType:
		soap_serialize_PointerTofims__RevisionIDType(soap, (std::wstring *const*)ptr);
		break;
	case SOAP_TYPE_PointerToedlprovider__MapItemType:
		soap_serialize_PointerToedlprovider__MapItemType(soap, (edlprovider__MapItemType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_edlprovider__Map:
		soap_serialize_PointerTo_edlprovider__Map(soap, (_edlprovider__Map *const*)ptr);
		break;
	case SOAP_TYPE_PointerToxsd__base64Binary:
		soap_serialize_PointerToxsd__base64Binary(soap, (xsd__base64Binary *const*)ptr);
		break;
	case SOAP_TYPE_PointerTostd__wstring:
		soap_serialize_PointerTostd__wstring(soap, (std::wstring *const*)ptr);
		break;
	case SOAP_TYPE_PointerToedlprovider__ArrayOfClips:
		soap_serialize_PointerToedlprovider__ArrayOfClips(soap, (edlprovider__ArrayOfClips *const*)ptr);
		break;
	case SOAP_TYPE_PointerTofims__BMObjectType:
		soap_serialize_PointerTofims__BMObjectType(soap, (fims__BMObjectType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTofimstime__TimeType:
		soap_serialize_PointerTofimstime__TimeType(soap, (fimstime__TimeType *const*)ptr);
		break;
	case SOAP_TYPE_PointerToedlprovider__ClipType:
		soap_serialize_PointerToedlprovider__ClipType(soap, (edlprovider__ClipType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTounsignedByte:
		soap_serialize_PointerTounsignedByte(soap, (unsigned char *const*)ptr);
		break;
	case SOAP_TYPE__QName:
		soap_serialize_string(soap, (char*const*)(void*)&ptr);
		break;
	case SOAP_TYPE_string:
		soap_serialize_string(soap, (char*const*)(void*)&ptr);
		break;
	}
}

#ifdef __cplusplus
}
#endif
#endif

SOAP_FMAC3 void * SOAP_FMAC4 EDLProvider_instantiate(struct soap *soap, int t, const char *type, const char *arrayType, size_t *n)
{	(void)type;
	switch (t)
	{
	case SOAP_TYPE_xsd__base64Binary:
		return (void*)soap_instantiate_xsd__base64Binary(soap, -1, type, arrayType, n);
	case SOAP_TYPE_xsd__hexBinary:
		return (void*)soap_instantiate_xsd__hexBinary(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__wstring:
		return (void*)soap_instantiate_std__wstring(soap, -1, type, arrayType, n);
	case SOAP_TYPE_edlprovider__ArrayOfstring:
		return (void*)soap_instantiate_edlprovider__ArrayOfstring(soap, -1, type, arrayType, n);
	case SOAP_TYPE_edlprovider__ArrayOfClips:
		return (void*)soap_instantiate_edlprovider__ArrayOfClips(soap, -1, type, arrayType, n);
	case SOAP_TYPE_edlprovider__ClipType:
		return (void*)soap_instantiate_edlprovider__ClipType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_edlprovider__MapItemType:
		return (void*)soap_instantiate_edlprovider__MapItemType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_edlprovider__EdlCreateRequestBaseType:
		return (void*)soap_instantiate_edlprovider__EdlCreateRequestBaseType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_edlprovider__EdlCreateResponseType:
		return (void*)soap_instantiate_edlprovider__EdlCreateResponseType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_edlprovider__InstalledEdlsResponseType:
		return (void*)soap_instantiate_edlprovider__InstalledEdlsResponseType(soap, -1, type, arrayType, n);
	case SOAP_TYPE__edlprovider__Map:
		return (void*)soap_instantiate__edlprovider__Map(soap, -1, type, arrayType, n);
	case SOAP_TYPE_fims__ExtensionGroup:
		return (void*)soap_instantiate_fims__ExtensionGroup(soap, -1, type, arrayType, n);
	case SOAP_TYPE_fims__ExtensionAttributes:
		return (void*)soap_instantiate_fims__ExtensionAttributes(soap, -1, type, arrayType, n);
	case SOAP_TYPE_fims__ResourceReferenceType:
		return (void*)soap_instantiate_fims__ResourceReferenceType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_fims__ExtensionBaseType:
		return (void*)soap_instantiate_fims__ExtensionBaseType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_fims__AsyncEndpointType:
		return (void*)soap_instantiate_fims__AsyncEndpointType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_fims__AncillaryDataFormatType:
		return (void*)soap_instantiate_fims__AncillaryDataFormatType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_fims__BMTrackType:
		return (void*)soap_instantiate_fims__BMTrackType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_fims__CodecType:
		return (void*)soap_instantiate_fims__CodecType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_fims__TransferAtomType:
		return (void*)soap_instantiate_fims__TransferAtomType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_fims__TransformAtomType:
		return (void*)soap_instantiate_fims__TransformAtomType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_fims__HashType:
		return (void*)soap_instantiate_fims__HashType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_fims__ProcessedInfoType:
		return (void*)soap_instantiate_fims__ProcessedInfoType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_fims__StartProcessType:
		return (void*)soap_instantiate_fims__StartProcessType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_fims__StopProcessType:
		return (void*)soap_instantiate_fims__StopProcessType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_fims__StartJobType:
		return (void*)soap_instantiate_fims__StartJobType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_fims__ManageJobRequestType:
		return (void*)soap_instantiate_fims__ManageJobRequestType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_fims__ManageJobResponseType:
		return (void*)soap_instantiate_fims__ManageJobResponseType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_fims__ManageQueueRequestType:
		return (void*)soap_instantiate_fims__ManageQueueRequestType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_fims__ManageQueueResponseType:
		return (void*)soap_instantiate_fims__ManageQueueResponseType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_fims__QueryJobRequestType:
		return (void*)soap_instantiate_fims__QueryJobRequestType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_fims__QueryJobResponseType:
		return (void*)soap_instantiate_fims__QueryJobResponseType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_fims__QueryServiceDescriptionRequestType:
		return (void*)soap_instantiate_fims__QueryServiceDescriptionRequestType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_fims__QueryServiceDescriptionResponseType:
		return (void*)soap_instantiate_fims__QueryServiceDescriptionResponseType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_fims__ListFilterType:
		return (void*)soap_instantiate_fims__ListFilterType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_fims__FaultType:
		return (void*)soap_instantiate_fims__FaultType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_fims__InnerFaultType:
		return (void*)soap_instantiate_fims__InnerFaultType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_fims__ResourcesType:
		return (void*)soap_instantiate_fims__ResourcesType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_fims__ProfilesType:
		return (void*)soap_instantiate_fims__ProfilesType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_fims__ServicesType:
		return (void*)soap_instantiate_fims__ServicesType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_fims__QueuesType:
		return (void*)soap_instantiate_fims__QueuesType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_fims__JobsType:
		return (void*)soap_instantiate_fims__JobsType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_fims__VideoFormatsType:
		return (void*)soap_instantiate_fims__VideoFormatsType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_fims__AudioFormatsType:
		return (void*)soap_instantiate_fims__AudioFormatsType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_fims__ContainerFormatsType:
		return (void*)soap_instantiate_fims__ContainerFormatsType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_fims__DataFormatsType:
		return (void*)soap_instantiate_fims__DataFormatsType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_fims__BMObjectsType:
		return (void*)soap_instantiate_fims__BMObjectsType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_fims__BMContentsType:
		return (void*)soap_instantiate_fims__BMContentsType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_fims__BMContentFormatsType:
		return (void*)soap_instantiate_fims__BMContentFormatsType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_fims__BMEssenceLocatorsType:
		return (void*)soap_instantiate_fims__BMEssenceLocatorsType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_fims__DescriptionsType:
		return (void*)soap_instantiate_fims__DescriptionsType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_fims__ResourceReferencesType:
		return (void*)soap_instantiate_fims__ResourceReferencesType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_fims__CustomValueType:
		return (void*)soap_instantiate_fims__CustomValueType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_fims__CustomValuesType:
		return (void*)soap_instantiate_fims__CustomValuesType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_fims__BMCustomStatusExtensionsType:
		return (void*)soap_instantiate_fims__BMCustomStatusExtensionsType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_fims__BMContentStatusesType:
		return (void*)soap_instantiate_fims__BMContentStatusesType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_fims__BMEssenceLocatorStatusesType:
		return (void*)soap_instantiate_fims__BMEssenceLocatorStatusesType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_fims__CredentialType:
		return (void*)soap_instantiate_fims__CredentialType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_fims__CredentialsType:
		return (void*)soap_instantiate_fims__CredentialsType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_fims__LockTokensType:
		return (void*)soap_instantiate_fims__LockTokensType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_fims__SuperLockTokensType:
		return (void*)soap_instantiate_fims__SuperLockTokensType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_fims__QueryExpressionType:
		return (void*)soap_instantiate_fims__QueryExpressionType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_fims__QueryExpressionsType:
		return (void*)soap_instantiate_fims__QueryExpressionsType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_fims__CustomQueryParameterOperatorType:
		return (void*)soap_instantiate_fims__CustomQueryParameterOperatorType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_fims__CustomQueryParameterOperatorsType:
		return (void*)soap_instantiate_fims__CustomQueryParameterOperatorsType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_fims__QueryParameterType:
		return (void*)soap_instantiate_fims__QueryParameterType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_fims__QueryParametersType:
		return (void*)soap_instantiate_fims__QueryParametersType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_fims__CustomQueryGroupOperatorType:
		return (void*)soap_instantiate_fims__CustomQueryGroupOperatorType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_fims__CustomQueryGroupOperatorsType:
		return (void*)soap_instantiate_fims__CustomQueryGroupOperatorsType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_fims__QueryGroupType:
		return (void*)soap_instantiate_fims__QueryGroupType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_fims__QueryGroupsType:
		return (void*)soap_instantiate_fims__QueryGroupsType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_fims__CustomEventTemplateType:
		return (void*)soap_instantiate_fims__CustomEventTemplateType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_fims__CustomEventTemplatesType:
		return (void*)soap_instantiate_fims__CustomEventTemplatesType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_fims__EventEnvelopeType:
		return (void*)soap_instantiate_fims__EventEnvelopeType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_fims__EventEnvelopesType:
		return (void*)soap_instantiate_fims__EventEnvelopesType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_fims__EventPayloadType:
		return (void*)soap_instantiate_fims__EventPayloadType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_fims__EventPayloadsType:
		return (void*)soap_instantiate_fims__EventPayloadsType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_fims__ContentEventsType:
		return (void*)soap_instantiate_fims__ContentEventsType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_fims__ContentStatusEventsType:
		return (void*)soap_instantiate_fims__ContentStatusEventsType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_fims__ContentCustomEventsType:
		return (void*)soap_instantiate_fims__ContentCustomEventsType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_fims__SystemEventsType:
		return (void*)soap_instantiate_fims__SystemEventsType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_fims__SystemExceptionEventsType:
		return (void*)soap_instantiate_fims__SystemExceptionEventsType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_fims__SystemPerformanceEventsType:
		return (void*)soap_instantiate_fims__SystemPerformanceEventsType(soap, -1, type, arrayType, n);
	case SOAP_TYPE__fims__formatCollection:
		return (void*)soap_instantiate__fims__formatCollection(soap, -1, type, arrayType, n);
	case SOAP_TYPE_fimstime__DurationType:
		return (void*)soap_instantiate_fimstime__DurationType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_fimstime__TimeType:
		return (void*)soap_instantiate_fimstime__TimeType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_fimsdescription__bmContentDescriptionType:
		return (void*)soap_instantiate_fimsdescription__bmContentDescriptionType(soap, -1, type, arrayType, n);
	case SOAP_TYPE__fimsdescription__typeType_genre:
		return (void*)soap_instantiate__fimsdescription__typeType_genre(soap, -1, type, arrayType, n);
	case SOAP_TYPE__fimsdescription__typeType_objectType:
		return (void*)soap_instantiate__fimsdescription__typeType_objectType(soap, -1, type, arrayType, n);
	case SOAP_TYPE__fimsdescription__typeType_targetAudience:
		return (void*)soap_instantiate__fimsdescription__typeType_targetAudience(soap, -1, type, arrayType, n);
	case SOAP_TYPE_fimsdescription__typeType:
		return (void*)soap_instantiate_fimsdescription__typeType(soap, -1, type, arrayType, n);
	case SOAP_TYPE__fimsdescription__coverageType_temporal:
		return (void*)soap_instantiate__fimsdescription__coverageType_temporal(soap, -1, type, arrayType, n);
	case SOAP_TYPE__fimsdescription__coverageType_spatial_locationName:
		return (void*)soap_instantiate__fimsdescription__coverageType_spatial_locationName(soap, -1, type, arrayType, n);
	case SOAP_TYPE__fimsdescription__coverageType_spatial_coordinates:
		return (void*)soap_instantiate__fimsdescription__coverageType_spatial_coordinates(soap, -1, type, arrayType, n);
	case SOAP_TYPE__fimsdescription__coverageType_spatial:
		return (void*)soap_instantiate__fimsdescription__coverageType_spatial(soap, -1, type, arrayType, n);
	case SOAP_TYPE_fimsdescription__coverageType:
		return (void*)soap_instantiate_fimsdescription__coverageType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_fimsdescription__rightsType:
		return (void*)soap_instantiate_fimsdescription__rightsType(soap, -1, type, arrayType, n);
	case SOAP_TYPE__fimsdescription__dateType_created:
		return (void*)soap_instantiate__fimsdescription__dateType_created(soap, -1, type, arrayType, n);
	case SOAP_TYPE__fimsdescription__dateType_modified:
		return (void*)soap_instantiate__fimsdescription__dateType_modified(soap, -1, type, arrayType, n);
	case SOAP_TYPE__fimsdescription__dateType_issued:
		return (void*)soap_instantiate__fimsdescription__dateType_issued(soap, -1, type, arrayType, n);
	case SOAP_TYPE__fimsdescription__dateType_alternative:
		return (void*)soap_instantiate__fimsdescription__dateType_alternative(soap, -1, type, arrayType, n);
	case SOAP_TYPE_fimsdescription__dateType:
		return (void*)soap_instantiate_fimsdescription__dateType(soap, -1, type, arrayType, n);
	case SOAP_TYPE__fimsdescription__entityType_role:
		return (void*)soap_instantiate__fimsdescription__entityType_role(soap, -1, type, arrayType, n);
	case SOAP_TYPE_fimsdescription__entityType:
		return (void*)soap_instantiate_fimsdescription__entityType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_fimsdescription__contactDetailsType:
		return (void*)soap_instantiate_fimsdescription__contactDetailsType(soap, -1, type, arrayType, n);
	case SOAP_TYPE__fimsdescription__organisationDetailsType_organisationDepartment:
		return (void*)soap_instantiate__fimsdescription__organisationDetailsType_organisationDepartment(soap, -1, type, arrayType, n);
	case SOAP_TYPE_fimsdescription__organisationDetailsType:
		return (void*)soap_instantiate_fimsdescription__organisationDetailsType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_fimsdescription__detailsType:
		return (void*)soap_instantiate_fimsdescription__detailsType(soap, -1, type, arrayType, n);
	case SOAP_TYPE__fimsdescription__addressType_country:
		return (void*)soap_instantiate__fimsdescription__addressType_country(soap, -1, type, arrayType, n);
	case SOAP_TYPE_fimsdescription__addressType:
		return (void*)soap_instantiate_fimsdescription__addressType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_fimsdescription__languageType:
		return (void*)soap_instantiate_fimsdescription__languageType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_fimsdescription__relationType:
		return (void*)soap_instantiate_fimsdescription__relationType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_edlprovider__EdlCreateRequestType:
		return (void*)soap_instantiate_edlprovider__EdlCreateRequestType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_edlprovider__EdlCreateRequestDoubleType:
		return (void*)soap_instantiate_edlprovider__EdlCreateRequestDoubleType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_edlprovider__EdlProviderFaultType:
		return (void*)soap_instantiate_edlprovider__EdlProviderFaultType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_fims__ResourceType:
		return (void*)soap_instantiate_fims__ResourceType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_fims__CaptioningFormatType:
		return (void*)soap_instantiate_fims__CaptioningFormatType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_fims__TechnicalAttributeType:
		return (void*)soap_instantiate_fims__TechnicalAttributeType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_fims__LengthType:
		return (void*)soap_instantiate_fims__LengthType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_fims__RationalType:
		return (void*)soap_instantiate_fims__RationalType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_fims__ProcessedInfoByBytesType:
		return (void*)soap_instantiate_fims__ProcessedInfoByBytesType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_fims__ProcessedInfoByFramesType:
		return (void*)soap_instantiate_fims__ProcessedInfoByFramesType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_fims__StartProcessByNoWaitType:
		return (void*)soap_instantiate_fims__StartProcessByNoWaitType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_fims__StartProcessByTimeType:
		return (void*)soap_instantiate_fims__StartProcessByTimeType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_fims__StartProcessByTimeMarkType:
		return (void*)soap_instantiate_fims__StartProcessByTimeMarkType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_fims__StartProcessByServiceDefinedTimeType:
		return (void*)soap_instantiate_fims__StartProcessByServiceDefinedTimeType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_fims__StopProcessByTimeType:
		return (void*)soap_instantiate_fims__StopProcessByTimeType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_fims__StopProcessByDurationType:
		return (void*)soap_instantiate_fims__StopProcessByDurationType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_fims__StopProcessByTimeMarkType:
		return (void*)soap_instantiate_fims__StopProcessByTimeMarkType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_fims__StopProcessByServiceDefinedTimeType:
		return (void*)soap_instantiate_fims__StopProcessByServiceDefinedTimeType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_fims__StopProcessByOpenEndType:
		return (void*)soap_instantiate_fims__StopProcessByOpenEndType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_fims__StartJobByNoWaitType:
		return (void*)soap_instantiate_fims__StartJobByNoWaitType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_fims__StartJobByTimeType:
		return (void*)soap_instantiate_fims__StartJobByTimeType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_fims__StartJobByLatestType:
		return (void*)soap_instantiate_fims__StartJobByLatestType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_fims__QueryJobRequestByIDType:
		return (void*)soap_instantiate_fims__QueryJobRequestByIDType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_fims__QueryJobRequestByFilterType:
		return (void*)soap_instantiate_fims__QueryJobRequestByFilterType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_fims__ContentEventType:
		return (void*)soap_instantiate_fims__ContentEventType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_fims__SystemEventType:
		return (void*)soap_instantiate_fims__SystemEventType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_fimstime__EditUnitNumberType:
		return (void*)soap_instantiate_fimstime__EditUnitNumberType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_fimsdescription__identifierType:
		return (void*)soap_instantiate_fimsdescription__identifierType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_fimsdescription__textElementType:
		return (void*)soap_instantiate_fimsdescription__textElementType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_fimsdescription__partType:
		return (void*)soap_instantiate_fimsdescription__partType(soap, -1, type, arrayType, n);
	case SOAP_TYPE__fims__ServiceType_serviceDescription:
		return (void*)soap_instantiate__fims__ServiceType_serviceDescription(soap, -1, type, arrayType, n);
	case SOAP_TYPE_fims__ServiceType:
		return (void*)soap_instantiate_fims__ServiceType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_fims__ProfileType:
		return (void*)soap_instantiate_fims__ProfileType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_fims__QueueType:
		return (void*)soap_instantiate_fims__QueueType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_fims__JobType:
		return (void*)soap_instantiate_fims__JobType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_fims__FormatType:
		return (void*)soap_instantiate_fims__FormatType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_fims__BMObjectType:
		return (void*)soap_instantiate_fims__BMObjectType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_fims__BMContentType:
		return (void*)soap_instantiate_fims__BMContentType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_fims__DescriptionType:
		return (void*)soap_instantiate_fims__DescriptionType(soap, -1, type, arrayType, n);
	case SOAP_TYPE__fims__BMContentFormatType_mimeType:
		return (void*)soap_instantiate__fims__BMContentFormatType_mimeType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_fims__BMContentFormatType:
		return (void*)soap_instantiate_fims__BMContentFormatType(soap, -1, type, arrayType, n);
	case SOAP_TYPE__fims__BMEssenceLocatorType_containerMimeType:
		return (void*)soap_instantiate__fims__BMEssenceLocatorType_containerMimeType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_fims__BMEssenceLocatorType:
		return (void*)soap_instantiate_fims__BMEssenceLocatorType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_fims__StorageType:
		return (void*)soap_instantiate_fims__StorageType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_fims__HashFunctionType:
		return (void*)soap_instantiate_fims__HashFunctionType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_fims__BMCustomStatusExtensionType:
		return (void*)soap_instantiate_fims__BMCustomStatusExtensionType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_fims__BMContentStatusType:
		return (void*)soap_instantiate_fims__BMContentStatusType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_fims__BMEssenceLocatorStatusType:
		return (void*)soap_instantiate_fims__BMEssenceLocatorStatusType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_fims__LockTokenType:
		return (void*)soap_instantiate_fims__LockTokenType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_fims__SuperLockTokenType:
		return (void*)soap_instantiate_fims__SuperLockTokenType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_fims__ContentStatusEventType:
		return (void*)soap_instantiate_fims__ContentStatusEventType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_fims__ContentCustomEventType:
		return (void*)soap_instantiate_fims__ContentCustomEventType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_fims__SystemExceptionEventType:
		return (void*)soap_instantiate_fims__SystemExceptionEventType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_fims__SystemPerformanceEventType:
		return (void*)soap_instantiate_fims__SystemPerformanceEventType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_fimsdescription__titleType:
		return (void*)soap_instantiate_fimsdescription__titleType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_fimsdescription__subjectType:
		return (void*)soap_instantiate_fimsdescription__subjectType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_fimsdescription__descriptionType:
		return (void*)soap_instantiate_fimsdescription__descriptionType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_fims__VideoFormatType:
		return (void*)soap_instantiate_fims__VideoFormatType(soap, -1, type, arrayType, n);
	case SOAP_TYPE__fims__AudioFormatType_trackConfiguration:
		return (void*)soap_instantiate__fims__AudioFormatType_trackConfiguration(soap, -1, type, arrayType, n);
	case SOAP_TYPE_fims__AudioFormatType:
		return (void*)soap_instantiate_fims__AudioFormatType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_fims__DataFormatType:
		return (void*)soap_instantiate_fims__DataFormatType(soap, -1, type, arrayType, n);
	case SOAP_TYPE__fims__ContainerFormatType_containerFormat:
		return (void*)soap_instantiate__fims__ContainerFormatType_containerFormat(soap, -1, type, arrayType, n);
	case SOAP_TYPE_fims__ContainerFormatType:
		return (void*)soap_instantiate_fims__ContainerFormatType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_fims__SimpleFileLocatorType:
		return (void*)soap_instantiate_fims__SimpleFileLocatorType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_fims__ListFileLocatorType:
		return (void*)soap_instantiate_fims__ListFileLocatorType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_fims__FolderLocatorType:
		return (void*)soap_instantiate_fims__FolderLocatorType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_fims__EssencePlaceholderLocatorType:
		return (void*)soap_instantiate_fims__EssencePlaceholderLocatorType(soap, -1, type, arrayType, n);
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Detail:
		return (void*)soap_instantiate_SOAP_ENV__Detail(soap, -1, type, arrayType, n);
#endif
	case SOAP_TYPE___edlprovider__getInstalledEdls:
		return (void*)soap_instantiate___edlprovider__getInstalledEdls(soap, -1, type, arrayType, n);
	case SOAP_TYPE___edlprovider__getEdl:
		return (void*)soap_instantiate___edlprovider__getEdl(soap, -1, type, arrayType, n);
	case SOAP_TYPE___edlprovider__getEdlDouble:
		return (void*)soap_instantiate___edlprovider__getEdlDouble(soap, -1, type, arrayType, n);
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Header:
		return (void*)soap_instantiate_SOAP_ENV__Header(soap, -1, type, arrayType, n);
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Code:
		return (void*)soap_instantiate_SOAP_ENV__Code(soap, -1, type, arrayType, n);
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Reason:
		return (void*)soap_instantiate_SOAP_ENV__Reason(soap, -1, type, arrayType, n);
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Fault:
		return (void*)soap_instantiate_SOAP_ENV__Fault(soap, -1, type, arrayType, n);
#endif
	case SOAP_TYPE_xsd__NMTOKEN:
		return (void*)soap_instantiate_xsd__NMTOKEN(soap, -1, type, arrayType, n);
	case SOAP_TYPE_xsd__anyURI:
		return (void*)soap_instantiate_xsd__anyURI(soap, -1, type, arrayType, n);
	case SOAP_TYPE_xsd__date:
		return (void*)soap_instantiate_xsd__date(soap, -1, type, arrayType, n);
	case SOAP_TYPE_xsd__decimal:
		return (void*)soap_instantiate_xsd__decimal(soap, -1, type, arrayType, n);
	case SOAP_TYPE_xsd__gYear:
		return (void*)soap_instantiate_xsd__gYear(soap, -1, type, arrayType, n);
	case SOAP_TYPE_xsd__integer:
		return (void*)soap_instantiate_xsd__integer(soap, -1, type, arrayType, n);
	case SOAP_TYPE_xsd__language:
		return (void*)soap_instantiate_xsd__language(soap, -1, type, arrayType, n);
	case SOAP_TYPE_xsd__nonNegativeInteger:
		return (void*)soap_instantiate_xsd__nonNegativeInteger(soap, -1, type, arrayType, n);
	case SOAP_TYPE_xsd__positiveInteger:
		return (void*)soap_instantiate_xsd__positiveInteger(soap, -1, type, arrayType, n);
	case SOAP_TYPE_xsd__time:
		return (void*)soap_instantiate_xsd__time(soap, -1, type, arrayType, n);
	case SOAP_TYPE__xml__lang:
		return (void*)soap_instantiate__xml__lang(soap, -1, type, arrayType, n);
	case SOAP_TYPE_fims__UID:
		return (void*)soap_instantiate_fims__UID(soap, -1, type, arrayType, n);
	case SOAP_TYPE_fims__RevisionIDType:
		return (void*)soap_instantiate_fims__RevisionIDType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_fimstime__Timecode:
		return (void*)soap_instantiate_fimstime__Timecode(soap, -1, type, arrayType, n);
	case SOAP_TYPE_fimstime__TimecodeDuration:
		return (void*)soap_instantiate_fimstime__TimecodeDuration(soap, -1, type, arrayType, n);
	case SOAP_TYPE_fims__ResourceIDType:
		return (void*)soap_instantiate_fims__ResourceIDType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTofims__AncillaryDataFormatType:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTofims__AncillaryDataFormatType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTofims__CaptioningFormatType:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTofims__CaptioningFormatType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTofims__BMTrackType:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTofims__BMTrackType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTofims__TechnicalAttributeType:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTofims__TechnicalAttributeType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOffims__UID:
		return (void*)soap_instantiate_std__vectorTemplateOffims__UID(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfxsd__anyURI:
		return (void*)soap_instantiate_std__vectorTemplateOfxsd__anyURI(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTofimsdescription__detailsType:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTofimsdescription__detailsType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOf_fimsdescription__entityType_role:
		return (void*)soap_instantiate_std__vectorTemplateOf_fimsdescription__entityType_role(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTofimsdescription__organisationDetailsType:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTofimsdescription__organisationDetailsType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTofimsdescription__contactDetailsType:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTofimsdescription__contactDetailsType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOf_fimsdescription__typeType_targetAudience:
		return (void*)soap_instantiate_std__vectorTemplateOf_fimsdescription__typeType_targetAudience(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOf_fimsdescription__typeType_objectType:
		return (void*)soap_instantiate_std__vectorTemplateOf_fimsdescription__typeType_objectType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOf_fimsdescription__typeType_genre:
		return (void*)soap_instantiate_std__vectorTemplateOf_fimsdescription__typeType_genre(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTofimsdescription__partType:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTofimsdescription__partType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTofimsdescription__rightsType:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTofimsdescription__rightsType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTofimsdescription__coverageType:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTofimsdescription__coverageType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTofimsdescription__relationType:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTofimsdescription__relationType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTofimsdescription__languageType:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTofimsdescription__languageType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTofimsdescription__identifierType:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTofimsdescription__identifierType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTofimsdescription__typeType:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTofimsdescription__typeType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTofimsdescription__dateType:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTofimsdescription__dateType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTofimsdescription__descriptionType:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTofimsdescription__descriptionType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTofimsdescription__subjectType:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTofimsdescription__subjectType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTofimsdescription__entityType:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTofimsdescription__entityType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTofimsdescription__titleType:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTofimsdescription__titleType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTofimsdescription__textElementType:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTofimsdescription__textElementType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTofims__SystemPerformanceEventType:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTofims__SystemPerformanceEventType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTofims__SystemExceptionEventType:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTofims__SystemExceptionEventType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTofims__SystemEventType:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTofims__SystemEventType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTofims__ContentCustomEventType:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTofims__ContentCustomEventType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTofims__ContentStatusEventType:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTofims__ContentStatusEventType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTofims__ContentEventType:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTofims__ContentEventType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTofims__EventPayloadType:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTofims__EventPayloadType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTofims__EventEnvelopeType:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTofims__EventEnvelopeType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTofims__CustomEventTemplateType:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTofims__CustomEventTemplateType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTofims__QueryGroupType:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTofims__QueryGroupType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTofims__CustomQueryGroupOperatorType:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTofims__CustomQueryGroupOperatorType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTofims__QueryParameterType:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTofims__QueryParameterType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTofims__CustomQueryParameterOperatorType:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTofims__CustomQueryParameterOperatorType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTofims__QueryExpressionType:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTofims__QueryExpressionType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTofims__SuperLockTokenType:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTofims__SuperLockTokenType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTofims__LockTokenType:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTofims__LockTokenType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTofims__CredentialType:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTofims__CredentialType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTofims__BMEssenceLocatorStatusType:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTofims__BMEssenceLocatorStatusType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTofims__BMContentStatusType:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTofims__BMContentStatusType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTofims__BMCustomStatusExtensionType:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTofims__BMCustomStatusExtensionType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTofims__CustomValueType:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTofims__CustomValueType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTofims__ResourceReferenceType:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTofims__ResourceReferenceType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTofims__DescriptionType:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTofims__DescriptionType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTofims__BMEssenceLocatorType:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTofims__BMEssenceLocatorType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTofims__BMContentFormatType:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTofims__BMContentFormatType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTofims__BMContentType:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTofims__BMContentType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTofims__BMObjectType:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTofims__BMObjectType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTofims__DataFormatType:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTofims__DataFormatType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTofims__ContainerFormatType:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTofims__ContainerFormatType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTofims__AudioFormatType:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTofims__AudioFormatType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTofims__VideoFormatType:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTofims__VideoFormatType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTofims__JobType:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTofims__JobType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTofims__QueueType:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTofims__QueueType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTofims__ServiceType:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTofims__ServiceType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTofims__ProfileType:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTofims__ProfileType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTofims__ResourceType:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTofims__ResourceType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTofims__InnerFaultType:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTofims__InnerFaultType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOf_XML:
		return (void*)soap_instantiate_std__vectorTemplateOf_XML(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerToedlprovider__MapItemType:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerToedlprovider__MapItemType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerToedlprovider__ClipType:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerToedlprovider__ClipType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfstd__wstring:
		return (void*)soap_instantiate_std__vectorTemplateOfstd__wstring(soap, -1, type, arrayType, n);
	}
	return NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 EDLProvider_fdelete(struct soap_clist *p)
{	switch (p->type)
	{
	case SOAP_TYPE_xsd__base64Binary:
		if (p->size < 0)
			SOAP_DELETE((xsd__base64Binary*)p->ptr);
		else
			SOAP_DELETE_ARRAY((xsd__base64Binary*)p->ptr);
		break;
	case SOAP_TYPE_xsd__hexBinary:
		if (p->size < 0)
			SOAP_DELETE((xsd__hexBinary*)p->ptr);
		else
			SOAP_DELETE_ARRAY((xsd__hexBinary*)p->ptr);
		break;
	case SOAP_TYPE_std__wstring:
		if (p->size < 0)
			SOAP_DELETE((std::wstring*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::wstring*)p->ptr);
		break;
	case SOAP_TYPE_edlprovider__ArrayOfstring:
		if (p->size < 0)
			SOAP_DELETE((edlprovider__ArrayOfstring*)p->ptr);
		else
			SOAP_DELETE_ARRAY((edlprovider__ArrayOfstring*)p->ptr);
		break;
	case SOAP_TYPE_edlprovider__ArrayOfClips:
		if (p->size < 0)
			SOAP_DELETE((edlprovider__ArrayOfClips*)p->ptr);
		else
			SOAP_DELETE_ARRAY((edlprovider__ArrayOfClips*)p->ptr);
		break;
	case SOAP_TYPE_edlprovider__ClipType:
		if (p->size < 0)
			SOAP_DELETE((edlprovider__ClipType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((edlprovider__ClipType*)p->ptr);
		break;
	case SOAP_TYPE_edlprovider__MapItemType:
		if (p->size < 0)
			SOAP_DELETE((edlprovider__MapItemType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((edlprovider__MapItemType*)p->ptr);
		break;
	case SOAP_TYPE_edlprovider__EdlCreateRequestBaseType:
		if (p->size < 0)
			SOAP_DELETE((edlprovider__EdlCreateRequestBaseType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((edlprovider__EdlCreateRequestBaseType*)p->ptr);
		break;
	case SOAP_TYPE_edlprovider__EdlCreateResponseType:
		if (p->size < 0)
			SOAP_DELETE((edlprovider__EdlCreateResponseType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((edlprovider__EdlCreateResponseType*)p->ptr);
		break;
	case SOAP_TYPE_edlprovider__InstalledEdlsResponseType:
		if (p->size < 0)
			SOAP_DELETE((edlprovider__InstalledEdlsResponseType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((edlprovider__InstalledEdlsResponseType*)p->ptr);
		break;
	case SOAP_TYPE__edlprovider__Map:
		if (p->size < 0)
			SOAP_DELETE((_edlprovider__Map*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_edlprovider__Map*)p->ptr);
		break;
	case SOAP_TYPE_fims__ExtensionGroup:
		if (p->size < 0)
			SOAP_DELETE((fims__ExtensionGroup*)p->ptr);
		else
			SOAP_DELETE_ARRAY((fims__ExtensionGroup*)p->ptr);
		break;
	case SOAP_TYPE_fims__ExtensionAttributes:
		if (p->size < 0)
			SOAP_DELETE((fims__ExtensionAttributes*)p->ptr);
		else
			SOAP_DELETE_ARRAY((fims__ExtensionAttributes*)p->ptr);
		break;
	case SOAP_TYPE_fims__ResourceReferenceType:
		if (p->size < 0)
			SOAP_DELETE((fims__ResourceReferenceType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((fims__ResourceReferenceType*)p->ptr);
		break;
	case SOAP_TYPE_fims__ExtensionBaseType:
		if (p->size < 0)
			SOAP_DELETE((fims__ExtensionBaseType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((fims__ExtensionBaseType*)p->ptr);
		break;
	case SOAP_TYPE_fims__AsyncEndpointType:
		if (p->size < 0)
			SOAP_DELETE((fims__AsyncEndpointType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((fims__AsyncEndpointType*)p->ptr);
		break;
	case SOAP_TYPE_fims__AncillaryDataFormatType:
		if (p->size < 0)
			SOAP_DELETE((fims__AncillaryDataFormatType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((fims__AncillaryDataFormatType*)p->ptr);
		break;
	case SOAP_TYPE_fims__BMTrackType:
		if (p->size < 0)
			SOAP_DELETE((fims__BMTrackType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((fims__BMTrackType*)p->ptr);
		break;
	case SOAP_TYPE_fims__CodecType:
		if (p->size < 0)
			SOAP_DELETE((fims__CodecType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((fims__CodecType*)p->ptr);
		break;
	case SOAP_TYPE_fims__TransferAtomType:
		if (p->size < 0)
			SOAP_DELETE((fims__TransferAtomType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((fims__TransferAtomType*)p->ptr);
		break;
	case SOAP_TYPE_fims__TransformAtomType:
		if (p->size < 0)
			SOAP_DELETE((fims__TransformAtomType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((fims__TransformAtomType*)p->ptr);
		break;
	case SOAP_TYPE_fims__HashType:
		if (p->size < 0)
			SOAP_DELETE((fims__HashType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((fims__HashType*)p->ptr);
		break;
	case SOAP_TYPE_fims__ProcessedInfoType:
		if (p->size < 0)
			SOAP_DELETE((fims__ProcessedInfoType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((fims__ProcessedInfoType*)p->ptr);
		break;
	case SOAP_TYPE_fims__StartProcessType:
		if (p->size < 0)
			SOAP_DELETE((fims__StartProcessType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((fims__StartProcessType*)p->ptr);
		break;
	case SOAP_TYPE_fims__StopProcessType:
		if (p->size < 0)
			SOAP_DELETE((fims__StopProcessType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((fims__StopProcessType*)p->ptr);
		break;
	case SOAP_TYPE_fims__StartJobType:
		if (p->size < 0)
			SOAP_DELETE((fims__StartJobType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((fims__StartJobType*)p->ptr);
		break;
	case SOAP_TYPE_fims__ManageJobRequestType:
		if (p->size < 0)
			SOAP_DELETE((fims__ManageJobRequestType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((fims__ManageJobRequestType*)p->ptr);
		break;
	case SOAP_TYPE_fims__ManageJobResponseType:
		if (p->size < 0)
			SOAP_DELETE((fims__ManageJobResponseType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((fims__ManageJobResponseType*)p->ptr);
		break;
	case SOAP_TYPE_fims__ManageQueueRequestType:
		if (p->size < 0)
			SOAP_DELETE((fims__ManageQueueRequestType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((fims__ManageQueueRequestType*)p->ptr);
		break;
	case SOAP_TYPE_fims__ManageQueueResponseType:
		if (p->size < 0)
			SOAP_DELETE((fims__ManageQueueResponseType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((fims__ManageQueueResponseType*)p->ptr);
		break;
	case SOAP_TYPE_fims__QueryJobRequestType:
		if (p->size < 0)
			SOAP_DELETE((fims__QueryJobRequestType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((fims__QueryJobRequestType*)p->ptr);
		break;
	case SOAP_TYPE_fims__QueryJobResponseType:
		if (p->size < 0)
			SOAP_DELETE((fims__QueryJobResponseType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((fims__QueryJobResponseType*)p->ptr);
		break;
	case SOAP_TYPE_fims__QueryServiceDescriptionRequestType:
		if (p->size < 0)
			SOAP_DELETE((fims__QueryServiceDescriptionRequestType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((fims__QueryServiceDescriptionRequestType*)p->ptr);
		break;
	case SOAP_TYPE_fims__QueryServiceDescriptionResponseType:
		if (p->size < 0)
			SOAP_DELETE((fims__QueryServiceDescriptionResponseType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((fims__QueryServiceDescriptionResponseType*)p->ptr);
		break;
	case SOAP_TYPE_fims__ListFilterType:
		if (p->size < 0)
			SOAP_DELETE((fims__ListFilterType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((fims__ListFilterType*)p->ptr);
		break;
	case SOAP_TYPE_fims__FaultType:
		if (p->size < 0)
			SOAP_DELETE((fims__FaultType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((fims__FaultType*)p->ptr);
		break;
	case SOAP_TYPE_fims__InnerFaultType:
		if (p->size < 0)
			SOAP_DELETE((fims__InnerFaultType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((fims__InnerFaultType*)p->ptr);
		break;
	case SOAP_TYPE_fims__ResourcesType:
		if (p->size < 0)
			SOAP_DELETE((fims__ResourcesType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((fims__ResourcesType*)p->ptr);
		break;
	case SOAP_TYPE_fims__ProfilesType:
		if (p->size < 0)
			SOAP_DELETE((fims__ProfilesType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((fims__ProfilesType*)p->ptr);
		break;
	case SOAP_TYPE_fims__ServicesType:
		if (p->size < 0)
			SOAP_DELETE((fims__ServicesType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((fims__ServicesType*)p->ptr);
		break;
	case SOAP_TYPE_fims__QueuesType:
		if (p->size < 0)
			SOAP_DELETE((fims__QueuesType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((fims__QueuesType*)p->ptr);
		break;
	case SOAP_TYPE_fims__JobsType:
		if (p->size < 0)
			SOAP_DELETE((fims__JobsType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((fims__JobsType*)p->ptr);
		break;
	case SOAP_TYPE_fims__VideoFormatsType:
		if (p->size < 0)
			SOAP_DELETE((fims__VideoFormatsType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((fims__VideoFormatsType*)p->ptr);
		break;
	case SOAP_TYPE_fims__AudioFormatsType:
		if (p->size < 0)
			SOAP_DELETE((fims__AudioFormatsType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((fims__AudioFormatsType*)p->ptr);
		break;
	case SOAP_TYPE_fims__ContainerFormatsType:
		if (p->size < 0)
			SOAP_DELETE((fims__ContainerFormatsType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((fims__ContainerFormatsType*)p->ptr);
		break;
	case SOAP_TYPE_fims__DataFormatsType:
		if (p->size < 0)
			SOAP_DELETE((fims__DataFormatsType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((fims__DataFormatsType*)p->ptr);
		break;
	case SOAP_TYPE_fims__BMObjectsType:
		if (p->size < 0)
			SOAP_DELETE((fims__BMObjectsType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((fims__BMObjectsType*)p->ptr);
		break;
	case SOAP_TYPE_fims__BMContentsType:
		if (p->size < 0)
			SOAP_DELETE((fims__BMContentsType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((fims__BMContentsType*)p->ptr);
		break;
	case SOAP_TYPE_fims__BMContentFormatsType:
		if (p->size < 0)
			SOAP_DELETE((fims__BMContentFormatsType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((fims__BMContentFormatsType*)p->ptr);
		break;
	case SOAP_TYPE_fims__BMEssenceLocatorsType:
		if (p->size < 0)
			SOAP_DELETE((fims__BMEssenceLocatorsType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((fims__BMEssenceLocatorsType*)p->ptr);
		break;
	case SOAP_TYPE_fims__DescriptionsType:
		if (p->size < 0)
			SOAP_DELETE((fims__DescriptionsType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((fims__DescriptionsType*)p->ptr);
		break;
	case SOAP_TYPE_fims__ResourceReferencesType:
		if (p->size < 0)
			SOAP_DELETE((fims__ResourceReferencesType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((fims__ResourceReferencesType*)p->ptr);
		break;
	case SOAP_TYPE_fims__CustomValueType:
		if (p->size < 0)
			SOAP_DELETE((fims__CustomValueType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((fims__CustomValueType*)p->ptr);
		break;
	case SOAP_TYPE_fims__CustomValuesType:
		if (p->size < 0)
			SOAP_DELETE((fims__CustomValuesType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((fims__CustomValuesType*)p->ptr);
		break;
	case SOAP_TYPE_fims__BMCustomStatusExtensionsType:
		if (p->size < 0)
			SOAP_DELETE((fims__BMCustomStatusExtensionsType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((fims__BMCustomStatusExtensionsType*)p->ptr);
		break;
	case SOAP_TYPE_fims__BMContentStatusesType:
		if (p->size < 0)
			SOAP_DELETE((fims__BMContentStatusesType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((fims__BMContentStatusesType*)p->ptr);
		break;
	case SOAP_TYPE_fims__BMEssenceLocatorStatusesType:
		if (p->size < 0)
			SOAP_DELETE((fims__BMEssenceLocatorStatusesType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((fims__BMEssenceLocatorStatusesType*)p->ptr);
		break;
	case SOAP_TYPE_fims__CredentialType:
		if (p->size < 0)
			SOAP_DELETE((fims__CredentialType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((fims__CredentialType*)p->ptr);
		break;
	case SOAP_TYPE_fims__CredentialsType:
		if (p->size < 0)
			SOAP_DELETE((fims__CredentialsType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((fims__CredentialsType*)p->ptr);
		break;
	case SOAP_TYPE_fims__LockTokensType:
		if (p->size < 0)
			SOAP_DELETE((fims__LockTokensType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((fims__LockTokensType*)p->ptr);
		break;
	case SOAP_TYPE_fims__SuperLockTokensType:
		if (p->size < 0)
			SOAP_DELETE((fims__SuperLockTokensType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((fims__SuperLockTokensType*)p->ptr);
		break;
	case SOAP_TYPE_fims__QueryExpressionType:
		if (p->size < 0)
			SOAP_DELETE((fims__QueryExpressionType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((fims__QueryExpressionType*)p->ptr);
		break;
	case SOAP_TYPE_fims__QueryExpressionsType:
		if (p->size < 0)
			SOAP_DELETE((fims__QueryExpressionsType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((fims__QueryExpressionsType*)p->ptr);
		break;
	case SOAP_TYPE_fims__CustomQueryParameterOperatorType:
		if (p->size < 0)
			SOAP_DELETE((fims__CustomQueryParameterOperatorType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((fims__CustomQueryParameterOperatorType*)p->ptr);
		break;
	case SOAP_TYPE_fims__CustomQueryParameterOperatorsType:
		if (p->size < 0)
			SOAP_DELETE((fims__CustomQueryParameterOperatorsType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((fims__CustomQueryParameterOperatorsType*)p->ptr);
		break;
	case SOAP_TYPE_fims__QueryParameterType:
		if (p->size < 0)
			SOAP_DELETE((fims__QueryParameterType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((fims__QueryParameterType*)p->ptr);
		break;
	case SOAP_TYPE_fims__QueryParametersType:
		if (p->size < 0)
			SOAP_DELETE((fims__QueryParametersType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((fims__QueryParametersType*)p->ptr);
		break;
	case SOAP_TYPE_fims__CustomQueryGroupOperatorType:
		if (p->size < 0)
			SOAP_DELETE((fims__CustomQueryGroupOperatorType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((fims__CustomQueryGroupOperatorType*)p->ptr);
		break;
	case SOAP_TYPE_fims__CustomQueryGroupOperatorsType:
		if (p->size < 0)
			SOAP_DELETE((fims__CustomQueryGroupOperatorsType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((fims__CustomQueryGroupOperatorsType*)p->ptr);
		break;
	case SOAP_TYPE_fims__QueryGroupType:
		if (p->size < 0)
			SOAP_DELETE((fims__QueryGroupType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((fims__QueryGroupType*)p->ptr);
		break;
	case SOAP_TYPE_fims__QueryGroupsType:
		if (p->size < 0)
			SOAP_DELETE((fims__QueryGroupsType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((fims__QueryGroupsType*)p->ptr);
		break;
	case SOAP_TYPE_fims__CustomEventTemplateType:
		if (p->size < 0)
			SOAP_DELETE((fims__CustomEventTemplateType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((fims__CustomEventTemplateType*)p->ptr);
		break;
	case SOAP_TYPE_fims__CustomEventTemplatesType:
		if (p->size < 0)
			SOAP_DELETE((fims__CustomEventTemplatesType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((fims__CustomEventTemplatesType*)p->ptr);
		break;
	case SOAP_TYPE_fims__EventEnvelopeType:
		if (p->size < 0)
			SOAP_DELETE((fims__EventEnvelopeType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((fims__EventEnvelopeType*)p->ptr);
		break;
	case SOAP_TYPE_fims__EventEnvelopesType:
		if (p->size < 0)
			SOAP_DELETE((fims__EventEnvelopesType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((fims__EventEnvelopesType*)p->ptr);
		break;
	case SOAP_TYPE_fims__EventPayloadType:
		if (p->size < 0)
			SOAP_DELETE((fims__EventPayloadType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((fims__EventPayloadType*)p->ptr);
		break;
	case SOAP_TYPE_fims__EventPayloadsType:
		if (p->size < 0)
			SOAP_DELETE((fims__EventPayloadsType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((fims__EventPayloadsType*)p->ptr);
		break;
	case SOAP_TYPE_fims__ContentEventsType:
		if (p->size < 0)
			SOAP_DELETE((fims__ContentEventsType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((fims__ContentEventsType*)p->ptr);
		break;
	case SOAP_TYPE_fims__ContentStatusEventsType:
		if (p->size < 0)
			SOAP_DELETE((fims__ContentStatusEventsType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((fims__ContentStatusEventsType*)p->ptr);
		break;
	case SOAP_TYPE_fims__ContentCustomEventsType:
		if (p->size < 0)
			SOAP_DELETE((fims__ContentCustomEventsType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((fims__ContentCustomEventsType*)p->ptr);
		break;
	case SOAP_TYPE_fims__SystemEventsType:
		if (p->size < 0)
			SOAP_DELETE((fims__SystemEventsType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((fims__SystemEventsType*)p->ptr);
		break;
	case SOAP_TYPE_fims__SystemExceptionEventsType:
		if (p->size < 0)
			SOAP_DELETE((fims__SystemExceptionEventsType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((fims__SystemExceptionEventsType*)p->ptr);
		break;
	case SOAP_TYPE_fims__SystemPerformanceEventsType:
		if (p->size < 0)
			SOAP_DELETE((fims__SystemPerformanceEventsType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((fims__SystemPerformanceEventsType*)p->ptr);
		break;
	case SOAP_TYPE__fims__formatCollection:
		if (p->size < 0)
			SOAP_DELETE((_fims__formatCollection*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_fims__formatCollection*)p->ptr);
		break;
	case SOAP_TYPE_fimstime__DurationType:
		if (p->size < 0)
			SOAP_DELETE((fimstime__DurationType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((fimstime__DurationType*)p->ptr);
		break;
	case SOAP_TYPE_fimstime__TimeType:
		if (p->size < 0)
			SOAP_DELETE((fimstime__TimeType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((fimstime__TimeType*)p->ptr);
		break;
	case SOAP_TYPE_fimsdescription__bmContentDescriptionType:
		if (p->size < 0)
			SOAP_DELETE((fimsdescription__bmContentDescriptionType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((fimsdescription__bmContentDescriptionType*)p->ptr);
		break;
	case SOAP_TYPE__fimsdescription__typeType_genre:
		if (p->size < 0)
			SOAP_DELETE((_fimsdescription__typeType_genre*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_fimsdescription__typeType_genre*)p->ptr);
		break;
	case SOAP_TYPE__fimsdescription__typeType_objectType:
		if (p->size < 0)
			SOAP_DELETE((_fimsdescription__typeType_objectType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_fimsdescription__typeType_objectType*)p->ptr);
		break;
	case SOAP_TYPE__fimsdescription__typeType_targetAudience:
		if (p->size < 0)
			SOAP_DELETE((_fimsdescription__typeType_targetAudience*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_fimsdescription__typeType_targetAudience*)p->ptr);
		break;
	case SOAP_TYPE_fimsdescription__typeType:
		if (p->size < 0)
			SOAP_DELETE((fimsdescription__typeType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((fimsdescription__typeType*)p->ptr);
		break;
	case SOAP_TYPE__fimsdescription__coverageType_temporal:
		if (p->size < 0)
			SOAP_DELETE((_fimsdescription__coverageType_temporal*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_fimsdescription__coverageType_temporal*)p->ptr);
		break;
	case SOAP_TYPE__fimsdescription__coverageType_spatial_locationName:
		if (p->size < 0)
			SOAP_DELETE((_fimsdescription__coverageType_spatial_locationName*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_fimsdescription__coverageType_spatial_locationName*)p->ptr);
		break;
	case SOAP_TYPE__fimsdescription__coverageType_spatial_coordinates:
		if (p->size < 0)
			SOAP_DELETE((_fimsdescription__coverageType_spatial_coordinates*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_fimsdescription__coverageType_spatial_coordinates*)p->ptr);
		break;
	case SOAP_TYPE__fimsdescription__coverageType_spatial:
		if (p->size < 0)
			SOAP_DELETE((_fimsdescription__coverageType_spatial*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_fimsdescription__coverageType_spatial*)p->ptr);
		break;
	case SOAP_TYPE_fimsdescription__coverageType:
		if (p->size < 0)
			SOAP_DELETE((fimsdescription__coverageType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((fimsdescription__coverageType*)p->ptr);
		break;
	case SOAP_TYPE_fimsdescription__rightsType:
		if (p->size < 0)
			SOAP_DELETE((fimsdescription__rightsType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((fimsdescription__rightsType*)p->ptr);
		break;
	case SOAP_TYPE__fimsdescription__dateType_created:
		if (p->size < 0)
			SOAP_DELETE((_fimsdescription__dateType_created*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_fimsdescription__dateType_created*)p->ptr);
		break;
	case SOAP_TYPE__fimsdescription__dateType_modified:
		if (p->size < 0)
			SOAP_DELETE((_fimsdescription__dateType_modified*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_fimsdescription__dateType_modified*)p->ptr);
		break;
	case SOAP_TYPE__fimsdescription__dateType_issued:
		if (p->size < 0)
			SOAP_DELETE((_fimsdescription__dateType_issued*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_fimsdescription__dateType_issued*)p->ptr);
		break;
	case SOAP_TYPE__fimsdescription__dateType_alternative:
		if (p->size < 0)
			SOAP_DELETE((_fimsdescription__dateType_alternative*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_fimsdescription__dateType_alternative*)p->ptr);
		break;
	case SOAP_TYPE_fimsdescription__dateType:
		if (p->size < 0)
			SOAP_DELETE((fimsdescription__dateType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((fimsdescription__dateType*)p->ptr);
		break;
	case SOAP_TYPE__fimsdescription__entityType_role:
		if (p->size < 0)
			SOAP_DELETE((_fimsdescription__entityType_role*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_fimsdescription__entityType_role*)p->ptr);
		break;
	case SOAP_TYPE_fimsdescription__entityType:
		if (p->size < 0)
			SOAP_DELETE((fimsdescription__entityType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((fimsdescription__entityType*)p->ptr);
		break;
	case SOAP_TYPE_fimsdescription__contactDetailsType:
		if (p->size < 0)
			SOAP_DELETE((fimsdescription__contactDetailsType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((fimsdescription__contactDetailsType*)p->ptr);
		break;
	case SOAP_TYPE__fimsdescription__organisationDetailsType_organisationDepartment:
		if (p->size < 0)
			SOAP_DELETE((_fimsdescription__organisationDetailsType_organisationDepartment*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_fimsdescription__organisationDetailsType_organisationDepartment*)p->ptr);
		break;
	case SOAP_TYPE_fimsdescription__organisationDetailsType:
		if (p->size < 0)
			SOAP_DELETE((fimsdescription__organisationDetailsType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((fimsdescription__organisationDetailsType*)p->ptr);
		break;
	case SOAP_TYPE_fimsdescription__detailsType:
		if (p->size < 0)
			SOAP_DELETE((fimsdescription__detailsType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((fimsdescription__detailsType*)p->ptr);
		break;
	case SOAP_TYPE__fimsdescription__addressType_country:
		if (p->size < 0)
			SOAP_DELETE((_fimsdescription__addressType_country*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_fimsdescription__addressType_country*)p->ptr);
		break;
	case SOAP_TYPE_fimsdescription__addressType:
		if (p->size < 0)
			SOAP_DELETE((fimsdescription__addressType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((fimsdescription__addressType*)p->ptr);
		break;
	case SOAP_TYPE_fimsdescription__languageType:
		if (p->size < 0)
			SOAP_DELETE((fimsdescription__languageType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((fimsdescription__languageType*)p->ptr);
		break;
	case SOAP_TYPE_fimsdescription__relationType:
		if (p->size < 0)
			SOAP_DELETE((fimsdescription__relationType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((fimsdescription__relationType*)p->ptr);
		break;
	case SOAP_TYPE_edlprovider__EdlCreateRequestType:
		if (p->size < 0)
			SOAP_DELETE((edlprovider__EdlCreateRequestType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((edlprovider__EdlCreateRequestType*)p->ptr);
		break;
	case SOAP_TYPE_edlprovider__EdlCreateRequestDoubleType:
		if (p->size < 0)
			SOAP_DELETE((edlprovider__EdlCreateRequestDoubleType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((edlprovider__EdlCreateRequestDoubleType*)p->ptr);
		break;
	case SOAP_TYPE_edlprovider__EdlProviderFaultType:
		if (p->size < 0)
			SOAP_DELETE((edlprovider__EdlProviderFaultType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((edlprovider__EdlProviderFaultType*)p->ptr);
		break;
	case SOAP_TYPE_fims__ResourceType:
		if (p->size < 0)
			SOAP_DELETE((fims__ResourceType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((fims__ResourceType*)p->ptr);
		break;
	case SOAP_TYPE_fims__CaptioningFormatType:
		if (p->size < 0)
			SOAP_DELETE((fims__CaptioningFormatType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((fims__CaptioningFormatType*)p->ptr);
		break;
	case SOAP_TYPE_fims__TechnicalAttributeType:
		if (p->size < 0)
			SOAP_DELETE((fims__TechnicalAttributeType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((fims__TechnicalAttributeType*)p->ptr);
		break;
	case SOAP_TYPE_fims__LengthType:
		if (p->size < 0)
			SOAP_DELETE((fims__LengthType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((fims__LengthType*)p->ptr);
		break;
	case SOAP_TYPE_fims__RationalType:
		if (p->size < 0)
			SOAP_DELETE((fims__RationalType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((fims__RationalType*)p->ptr);
		break;
	case SOAP_TYPE_fims__ProcessedInfoByBytesType:
		if (p->size < 0)
			SOAP_DELETE((fims__ProcessedInfoByBytesType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((fims__ProcessedInfoByBytesType*)p->ptr);
		break;
	case SOAP_TYPE_fims__ProcessedInfoByFramesType:
		if (p->size < 0)
			SOAP_DELETE((fims__ProcessedInfoByFramesType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((fims__ProcessedInfoByFramesType*)p->ptr);
		break;
	case SOAP_TYPE_fims__StartProcessByNoWaitType:
		if (p->size < 0)
			SOAP_DELETE((fims__StartProcessByNoWaitType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((fims__StartProcessByNoWaitType*)p->ptr);
		break;
	case SOAP_TYPE_fims__StartProcessByTimeType:
		if (p->size < 0)
			SOAP_DELETE((fims__StartProcessByTimeType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((fims__StartProcessByTimeType*)p->ptr);
		break;
	case SOAP_TYPE_fims__StartProcessByTimeMarkType:
		if (p->size < 0)
			SOAP_DELETE((fims__StartProcessByTimeMarkType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((fims__StartProcessByTimeMarkType*)p->ptr);
		break;
	case SOAP_TYPE_fims__StartProcessByServiceDefinedTimeType:
		if (p->size < 0)
			SOAP_DELETE((fims__StartProcessByServiceDefinedTimeType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((fims__StartProcessByServiceDefinedTimeType*)p->ptr);
		break;
	case SOAP_TYPE_fims__StopProcessByTimeType:
		if (p->size < 0)
			SOAP_DELETE((fims__StopProcessByTimeType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((fims__StopProcessByTimeType*)p->ptr);
		break;
	case SOAP_TYPE_fims__StopProcessByDurationType:
		if (p->size < 0)
			SOAP_DELETE((fims__StopProcessByDurationType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((fims__StopProcessByDurationType*)p->ptr);
		break;
	case SOAP_TYPE_fims__StopProcessByTimeMarkType:
		if (p->size < 0)
			SOAP_DELETE((fims__StopProcessByTimeMarkType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((fims__StopProcessByTimeMarkType*)p->ptr);
		break;
	case SOAP_TYPE_fims__StopProcessByServiceDefinedTimeType:
		if (p->size < 0)
			SOAP_DELETE((fims__StopProcessByServiceDefinedTimeType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((fims__StopProcessByServiceDefinedTimeType*)p->ptr);
		break;
	case SOAP_TYPE_fims__StopProcessByOpenEndType:
		if (p->size < 0)
			SOAP_DELETE((fims__StopProcessByOpenEndType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((fims__StopProcessByOpenEndType*)p->ptr);
		break;
	case SOAP_TYPE_fims__StartJobByNoWaitType:
		if (p->size < 0)
			SOAP_DELETE((fims__StartJobByNoWaitType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((fims__StartJobByNoWaitType*)p->ptr);
		break;
	case SOAP_TYPE_fims__StartJobByTimeType:
		if (p->size < 0)
			SOAP_DELETE((fims__StartJobByTimeType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((fims__StartJobByTimeType*)p->ptr);
		break;
	case SOAP_TYPE_fims__StartJobByLatestType:
		if (p->size < 0)
			SOAP_DELETE((fims__StartJobByLatestType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((fims__StartJobByLatestType*)p->ptr);
		break;
	case SOAP_TYPE_fims__QueryJobRequestByIDType:
		if (p->size < 0)
			SOAP_DELETE((fims__QueryJobRequestByIDType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((fims__QueryJobRequestByIDType*)p->ptr);
		break;
	case SOAP_TYPE_fims__QueryJobRequestByFilterType:
		if (p->size < 0)
			SOAP_DELETE((fims__QueryJobRequestByFilterType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((fims__QueryJobRequestByFilterType*)p->ptr);
		break;
	case SOAP_TYPE_fims__ContentEventType:
		if (p->size < 0)
			SOAP_DELETE((fims__ContentEventType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((fims__ContentEventType*)p->ptr);
		break;
	case SOAP_TYPE_fims__SystemEventType:
		if (p->size < 0)
			SOAP_DELETE((fims__SystemEventType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((fims__SystemEventType*)p->ptr);
		break;
	case SOAP_TYPE_fimstime__EditUnitNumberType:
		if (p->size < 0)
			SOAP_DELETE((fimstime__EditUnitNumberType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((fimstime__EditUnitNumberType*)p->ptr);
		break;
	case SOAP_TYPE_fimsdescription__identifierType:
		if (p->size < 0)
			SOAP_DELETE((fimsdescription__identifierType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((fimsdescription__identifierType*)p->ptr);
		break;
	case SOAP_TYPE_fimsdescription__textElementType:
		if (p->size < 0)
			SOAP_DELETE((fimsdescription__textElementType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((fimsdescription__textElementType*)p->ptr);
		break;
	case SOAP_TYPE_fimsdescription__partType:
		if (p->size < 0)
			SOAP_DELETE((fimsdescription__partType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((fimsdescription__partType*)p->ptr);
		break;
	case SOAP_TYPE__fims__ServiceType_serviceDescription:
		if (p->size < 0)
			SOAP_DELETE((_fims__ServiceType_serviceDescription*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_fims__ServiceType_serviceDescription*)p->ptr);
		break;
	case SOAP_TYPE_fims__ServiceType:
		if (p->size < 0)
			SOAP_DELETE((fims__ServiceType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((fims__ServiceType*)p->ptr);
		break;
	case SOAP_TYPE_fims__ProfileType:
		if (p->size < 0)
			SOAP_DELETE((fims__ProfileType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((fims__ProfileType*)p->ptr);
		break;
	case SOAP_TYPE_fims__QueueType:
		if (p->size < 0)
			SOAP_DELETE((fims__QueueType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((fims__QueueType*)p->ptr);
		break;
	case SOAP_TYPE_fims__JobType:
		if (p->size < 0)
			SOAP_DELETE((fims__JobType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((fims__JobType*)p->ptr);
		break;
	case SOAP_TYPE_fims__FormatType:
		if (p->size < 0)
			SOAP_DELETE((fims__FormatType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((fims__FormatType*)p->ptr);
		break;
	case SOAP_TYPE_fims__BMObjectType:
		if (p->size < 0)
			SOAP_DELETE((fims__BMObjectType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((fims__BMObjectType*)p->ptr);
		break;
	case SOAP_TYPE_fims__BMContentType:
		if (p->size < 0)
			SOAP_DELETE((fims__BMContentType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((fims__BMContentType*)p->ptr);
		break;
	case SOAP_TYPE_fims__DescriptionType:
		if (p->size < 0)
			SOAP_DELETE((fims__DescriptionType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((fims__DescriptionType*)p->ptr);
		break;
	case SOAP_TYPE__fims__BMContentFormatType_mimeType:
		if (p->size < 0)
			SOAP_DELETE((_fims__BMContentFormatType_mimeType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_fims__BMContentFormatType_mimeType*)p->ptr);
		break;
	case SOAP_TYPE_fims__BMContentFormatType:
		if (p->size < 0)
			SOAP_DELETE((fims__BMContentFormatType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((fims__BMContentFormatType*)p->ptr);
		break;
	case SOAP_TYPE__fims__BMEssenceLocatorType_containerMimeType:
		if (p->size < 0)
			SOAP_DELETE((_fims__BMEssenceLocatorType_containerMimeType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_fims__BMEssenceLocatorType_containerMimeType*)p->ptr);
		break;
	case SOAP_TYPE_fims__BMEssenceLocatorType:
		if (p->size < 0)
			SOAP_DELETE((fims__BMEssenceLocatorType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((fims__BMEssenceLocatorType*)p->ptr);
		break;
	case SOAP_TYPE_fims__StorageType:
		if (p->size < 0)
			SOAP_DELETE((fims__StorageType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((fims__StorageType*)p->ptr);
		break;
	case SOAP_TYPE_fims__HashFunctionType:
		if (p->size < 0)
			SOAP_DELETE((fims__HashFunctionType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((fims__HashFunctionType*)p->ptr);
		break;
	case SOAP_TYPE_fims__BMCustomStatusExtensionType:
		if (p->size < 0)
			SOAP_DELETE((fims__BMCustomStatusExtensionType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((fims__BMCustomStatusExtensionType*)p->ptr);
		break;
	case SOAP_TYPE_fims__BMContentStatusType:
		if (p->size < 0)
			SOAP_DELETE((fims__BMContentStatusType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((fims__BMContentStatusType*)p->ptr);
		break;
	case SOAP_TYPE_fims__BMEssenceLocatorStatusType:
		if (p->size < 0)
			SOAP_DELETE((fims__BMEssenceLocatorStatusType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((fims__BMEssenceLocatorStatusType*)p->ptr);
		break;
	case SOAP_TYPE_fims__LockTokenType:
		if (p->size < 0)
			SOAP_DELETE((fims__LockTokenType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((fims__LockTokenType*)p->ptr);
		break;
	case SOAP_TYPE_fims__SuperLockTokenType:
		if (p->size < 0)
			SOAP_DELETE((fims__SuperLockTokenType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((fims__SuperLockTokenType*)p->ptr);
		break;
	case SOAP_TYPE_fims__ContentStatusEventType:
		if (p->size < 0)
			SOAP_DELETE((fims__ContentStatusEventType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((fims__ContentStatusEventType*)p->ptr);
		break;
	case SOAP_TYPE_fims__ContentCustomEventType:
		if (p->size < 0)
			SOAP_DELETE((fims__ContentCustomEventType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((fims__ContentCustomEventType*)p->ptr);
		break;
	case SOAP_TYPE_fims__SystemExceptionEventType:
		if (p->size < 0)
			SOAP_DELETE((fims__SystemExceptionEventType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((fims__SystemExceptionEventType*)p->ptr);
		break;
	case SOAP_TYPE_fims__SystemPerformanceEventType:
		if (p->size < 0)
			SOAP_DELETE((fims__SystemPerformanceEventType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((fims__SystemPerformanceEventType*)p->ptr);
		break;
	case SOAP_TYPE_fimsdescription__titleType:
		if (p->size < 0)
			SOAP_DELETE((fimsdescription__titleType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((fimsdescription__titleType*)p->ptr);
		break;
	case SOAP_TYPE_fimsdescription__subjectType:
		if (p->size < 0)
			SOAP_DELETE((fimsdescription__subjectType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((fimsdescription__subjectType*)p->ptr);
		break;
	case SOAP_TYPE_fimsdescription__descriptionType:
		if (p->size < 0)
			SOAP_DELETE((fimsdescription__descriptionType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((fimsdescription__descriptionType*)p->ptr);
		break;
	case SOAP_TYPE_fims__VideoFormatType:
		if (p->size < 0)
			SOAP_DELETE((fims__VideoFormatType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((fims__VideoFormatType*)p->ptr);
		break;
	case SOAP_TYPE__fims__AudioFormatType_trackConfiguration:
		if (p->size < 0)
			SOAP_DELETE((_fims__AudioFormatType_trackConfiguration*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_fims__AudioFormatType_trackConfiguration*)p->ptr);
		break;
	case SOAP_TYPE_fims__AudioFormatType:
		if (p->size < 0)
			SOAP_DELETE((fims__AudioFormatType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((fims__AudioFormatType*)p->ptr);
		break;
	case SOAP_TYPE_fims__DataFormatType:
		if (p->size < 0)
			SOAP_DELETE((fims__DataFormatType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((fims__DataFormatType*)p->ptr);
		break;
	case SOAP_TYPE__fims__ContainerFormatType_containerFormat:
		if (p->size < 0)
			SOAP_DELETE((_fims__ContainerFormatType_containerFormat*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_fims__ContainerFormatType_containerFormat*)p->ptr);
		break;
	case SOAP_TYPE_fims__ContainerFormatType:
		if (p->size < 0)
			SOAP_DELETE((fims__ContainerFormatType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((fims__ContainerFormatType*)p->ptr);
		break;
	case SOAP_TYPE_fims__SimpleFileLocatorType:
		if (p->size < 0)
			SOAP_DELETE((fims__SimpleFileLocatorType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((fims__SimpleFileLocatorType*)p->ptr);
		break;
	case SOAP_TYPE_fims__ListFileLocatorType:
		if (p->size < 0)
			SOAP_DELETE((fims__ListFileLocatorType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((fims__ListFileLocatorType*)p->ptr);
		break;
	case SOAP_TYPE_fims__FolderLocatorType:
		if (p->size < 0)
			SOAP_DELETE((fims__FolderLocatorType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((fims__FolderLocatorType*)p->ptr);
		break;
	case SOAP_TYPE_fims__EssencePlaceholderLocatorType:
		if (p->size < 0)
			SOAP_DELETE((fims__EssencePlaceholderLocatorType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((fims__EssencePlaceholderLocatorType*)p->ptr);
		break;
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Detail:
		if (p->size < 0)
			SOAP_DELETE((struct SOAP_ENV__Detail*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct SOAP_ENV__Detail*)p->ptr);
		break;
#endif
	case SOAP_TYPE___edlprovider__getInstalledEdls:
		if (p->size < 0)
			SOAP_DELETE((struct __edlprovider__getInstalledEdls*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __edlprovider__getInstalledEdls*)p->ptr);
		break;
	case SOAP_TYPE___edlprovider__getEdl:
		if (p->size < 0)
			SOAP_DELETE((struct __edlprovider__getEdl*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __edlprovider__getEdl*)p->ptr);
		break;
	case SOAP_TYPE___edlprovider__getEdlDouble:
		if (p->size < 0)
			SOAP_DELETE((struct __edlprovider__getEdlDouble*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __edlprovider__getEdlDouble*)p->ptr);
		break;
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Header:
		if (p->size < 0)
			SOAP_DELETE((struct SOAP_ENV__Header*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct SOAP_ENV__Header*)p->ptr);
		break;
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Code:
		if (p->size < 0)
			SOAP_DELETE((struct SOAP_ENV__Code*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct SOAP_ENV__Code*)p->ptr);
		break;
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Reason:
		if (p->size < 0)
			SOAP_DELETE((struct SOAP_ENV__Reason*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct SOAP_ENV__Reason*)p->ptr);
		break;
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Fault:
		if (p->size < 0)
			SOAP_DELETE((struct SOAP_ENV__Fault*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct SOAP_ENV__Fault*)p->ptr);
		break;
#endif
	case SOAP_TYPE_xsd__NMTOKEN:
		if (p->size < 0)
			SOAP_DELETE((std::wstring*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::wstring*)p->ptr);
		break;
	case SOAP_TYPE_xsd__anyURI:
		if (p->size < 0)
			SOAP_DELETE((std::wstring*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::wstring*)p->ptr);
		break;
	case SOAP_TYPE_xsd__date:
		if (p->size < 0)
			SOAP_DELETE((std::wstring*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::wstring*)p->ptr);
		break;
	case SOAP_TYPE_xsd__decimal:
		if (p->size < 0)
			SOAP_DELETE((std::wstring*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::wstring*)p->ptr);
		break;
	case SOAP_TYPE_xsd__gYear:
		if (p->size < 0)
			SOAP_DELETE((std::wstring*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::wstring*)p->ptr);
		break;
	case SOAP_TYPE_xsd__integer:
		if (p->size < 0)
			SOAP_DELETE((std::wstring*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::wstring*)p->ptr);
		break;
	case SOAP_TYPE_xsd__language:
		if (p->size < 0)
			SOAP_DELETE((std::wstring*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::wstring*)p->ptr);
		break;
	case SOAP_TYPE_xsd__nonNegativeInteger:
		if (p->size < 0)
			SOAP_DELETE((std::wstring*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::wstring*)p->ptr);
		break;
	case SOAP_TYPE_xsd__positiveInteger:
		if (p->size < 0)
			SOAP_DELETE((std::wstring*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::wstring*)p->ptr);
		break;
	case SOAP_TYPE_xsd__time:
		if (p->size < 0)
			SOAP_DELETE((std::wstring*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::wstring*)p->ptr);
		break;
	case SOAP_TYPE__xml__lang:
		if (p->size < 0)
			SOAP_DELETE((std::wstring*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::wstring*)p->ptr);
		break;
	case SOAP_TYPE_fims__UID:
		if (p->size < 0)
			SOAP_DELETE((std::wstring*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::wstring*)p->ptr);
		break;
	case SOAP_TYPE_fims__RevisionIDType:
		if (p->size < 0)
			SOAP_DELETE((std::wstring*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::wstring*)p->ptr);
		break;
	case SOAP_TYPE_fimstime__Timecode:
		if (p->size < 0)
			SOAP_DELETE((std::wstring*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::wstring*)p->ptr);
		break;
	case SOAP_TYPE_fimstime__TimecodeDuration:
		if (p->size < 0)
			SOAP_DELETE((std::wstring*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::wstring*)p->ptr);
		break;
	case SOAP_TYPE_fims__ResourceIDType:
		if (p->size < 0)
			SOAP_DELETE((std::wstring*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::wstring*)p->ptr);
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTofims__AncillaryDataFormatType:
		if (p->size < 0)
			SOAP_DELETE((std::vector<fims__AncillaryDataFormatType * >*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::vector<fims__AncillaryDataFormatType * >*)p->ptr);
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTofims__CaptioningFormatType:
		if (p->size < 0)
			SOAP_DELETE((std::vector<fims__CaptioningFormatType * >*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::vector<fims__CaptioningFormatType * >*)p->ptr);
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTofims__BMTrackType:
		if (p->size < 0)
			SOAP_DELETE((std::vector<fims__BMTrackType * >*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::vector<fims__BMTrackType * >*)p->ptr);
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTofims__TechnicalAttributeType:
		if (p->size < 0)
			SOAP_DELETE((std::vector<fims__TechnicalAttributeType * >*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::vector<fims__TechnicalAttributeType * >*)p->ptr);
		break;
	case SOAP_TYPE_std__vectorTemplateOffims__UID:
		if (p->size < 0)
			SOAP_DELETE((std::vector<std::wstring >*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::vector<std::wstring >*)p->ptr);
		break;
	case SOAP_TYPE_std__vectorTemplateOfxsd__anyURI:
		if (p->size < 0)
			SOAP_DELETE((std::vector<std::wstring >*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::vector<std::wstring >*)p->ptr);
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTofimsdescription__detailsType:
		if (p->size < 0)
			SOAP_DELETE((std::vector<fimsdescription__detailsType * >*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::vector<fimsdescription__detailsType * >*)p->ptr);
		break;
	case SOAP_TYPE_std__vectorTemplateOf_fimsdescription__entityType_role:
		if (p->size < 0)
			SOAP_DELETE((std::vector<_fimsdescription__entityType_role >*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::vector<_fimsdescription__entityType_role >*)p->ptr);
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTofimsdescription__organisationDetailsType:
		if (p->size < 0)
			SOAP_DELETE((std::vector<fimsdescription__organisationDetailsType * >*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::vector<fimsdescription__organisationDetailsType * >*)p->ptr);
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTofimsdescription__contactDetailsType:
		if (p->size < 0)
			SOAP_DELETE((std::vector<fimsdescription__contactDetailsType * >*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::vector<fimsdescription__contactDetailsType * >*)p->ptr);
		break;
	case SOAP_TYPE_std__vectorTemplateOf_fimsdescription__typeType_targetAudience:
		if (p->size < 0)
			SOAP_DELETE((std::vector<_fimsdescription__typeType_targetAudience >*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::vector<_fimsdescription__typeType_targetAudience >*)p->ptr);
		break;
	case SOAP_TYPE_std__vectorTemplateOf_fimsdescription__typeType_objectType:
		if (p->size < 0)
			SOAP_DELETE((std::vector<_fimsdescription__typeType_objectType >*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::vector<_fimsdescription__typeType_objectType >*)p->ptr);
		break;
	case SOAP_TYPE_std__vectorTemplateOf_fimsdescription__typeType_genre:
		if (p->size < 0)
			SOAP_DELETE((std::vector<_fimsdescription__typeType_genre >*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::vector<_fimsdescription__typeType_genre >*)p->ptr);
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTofimsdescription__partType:
		if (p->size < 0)
			SOAP_DELETE((std::vector<fimsdescription__partType * >*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::vector<fimsdescription__partType * >*)p->ptr);
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTofimsdescription__rightsType:
		if (p->size < 0)
			SOAP_DELETE((std::vector<fimsdescription__rightsType * >*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::vector<fimsdescription__rightsType * >*)p->ptr);
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTofimsdescription__coverageType:
		if (p->size < 0)
			SOAP_DELETE((std::vector<fimsdescription__coverageType * >*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::vector<fimsdescription__coverageType * >*)p->ptr);
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTofimsdescription__relationType:
		if (p->size < 0)
			SOAP_DELETE((std::vector<fimsdescription__relationType * >*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::vector<fimsdescription__relationType * >*)p->ptr);
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTofimsdescription__languageType:
		if (p->size < 0)
			SOAP_DELETE((std::vector<fimsdescription__languageType * >*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::vector<fimsdescription__languageType * >*)p->ptr);
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTofimsdescription__identifierType:
		if (p->size < 0)
			SOAP_DELETE((std::vector<fimsdescription__identifierType * >*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::vector<fimsdescription__identifierType * >*)p->ptr);
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTofimsdescription__typeType:
		if (p->size < 0)
			SOAP_DELETE((std::vector<fimsdescription__typeType * >*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::vector<fimsdescription__typeType * >*)p->ptr);
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTofimsdescription__dateType:
		if (p->size < 0)
			SOAP_DELETE((std::vector<fimsdescription__dateType * >*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::vector<fimsdescription__dateType * >*)p->ptr);
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTofimsdescription__descriptionType:
		if (p->size < 0)
			SOAP_DELETE((std::vector<fimsdescription__descriptionType * >*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::vector<fimsdescription__descriptionType * >*)p->ptr);
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTofimsdescription__subjectType:
		if (p->size < 0)
			SOAP_DELETE((std::vector<fimsdescription__subjectType * >*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::vector<fimsdescription__subjectType * >*)p->ptr);
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTofimsdescription__entityType:
		if (p->size < 0)
			SOAP_DELETE((std::vector<fimsdescription__entityType * >*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::vector<fimsdescription__entityType * >*)p->ptr);
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTofimsdescription__titleType:
		if (p->size < 0)
			SOAP_DELETE((std::vector<fimsdescription__titleType * >*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::vector<fimsdescription__titleType * >*)p->ptr);
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTofimsdescription__textElementType:
		if (p->size < 0)
			SOAP_DELETE((std::vector<fimsdescription__textElementType * >*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::vector<fimsdescription__textElementType * >*)p->ptr);
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTofims__SystemPerformanceEventType:
		if (p->size < 0)
			SOAP_DELETE((std::vector<fims__SystemPerformanceEventType * >*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::vector<fims__SystemPerformanceEventType * >*)p->ptr);
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTofims__SystemExceptionEventType:
		if (p->size < 0)
			SOAP_DELETE((std::vector<fims__SystemExceptionEventType * >*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::vector<fims__SystemExceptionEventType * >*)p->ptr);
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTofims__SystemEventType:
		if (p->size < 0)
			SOAP_DELETE((std::vector<fims__SystemEventType * >*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::vector<fims__SystemEventType * >*)p->ptr);
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTofims__ContentCustomEventType:
		if (p->size < 0)
			SOAP_DELETE((std::vector<fims__ContentCustomEventType * >*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::vector<fims__ContentCustomEventType * >*)p->ptr);
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTofims__ContentStatusEventType:
		if (p->size < 0)
			SOAP_DELETE((std::vector<fims__ContentStatusEventType * >*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::vector<fims__ContentStatusEventType * >*)p->ptr);
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTofims__ContentEventType:
		if (p->size < 0)
			SOAP_DELETE((std::vector<fims__ContentEventType * >*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::vector<fims__ContentEventType * >*)p->ptr);
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTofims__EventPayloadType:
		if (p->size < 0)
			SOAP_DELETE((std::vector<fims__EventPayloadType * >*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::vector<fims__EventPayloadType * >*)p->ptr);
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTofims__EventEnvelopeType:
		if (p->size < 0)
			SOAP_DELETE((std::vector<fims__EventEnvelopeType * >*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::vector<fims__EventEnvelopeType * >*)p->ptr);
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTofims__CustomEventTemplateType:
		if (p->size < 0)
			SOAP_DELETE((std::vector<fims__CustomEventTemplateType * >*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::vector<fims__CustomEventTemplateType * >*)p->ptr);
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTofims__QueryGroupType:
		if (p->size < 0)
			SOAP_DELETE((std::vector<fims__QueryGroupType * >*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::vector<fims__QueryGroupType * >*)p->ptr);
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTofims__CustomQueryGroupOperatorType:
		if (p->size < 0)
			SOAP_DELETE((std::vector<fims__CustomQueryGroupOperatorType * >*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::vector<fims__CustomQueryGroupOperatorType * >*)p->ptr);
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTofims__QueryParameterType:
		if (p->size < 0)
			SOAP_DELETE((std::vector<fims__QueryParameterType * >*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::vector<fims__QueryParameterType * >*)p->ptr);
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTofims__CustomQueryParameterOperatorType:
		if (p->size < 0)
			SOAP_DELETE((std::vector<fims__CustomQueryParameterOperatorType * >*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::vector<fims__CustomQueryParameterOperatorType * >*)p->ptr);
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTofims__QueryExpressionType:
		if (p->size < 0)
			SOAP_DELETE((std::vector<fims__QueryExpressionType * >*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::vector<fims__QueryExpressionType * >*)p->ptr);
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTofims__SuperLockTokenType:
		if (p->size < 0)
			SOAP_DELETE((std::vector<fims__SuperLockTokenType * >*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::vector<fims__SuperLockTokenType * >*)p->ptr);
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTofims__LockTokenType:
		if (p->size < 0)
			SOAP_DELETE((std::vector<fims__LockTokenType * >*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::vector<fims__LockTokenType * >*)p->ptr);
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTofims__CredentialType:
		if (p->size < 0)
			SOAP_DELETE((std::vector<fims__CredentialType * >*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::vector<fims__CredentialType * >*)p->ptr);
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTofims__BMEssenceLocatorStatusType:
		if (p->size < 0)
			SOAP_DELETE((std::vector<fims__BMEssenceLocatorStatusType * >*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::vector<fims__BMEssenceLocatorStatusType * >*)p->ptr);
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTofims__BMContentStatusType:
		if (p->size < 0)
			SOAP_DELETE((std::vector<fims__BMContentStatusType * >*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::vector<fims__BMContentStatusType * >*)p->ptr);
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTofims__BMCustomStatusExtensionType:
		if (p->size < 0)
			SOAP_DELETE((std::vector<fims__BMCustomStatusExtensionType * >*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::vector<fims__BMCustomStatusExtensionType * >*)p->ptr);
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTofims__CustomValueType:
		if (p->size < 0)
			SOAP_DELETE((std::vector<fims__CustomValueType * >*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::vector<fims__CustomValueType * >*)p->ptr);
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTofims__ResourceReferenceType:
		if (p->size < 0)
			SOAP_DELETE((std::vector<fims__ResourceReferenceType * >*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::vector<fims__ResourceReferenceType * >*)p->ptr);
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTofims__DescriptionType:
		if (p->size < 0)
			SOAP_DELETE((std::vector<fims__DescriptionType * >*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::vector<fims__DescriptionType * >*)p->ptr);
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTofims__BMEssenceLocatorType:
		if (p->size < 0)
			SOAP_DELETE((std::vector<fims__BMEssenceLocatorType * >*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::vector<fims__BMEssenceLocatorType * >*)p->ptr);
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTofims__BMContentFormatType:
		if (p->size < 0)
			SOAP_DELETE((std::vector<fims__BMContentFormatType * >*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::vector<fims__BMContentFormatType * >*)p->ptr);
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTofims__BMContentType:
		if (p->size < 0)
			SOAP_DELETE((std::vector<fims__BMContentType * >*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::vector<fims__BMContentType * >*)p->ptr);
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTofims__BMObjectType:
		if (p->size < 0)
			SOAP_DELETE((std::vector<fims__BMObjectType * >*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::vector<fims__BMObjectType * >*)p->ptr);
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTofims__DataFormatType:
		if (p->size < 0)
			SOAP_DELETE((std::vector<fims__DataFormatType * >*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::vector<fims__DataFormatType * >*)p->ptr);
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTofims__ContainerFormatType:
		if (p->size < 0)
			SOAP_DELETE((std::vector<fims__ContainerFormatType * >*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::vector<fims__ContainerFormatType * >*)p->ptr);
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTofims__AudioFormatType:
		if (p->size < 0)
			SOAP_DELETE((std::vector<fims__AudioFormatType * >*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::vector<fims__AudioFormatType * >*)p->ptr);
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTofims__VideoFormatType:
		if (p->size < 0)
			SOAP_DELETE((std::vector<fims__VideoFormatType * >*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::vector<fims__VideoFormatType * >*)p->ptr);
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTofims__JobType:
		if (p->size < 0)
			SOAP_DELETE((std::vector<fims__JobType * >*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::vector<fims__JobType * >*)p->ptr);
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTofims__QueueType:
		if (p->size < 0)
			SOAP_DELETE((std::vector<fims__QueueType * >*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::vector<fims__QueueType * >*)p->ptr);
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTofims__ServiceType:
		if (p->size < 0)
			SOAP_DELETE((std::vector<fims__ServiceType * >*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::vector<fims__ServiceType * >*)p->ptr);
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTofims__ProfileType:
		if (p->size < 0)
			SOAP_DELETE((std::vector<fims__ProfileType * >*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::vector<fims__ProfileType * >*)p->ptr);
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTofims__ResourceType:
		if (p->size < 0)
			SOAP_DELETE((std::vector<fims__ResourceType * >*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::vector<fims__ResourceType * >*)p->ptr);
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTofims__InnerFaultType:
		if (p->size < 0)
			SOAP_DELETE((std::vector<fims__InnerFaultType * >*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::vector<fims__InnerFaultType * >*)p->ptr);
		break;
	case SOAP_TYPE_std__vectorTemplateOf_XML:
		if (p->size < 0)
			SOAP_DELETE((std::vector<char * >*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::vector<char * >*)p->ptr);
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerToedlprovider__MapItemType:
		if (p->size < 0)
			SOAP_DELETE((std::vector<edlprovider__MapItemType * >*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::vector<edlprovider__MapItemType * >*)p->ptr);
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerToedlprovider__ClipType:
		if (p->size < 0)
			SOAP_DELETE((std::vector<edlprovider__ClipType * >*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::vector<edlprovider__ClipType * >*)p->ptr);
		break;
	case SOAP_TYPE_std__vectorTemplateOfstd__wstring:
		if (p->size < 0)
			SOAP_DELETE((std::vector<std::wstring >*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::vector<std::wstring >*)p->ptr);
		break;
	default:	return SOAP_ERR;
	}
	return SOAP_OK;
}

SOAP_FMAC3 void* SOAP_FMAC4 soap_class_id_enter(struct soap *soap, const char *id, void *p, int t, size_t n, const char *type, const char *arrayType)
{	return soap_id_enter(soap, id, p, t, n, 0, type, arrayType, EDLProvider_instantiate);
}

SOAP_FMAC3 void* SOAP_FMAC4 soap_container_id_forward(struct soap *soap, const char *href, void *p, size_t len, int st, int tt, size_t n, unsigned int k)
{	return soap_id_forward(soap, href, p, len, st, tt, n, k, EDLProvider_container_insert);
}

SOAP_FMAC3 void SOAP_FMAC4 EDLProvider_container_insert(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
#ifdef WIN32
#pragma warning(push)
#pragma warning(disable:4065)
#endif
{
	(void)soap; (void)st; (void)p; (void)len; (void)q; (void)n; /* appease -Wall -Werror */
	switch (tt)
	{
	case SOAP_TYPE_std__vectorTemplateOfPointerTofims__AncillaryDataFormatType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container EDLProvider_container_insert type = %d in %d location = %p object = %p len = %lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<fims__AncillaryDataFormatType * >*)p)[len] = *(fims__AncillaryDataFormatType **)q;
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTofims__CaptioningFormatType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container EDLProvider_container_insert type = %d in %d location = %p object = %p len = %lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<fims__CaptioningFormatType * >*)p)[len] = *(fims__CaptioningFormatType **)q;
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTofims__BMTrackType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container EDLProvider_container_insert type = %d in %d location = %p object = %p len = %lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<fims__BMTrackType * >*)p)[len] = *(fims__BMTrackType **)q;
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTofims__TechnicalAttributeType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container EDLProvider_container_insert type = %d in %d location = %p object = %p len = %lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<fims__TechnicalAttributeType * >*)p)[len] = *(fims__TechnicalAttributeType **)q;
		break;
	case SOAP_TYPE_std__vectorTemplateOffims__UID:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container EDLProvider_container_insert type = %d in %d location = %p object = %p len = %lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<std::wstring >*)p)[len] = *(std::wstring *)q;
		break;
	case SOAP_TYPE_std__vectorTemplateOfxsd__anyURI:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container EDLProvider_container_insert type = %d in %d location = %p object = %p len = %lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<std::wstring >*)p)[len] = *(std::wstring *)q;
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTofimsdescription__detailsType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container EDLProvider_container_insert type = %d in %d location = %p object = %p len = %lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<fimsdescription__detailsType * >*)p)[len] = *(fimsdescription__detailsType **)q;
		break;
	case SOAP_TYPE_std__vectorTemplateOf_fimsdescription__entityType_role:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container EDLProvider_container_insert type = %d in %d location = %p object = %p len = %lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<_fimsdescription__entityType_role >*)p)[len] = *(_fimsdescription__entityType_role *)q;
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTofimsdescription__organisationDetailsType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container EDLProvider_container_insert type = %d in %d location = %p object = %p len = %lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<fimsdescription__organisationDetailsType * >*)p)[len] = *(fimsdescription__organisationDetailsType **)q;
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTofimsdescription__contactDetailsType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container EDLProvider_container_insert type = %d in %d location = %p object = %p len = %lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<fimsdescription__contactDetailsType * >*)p)[len] = *(fimsdescription__contactDetailsType **)q;
		break;
	case SOAP_TYPE_std__vectorTemplateOf_fimsdescription__typeType_targetAudience:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container EDLProvider_container_insert type = %d in %d location = %p object = %p len = %lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<_fimsdescription__typeType_targetAudience >*)p)[len] = *(_fimsdescription__typeType_targetAudience *)q;
		break;
	case SOAP_TYPE_std__vectorTemplateOf_fimsdescription__typeType_objectType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container EDLProvider_container_insert type = %d in %d location = %p object = %p len = %lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<_fimsdescription__typeType_objectType >*)p)[len] = *(_fimsdescription__typeType_objectType *)q;
		break;
	case SOAP_TYPE_std__vectorTemplateOf_fimsdescription__typeType_genre:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container EDLProvider_container_insert type = %d in %d location = %p object = %p len = %lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<_fimsdescription__typeType_genre >*)p)[len] = *(_fimsdescription__typeType_genre *)q;
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTofimsdescription__partType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container EDLProvider_container_insert type = %d in %d location = %p object = %p len = %lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<fimsdescription__partType * >*)p)[len] = *(fimsdescription__partType **)q;
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTofimsdescription__rightsType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container EDLProvider_container_insert type = %d in %d location = %p object = %p len = %lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<fimsdescription__rightsType * >*)p)[len] = *(fimsdescription__rightsType **)q;
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTofimsdescription__coverageType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container EDLProvider_container_insert type = %d in %d location = %p object = %p len = %lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<fimsdescription__coverageType * >*)p)[len] = *(fimsdescription__coverageType **)q;
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTofimsdescription__relationType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container EDLProvider_container_insert type = %d in %d location = %p object = %p len = %lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<fimsdescription__relationType * >*)p)[len] = *(fimsdescription__relationType **)q;
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTofimsdescription__languageType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container EDLProvider_container_insert type = %d in %d location = %p object = %p len = %lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<fimsdescription__languageType * >*)p)[len] = *(fimsdescription__languageType **)q;
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTofimsdescription__identifierType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container EDLProvider_container_insert type = %d in %d location = %p object = %p len = %lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<fimsdescription__identifierType * >*)p)[len] = *(fimsdescription__identifierType **)q;
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTofimsdescription__typeType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container EDLProvider_container_insert type = %d in %d location = %p object = %p len = %lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<fimsdescription__typeType * >*)p)[len] = *(fimsdescription__typeType **)q;
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTofimsdescription__dateType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container EDLProvider_container_insert type = %d in %d location = %p object = %p len = %lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<fimsdescription__dateType * >*)p)[len] = *(fimsdescription__dateType **)q;
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTofimsdescription__descriptionType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container EDLProvider_container_insert type = %d in %d location = %p object = %p len = %lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<fimsdescription__descriptionType * >*)p)[len] = *(fimsdescription__descriptionType **)q;
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTofimsdescription__subjectType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container EDLProvider_container_insert type = %d in %d location = %p object = %p len = %lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<fimsdescription__subjectType * >*)p)[len] = *(fimsdescription__subjectType **)q;
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTofimsdescription__entityType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container EDLProvider_container_insert type = %d in %d location = %p object = %p len = %lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<fimsdescription__entityType * >*)p)[len] = *(fimsdescription__entityType **)q;
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTofimsdescription__titleType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container EDLProvider_container_insert type = %d in %d location = %p object = %p len = %lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<fimsdescription__titleType * >*)p)[len] = *(fimsdescription__titleType **)q;
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTofimsdescription__textElementType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container EDLProvider_container_insert type = %d in %d location = %p object = %p len = %lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<fimsdescription__textElementType * >*)p)[len] = *(fimsdescription__textElementType **)q;
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTofims__SystemPerformanceEventType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container EDLProvider_container_insert type = %d in %d location = %p object = %p len = %lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<fims__SystemPerformanceEventType * >*)p)[len] = *(fims__SystemPerformanceEventType **)q;
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTofims__SystemExceptionEventType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container EDLProvider_container_insert type = %d in %d location = %p object = %p len = %lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<fims__SystemExceptionEventType * >*)p)[len] = *(fims__SystemExceptionEventType **)q;
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTofims__SystemEventType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container EDLProvider_container_insert type = %d in %d location = %p object = %p len = %lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<fims__SystemEventType * >*)p)[len] = *(fims__SystemEventType **)q;
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTofims__ContentCustomEventType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container EDLProvider_container_insert type = %d in %d location = %p object = %p len = %lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<fims__ContentCustomEventType * >*)p)[len] = *(fims__ContentCustomEventType **)q;
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTofims__ContentStatusEventType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container EDLProvider_container_insert type = %d in %d location = %p object = %p len = %lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<fims__ContentStatusEventType * >*)p)[len] = *(fims__ContentStatusEventType **)q;
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTofims__ContentEventType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container EDLProvider_container_insert type = %d in %d location = %p object = %p len = %lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<fims__ContentEventType * >*)p)[len] = *(fims__ContentEventType **)q;
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTofims__EventPayloadType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container EDLProvider_container_insert type = %d in %d location = %p object = %p len = %lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<fims__EventPayloadType * >*)p)[len] = *(fims__EventPayloadType **)q;
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTofims__EventEnvelopeType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container EDLProvider_container_insert type = %d in %d location = %p object = %p len = %lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<fims__EventEnvelopeType * >*)p)[len] = *(fims__EventEnvelopeType **)q;
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTofims__CustomEventTemplateType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container EDLProvider_container_insert type = %d in %d location = %p object = %p len = %lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<fims__CustomEventTemplateType * >*)p)[len] = *(fims__CustomEventTemplateType **)q;
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTofims__QueryGroupType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container EDLProvider_container_insert type = %d in %d location = %p object = %p len = %lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<fims__QueryGroupType * >*)p)[len] = *(fims__QueryGroupType **)q;
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTofims__CustomQueryGroupOperatorType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container EDLProvider_container_insert type = %d in %d location = %p object = %p len = %lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<fims__CustomQueryGroupOperatorType * >*)p)[len] = *(fims__CustomQueryGroupOperatorType **)q;
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTofims__QueryParameterType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container EDLProvider_container_insert type = %d in %d location = %p object = %p len = %lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<fims__QueryParameterType * >*)p)[len] = *(fims__QueryParameterType **)q;
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTofims__CustomQueryParameterOperatorType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container EDLProvider_container_insert type = %d in %d location = %p object = %p len = %lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<fims__CustomQueryParameterOperatorType * >*)p)[len] = *(fims__CustomQueryParameterOperatorType **)q;
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTofims__QueryExpressionType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container EDLProvider_container_insert type = %d in %d location = %p object = %p len = %lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<fims__QueryExpressionType * >*)p)[len] = *(fims__QueryExpressionType **)q;
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTofims__SuperLockTokenType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container EDLProvider_container_insert type = %d in %d location = %p object = %p len = %lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<fims__SuperLockTokenType * >*)p)[len] = *(fims__SuperLockTokenType **)q;
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTofims__LockTokenType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container EDLProvider_container_insert type = %d in %d location = %p object = %p len = %lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<fims__LockTokenType * >*)p)[len] = *(fims__LockTokenType **)q;
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTofims__CredentialType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container EDLProvider_container_insert type = %d in %d location = %p object = %p len = %lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<fims__CredentialType * >*)p)[len] = *(fims__CredentialType **)q;
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTofims__BMEssenceLocatorStatusType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container EDLProvider_container_insert type = %d in %d location = %p object = %p len = %lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<fims__BMEssenceLocatorStatusType * >*)p)[len] = *(fims__BMEssenceLocatorStatusType **)q;
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTofims__BMContentStatusType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container EDLProvider_container_insert type = %d in %d location = %p object = %p len = %lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<fims__BMContentStatusType * >*)p)[len] = *(fims__BMContentStatusType **)q;
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTofims__BMCustomStatusExtensionType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container EDLProvider_container_insert type = %d in %d location = %p object = %p len = %lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<fims__BMCustomStatusExtensionType * >*)p)[len] = *(fims__BMCustomStatusExtensionType **)q;
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTofims__CustomValueType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container EDLProvider_container_insert type = %d in %d location = %p object = %p len = %lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<fims__CustomValueType * >*)p)[len] = *(fims__CustomValueType **)q;
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTofims__ResourceReferenceType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container EDLProvider_container_insert type = %d in %d location = %p object = %p len = %lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<fims__ResourceReferenceType * >*)p)[len] = *(fims__ResourceReferenceType **)q;
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTofims__DescriptionType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container EDLProvider_container_insert type = %d in %d location = %p object = %p len = %lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<fims__DescriptionType * >*)p)[len] = *(fims__DescriptionType **)q;
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTofims__BMEssenceLocatorType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container EDLProvider_container_insert type = %d in %d location = %p object = %p len = %lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<fims__BMEssenceLocatorType * >*)p)[len] = *(fims__BMEssenceLocatorType **)q;
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTofims__BMContentFormatType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container EDLProvider_container_insert type = %d in %d location = %p object = %p len = %lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<fims__BMContentFormatType * >*)p)[len] = *(fims__BMContentFormatType **)q;
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTofims__BMContentType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container EDLProvider_container_insert type = %d in %d location = %p object = %p len = %lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<fims__BMContentType * >*)p)[len] = *(fims__BMContentType **)q;
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTofims__BMObjectType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container EDLProvider_container_insert type = %d in %d location = %p object = %p len = %lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<fims__BMObjectType * >*)p)[len] = *(fims__BMObjectType **)q;
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTofims__DataFormatType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container EDLProvider_container_insert type = %d in %d location = %p object = %p len = %lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<fims__DataFormatType * >*)p)[len] = *(fims__DataFormatType **)q;
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTofims__ContainerFormatType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container EDLProvider_container_insert type = %d in %d location = %p object = %p len = %lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<fims__ContainerFormatType * >*)p)[len] = *(fims__ContainerFormatType **)q;
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTofims__AudioFormatType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container EDLProvider_container_insert type = %d in %d location = %p object = %p len = %lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<fims__AudioFormatType * >*)p)[len] = *(fims__AudioFormatType **)q;
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTofims__VideoFormatType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container EDLProvider_container_insert type = %d in %d location = %p object = %p len = %lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<fims__VideoFormatType * >*)p)[len] = *(fims__VideoFormatType **)q;
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTofims__JobType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container EDLProvider_container_insert type = %d in %d location = %p object = %p len = %lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<fims__JobType * >*)p)[len] = *(fims__JobType **)q;
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTofims__QueueType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container EDLProvider_container_insert type = %d in %d location = %p object = %p len = %lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<fims__QueueType * >*)p)[len] = *(fims__QueueType **)q;
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTofims__ServiceType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container EDLProvider_container_insert type = %d in %d location = %p object = %p len = %lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<fims__ServiceType * >*)p)[len] = *(fims__ServiceType **)q;
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTofims__ProfileType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container EDLProvider_container_insert type = %d in %d location = %p object = %p len = %lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<fims__ProfileType * >*)p)[len] = *(fims__ProfileType **)q;
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTofims__ResourceType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container EDLProvider_container_insert type = %d in %d location = %p object = %p len = %lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<fims__ResourceType * >*)p)[len] = *(fims__ResourceType **)q;
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTofims__InnerFaultType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container EDLProvider_container_insert type = %d in %d location = %p object = %p len = %lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<fims__InnerFaultType * >*)p)[len] = *(fims__InnerFaultType **)q;
		break;
	case SOAP_TYPE_std__vectorTemplateOf_XML:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container EDLProvider_container_insert type = %d in %d location = %p object = %p len = %lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<char * >*)p)[len] = *(char **)q;
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerToedlprovider__MapItemType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container EDLProvider_container_insert type = %d in %d location = %p object = %p len = %lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<edlprovider__MapItemType * >*)p)[len] = *(edlprovider__MapItemType **)q;
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerToedlprovider__ClipType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container EDLProvider_container_insert type = %d in %d location = %p object = %p len = %lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<edlprovider__ClipType * >*)p)[len] = *(edlprovider__ClipType **)q;
		break;
	case SOAP_TYPE_std__vectorTemplateOfstd__wstring:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container EDLProvider_container_insert type = %d in %d location = %p object = %p len = %lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<std::wstring >*)p)[len] = *(std::wstring *)q;
		break;
	default:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Could not insert type = %d in %d\n", st, tt));
	}
#ifdef WIN32
#pragma warning(pop)
#endif
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_byte(struct soap *soap, char *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_byte
	*a = SOAP_DEFAULT_byte;
#else
	*a = (char)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_byte(struct soap *soap, const char *tag, int id, const char *a, const char *type)
{
	return soap_outbyte(soap, tag, id, a, type, SOAP_TYPE_byte);
}

SOAP_FMAC3 char * SOAP_FMAC4 soap_in_byte(struct soap *soap, const char *tag, char *a, const char *type)
{	char *p;
	p = soap_inbyte(soap, tag, a, type, SOAP_TYPE_byte);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_byte(struct soap *soap, const char *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_byte);
	if (soap_out_byte(soap, tag?tag:"byte", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char * SOAP_FMAC4 soap_get_byte(struct soap *soap, char *p, const char *tag, const char *type)
{
	if ((p = soap_in_byte(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_int(struct soap *soap, int *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_int
	*a = SOAP_DEFAULT_int;
#else
	*a = (int)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_int(struct soap *soap, const char *tag, int id, const int *a, const char *type)
{
	return soap_outint(soap, tag, id, a, type, SOAP_TYPE_int);
}

SOAP_FMAC3 int * SOAP_FMAC4 soap_in_int(struct soap *soap, const char *tag, int *a, const char *type)
{	int *p;
	p = soap_inint(soap, tag, a, type, SOAP_TYPE_int);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_int(struct soap *soap, const int *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_int);
	if (soap_out_int(soap, tag?tag:"int", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int * SOAP_FMAC4 soap_get_int(struct soap *soap, int *p, const char *tag, const char *type)
{
	if ((p = soap_in_int(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_LONG64(struct soap *soap, LONG64 *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_LONG64
	*a = SOAP_DEFAULT_LONG64;
#else
	*a = (LONG64)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_LONG64(struct soap *soap, const char *tag, int id, const LONG64 *a, const char *type)
{
	return soap_outLONG64(soap, tag, id, a, type, SOAP_TYPE_LONG64);
}

SOAP_FMAC3 LONG64 * SOAP_FMAC4 soap_in_LONG64(struct soap *soap, const char *tag, LONG64 *a, const char *type)
{	LONG64 *p;
	p = soap_inLONG64(soap, tag, a, type, SOAP_TYPE_LONG64);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_LONG64(struct soap *soap, const LONG64 *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_LONG64);
	if (soap_out_LONG64(soap, tag?tag:"long", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 LONG64 * SOAP_FMAC4 soap_get_LONG64(struct soap *soap, LONG64 *p, const char *tag, const char *type)
{
	if ((p = soap_in_LONG64(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xsd__duration(struct soap *soap, const LONG64 *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_xsd__duration);
	if (soap_out_xsd__duration(soap, tag?tag:"xsd:duration", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 LONG64 * SOAP_FMAC4 soap_get_xsd__duration(struct soap *soap, LONG64 *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__duration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_float(struct soap *soap, float *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_float
	*a = SOAP_DEFAULT_float;
#else
	*a = (float)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_float(struct soap *soap, const char *tag, int id, const float *a, const char *type)
{
	return soap_outfloat(soap, tag, id, a, type, SOAP_TYPE_float);
}

SOAP_FMAC3 float * SOAP_FMAC4 soap_in_float(struct soap *soap, const char *tag, float *a, const char *type)
{	float *p;
	p = soap_infloat(soap, tag, a, type, SOAP_TYPE_float);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_float(struct soap *soap, const float *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_float);
	if (soap_out_float(soap, tag?tag:"float", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 float * SOAP_FMAC4 soap_get_float(struct soap *soap, float *p, const char *tag, const char *type)
{
	if ((p = soap_in_float(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_double(struct soap *soap, double *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_double
	*a = SOAP_DEFAULT_double;
#else
	*a = (double)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_double(struct soap *soap, const char *tag, int id, const double *a, const char *type)
{
	return soap_outdouble(soap, tag, id, a, type, SOAP_TYPE_double);
}

SOAP_FMAC3 double * SOAP_FMAC4 soap_in_double(struct soap *soap, const char *tag, double *a, const char *type)
{	double *p;
	p = soap_indouble(soap, tag, a, type, SOAP_TYPE_double);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_double(struct soap *soap, const double *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_double);
	if (soap_out_double(soap, tag?tag:"double", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 double * SOAP_FMAC4 soap_get_double(struct soap *soap, double *p, const char *tag, const char *type)
{
	if ((p = soap_in_double(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_unsignedByte(struct soap *soap, unsigned char *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_unsignedByte
	*a = SOAP_DEFAULT_unsignedByte;
#else
	*a = (unsigned char)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_unsignedByte(struct soap *soap, const char *tag, int id, const unsigned char *a, const char *type)
{
	return soap_outunsignedByte(soap, tag, id, a, type, SOAP_TYPE_unsignedByte);
}

SOAP_FMAC3 unsigned char * SOAP_FMAC4 soap_in_unsignedByte(struct soap *soap, const char *tag, unsigned char *a, const char *type)
{	unsigned char *p;
	p = soap_inunsignedByte(soap, tag, a, type, SOAP_TYPE_unsignedByte);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_unsignedByte(struct soap *soap, const unsigned char *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_unsignedByte);
	if (soap_out_unsignedByte(soap, tag?tag:"unsignedByte", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 unsigned char * SOAP_FMAC4 soap_get_unsignedByte(struct soap *soap, unsigned char *p, const char *tag, const char *type)
{
	if ((p = soap_in_unsignedByte(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_unsignedInt(struct soap *soap, unsigned int *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_unsignedInt
	*a = SOAP_DEFAULT_unsignedInt;
#else
	*a = (unsigned int)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_unsignedInt(struct soap *soap, const char *tag, int id, const unsigned int *a, const char *type)
{
	return soap_outunsignedInt(soap, tag, id, a, type, SOAP_TYPE_unsignedInt);
}

SOAP_FMAC3 unsigned int * SOAP_FMAC4 soap_in_unsignedInt(struct soap *soap, const char *tag, unsigned int *a, const char *type)
{	unsigned int *p;
	p = soap_inunsignedInt(soap, tag, a, type, SOAP_TYPE_unsignedInt);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_unsignedInt(struct soap *soap, const unsigned int *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_unsignedInt);
	if (soap_out_unsignedInt(soap, tag?tag:"unsignedInt", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 unsigned int * SOAP_FMAC4 soap_get_unsignedInt(struct soap *soap, unsigned int *p, const char *tag, const char *type)
{
	if ((p = soap_in_unsignedInt(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_unsignedLONG64(struct soap *soap, ULONG64 *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_unsignedLONG64
	*a = SOAP_DEFAULT_unsignedLONG64;
#else
	*a = (ULONG64)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_unsignedLONG64(struct soap *soap, const char *tag, int id, const ULONG64 *a, const char *type)
{
	return soap_outULONG64(soap, tag, id, a, type, SOAP_TYPE_unsignedLONG64);
}

SOAP_FMAC3 ULONG64 * SOAP_FMAC4 soap_in_unsignedLONG64(struct soap *soap, const char *tag, ULONG64 *a, const char *type)
{	ULONG64 *p;
	p = soap_inULONG64(soap, tag, a, type, SOAP_TYPE_unsignedLONG64);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_unsignedLONG64(struct soap *soap, const ULONG64 *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_unsignedLONG64);
	if (soap_out_unsignedLONG64(soap, tag?tag:"unsignedLong", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ULONG64 * SOAP_FMAC4 soap_get_unsignedLONG64(struct soap *soap, ULONG64 *p, const char *tag, const char *type)
{
	if ((p = soap_in_unsignedLONG64(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_time(struct soap *soap, time_t *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_time
	*a = SOAP_DEFAULT_time;
#else
	*a = (time_t)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_time(struct soap *soap, const char *tag, int id, const time_t *a, const char *type)
{
	return soap_outdateTime(soap, tag, id, a, type, SOAP_TYPE_time);
}

SOAP_FMAC3 time_t * SOAP_FMAC4 soap_in_time(struct soap *soap, const char *tag, time_t *a, const char *type)
{	time_t *p;
	p = soap_indateTime(soap, tag, a, type, SOAP_TYPE_time);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_time(struct soap *soap, const time_t *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_time);
	if (soap_out_time(soap, tag?tag:"dateTime", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 time_t * SOAP_FMAC4 soap_get_time(struct soap *soap, time_t *p, const char *tag, const char *type)
{
	if ((p = soap_in_time(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_bool(struct soap *soap, bool *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_bool
	*a = SOAP_DEFAULT_bool;
#else
	*a = (bool)0;
#endif
}

static const struct soap_code_map soap_codes_bool[] =
{	{ (long)false, "false" },
	{ (long)true, "true" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_bool2s(struct soap *soap, bool n)
{
	(void)soap; /* appease -Wall -Werror */
return soap_code_str(soap_codes_bool, n != 0);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_bool(struct soap *soap, const char *tag, int id, const bool *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_bool), type) || soap_send(soap, soap_bool2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2bool(struct soap *soap, const char *s, bool *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_bool, s);
	if (map)
		*a = (bool)(map->code != 0);
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || n < 0 || n > 1)
			return soap->error = SOAP_TYPE;
		*a = (bool)(n != 0);
	}
	return SOAP_OK;
}

SOAP_FMAC3 bool * SOAP_FMAC4 soap_in_bool(struct soap *soap, const char *tag, bool *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type) && soap_match_tag(soap, soap->type, ":boolean"))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (bool *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_bool, sizeof(bool), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2bool(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (bool *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_bool, 0, sizeof(bool), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_bool(struct soap *soap, const bool *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_bool);
	if (soap_out_bool(soap, tag?tag:"boolean", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 bool * SOAP_FMAC4 soap_get_bool(struct soap *soap, bool *p, const char *tag, const char *type)
{
	if ((p = soap_in_bool(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__fims__QueryServiceDescriptionRequestType_responseType(struct soap *soap, enum _fims__QueryServiceDescriptionRequestType_responseType *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT__fims__QueryServiceDescriptionRequestType_responseType
	*a = SOAP_DEFAULT__fims__QueryServiceDescriptionRequestType_responseType;
#else
	*a = (enum _fims__QueryServiceDescriptionRequestType_responseType)0;
#endif
}

static const struct soap_code_map soap_codes__fims__QueryServiceDescriptionRequestType_responseType[] =
{	{ (long)_fims__QueryServiceDescriptionRequestType_responseType__ref, "ref" },
	{ (long)_fims__QueryServiceDescriptionRequestType_responseType__value, "value" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap__fims__QueryServiceDescriptionRequestType_responseType2s(struct soap *soap, enum _fims__QueryServiceDescriptionRequestType_responseType n)
{	const char *s = soap_code_str(soap_codes__fims__QueryServiceDescriptionRequestType_responseType, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__fims__QueryServiceDescriptionRequestType_responseType(struct soap *soap, const char *tag, int id, const enum _fims__QueryServiceDescriptionRequestType_responseType *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__fims__QueryServiceDescriptionRequestType_responseType), type) || soap_send(soap, soap__fims__QueryServiceDescriptionRequestType_responseType2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2_fims__QueryServiceDescriptionRequestType_responseType(struct soap *soap, const char *s, enum _fims__QueryServiceDescriptionRequestType_responseType *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes__fims__QueryServiceDescriptionRequestType_responseType, s);
	if (map)
		*a = (enum _fims__QueryServiceDescriptionRequestType_responseType)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 1)))
			return soap->error = SOAP_TYPE;
		*a = (enum _fims__QueryServiceDescriptionRequestType_responseType)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum _fims__QueryServiceDescriptionRequestType_responseType * SOAP_FMAC4 soap_in__fims__QueryServiceDescriptionRequestType_responseType(struct soap *soap, const char *tag, enum _fims__QueryServiceDescriptionRequestType_responseType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum _fims__QueryServiceDescriptionRequestType_responseType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__fims__QueryServiceDescriptionRequestType_responseType, sizeof(enum _fims__QueryServiceDescriptionRequestType_responseType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2_fims__QueryServiceDescriptionRequestType_responseType(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum _fims__QueryServiceDescriptionRequestType_responseType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__fims__QueryServiceDescriptionRequestType_responseType, 0, sizeof(enum _fims__QueryServiceDescriptionRequestType_responseType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__fims__QueryServiceDescriptionRequestType_responseType(struct soap *soap, const enum _fims__QueryServiceDescriptionRequestType_responseType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__fims__QueryServiceDescriptionRequestType_responseType);
	if (soap_out__fims__QueryServiceDescriptionRequestType_responseType(soap, tag?tag:"fims:QueryServiceDescriptionRequestType-responseType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum _fims__QueryServiceDescriptionRequestType_responseType * SOAP_FMAC4 soap_get__fims__QueryServiceDescriptionRequestType_responseType(struct soap *soap, enum _fims__QueryServiceDescriptionRequestType_responseType *p, const char *tag, const char *type)
{
	if ((p = soap_in__fims__QueryServiceDescriptionRequestType_responseType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_fims__EventClassificationType(struct soap *soap, enum fims__EventClassificationType *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_fims__EventClassificationType
	*a = SOAP_DEFAULT_fims__EventClassificationType;
#else
	*a = (enum fims__EventClassificationType)0;
#endif
}

static const struct soap_code_map soap_codes_fims__EventClassificationType[] =
{	{ (long)fims__EventClassificationType__error, "error" },
	{ (long)fims__EventClassificationType__warning, "warning" },
	{ (long)fims__EventClassificationType__information, "information" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_fims__EventClassificationType2s(struct soap *soap, enum fims__EventClassificationType n)
{	const char *s = soap_code_str(soap_codes_fims__EventClassificationType, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_fims__EventClassificationType(struct soap *soap, const char *tag, int id, const enum fims__EventClassificationType *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_fims__EventClassificationType), type) || soap_send(soap, soap_fims__EventClassificationType2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2fims__EventClassificationType(struct soap *soap, const char *s, enum fims__EventClassificationType *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_fims__EventClassificationType, s);
	if (map)
		*a = (enum fims__EventClassificationType)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 2)))
			return soap->error = SOAP_TYPE;
		*a = (enum fims__EventClassificationType)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum fims__EventClassificationType * SOAP_FMAC4 soap_in_fims__EventClassificationType(struct soap *soap, const char *tag, enum fims__EventClassificationType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum fims__EventClassificationType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_fims__EventClassificationType, sizeof(enum fims__EventClassificationType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2fims__EventClassificationType(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum fims__EventClassificationType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_fims__EventClassificationType, 0, sizeof(enum fims__EventClassificationType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_fims__EventClassificationType(struct soap *soap, const enum fims__EventClassificationType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_fims__EventClassificationType);
	if (soap_out_fims__EventClassificationType(soap, tag?tag:"fims:EventClassificationType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum fims__EventClassificationType * SOAP_FMAC4 soap_get_fims__EventClassificationType(struct soap *soap, enum fims__EventClassificationType *p, const char *tag, const char *type)
{
	if ((p = soap_in_fims__EventClassificationType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_fims__EventSubType(struct soap *soap, enum fims__EventSubType *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_fims__EventSubType
	*a = SOAP_DEFAULT_fims__EventSubType;
#else
	*a = (enum fims__EventSubType)0;
#endif
}

static const struct soap_code_map soap_codes_fims__EventSubType[] =
{	{ (long)fims__EventSubType__systemException, "systemException" },
	{ (long)fims__EventSubType__systemPerformance, "systemPerformance" },
	{ (long)fims__EventSubType__created, "created" },
	{ (long)fims__EventSubType__removed, "removed" },
	{ (long)fims__EventSubType__purged, "purged" },
	{ (long)fims__EventSubType__relocated, "relocated" },
	{ (long)fims__EventSubType__newFormatAvailable, "newFormatAvailable" },
	{ (long)fims__EventSubType__copied, "copied" },
	{ (long)fims__EventSubType__qced, "qced" },
	{ (long)fims__EventSubType__modified, "modified" },
	{ (long)fims__EventSubType__custom, "custom" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_fims__EventSubType2s(struct soap *soap, enum fims__EventSubType n)
{	const char *s = soap_code_str(soap_codes_fims__EventSubType, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_fims__EventSubType(struct soap *soap, const char *tag, int id, const enum fims__EventSubType *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_fims__EventSubType), type) || soap_send(soap, soap_fims__EventSubType2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2fims__EventSubType(struct soap *soap, const char *s, enum fims__EventSubType *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_fims__EventSubType, s);
	if (map)
		*a = (enum fims__EventSubType)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 10)))
			return soap->error = SOAP_TYPE;
		*a = (enum fims__EventSubType)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum fims__EventSubType * SOAP_FMAC4 soap_in_fims__EventSubType(struct soap *soap, const char *tag, enum fims__EventSubType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum fims__EventSubType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_fims__EventSubType, sizeof(enum fims__EventSubType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2fims__EventSubType(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum fims__EventSubType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_fims__EventSubType, 0, sizeof(enum fims__EventSubType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_fims__EventSubType(struct soap *soap, const enum fims__EventSubType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_fims__EventSubType);
	if (soap_out_fims__EventSubType(soap, tag?tag:"fims:EventSubType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum fims__EventSubType * SOAP_FMAC4 soap_get_fims__EventSubType(struct soap *soap, enum fims__EventSubType *p, const char *tag, const char *type)
{
	if ((p = soap_in_fims__EventSubType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_fims__EventType(struct soap *soap, enum fims__EventType *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_fims__EventType
	*a = SOAP_DEFAULT_fims__EventType;
#else
	*a = (enum fims__EventType)0;
#endif
}

static const struct soap_code_map soap_codes_fims__EventType[] =
{	{ (long)fims__EventType__system, "system" },
	{ (long)fims__EventType__content, "content" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_fims__EventType2s(struct soap *soap, enum fims__EventType n)
{	const char *s = soap_code_str(soap_codes_fims__EventType, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_fims__EventType(struct soap *soap, const char *tag, int id, const enum fims__EventType *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_fims__EventType), type) || soap_send(soap, soap_fims__EventType2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2fims__EventType(struct soap *soap, const char *s, enum fims__EventType *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_fims__EventType, s);
	if (map)
		*a = (enum fims__EventType)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 1)))
			return soap->error = SOAP_TYPE;
		*a = (enum fims__EventType)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum fims__EventType * SOAP_FMAC4 soap_in_fims__EventType(struct soap *soap, const char *tag, enum fims__EventType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum fims__EventType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_fims__EventType, sizeof(enum fims__EventType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2fims__EventType(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum fims__EventType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_fims__EventType, 0, sizeof(enum fims__EventType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_fims__EventType(struct soap *soap, const enum fims__EventType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_fims__EventType);
	if (soap_out_fims__EventType(soap, tag?tag:"fims:EventType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum fims__EventType * SOAP_FMAC4 soap_get_fims__EventType(struct soap *soap, enum fims__EventType *p, const char *tag, const char *type)
{
	if ((p = soap_in_fims__EventType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_fims__QueryParameterOperatorType(struct soap *soap, enum fims__QueryParameterOperatorType *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_fims__QueryParameterOperatorType
	*a = SOAP_DEFAULT_fims__QueryParameterOperatorType;
#else
	*a = (enum fims__QueryParameterOperatorType)0;
#endif
}

static const struct soap_code_map soap_codes_fims__QueryParameterOperatorType[] =
{	{ (long)fims__QueryParameterOperatorType__equal, "equal" },
	{ (long)fims__QueryParameterOperatorType__notEqual, "notEqual" },
	{ (long)fims__QueryParameterOperatorType__greater, "greater" },
	{ (long)fims__QueryParameterOperatorType__less, "less" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_fims__QueryParameterOperatorType2s(struct soap *soap, enum fims__QueryParameterOperatorType n)
{	const char *s = soap_code_str(soap_codes_fims__QueryParameterOperatorType, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_fims__QueryParameterOperatorType(struct soap *soap, const char *tag, int id, const enum fims__QueryParameterOperatorType *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_fims__QueryParameterOperatorType), type) || soap_send(soap, soap_fims__QueryParameterOperatorType2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2fims__QueryParameterOperatorType(struct soap *soap, const char *s, enum fims__QueryParameterOperatorType *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_fims__QueryParameterOperatorType, s);
	if (map)
		*a = (enum fims__QueryParameterOperatorType)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 3)))
			return soap->error = SOAP_TYPE;
		*a = (enum fims__QueryParameterOperatorType)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum fims__QueryParameterOperatorType * SOAP_FMAC4 soap_in_fims__QueryParameterOperatorType(struct soap *soap, const char *tag, enum fims__QueryParameterOperatorType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum fims__QueryParameterOperatorType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_fims__QueryParameterOperatorType, sizeof(enum fims__QueryParameterOperatorType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2fims__QueryParameterOperatorType(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum fims__QueryParameterOperatorType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_fims__QueryParameterOperatorType, 0, sizeof(enum fims__QueryParameterOperatorType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_fims__QueryParameterOperatorType(struct soap *soap, const enum fims__QueryParameterOperatorType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_fims__QueryParameterOperatorType);
	if (soap_out_fims__QueryParameterOperatorType(soap, tag?tag:"fims:QueryParameterOperatorType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum fims__QueryParameterOperatorType * SOAP_FMAC4 soap_get_fims__QueryParameterOperatorType(struct soap *soap, enum fims__QueryParameterOperatorType *p, const char *tag, const char *type)
{
	if ((p = soap_in_fims__QueryParameterOperatorType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_fims__QueryGroupOperatorType(struct soap *soap, enum fims__QueryGroupOperatorType *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_fims__QueryGroupOperatorType
	*a = SOAP_DEFAULT_fims__QueryGroupOperatorType;
#else
	*a = (enum fims__QueryGroupOperatorType)0;
#endif
}

static const struct soap_code_map soap_codes_fims__QueryGroupOperatorType[] =
{	{ (long)fims__QueryGroupOperatorType__and_, "and" },
	{ (long)fims__QueryGroupOperatorType__or_, "or" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_fims__QueryGroupOperatorType2s(struct soap *soap, enum fims__QueryGroupOperatorType n)
{	const char *s = soap_code_str(soap_codes_fims__QueryGroupOperatorType, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_fims__QueryGroupOperatorType(struct soap *soap, const char *tag, int id, const enum fims__QueryGroupOperatorType *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_fims__QueryGroupOperatorType), type) || soap_send(soap, soap_fims__QueryGroupOperatorType2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2fims__QueryGroupOperatorType(struct soap *soap, const char *s, enum fims__QueryGroupOperatorType *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_fims__QueryGroupOperatorType, s);
	if (map)
		*a = (enum fims__QueryGroupOperatorType)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 1)))
			return soap->error = SOAP_TYPE;
		*a = (enum fims__QueryGroupOperatorType)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum fims__QueryGroupOperatorType * SOAP_FMAC4 soap_in_fims__QueryGroupOperatorType(struct soap *soap, const char *tag, enum fims__QueryGroupOperatorType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum fims__QueryGroupOperatorType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_fims__QueryGroupOperatorType, sizeof(enum fims__QueryGroupOperatorType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2fims__QueryGroupOperatorType(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum fims__QueryGroupOperatorType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_fims__QueryGroupOperatorType, 0, sizeof(enum fims__QueryGroupOperatorType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_fims__QueryGroupOperatorType(struct soap *soap, const enum fims__QueryGroupOperatorType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_fims__QueryGroupOperatorType);
	if (soap_out_fims__QueryGroupOperatorType(soap, tag?tag:"fims:QueryGroupOperatorType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum fims__QueryGroupOperatorType * SOAP_FMAC4 soap_get_fims__QueryGroupOperatorType(struct soap *soap, enum fims__QueryGroupOperatorType *p, const char *tag, const char *type)
{
	if ((p = soap_in_fims__QueryGroupOperatorType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_fims__BMStatusType(struct soap *soap, enum fims__BMStatusType *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_fims__BMStatusType
	*a = SOAP_DEFAULT_fims__BMStatusType;
#else
	*a = (enum fims__BMStatusType)0;
#endif
}

static const struct soap_code_map soap_codes_fims__BMStatusType[] =
{	{ (long)fims__BMStatusType__new_, "new" },
	{ (long)fims__BMStatusType__online, "online" },
	{ (long)fims__BMStatusType__offline, "offline" },
	{ (long)fims__BMStatusType__removed, "removed" },
	{ (long)fims__BMStatusType__purged, "purged" },
	{ (long)fims__BMStatusType__invalid, "invalid" },
	{ (long)fims__BMStatusType__processing, "processing" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_fims__BMStatusType2s(struct soap *soap, enum fims__BMStatusType n)
{	const char *s = soap_code_str(soap_codes_fims__BMStatusType, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_fims__BMStatusType(struct soap *soap, const char *tag, int id, const enum fims__BMStatusType *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_fims__BMStatusType), type) || soap_send(soap, soap_fims__BMStatusType2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2fims__BMStatusType(struct soap *soap, const char *s, enum fims__BMStatusType *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_fims__BMStatusType, s);
	if (map)
		*a = (enum fims__BMStatusType)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 6)))
			return soap->error = SOAP_TYPE;
		*a = (enum fims__BMStatusType)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum fims__BMStatusType * SOAP_FMAC4 soap_in_fims__BMStatusType(struct soap *soap, const char *tag, enum fims__BMStatusType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum fims__BMStatusType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_fims__BMStatusType, sizeof(enum fims__BMStatusType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2fims__BMStatusType(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum fims__BMStatusType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_fims__BMStatusType, 0, sizeof(enum fims__BMStatusType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_fims__BMStatusType(struct soap *soap, const enum fims__BMStatusType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_fims__BMStatusType);
	if (soap_out_fims__BMStatusType(soap, tag?tag:"fims:BMStatusType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum fims__BMStatusType * SOAP_FMAC4 soap_get_fims__BMStatusType(struct soap *soap, enum fims__BMStatusType *p, const char *tag, const char *type)
{
	if ((p = soap_in_fims__BMStatusType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_fims__DataTypeType(struct soap *soap, enum fims__DataTypeType *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_fims__DataTypeType
	*a = SOAP_DEFAULT_fims__DataTypeType;
#else
	*a = (enum fims__DataTypeType)0;
#endif
}

static const struct soap_code_map soap_codes_fims__DataTypeType[] =
{	{ (long)fims__DataTypeType__duration, "duration" },
	{ (long)fims__DataTypeType__dateTime, "dateTime" },
	{ (long)fims__DataTypeType__time, "time" },
	{ (long)fims__DataTypeType__date, "date" },
	{ (long)fims__DataTypeType__gYearMonth, "gYearMonth" },
	{ (long)fims__DataTypeType__gYear, "gYear" },
	{ (long)fims__DataTypeType__gMonthDay, "gMonthDay" },
	{ (long)fims__DataTypeType__gDay, "gDay" },
	{ (long)fims__DataTypeType__gMonth, "gMonth" },
	{ (long)fims__DataTypeType__boolean, "boolean" },
	{ (long)fims__DataTypeType__base64Binary, "base64Binary" },
	{ (long)fims__DataTypeType__hexBinary, "hexBinary" },
	{ (long)fims__DataTypeType__float_, "float" },
	{ (long)fims__DataTypeType__double_, "double" },
	{ (long)fims__DataTypeType__anyURI, "anyURI" },
	{ (long)fims__DataTypeType__decimal, "decimal" },
	{ (long)fims__DataTypeType__integer, "integer" },
	{ (long)fims__DataTypeType__nonPositiveInteger, "nonPositiveInteger" },
	{ (long)fims__DataTypeType__nonNegativeInteger, "nonNegativeInteger" },
	{ (long)fims__DataTypeType__long_, "long" },
	{ (long)fims__DataTypeType__positiveInteger, "positiveInteger" },
	{ (long)fims__DataTypeType__negativeInteger, "negativeInteger" },
	{ (long)fims__DataTypeType__int_, "int" },
	{ (long)fims__DataTypeType__unsignedLong, "unsignedLong" },
	{ (long)fims__DataTypeType__unsignedInt, "unsignedInt" },
	{ (long)fims__DataTypeType__short_, "short" },
	{ (long)fims__DataTypeType__unsignedShort, "unsignedShort" },
	{ (long)fims__DataTypeType__byte, "byte" },
	{ (long)fims__DataTypeType__unsignedByte, "unsignedByte" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_fims__DataTypeType2s(struct soap *soap, enum fims__DataTypeType n)
{	const char *s = soap_code_str(soap_codes_fims__DataTypeType, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_fims__DataTypeType(struct soap *soap, const char *tag, int id, const enum fims__DataTypeType *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_fims__DataTypeType), type) || soap_send(soap, soap_fims__DataTypeType2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2fims__DataTypeType(struct soap *soap, const char *s, enum fims__DataTypeType *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_fims__DataTypeType, s);
	if (map)
		*a = (enum fims__DataTypeType)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 28)))
			return soap->error = SOAP_TYPE;
		*a = (enum fims__DataTypeType)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum fims__DataTypeType * SOAP_FMAC4 soap_in_fims__DataTypeType(struct soap *soap, const char *tag, enum fims__DataTypeType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum fims__DataTypeType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_fims__DataTypeType, sizeof(enum fims__DataTypeType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2fims__DataTypeType(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum fims__DataTypeType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_fims__DataTypeType, 0, sizeof(enum fims__DataTypeType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_fims__DataTypeType(struct soap *soap, const enum fims__DataTypeType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_fims__DataTypeType);
	if (soap_out_fims__DataTypeType(soap, tag?tag:"fims:DataTypeType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum fims__DataTypeType * SOAP_FMAC4 soap_get_fims__DataTypeType(struct soap *soap, enum fims__DataTypeType *p, const char *tag, const char *type)
{
	if ((p = soap_in_fims__DataTypeType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_fims__JobInfoSelectionType(struct soap *soap, enum fims__JobInfoSelectionType *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_fims__JobInfoSelectionType
	*a = SOAP_DEFAULT_fims__JobInfoSelectionType;
#else
	*a = (enum fims__JobInfoSelectionType)0;
#endif
}

static const struct soap_code_map soap_codes_fims__JobInfoSelectionType[] =
{	{ (long)fims__JobInfoSelectionType__mandatory, "mandatory" },
	{ (long)fims__JobInfoSelectionType__all, "all" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_fims__JobInfoSelectionType2s(struct soap *soap, enum fims__JobInfoSelectionType n)
{	const char *s = soap_code_str(soap_codes_fims__JobInfoSelectionType, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_fims__JobInfoSelectionType(struct soap *soap, const char *tag, int id, const enum fims__JobInfoSelectionType *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_fims__JobInfoSelectionType), type) || soap_send(soap, soap_fims__JobInfoSelectionType2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2fims__JobInfoSelectionType(struct soap *soap, const char *s, enum fims__JobInfoSelectionType *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_fims__JobInfoSelectionType, s);
	if (map)
		*a = (enum fims__JobInfoSelectionType)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 1)))
			return soap->error = SOAP_TYPE;
		*a = (enum fims__JobInfoSelectionType)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum fims__JobInfoSelectionType * SOAP_FMAC4 soap_in_fims__JobInfoSelectionType(struct soap *soap, const char *tag, enum fims__JobInfoSelectionType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum fims__JobInfoSelectionType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_fims__JobInfoSelectionType, sizeof(enum fims__JobInfoSelectionType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2fims__JobInfoSelectionType(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum fims__JobInfoSelectionType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_fims__JobInfoSelectionType, 0, sizeof(enum fims__JobInfoSelectionType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_fims__JobInfoSelectionType(struct soap *soap, const enum fims__JobInfoSelectionType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_fims__JobInfoSelectionType);
	if (soap_out_fims__JobInfoSelectionType(soap, tag?tag:"fims:JobInfoSelectionType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum fims__JobInfoSelectionType * SOAP_FMAC4 soap_get_fims__JobInfoSelectionType(struct soap *soap, enum fims__JobInfoSelectionType *p, const char *tag, const char *type)
{
	if ((p = soap_in_fims__JobInfoSelectionType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_fims__ErrorCodeType(struct soap *soap, enum fims__ErrorCodeType *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_fims__ErrorCodeType
	*a = SOAP_DEFAULT_fims__ErrorCodeType;
#else
	*a = (enum fims__ErrorCodeType)0;
#endif
}

static const struct soap_code_map soap_codes_fims__ErrorCodeType[] =
{	{ (long)fims__ErrorCodeType__INF_USCORES00_USCORE0001, "INF_S00_0001" },
	{ (long)fims__ErrorCodeType__INF_USCORES00_USCORE0002, "INF_S00_0002" },
	{ (long)fims__ErrorCodeType__INF_USCORES00_USCORE0003, "INF_S00_0003" },
	{ (long)fims__ErrorCodeType__INF_USCORES00_USCORE0004, "INF_S00_0004" },
	{ (long)fims__ErrorCodeType__INF_USCORES00_USCORE0005, "INF_S00_0005" },
	{ (long)fims__ErrorCodeType__INF_USCORES00_USCORE0006, "INF_S00_0006" },
	{ (long)fims__ErrorCodeType__INF_USCORES00_USCORE0007, "INF_S00_0007" },
	{ (long)fims__ErrorCodeType__SVC_USCORES00_USCORE0001, "SVC_S00_0001" },
	{ (long)fims__ErrorCodeType__SVC_USCORES00_USCORE0002, "SVC_S00_0002" },
	{ (long)fims__ErrorCodeType__SVC_USCORES00_USCORE0003, "SVC_S00_0003" },
	{ (long)fims__ErrorCodeType__SVC_USCORES00_USCORE0004, "SVC_S00_0004" },
	{ (long)fims__ErrorCodeType__SVC_USCORES00_USCORE0005, "SVC_S00_0005" },
	{ (long)fims__ErrorCodeType__SVC_USCORES00_USCORE0006, "SVC_S00_0006" },
	{ (long)fims__ErrorCodeType__SVC_USCORES00_USCORE0007, "SVC_S00_0007" },
	{ (long)fims__ErrorCodeType__SVC_USCORES00_USCORE0008, "SVC_S00_0008" },
	{ (long)fims__ErrorCodeType__SVC_USCORES00_USCORE0009, "SVC_S00_0009" },
	{ (long)fims__ErrorCodeType__SVC_USCORES00_USCORE0010, "SVC_S00_0010" },
	{ (long)fims__ErrorCodeType__SVC_USCORES00_USCORE0011, "SVC_S00_0011" },
	{ (long)fims__ErrorCodeType__SVC_USCORES00_USCORE0012, "SVC_S00_0012" },
	{ (long)fims__ErrorCodeType__SVC_USCORES00_USCORE0013, "SVC_S00_0013" },
	{ (long)fims__ErrorCodeType__SVC_USCORES00_USCORE0014, "SVC_S00_0014" },
	{ (long)fims__ErrorCodeType__SVC_USCORES00_USCORE0015, "SVC_S00_0015" },
	{ (long)fims__ErrorCodeType__SVC_USCORES00_USCORE0016, "SVC_S00_0016" },
	{ (long)fims__ErrorCodeType__SVC_USCORES00_USCORE0017, "SVC_S00_0017" },
	{ (long)fims__ErrorCodeType__SVC_USCORES00_USCORE0018, "SVC_S00_0018" },
	{ (long)fims__ErrorCodeType__SVC_USCORES00_USCORE0019, "SVC_S00_0019" },
	{ (long)fims__ErrorCodeType__SVC_USCORES00_USCORE0020, "SVC_S00_0020" },
	{ (long)fims__ErrorCodeType__SVC_USCORES00_USCORE0021, "SVC_S00_0021" },
	{ (long)fims__ErrorCodeType__SVC_USCORES00_USCORE0022, "SVC_S00_0022" },
	{ (long)fims__ErrorCodeType__DAT_USCORES00_USCORE0001, "DAT_S00_0001" },
	{ (long)fims__ErrorCodeType__DAT_USCORES00_USCORE0002, "DAT_S00_0002" },
	{ (long)fims__ErrorCodeType__DAT_USCORES00_USCORE0003, "DAT_S00_0003" },
	{ (long)fims__ErrorCodeType__DAT_USCORES00_USCORE0004, "DAT_S00_0004" },
	{ (long)fims__ErrorCodeType__DAT_USCORES00_USCORE0005, "DAT_S00_0005" },
	{ (long)fims__ErrorCodeType__DAT_USCORES00_USCORE0006, "DAT_S00_0006" },
	{ (long)fims__ErrorCodeType__DAT_USCORES00_USCORE0007, "DAT_S00_0007" },
	{ (long)fims__ErrorCodeType__DAT_USCORES00_USCORE0008, "DAT_S00_0008" },
	{ (long)fims__ErrorCodeType__DAT_USCORES00_USCORE0009, "DAT_S00_0009" },
	{ (long)fims__ErrorCodeType__DAT_USCORES00_USCORE0010, "DAT_S00_0010" },
	{ (long)fims__ErrorCodeType__DAT_USCORES00_USCORE0011, "DAT_S00_0011" },
	{ (long)fims__ErrorCodeType__DAT_USCORES00_USCORE0012, "DAT_S00_0012" },
	{ (long)fims__ErrorCodeType__DAT_USCORES00_USCORE0013, "DAT_S00_0013" },
	{ (long)fims__ErrorCodeType__DAT_USCORES00_USCORE0014, "DAT_S00_0014" },
	{ (long)fims__ErrorCodeType__EXT_USCORES00_USCORE0000, "EXT_S00_0000" },
	{ (long)fims__ErrorCodeType__SEC_USCORES00_USCORE0001, "SEC_S00_0001" },
	{ (long)fims__ErrorCodeType__SEC_USCORES00_USCORE0002, "SEC_S00_0002" },
	{ (long)fims__ErrorCodeType__SEC_USCORES00_USCORE0003, "SEC_S00_0003" },
	{ (long)fims__ErrorCodeType__SEC_USCORES00_USCORE0004, "SEC_S00_0004" },
	{ (long)fims__ErrorCodeType__SEC_USCORES00_USCORE0005, "SEC_S00_0005" },
	{ (long)fims__ErrorCodeType__SEC_USCORES00_USCORE0006, "SEC_S00_0006" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_fims__ErrorCodeType2s(struct soap *soap, enum fims__ErrorCodeType n)
{	const char *s = soap_code_str(soap_codes_fims__ErrorCodeType, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_fims__ErrorCodeType(struct soap *soap, const char *tag, int id, const enum fims__ErrorCodeType *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_fims__ErrorCodeType), type) || soap_send(soap, soap_fims__ErrorCodeType2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2fims__ErrorCodeType(struct soap *soap, const char *s, enum fims__ErrorCodeType *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_fims__ErrorCodeType, s);
	if (map)
		*a = (enum fims__ErrorCodeType)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 49)))
			return soap->error = SOAP_TYPE;
		*a = (enum fims__ErrorCodeType)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum fims__ErrorCodeType * SOAP_FMAC4 soap_in_fims__ErrorCodeType(struct soap *soap, const char *tag, enum fims__ErrorCodeType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum fims__ErrorCodeType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_fims__ErrorCodeType, sizeof(enum fims__ErrorCodeType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2fims__ErrorCodeType(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum fims__ErrorCodeType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_fims__ErrorCodeType, 0, sizeof(enum fims__ErrorCodeType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_fims__ErrorCodeType(struct soap *soap, const enum fims__ErrorCodeType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_fims__ErrorCodeType);
	if (soap_out_fims__ErrorCodeType(soap, tag?tag:"fims:ErrorCodeType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum fims__ErrorCodeType * SOAP_FMAC4 soap_get_fims__ErrorCodeType(struct soap *soap, enum fims__ErrorCodeType *p, const char *tag, const char *type)
{
	if ((p = soap_in_fims__ErrorCodeType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_fims__BitRateModeType(struct soap *soap, enum fims__BitRateModeType *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_fims__BitRateModeType
	*a = SOAP_DEFAULT_fims__BitRateModeType;
#else
	*a = (enum fims__BitRateModeType)0;
#endif
}

static const struct soap_code_map soap_codes_fims__BitRateModeType[] =
{	{ (long)fims__BitRateModeType__constant, "constant" },
	{ (long)fims__BitRateModeType__variable, "variable" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_fims__BitRateModeType2s(struct soap *soap, enum fims__BitRateModeType n)
{	const char *s = soap_code_str(soap_codes_fims__BitRateModeType, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_fims__BitRateModeType(struct soap *soap, const char *tag, int id, const enum fims__BitRateModeType *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_fims__BitRateModeType), type) || soap_send(soap, soap_fims__BitRateModeType2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2fims__BitRateModeType(struct soap *soap, const char *s, enum fims__BitRateModeType *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_fims__BitRateModeType, s);
	if (map)
		*a = (enum fims__BitRateModeType)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 1)))
			return soap->error = SOAP_TYPE;
		*a = (enum fims__BitRateModeType)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum fims__BitRateModeType * SOAP_FMAC4 soap_in_fims__BitRateModeType(struct soap *soap, const char *tag, enum fims__BitRateModeType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum fims__BitRateModeType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_fims__BitRateModeType, sizeof(enum fims__BitRateModeType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2fims__BitRateModeType(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum fims__BitRateModeType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_fims__BitRateModeType, 0, sizeof(enum fims__BitRateModeType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_fims__BitRateModeType(struct soap *soap, const enum fims__BitRateModeType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_fims__BitRateModeType);
	if (soap_out_fims__BitRateModeType(soap, tag?tag:"fims:BitRateModeType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum fims__BitRateModeType * SOAP_FMAC4 soap_get_fims__BitRateModeType(struct soap *soap, enum fims__BitRateModeType *p, const char *tag, const char *type)
{
	if ((p = soap_in_fims__BitRateModeType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_fims__ScanningOrderType(struct soap *soap, enum fims__ScanningOrderType *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_fims__ScanningOrderType
	*a = SOAP_DEFAULT_fims__ScanningOrderType;
#else
	*a = (enum fims__ScanningOrderType)0;
#endif
}

static const struct soap_code_map soap_codes_fims__ScanningOrderType[] =
{	{ (long)fims__ScanningOrderType__top, "top" },
	{ (long)fims__ScanningOrderType__bottom, "bottom" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_fims__ScanningOrderType2s(struct soap *soap, enum fims__ScanningOrderType n)
{	const char *s = soap_code_str(soap_codes_fims__ScanningOrderType, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_fims__ScanningOrderType(struct soap *soap, const char *tag, int id, const enum fims__ScanningOrderType *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_fims__ScanningOrderType), type) || soap_send(soap, soap_fims__ScanningOrderType2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2fims__ScanningOrderType(struct soap *soap, const char *s, enum fims__ScanningOrderType *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_fims__ScanningOrderType, s);
	if (map)
		*a = (enum fims__ScanningOrderType)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 1)))
			return soap->error = SOAP_TYPE;
		*a = (enum fims__ScanningOrderType)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum fims__ScanningOrderType * SOAP_FMAC4 soap_in_fims__ScanningOrderType(struct soap *soap, const char *tag, enum fims__ScanningOrderType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum fims__ScanningOrderType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_fims__ScanningOrderType, sizeof(enum fims__ScanningOrderType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2fims__ScanningOrderType(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum fims__ScanningOrderType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_fims__ScanningOrderType, 0, sizeof(enum fims__ScanningOrderType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_fims__ScanningOrderType(struct soap *soap, const enum fims__ScanningOrderType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_fims__ScanningOrderType);
	if (soap_out_fims__ScanningOrderType(soap, tag?tag:"fims:ScanningOrderType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum fims__ScanningOrderType * SOAP_FMAC4 soap_get_fims__ScanningOrderType(struct soap *soap, enum fims__ScanningOrderType *p, const char *tag, const char *type)
{
	if ((p = soap_in_fims__ScanningOrderType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_fims__ScanningFormatType(struct soap *soap, enum fims__ScanningFormatType *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_fims__ScanningFormatType
	*a = SOAP_DEFAULT_fims__ScanningFormatType;
#else
	*a = (enum fims__ScanningFormatType)0;
#endif
}

static const struct soap_code_map soap_codes_fims__ScanningFormatType[] =
{	{ (long)fims__ScanningFormatType__interlaced, "interlaced" },
	{ (long)fims__ScanningFormatType__progressive, "progressive" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_fims__ScanningFormatType2s(struct soap *soap, enum fims__ScanningFormatType n)
{	const char *s = soap_code_str(soap_codes_fims__ScanningFormatType, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_fims__ScanningFormatType(struct soap *soap, const char *tag, int id, const enum fims__ScanningFormatType *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_fims__ScanningFormatType), type) || soap_send(soap, soap_fims__ScanningFormatType2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2fims__ScanningFormatType(struct soap *soap, const char *s, enum fims__ScanningFormatType *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_fims__ScanningFormatType, s);
	if (map)
		*a = (enum fims__ScanningFormatType)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 1)))
			return soap->error = SOAP_TYPE;
		*a = (enum fims__ScanningFormatType)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum fims__ScanningFormatType * SOAP_FMAC4 soap_in_fims__ScanningFormatType(struct soap *soap, const char *tag, enum fims__ScanningFormatType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum fims__ScanningFormatType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_fims__ScanningFormatType, sizeof(enum fims__ScanningFormatType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2fims__ScanningFormatType(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum fims__ScanningFormatType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_fims__ScanningFormatType, 0, sizeof(enum fims__ScanningFormatType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_fims__ScanningFormatType(struct soap *soap, const enum fims__ScanningFormatType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_fims__ScanningFormatType);
	if (soap_out_fims__ScanningFormatType(soap, tag?tag:"fims:ScanningFormatType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum fims__ScanningFormatType * SOAP_FMAC4 soap_get_fims__ScanningFormatType(struct soap *soap, enum fims__ScanningFormatType *p, const char *tag, const char *type)
{
	if ((p = soap_in_fims__ScanningFormatType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_fims__AudioSampleType(struct soap *soap, enum fims__AudioSampleType *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_fims__AudioSampleType
	*a = SOAP_DEFAULT_fims__AudioSampleType;
#else
	*a = (enum fims__AudioSampleType)0;
#endif
}

static const struct soap_code_map soap_codes_fims__AudioSampleType[] =
{	{ (long)fims__AudioSampleType__float_, "float" },
	{ (long)fims__AudioSampleType__integer, "integer" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_fims__AudioSampleType2s(struct soap *soap, enum fims__AudioSampleType n)
{	const char *s = soap_code_str(soap_codes_fims__AudioSampleType, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_fims__AudioSampleType(struct soap *soap, const char *tag, int id, const enum fims__AudioSampleType *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_fims__AudioSampleType), type) || soap_send(soap, soap_fims__AudioSampleType2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2fims__AudioSampleType(struct soap *soap, const char *s, enum fims__AudioSampleType *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_fims__AudioSampleType, s);
	if (map)
		*a = (enum fims__AudioSampleType)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 1)))
			return soap->error = SOAP_TYPE;
		*a = (enum fims__AudioSampleType)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum fims__AudioSampleType * SOAP_FMAC4 soap_in_fims__AudioSampleType(struct soap *soap, const char *tag, enum fims__AudioSampleType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum fims__AudioSampleType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_fims__AudioSampleType, sizeof(enum fims__AudioSampleType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2fims__AudioSampleType(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum fims__AudioSampleType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_fims__AudioSampleType, 0, sizeof(enum fims__AudioSampleType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_fims__AudioSampleType(struct soap *soap, const enum fims__AudioSampleType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_fims__AudioSampleType);
	if (soap_out_fims__AudioSampleType(soap, tag?tag:"fims:AudioSampleType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum fims__AudioSampleType * SOAP_FMAC4 soap_get_fims__AudioSampleType(struct soap *soap, enum fims__AudioSampleType *p, const char *tag, const char *type)
{
	if ((p = soap_in_fims__AudioSampleType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_fims__JobStatusType(struct soap *soap, enum fims__JobStatusType *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_fims__JobStatusType
	*a = SOAP_DEFAULT_fims__JobStatusType;
#else
	*a = (enum fims__JobStatusType)0;
#endif
}

static const struct soap_code_map soap_codes_fims__JobStatusType[] =
{	{ (long)fims__JobStatusType__new_, "new" },
	{ (long)fims__JobStatusType__queued, "queued" },
	{ (long)fims__JobStatusType__scheduled, "scheduled" },
	{ (long)fims__JobStatusType__running, "running" },
	{ (long)fims__JobStatusType__paused, "paused" },
	{ (long)fims__JobStatusType__completed, "completed" },
	{ (long)fims__JobStatusType__canceled, "canceled" },
	{ (long)fims__JobStatusType__stopped, "stopped" },
	{ (long)fims__JobStatusType__failed, "failed" },
	{ (long)fims__JobStatusType__cleaned, "cleaned" },
	{ (long)fims__JobStatusType__unknown, "unknown" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_fims__JobStatusType2s(struct soap *soap, enum fims__JobStatusType n)
{	const char *s = soap_code_str(soap_codes_fims__JobStatusType, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_fims__JobStatusType(struct soap *soap, const char *tag, int id, const enum fims__JobStatusType *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_fims__JobStatusType), type) || soap_send(soap, soap_fims__JobStatusType2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2fims__JobStatusType(struct soap *soap, const char *s, enum fims__JobStatusType *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_fims__JobStatusType, s);
	if (map)
		*a = (enum fims__JobStatusType)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 10)))
			return soap->error = SOAP_TYPE;
		*a = (enum fims__JobStatusType)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum fims__JobStatusType * SOAP_FMAC4 soap_in_fims__JobStatusType(struct soap *soap, const char *tag, enum fims__JobStatusType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum fims__JobStatusType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_fims__JobStatusType, sizeof(enum fims__JobStatusType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2fims__JobStatusType(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum fims__JobStatusType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_fims__JobStatusType, 0, sizeof(enum fims__JobStatusType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_fims__JobStatusType(struct soap *soap, const enum fims__JobStatusType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_fims__JobStatusType);
	if (soap_out_fims__JobStatusType(soap, tag?tag:"fims:JobStatusType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum fims__JobStatusType * SOAP_FMAC4 soap_get_fims__JobStatusType(struct soap *soap, enum fims__JobStatusType *p, const char *tag, const char *type)
{
	if ((p = soap_in_fims__JobStatusType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_fims__HashFunctionTypes(struct soap *soap, enum fims__HashFunctionTypes *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_fims__HashFunctionTypes
	*a = SOAP_DEFAULT_fims__HashFunctionTypes;
#else
	*a = (enum fims__HashFunctionTypes)0;
#endif
}

static const struct soap_code_map soap_codes_fims__HashFunctionTypes[] =
{	{ (long)fims__HashFunctionTypes__CRC32, "CRC32" },
	{ (long)fims__HashFunctionTypes__CRC64, "CRC64" },
	{ (long)fims__HashFunctionTypes__MD5, "MD5" },
	{ (long)fims__HashFunctionTypes__SHA1, "SHA1" },
	{ (long)fims__HashFunctionTypes__SHA256, "SHA256" },
	{ (long)fims__HashFunctionTypes__SHA384, "SHA384" },
	{ (long)fims__HashFunctionTypes__SHA512, "SHA512" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_fims__HashFunctionTypes2s(struct soap *soap, enum fims__HashFunctionTypes n)
{	const char *s = soap_code_str(soap_codes_fims__HashFunctionTypes, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_fims__HashFunctionTypes(struct soap *soap, const char *tag, int id, const enum fims__HashFunctionTypes *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_fims__HashFunctionTypes), type) || soap_send(soap, soap_fims__HashFunctionTypes2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2fims__HashFunctionTypes(struct soap *soap, const char *s, enum fims__HashFunctionTypes *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_fims__HashFunctionTypes, s);
	if (map)
		*a = (enum fims__HashFunctionTypes)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 6)))
			return soap->error = SOAP_TYPE;
		*a = (enum fims__HashFunctionTypes)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum fims__HashFunctionTypes * SOAP_FMAC4 soap_in_fims__HashFunctionTypes(struct soap *soap, const char *tag, enum fims__HashFunctionTypes *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum fims__HashFunctionTypes *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_fims__HashFunctionTypes, sizeof(enum fims__HashFunctionTypes), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2fims__HashFunctionTypes(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum fims__HashFunctionTypes *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_fims__HashFunctionTypes, 0, sizeof(enum fims__HashFunctionTypes), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_fims__HashFunctionTypes(struct soap *soap, const enum fims__HashFunctionTypes *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_fims__HashFunctionTypes);
	if (soap_out_fims__HashFunctionTypes(soap, tag?tag:"fims:HashFunctionTypes", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum fims__HashFunctionTypes * SOAP_FMAC4 soap_get_fims__HashFunctionTypes(struct soap *soap, enum fims__HashFunctionTypes *p, const char *tag, const char *type)
{
	if ((p = soap_in_fims__HashFunctionTypes(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_fims__JobCommandType(struct soap *soap, enum fims__JobCommandType *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_fims__JobCommandType
	*a = SOAP_DEFAULT_fims__JobCommandType;
#else
	*a = (enum fims__JobCommandType)0;
#endif
}

static const struct soap_code_map soap_codes_fims__JobCommandType[] =
{	{ (long)fims__JobCommandType__cancel, "cancel" },
	{ (long)fims__JobCommandType__pause, "pause" },
	{ (long)fims__JobCommandType__resume, "resume" },
	{ (long)fims__JobCommandType__restart, "restart" },
	{ (long)fims__JobCommandType__stop, "stop" },
	{ (long)fims__JobCommandType__cleanup, "cleanup" },
	{ (long)fims__JobCommandType__modifyPriority, "modifyPriority" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_fims__JobCommandType2s(struct soap *soap, enum fims__JobCommandType n)
{	const char *s = soap_code_str(soap_codes_fims__JobCommandType, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_fims__JobCommandType(struct soap *soap, const char *tag, int id, const enum fims__JobCommandType *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_fims__JobCommandType), type) || soap_send(soap, soap_fims__JobCommandType2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2fims__JobCommandType(struct soap *soap, const char *s, enum fims__JobCommandType *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_fims__JobCommandType, s);
	if (map)
		*a = (enum fims__JobCommandType)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 6)))
			return soap->error = SOAP_TYPE;
		*a = (enum fims__JobCommandType)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum fims__JobCommandType * SOAP_FMAC4 soap_in_fims__JobCommandType(struct soap *soap, const char *tag, enum fims__JobCommandType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum fims__JobCommandType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_fims__JobCommandType, sizeof(enum fims__JobCommandType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2fims__JobCommandType(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum fims__JobCommandType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_fims__JobCommandType, 0, sizeof(enum fims__JobCommandType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_fims__JobCommandType(struct soap *soap, const enum fims__JobCommandType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_fims__JobCommandType);
	if (soap_out_fims__JobCommandType(soap, tag?tag:"fims:JobCommandType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum fims__JobCommandType * SOAP_FMAC4 soap_get_fims__JobCommandType(struct soap *soap, enum fims__JobCommandType *p, const char *tag, const char *type)
{
	if ((p = soap_in_fims__JobCommandType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_fims__QueueCommandType(struct soap *soap, enum fims__QueueCommandType *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_fims__QueueCommandType
	*a = SOAP_DEFAULT_fims__QueueCommandType;
#else
	*a = (enum fims__QueueCommandType)0;
#endif
}

static const struct soap_code_map soap_codes_fims__QueueCommandType[] =
{	{ (long)fims__QueueCommandType__status, "status" },
	{ (long)fims__QueueCommandType__clear, "clear" },
	{ (long)fims__QueueCommandType__stop, "stop" },
	{ (long)fims__QueueCommandType__start, "start" },
	{ (long)fims__QueueCommandType__lock, "lock" },
	{ (long)fims__QueueCommandType__unlock, "unlock" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_fims__QueueCommandType2s(struct soap *soap, enum fims__QueueCommandType n)
{	const char *s = soap_code_str(soap_codes_fims__QueueCommandType, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_fims__QueueCommandType(struct soap *soap, const char *tag, int id, const enum fims__QueueCommandType *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_fims__QueueCommandType), type) || soap_send(soap, soap_fims__QueueCommandType2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2fims__QueueCommandType(struct soap *soap, const char *s, enum fims__QueueCommandType *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_fims__QueueCommandType, s);
	if (map)
		*a = (enum fims__QueueCommandType)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 5)))
			return soap->error = SOAP_TYPE;
		*a = (enum fims__QueueCommandType)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum fims__QueueCommandType * SOAP_FMAC4 soap_in_fims__QueueCommandType(struct soap *soap, const char *tag, enum fims__QueueCommandType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum fims__QueueCommandType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_fims__QueueCommandType, sizeof(enum fims__QueueCommandType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2fims__QueueCommandType(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum fims__QueueCommandType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_fims__QueueCommandType, 0, sizeof(enum fims__QueueCommandType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_fims__QueueCommandType(struct soap *soap, const enum fims__QueueCommandType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_fims__QueueCommandType);
	if (soap_out_fims__QueueCommandType(soap, tag?tag:"fims:QueueCommandType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum fims__QueueCommandType * SOAP_FMAC4 soap_get_fims__QueueCommandType(struct soap *soap, enum fims__QueueCommandType *p, const char *tag, const char *type)
{
	if ((p = soap_in_fims__QueueCommandType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_fims__StorageTypes(struct soap *soap, enum fims__StorageTypes *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_fims__StorageTypes
	*a = SOAP_DEFAULT_fims__StorageTypes;
#else
	*a = (enum fims__StorageTypes)0;
#endif
}

static const struct soap_code_map soap_codes_fims__StorageTypes[] =
{	{ (long)fims__StorageTypes__online, "online" },
	{ (long)fims__StorageTypes__offline, "offline" },
	{ (long)fims__StorageTypes__hsm, "hsm" },
	{ (long)fims__StorageTypes__archive, "archive" },
	{ (long)fims__StorageTypes__playout, "playout" },
	{ (long)fims__StorageTypes__other, "other" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_fims__StorageTypes2s(struct soap *soap, enum fims__StorageTypes n)
{	const char *s = soap_code_str(soap_codes_fims__StorageTypes, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_fims__StorageTypes(struct soap *soap, const char *tag, int id, const enum fims__StorageTypes *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_fims__StorageTypes), type) || soap_send(soap, soap_fims__StorageTypes2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2fims__StorageTypes(struct soap *soap, const char *s, enum fims__StorageTypes *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_fims__StorageTypes, s);
	if (map)
		*a = (enum fims__StorageTypes)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 5)))
			return soap->error = SOAP_TYPE;
		*a = (enum fims__StorageTypes)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum fims__StorageTypes * SOAP_FMAC4 soap_in_fims__StorageTypes(struct soap *soap, const char *tag, enum fims__StorageTypes *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum fims__StorageTypes *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_fims__StorageTypes, sizeof(enum fims__StorageTypes), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2fims__StorageTypes(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum fims__StorageTypes *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_fims__StorageTypes, 0, sizeof(enum fims__StorageTypes), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_fims__StorageTypes(struct soap *soap, const enum fims__StorageTypes *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_fims__StorageTypes);
	if (soap_out_fims__StorageTypes(soap, tag?tag:"fims:StorageTypes", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum fims__StorageTypes * SOAP_FMAC4 soap_get_fims__StorageTypes(struct soap *soap, enum fims__StorageTypes *p, const char *tag, const char *type)
{
	if ((p = soap_in_fims__StorageTypes(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_fims__PriorityType(struct soap *soap, enum fims__PriorityType *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_fims__PriorityType
	*a = SOAP_DEFAULT_fims__PriorityType;
#else
	*a = (enum fims__PriorityType)0;
#endif
}

static const struct soap_code_map soap_codes_fims__PriorityType[] =
{	{ (long)fims__PriorityType__low, "low" },
	{ (long)fims__PriorityType__medium, "medium" },
	{ (long)fims__PriorityType__high, "high" },
	{ (long)fims__PriorityType__urgent, "urgent" },
	{ (long)fims__PriorityType__immediate, "immediate" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_fims__PriorityType2s(struct soap *soap, enum fims__PriorityType n)
{	const char *s = soap_code_str(soap_codes_fims__PriorityType, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_fims__PriorityType(struct soap *soap, const char *tag, int id, const enum fims__PriorityType *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_fims__PriorityType), type) || soap_send(soap, soap_fims__PriorityType2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2fims__PriorityType(struct soap *soap, const char *s, enum fims__PriorityType *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_fims__PriorityType, s);
	if (map)
		*a = (enum fims__PriorityType)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 4)))
			return soap->error = SOAP_TYPE;
		*a = (enum fims__PriorityType)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum fims__PriorityType * SOAP_FMAC4 soap_in_fims__PriorityType(struct soap *soap, const char *tag, enum fims__PriorityType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum fims__PriorityType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_fims__PriorityType, sizeof(enum fims__PriorityType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2fims__PriorityType(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum fims__PriorityType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_fims__PriorityType, 0, sizeof(enum fims__PriorityType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_fims__PriorityType(struct soap *soap, const enum fims__PriorityType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_fims__PriorityType);
	if (soap_out_fims__PriorityType(soap, tag?tag:"fims:PriorityType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum fims__PriorityType * SOAP_FMAC4 soap_get_fims__PriorityType(struct soap *soap, enum fims__PriorityType *p, const char *tag, const char *type)
{
	if ((p = soap_in_fims__PriorityType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_fims__QueueStatusType(struct soap *soap, enum fims__QueueStatusType *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_fims__QueueStatusType
	*a = SOAP_DEFAULT_fims__QueueStatusType;
#else
	*a = (enum fims__QueueStatusType)0;
#endif
}

static const struct soap_code_map soap_codes_fims__QueueStatusType[] =
{	{ (long)fims__QueueStatusType__started, "started" },
	{ (long)fims__QueueStatusType__stopped, "stopped" },
	{ (long)fims__QueueStatusType__locked, "locked" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_fims__QueueStatusType2s(struct soap *soap, enum fims__QueueStatusType n)
{	const char *s = soap_code_str(soap_codes_fims__QueueStatusType, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_fims__QueueStatusType(struct soap *soap, const char *tag, int id, const enum fims__QueueStatusType *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_fims__QueueStatusType), type) || soap_send(soap, soap_fims__QueueStatusType2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2fims__QueueStatusType(struct soap *soap, const char *s, enum fims__QueueStatusType *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_fims__QueueStatusType, s);
	if (map)
		*a = (enum fims__QueueStatusType)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 2)))
			return soap->error = SOAP_TYPE;
		*a = (enum fims__QueueStatusType)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum fims__QueueStatusType * SOAP_FMAC4 soap_in_fims__QueueStatusType(struct soap *soap, const char *tag, enum fims__QueueStatusType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum fims__QueueStatusType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_fims__QueueStatusType, sizeof(enum fims__QueueStatusType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2fims__QueueStatusType(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum fims__QueueStatusType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_fims__QueueStatusType, 0, sizeof(enum fims__QueueStatusType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_fims__QueueStatusType(struct soap *soap, const enum fims__QueueStatusType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_fims__QueueStatusType);
	if (soap_out_fims__QueueStatusType(soap, tag?tag:"fims:QueueStatusType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum fims__QueueStatusType * SOAP_FMAC4 soap_get_fims__QueueStatusType(struct soap *soap, enum fims__QueueStatusType *p, const char *tag, const char *type)
{
	if ((p = soap_in_fims__QueueStatusType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_fims__CurrentVersion(struct soap *soap, enum fims__CurrentVersion *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_fims__CurrentVersion
	*a = SOAP_DEFAULT_fims__CurrentVersion;
#else
	*a = (enum fims__CurrentVersion)0;
#endif
}

static const struct soap_code_map soap_codes_fims__CurrentVersion[] =
{	{ (long)fims__CurrentVersion__1_USCORE1_USCORE0, "1_1_0" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_fims__CurrentVersion2s(struct soap *soap, enum fims__CurrentVersion n)
{	const char *s = soap_code_str(soap_codes_fims__CurrentVersion, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_fims__CurrentVersion(struct soap *soap, const char *tag, int id, const enum fims__CurrentVersion *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_fims__CurrentVersion), type) || soap_send(soap, soap_fims__CurrentVersion2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2fims__CurrentVersion(struct soap *soap, const char *s, enum fims__CurrentVersion *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_fims__CurrentVersion, s);
	if (map)
		*a = (enum fims__CurrentVersion)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 0)))
			return soap->error = SOAP_TYPE;
		*a = (enum fims__CurrentVersion)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum fims__CurrentVersion * SOAP_FMAC4 soap_in_fims__CurrentVersion(struct soap *soap, const char *tag, enum fims__CurrentVersion *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum fims__CurrentVersion *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_fims__CurrentVersion, sizeof(enum fims__CurrentVersion), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2fims__CurrentVersion(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum fims__CurrentVersion *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_fims__CurrentVersion, 0, sizeof(enum fims__CurrentVersion), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_fims__CurrentVersion(struct soap *soap, const enum fims__CurrentVersion *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_fims__CurrentVersion);
	if (soap_out_fims__CurrentVersion(soap, tag?tag:"fims:CurrentVersion", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum fims__CurrentVersion * SOAP_FMAC4 soap_get_fims__CurrentVersion(struct soap *soap, enum fims__CurrentVersion *p, const char *tag, const char *type)
{
	if ((p = soap_in_fims__CurrentVersion(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_edlprovider__EdlProviderErrorCodeType(struct soap *soap, enum edlprovider__EdlProviderErrorCodeType *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_edlprovider__EdlProviderErrorCodeType
	*a = SOAP_DEFAULT_edlprovider__EdlProviderErrorCodeType;
#else
	*a = (enum edlprovider__EdlProviderErrorCodeType)0;
#endif
}

static const struct soap_code_map soap_codes_edlprovider__EdlProviderErrorCodeType[] =
{	{ (long)edlprovider__EdlProviderErrorCodeType__EXT_USCORES00_USCORE0001, "EXT_S00_0001" },
	{ (long)edlprovider__EdlProviderErrorCodeType__EXT_USCORES00_USCORE0002, "EXT_S00_0002" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_edlprovider__EdlProviderErrorCodeType2s(struct soap *soap, enum edlprovider__EdlProviderErrorCodeType n)
{	const char *s = soap_code_str(soap_codes_edlprovider__EdlProviderErrorCodeType, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_edlprovider__EdlProviderErrorCodeType(struct soap *soap, const char *tag, int id, const enum edlprovider__EdlProviderErrorCodeType *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_edlprovider__EdlProviderErrorCodeType), type) || soap_send(soap, soap_edlprovider__EdlProviderErrorCodeType2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2edlprovider__EdlProviderErrorCodeType(struct soap *soap, const char *s, enum edlprovider__EdlProviderErrorCodeType *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_edlprovider__EdlProviderErrorCodeType, s);
	if (map)
		*a = (enum edlprovider__EdlProviderErrorCodeType)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 1)))
			return soap->error = SOAP_TYPE;
		*a = (enum edlprovider__EdlProviderErrorCodeType)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum edlprovider__EdlProviderErrorCodeType * SOAP_FMAC4 soap_in_edlprovider__EdlProviderErrorCodeType(struct soap *soap, const char *tag, enum edlprovider__EdlProviderErrorCodeType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum edlprovider__EdlProviderErrorCodeType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_edlprovider__EdlProviderErrorCodeType, sizeof(enum edlprovider__EdlProviderErrorCodeType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2edlprovider__EdlProviderErrorCodeType(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum edlprovider__EdlProviderErrorCodeType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_edlprovider__EdlProviderErrorCodeType, 0, sizeof(enum edlprovider__EdlProviderErrorCodeType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_edlprovider__EdlProviderErrorCodeType(struct soap *soap, const enum edlprovider__EdlProviderErrorCodeType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_edlprovider__EdlProviderErrorCodeType);
	if (soap_out_edlprovider__EdlProviderErrorCodeType(soap, tag?tag:"edlprovider:EdlProviderErrorCodeType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum edlprovider__EdlProviderErrorCodeType * SOAP_FMAC4 soap_get_edlprovider__EdlProviderErrorCodeType(struct soap *soap, enum edlprovider__EdlProviderErrorCodeType *p, const char *tag, const char *type)
{
	if ((p = soap_in_edlprovider__EdlProviderErrorCodeType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _fims__ContainerFormatType_containerFormat::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_std__wstring(soap, &this->_fims__ContainerFormatType_containerFormat::__item);
	this->_fims__ContainerFormatType_containerFormat::formatLabel = NULL;
	this->_fims__ContainerFormatType_containerFormat::formatDefinition = NULL;
	this->_fims__ContainerFormatType_containerFormat::formatLink = NULL;
}

void _fims__ContainerFormatType_containerFormat::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &this->_fims__ContainerFormatType_containerFormat::__item, SOAP_TYPE_std__wstring);
	soap_serialize_std__wstring(soap, &this->_fims__ContainerFormatType_containerFormat::__item);
#endif
}

int _fims__ContainerFormatType_containerFormat::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__fims__ContainerFormatType_containerFormat(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__fims__ContainerFormatType_containerFormat(struct soap *soap, const char *tag, int id, const _fims__ContainerFormatType_containerFormat *a, const char *type)
{
	if (((_fims__ContainerFormatType_containerFormat*)a)->formatLabel)
		soap_set_attr(soap, "formatLabel", soap_wchar2s(soap, ((_fims__ContainerFormatType_containerFormat*)a)->formatLabel->c_str()), 2);
	if (((_fims__ContainerFormatType_containerFormat*)a)->formatDefinition)
		soap_set_attr(soap, "formatDefinition", soap_wchar2s(soap, ((_fims__ContainerFormatType_containerFormat*)a)->formatDefinition->c_str()), 2);
	if (((_fims__ContainerFormatType_containerFormat*)a)->formatLink)
		soap_set_attr(soap, "formatLink", soap_wchar2s(soap, ((_fims__ContainerFormatType_containerFormat*)a)->formatLink->c_str()), 2);
	return soap_out_std__wstring(soap, tag, id, &a->_fims__ContainerFormatType_containerFormat::__item, "");
}

void *_fims__ContainerFormatType_containerFormat::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__fims__ContainerFormatType_containerFormat(soap, tag, this, type);
}

SOAP_FMAC3 _fims__ContainerFormatType_containerFormat * SOAP_FMAC4 soap_in__fims__ContainerFormatType_containerFormat(struct soap *soap, const char *tag, _fims__ContainerFormatType_containerFormat *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (_fims__ContainerFormatType_containerFormat *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__fims__ContainerFormatType_containerFormat, sizeof(_fims__ContainerFormatType_containerFormat), soap->type, soap->arrayType)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__fims__ContainerFormatType_containerFormat)
			return (_fims__ContainerFormatType_containerFormat *)a->soap_in(soap, tag, type);
	}
	{	const char *t = soap_attr_value(soap, "formatLabel", 0);
		if (t)
		{
			if (!(((_fims__ContainerFormatType_containerFormat*)a)->formatLabel = (std::wstring *)soap_malloc(soap, sizeof(std::wstring))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			wchar_t *s = NULL;
			if (soap_s2wchar(soap, t, &s, 0, -1))
				return NULL;
			if (s)
			{	((_fims__ContainerFormatType_containerFormat*)a)->formatLabel = soap_new_std__wstring(soap, -1);
				((_fims__ContainerFormatType_containerFormat*)a)->formatLabel->assign(s);
			}
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "formatDefinition", 0);
		if (t)
		{
			if (!(((_fims__ContainerFormatType_containerFormat*)a)->formatDefinition = (std::wstring *)soap_malloc(soap, sizeof(std::wstring))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			wchar_t *s = NULL;
			if (soap_s2wchar(soap, t, &s, 0, -1))
				return NULL;
			if (s)
			{	((_fims__ContainerFormatType_containerFormat*)a)->formatDefinition = soap_new_std__wstring(soap, -1);
				((_fims__ContainerFormatType_containerFormat*)a)->formatDefinition->assign(s);
			}
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "formatLink", 0);
		if (t)
		{
			if (!(((_fims__ContainerFormatType_containerFormat*)a)->formatLink = (std::wstring *)soap_malloc(soap, sizeof(std::wstring))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			wchar_t *s = NULL;
			if (soap_s2wchar(soap, t, &s, 0, -1))
				return NULL;
			if (s)
			{	((_fims__ContainerFormatType_containerFormat*)a)->formatLink = soap_new_std__wstring(soap, -1);
				((_fims__ContainerFormatType_containerFormat*)a)->formatLink->assign(s);
			}
		}
		else if (soap->error)
			return NULL;
	}
	if (!soap_in_std__wstring(soap, tag, &(a->_fims__ContainerFormatType_containerFormat::__item), ""))
		return NULL;
	return a;
}

int _fims__ContainerFormatType_containerFormat::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__fims__ContainerFormatType_containerFormat);
	if (this->soap_out(soap, tag?tag:"fims:ContainerFormatType-containerFormat", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_fims__ContainerFormatType_containerFormat::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__fims__ContainerFormatType_containerFormat(soap, this, tag, type);
}

SOAP_FMAC3 _fims__ContainerFormatType_containerFormat * SOAP_FMAC4 soap_get__fims__ContainerFormatType_containerFormat(struct soap *soap, _fims__ContainerFormatType_containerFormat *p, const char *tag, const char *type)
{
	if ((p = soap_in__fims__ContainerFormatType_containerFormat(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _fims__ContainerFormatType_containerFormat * SOAP_FMAC2 soap_instantiate__fims__ContainerFormatType_containerFormat(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__fims__ContainerFormatType_containerFormat(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__fims__ContainerFormatType_containerFormat, n, EDLProvider_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_fims__ContainerFormatType_containerFormat);
		if (size)
			*size = sizeof(_fims__ContainerFormatType_containerFormat);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(_fims__ContainerFormatType_containerFormat, n);
		if (size)
			*size = n * sizeof(_fims__ContainerFormatType_containerFormat);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (_fims__ContainerFormatType_containerFormat*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__fims__ContainerFormatType_containerFormat(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _fims__ContainerFormatType_containerFormat %p -> %p\n", q, p));
	*(_fims__ContainerFormatType_containerFormat*)p = *(_fims__ContainerFormatType_containerFormat*)q;
}

void _fims__AudioFormatType_trackConfiguration::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	this->_fims__AudioFormatType_trackConfiguration::typeLabel = NULL;
	this->_fims__AudioFormatType_trackConfiguration::typeDefinition = NULL;
	this->_fims__AudioFormatType_trackConfiguration::typeLink = NULL;
}

void _fims__AudioFormatType_trackConfiguration::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
#endif
}

int _fims__AudioFormatType_trackConfiguration::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__fims__AudioFormatType_trackConfiguration(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__fims__AudioFormatType_trackConfiguration(struct soap *soap, const char *tag, int id, const _fims__AudioFormatType_trackConfiguration *a, const char *type)
{
	if (((_fims__AudioFormatType_trackConfiguration*)a)->typeLabel)
		soap_set_attr(soap, "typeLabel", soap_wchar2s(soap, ((_fims__AudioFormatType_trackConfiguration*)a)->typeLabel->c_str()), 2);
	if (((_fims__AudioFormatType_trackConfiguration*)a)->typeDefinition)
		soap_set_attr(soap, "typeDefinition", soap_wchar2s(soap, ((_fims__AudioFormatType_trackConfiguration*)a)->typeDefinition->c_str()), 2);
	if (((_fims__AudioFormatType_trackConfiguration*)a)->typeLink)
		soap_set_attr(soap, "typeLink", soap_wchar2s(soap, ((_fims__AudioFormatType_trackConfiguration*)a)->typeLink->c_str()), 2);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__fims__AudioFormatType_trackConfiguration), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_fims__AudioFormatType_trackConfiguration::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__fims__AudioFormatType_trackConfiguration(soap, tag, this, type);
}

SOAP_FMAC3 _fims__AudioFormatType_trackConfiguration * SOAP_FMAC4 soap_in__fims__AudioFormatType_trackConfiguration(struct soap *soap, const char *tag, _fims__AudioFormatType_trackConfiguration *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_fims__AudioFormatType_trackConfiguration *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__fims__AudioFormatType_trackConfiguration, sizeof(_fims__AudioFormatType_trackConfiguration), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__fims__AudioFormatType_trackConfiguration)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_fims__AudioFormatType_trackConfiguration *)a->soap_in(soap, tag, type);
		}
	}
	{	const char *t = soap_attr_value(soap, "typeLabel", 0);
		if (t)
		{
			if (!(((_fims__AudioFormatType_trackConfiguration*)a)->typeLabel = (std::wstring *)soap_malloc(soap, sizeof(std::wstring))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			wchar_t *s = NULL;
			if (soap_s2wchar(soap, t, &s, 0, -1))
				return NULL;
			if (s)
			{	((_fims__AudioFormatType_trackConfiguration*)a)->typeLabel = soap_new_std__wstring(soap, -1);
				((_fims__AudioFormatType_trackConfiguration*)a)->typeLabel->assign(s);
			}
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "typeDefinition", 0);
		if (t)
		{
			if (!(((_fims__AudioFormatType_trackConfiguration*)a)->typeDefinition = (std::wstring *)soap_malloc(soap, sizeof(std::wstring))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			wchar_t *s = NULL;
			if (soap_s2wchar(soap, t, &s, 0, -1))
				return NULL;
			if (s)
			{	((_fims__AudioFormatType_trackConfiguration*)a)->typeDefinition = soap_new_std__wstring(soap, -1);
				((_fims__AudioFormatType_trackConfiguration*)a)->typeDefinition->assign(s);
			}
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "typeLink", 0);
		if (t)
		{
			if (!(((_fims__AudioFormatType_trackConfiguration*)a)->typeLink = (std::wstring *)soap_malloc(soap, sizeof(std::wstring))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			wchar_t *s = NULL;
			if (soap_s2wchar(soap, t, &s, 0, -1))
				return NULL;
			if (s)
			{	((_fims__AudioFormatType_trackConfiguration*)a)->typeLink = soap_new_std__wstring(soap, -1);
				((_fims__AudioFormatType_trackConfiguration*)a)->typeLink->assign(s);
			}
		}
		else if (soap->error)
			return NULL;
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_fims__AudioFormatType_trackConfiguration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__fims__AudioFormatType_trackConfiguration, 0, sizeof(_fims__AudioFormatType_trackConfiguration), 0, soap_copy__fims__AudioFormatType_trackConfiguration);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int _fims__AudioFormatType_trackConfiguration::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__fims__AudioFormatType_trackConfiguration);
	if (this->soap_out(soap, tag?tag:"fims:AudioFormatType-trackConfiguration", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_fims__AudioFormatType_trackConfiguration::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__fims__AudioFormatType_trackConfiguration(soap, this, tag, type);
}

SOAP_FMAC3 _fims__AudioFormatType_trackConfiguration * SOAP_FMAC4 soap_get__fims__AudioFormatType_trackConfiguration(struct soap *soap, _fims__AudioFormatType_trackConfiguration *p, const char *tag, const char *type)
{
	if ((p = soap_in__fims__AudioFormatType_trackConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _fims__AudioFormatType_trackConfiguration * SOAP_FMAC2 soap_instantiate__fims__AudioFormatType_trackConfiguration(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__fims__AudioFormatType_trackConfiguration(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__fims__AudioFormatType_trackConfiguration, n, EDLProvider_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_fims__AudioFormatType_trackConfiguration);
		if (size)
			*size = sizeof(_fims__AudioFormatType_trackConfiguration);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(_fims__AudioFormatType_trackConfiguration, n);
		if (size)
			*size = n * sizeof(_fims__AudioFormatType_trackConfiguration);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (_fims__AudioFormatType_trackConfiguration*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__fims__AudioFormatType_trackConfiguration(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _fims__AudioFormatType_trackConfiguration %p -> %p\n", q, p));
	*(_fims__AudioFormatType_trackConfiguration*)p = *(_fims__AudioFormatType_trackConfiguration*)q;
}

void _fims__BMEssenceLocatorType_containerMimeType::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_std__wstring(soap, &this->_fims__BMEssenceLocatorType_containerMimeType::__item);
	this->_fims__BMEssenceLocatorType_containerMimeType::typeLabel = NULL;
	this->_fims__BMEssenceLocatorType_containerMimeType::typeDefinition = NULL;
	this->_fims__BMEssenceLocatorType_containerMimeType::typeLink = NULL;
}

void _fims__BMEssenceLocatorType_containerMimeType::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &this->_fims__BMEssenceLocatorType_containerMimeType::__item, SOAP_TYPE_std__wstring);
	soap_serialize_std__wstring(soap, &this->_fims__BMEssenceLocatorType_containerMimeType::__item);
#endif
}

int _fims__BMEssenceLocatorType_containerMimeType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__fims__BMEssenceLocatorType_containerMimeType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__fims__BMEssenceLocatorType_containerMimeType(struct soap *soap, const char *tag, int id, const _fims__BMEssenceLocatorType_containerMimeType *a, const char *type)
{
	if (((_fims__BMEssenceLocatorType_containerMimeType*)a)->typeLabel)
		soap_set_attr(soap, "typeLabel", soap_wchar2s(soap, ((_fims__BMEssenceLocatorType_containerMimeType*)a)->typeLabel->c_str()), 2);
	if (((_fims__BMEssenceLocatorType_containerMimeType*)a)->typeDefinition)
		soap_set_attr(soap, "typeDefinition", soap_wchar2s(soap, ((_fims__BMEssenceLocatorType_containerMimeType*)a)->typeDefinition->c_str()), 2);
	if (((_fims__BMEssenceLocatorType_containerMimeType*)a)->typeLink)
		soap_set_attr(soap, "typeLink", soap_wchar2s(soap, ((_fims__BMEssenceLocatorType_containerMimeType*)a)->typeLink->c_str()), 2);
	return soap_out_std__wstring(soap, tag, id, &a->_fims__BMEssenceLocatorType_containerMimeType::__item, "");
}

void *_fims__BMEssenceLocatorType_containerMimeType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__fims__BMEssenceLocatorType_containerMimeType(soap, tag, this, type);
}

SOAP_FMAC3 _fims__BMEssenceLocatorType_containerMimeType * SOAP_FMAC4 soap_in__fims__BMEssenceLocatorType_containerMimeType(struct soap *soap, const char *tag, _fims__BMEssenceLocatorType_containerMimeType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (_fims__BMEssenceLocatorType_containerMimeType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__fims__BMEssenceLocatorType_containerMimeType, sizeof(_fims__BMEssenceLocatorType_containerMimeType), soap->type, soap->arrayType)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__fims__BMEssenceLocatorType_containerMimeType)
			return (_fims__BMEssenceLocatorType_containerMimeType *)a->soap_in(soap, tag, type);
	}
	{	const char *t = soap_attr_value(soap, "typeLabel", 0);
		if (t)
		{
			if (!(((_fims__BMEssenceLocatorType_containerMimeType*)a)->typeLabel = (std::wstring *)soap_malloc(soap, sizeof(std::wstring))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			wchar_t *s = NULL;
			if (soap_s2wchar(soap, t, &s, 0, -1))
				return NULL;
			if (s)
			{	((_fims__BMEssenceLocatorType_containerMimeType*)a)->typeLabel = soap_new_std__wstring(soap, -1);
				((_fims__BMEssenceLocatorType_containerMimeType*)a)->typeLabel->assign(s);
			}
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "typeDefinition", 0);
		if (t)
		{
			if (!(((_fims__BMEssenceLocatorType_containerMimeType*)a)->typeDefinition = (std::wstring *)soap_malloc(soap, sizeof(std::wstring))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			wchar_t *s = NULL;
			if (soap_s2wchar(soap, t, &s, 0, -1))
				return NULL;
			if (s)
			{	((_fims__BMEssenceLocatorType_containerMimeType*)a)->typeDefinition = soap_new_std__wstring(soap, -1);
				((_fims__BMEssenceLocatorType_containerMimeType*)a)->typeDefinition->assign(s);
			}
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "typeLink", 0);
		if (t)
		{
			if (!(((_fims__BMEssenceLocatorType_containerMimeType*)a)->typeLink = (std::wstring *)soap_malloc(soap, sizeof(std::wstring))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			wchar_t *s = NULL;
			if (soap_s2wchar(soap, t, &s, 0, -1))
				return NULL;
			if (s)
			{	((_fims__BMEssenceLocatorType_containerMimeType*)a)->typeLink = soap_new_std__wstring(soap, -1);
				((_fims__BMEssenceLocatorType_containerMimeType*)a)->typeLink->assign(s);
			}
		}
		else if (soap->error)
			return NULL;
	}
	if (!soap_in_std__wstring(soap, tag, &(a->_fims__BMEssenceLocatorType_containerMimeType::__item), ""))
		return NULL;
	return a;
}

int _fims__BMEssenceLocatorType_containerMimeType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__fims__BMEssenceLocatorType_containerMimeType);
	if (this->soap_out(soap, tag?tag:"fims:BMEssenceLocatorType-containerMimeType", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_fims__BMEssenceLocatorType_containerMimeType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__fims__BMEssenceLocatorType_containerMimeType(soap, this, tag, type);
}

SOAP_FMAC3 _fims__BMEssenceLocatorType_containerMimeType * SOAP_FMAC4 soap_get__fims__BMEssenceLocatorType_containerMimeType(struct soap *soap, _fims__BMEssenceLocatorType_containerMimeType *p, const char *tag, const char *type)
{
	if ((p = soap_in__fims__BMEssenceLocatorType_containerMimeType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _fims__BMEssenceLocatorType_containerMimeType * SOAP_FMAC2 soap_instantiate__fims__BMEssenceLocatorType_containerMimeType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__fims__BMEssenceLocatorType_containerMimeType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__fims__BMEssenceLocatorType_containerMimeType, n, EDLProvider_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_fims__BMEssenceLocatorType_containerMimeType);
		if (size)
			*size = sizeof(_fims__BMEssenceLocatorType_containerMimeType);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(_fims__BMEssenceLocatorType_containerMimeType, n);
		if (size)
			*size = n * sizeof(_fims__BMEssenceLocatorType_containerMimeType);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (_fims__BMEssenceLocatorType_containerMimeType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__fims__BMEssenceLocatorType_containerMimeType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _fims__BMEssenceLocatorType_containerMimeType %p -> %p\n", q, p));
	*(_fims__BMEssenceLocatorType_containerMimeType*)p = *(_fims__BMEssenceLocatorType_containerMimeType*)q;
}

void _fims__BMContentFormatType_mimeType::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_std__wstring(soap, &this->_fims__BMContentFormatType_mimeType::__item);
	this->_fims__BMContentFormatType_mimeType::typeLabel = NULL;
	this->_fims__BMContentFormatType_mimeType::typeDefinition = NULL;
	this->_fims__BMContentFormatType_mimeType::typeLink = NULL;
}

void _fims__BMContentFormatType_mimeType::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &this->_fims__BMContentFormatType_mimeType::__item, SOAP_TYPE_std__wstring);
	soap_serialize_std__wstring(soap, &this->_fims__BMContentFormatType_mimeType::__item);
#endif
}

int _fims__BMContentFormatType_mimeType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__fims__BMContentFormatType_mimeType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__fims__BMContentFormatType_mimeType(struct soap *soap, const char *tag, int id, const _fims__BMContentFormatType_mimeType *a, const char *type)
{
	if (((_fims__BMContentFormatType_mimeType*)a)->typeLabel)
		soap_set_attr(soap, "typeLabel", soap_wchar2s(soap, ((_fims__BMContentFormatType_mimeType*)a)->typeLabel->c_str()), 2);
	if (((_fims__BMContentFormatType_mimeType*)a)->typeDefinition)
		soap_set_attr(soap, "typeDefinition", soap_wchar2s(soap, ((_fims__BMContentFormatType_mimeType*)a)->typeDefinition->c_str()), 2);
	if (((_fims__BMContentFormatType_mimeType*)a)->typeLink)
		soap_set_attr(soap, "typeLink", soap_wchar2s(soap, ((_fims__BMContentFormatType_mimeType*)a)->typeLink->c_str()), 2);
	return soap_out_std__wstring(soap, tag, id, &a->_fims__BMContentFormatType_mimeType::__item, "");
}

void *_fims__BMContentFormatType_mimeType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__fims__BMContentFormatType_mimeType(soap, tag, this, type);
}

SOAP_FMAC3 _fims__BMContentFormatType_mimeType * SOAP_FMAC4 soap_in__fims__BMContentFormatType_mimeType(struct soap *soap, const char *tag, _fims__BMContentFormatType_mimeType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (_fims__BMContentFormatType_mimeType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__fims__BMContentFormatType_mimeType, sizeof(_fims__BMContentFormatType_mimeType), soap->type, soap->arrayType)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__fims__BMContentFormatType_mimeType)
			return (_fims__BMContentFormatType_mimeType *)a->soap_in(soap, tag, type);
	}
	{	const char *t = soap_attr_value(soap, "typeLabel", 0);
		if (t)
		{
			if (!(((_fims__BMContentFormatType_mimeType*)a)->typeLabel = (std::wstring *)soap_malloc(soap, sizeof(std::wstring))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			wchar_t *s = NULL;
			if (soap_s2wchar(soap, t, &s, 0, -1))
				return NULL;
			if (s)
			{	((_fims__BMContentFormatType_mimeType*)a)->typeLabel = soap_new_std__wstring(soap, -1);
				((_fims__BMContentFormatType_mimeType*)a)->typeLabel->assign(s);
			}
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "typeDefinition", 0);
		if (t)
		{
			if (!(((_fims__BMContentFormatType_mimeType*)a)->typeDefinition = (std::wstring *)soap_malloc(soap, sizeof(std::wstring))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			wchar_t *s = NULL;
			if (soap_s2wchar(soap, t, &s, 0, -1))
				return NULL;
			if (s)
			{	((_fims__BMContentFormatType_mimeType*)a)->typeDefinition = soap_new_std__wstring(soap, -1);
				((_fims__BMContentFormatType_mimeType*)a)->typeDefinition->assign(s);
			}
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "typeLink", 0);
		if (t)
		{
			if (!(((_fims__BMContentFormatType_mimeType*)a)->typeLink = (std::wstring *)soap_malloc(soap, sizeof(std::wstring))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			wchar_t *s = NULL;
			if (soap_s2wchar(soap, t, &s, 0, -1))
				return NULL;
			if (s)
			{	((_fims__BMContentFormatType_mimeType*)a)->typeLink = soap_new_std__wstring(soap, -1);
				((_fims__BMContentFormatType_mimeType*)a)->typeLink->assign(s);
			}
		}
		else if (soap->error)
			return NULL;
	}
	if (!soap_in_std__wstring(soap, tag, &(a->_fims__BMContentFormatType_mimeType::__item), ""))
		return NULL;
	return a;
}

int _fims__BMContentFormatType_mimeType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__fims__BMContentFormatType_mimeType);
	if (this->soap_out(soap, tag?tag:"fims:BMContentFormatType-mimeType", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_fims__BMContentFormatType_mimeType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__fims__BMContentFormatType_mimeType(soap, this, tag, type);
}

SOAP_FMAC3 _fims__BMContentFormatType_mimeType * SOAP_FMAC4 soap_get__fims__BMContentFormatType_mimeType(struct soap *soap, _fims__BMContentFormatType_mimeType *p, const char *tag, const char *type)
{
	if ((p = soap_in__fims__BMContentFormatType_mimeType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _fims__BMContentFormatType_mimeType * SOAP_FMAC2 soap_instantiate__fims__BMContentFormatType_mimeType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__fims__BMContentFormatType_mimeType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__fims__BMContentFormatType_mimeType, n, EDLProvider_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_fims__BMContentFormatType_mimeType);
		if (size)
			*size = sizeof(_fims__BMContentFormatType_mimeType);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(_fims__BMContentFormatType_mimeType, n);
		if (size)
			*size = n * sizeof(_fims__BMContentFormatType_mimeType);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (_fims__BMContentFormatType_mimeType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__fims__BMContentFormatType_mimeType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _fims__BMContentFormatType_mimeType %p -> %p\n", q, p));
	*(_fims__BMContentFormatType_mimeType*)p = *(_fims__BMContentFormatType_mimeType*)q;
}

void _fims__ServiceType_serviceDescription::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_std__vectorTemplateOf_XML(soap, &this->_fims__ServiceType_serviceDescription::__any);
}

void _fims__ServiceType_serviceDescription::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOf_XML(soap, &this->_fims__ServiceType_serviceDescription::__any);
#endif
}

int _fims__ServiceType_serviceDescription::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__fims__ServiceType_serviceDescription(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__fims__ServiceType_serviceDescription(struct soap *soap, const char *tag, int id, const _fims__ServiceType_serviceDescription *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__fims__ServiceType_serviceDescription), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOf_XML(soap, "-any", -1, &(a->_fims__ServiceType_serviceDescription::__any), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_fims__ServiceType_serviceDescription::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__fims__ServiceType_serviceDescription(soap, tag, this, type);
}

SOAP_FMAC3 _fims__ServiceType_serviceDescription * SOAP_FMAC4 soap_in__fims__ServiceType_serviceDescription(struct soap *soap, const char *tag, _fims__ServiceType_serviceDescription *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_fims__ServiceType_serviceDescription *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__fims__ServiceType_serviceDescription, sizeof(_fims__ServiceType_serviceDescription), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__fims__ServiceType_serviceDescription)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_fims__ServiceType_serviceDescription *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOf_XML(soap, "-any", &(a->_fims__ServiceType_serviceDescription::__any), ""))
					continue;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_fims__ServiceType_serviceDescription *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__fims__ServiceType_serviceDescription, 0, sizeof(_fims__ServiceType_serviceDescription), 0, soap_copy__fims__ServiceType_serviceDescription);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int _fims__ServiceType_serviceDescription::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__fims__ServiceType_serviceDescription);
	if (this->soap_out(soap, tag?tag:"fims:ServiceType-serviceDescription", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_fims__ServiceType_serviceDescription::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__fims__ServiceType_serviceDescription(soap, this, tag, type);
}

SOAP_FMAC3 _fims__ServiceType_serviceDescription * SOAP_FMAC4 soap_get__fims__ServiceType_serviceDescription(struct soap *soap, _fims__ServiceType_serviceDescription *p, const char *tag, const char *type)
{
	if ((p = soap_in__fims__ServiceType_serviceDescription(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _fims__ServiceType_serviceDescription * SOAP_FMAC2 soap_instantiate__fims__ServiceType_serviceDescription(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__fims__ServiceType_serviceDescription(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__fims__ServiceType_serviceDescription, n, EDLProvider_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_fims__ServiceType_serviceDescription);
		if (size)
			*size = sizeof(_fims__ServiceType_serviceDescription);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(_fims__ServiceType_serviceDescription, n);
		if (size)
			*size = n * sizeof(_fims__ServiceType_serviceDescription);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (_fims__ServiceType_serviceDescription*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__fims__ServiceType_serviceDescription(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _fims__ServiceType_serviceDescription %p -> %p\n", q, p));
	*(_fims__ServiceType_serviceDescription*)p = *(_fims__ServiceType_serviceDescription*)q;
}

void _fimsdescription__addressType_country::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	this->_fimsdescription__addressType_country::typeLabel = NULL;
	this->_fimsdescription__addressType_country::typeDefinition = NULL;
	this->_fimsdescription__addressType_country::typeLink = NULL;
	this->_fimsdescription__addressType_country::typeLanguage = NULL;
}

void _fimsdescription__addressType_country::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
#endif
}

int _fimsdescription__addressType_country::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__fimsdescription__addressType_country(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__fimsdescription__addressType_country(struct soap *soap, const char *tag, int id, const _fimsdescription__addressType_country *a, const char *type)
{
	if (((_fimsdescription__addressType_country*)a)->typeLabel)
		soap_set_attr(soap, "typeLabel", soap_wchar2s(soap, ((_fimsdescription__addressType_country*)a)->typeLabel->c_str()), 2);
	if (((_fimsdescription__addressType_country*)a)->typeDefinition)
		soap_set_attr(soap, "typeDefinition", soap_wchar2s(soap, ((_fimsdescription__addressType_country*)a)->typeDefinition->c_str()), 2);
	if (((_fimsdescription__addressType_country*)a)->typeLink)
		soap_set_attr(soap, "typeLink", soap_wchar2s(soap, ((_fimsdescription__addressType_country*)a)->typeLink->c_str()), 2);
	if (((_fimsdescription__addressType_country*)a)->typeLanguage)
		soap_set_attr(soap, "typeLanguage", soap_wchar2s(soap, ((_fimsdescription__addressType_country*)a)->typeLanguage->c_str()), 2);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__fimsdescription__addressType_country), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_fimsdescription__addressType_country::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__fimsdescription__addressType_country(soap, tag, this, type);
}

SOAP_FMAC3 _fimsdescription__addressType_country * SOAP_FMAC4 soap_in__fimsdescription__addressType_country(struct soap *soap, const char *tag, _fimsdescription__addressType_country *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_fimsdescription__addressType_country *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__fimsdescription__addressType_country, sizeof(_fimsdescription__addressType_country), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__fimsdescription__addressType_country)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_fimsdescription__addressType_country *)a->soap_in(soap, tag, type);
		}
	}
	{	const char *t = soap_attr_value(soap, "typeLabel", 0);
		if (t)
		{
			if (!(((_fimsdescription__addressType_country*)a)->typeLabel = (std::wstring *)soap_malloc(soap, sizeof(std::wstring))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			wchar_t *s = NULL;
			if (soap_s2wchar(soap, t, &s, 0, -1))
				return NULL;
			if (s)
			{	((_fimsdescription__addressType_country*)a)->typeLabel = soap_new_std__wstring(soap, -1);
				((_fimsdescription__addressType_country*)a)->typeLabel->assign(s);
			}
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "typeDefinition", 0);
		if (t)
		{
			if (!(((_fimsdescription__addressType_country*)a)->typeDefinition = (std::wstring *)soap_malloc(soap, sizeof(std::wstring))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			wchar_t *s = NULL;
			if (soap_s2wchar(soap, t, &s, 0, -1))
				return NULL;
			if (s)
			{	((_fimsdescription__addressType_country*)a)->typeDefinition = soap_new_std__wstring(soap, -1);
				((_fimsdescription__addressType_country*)a)->typeDefinition->assign(s);
			}
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "typeLink", 0);
		if (t)
		{
			if (!(((_fimsdescription__addressType_country*)a)->typeLink = (std::wstring *)soap_malloc(soap, sizeof(std::wstring))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			wchar_t *s = NULL;
			if (soap_s2wchar(soap, t, &s, 0, -1))
				return NULL;
			if (s)
			{	((_fimsdescription__addressType_country*)a)->typeLink = soap_new_std__wstring(soap, -1);
				((_fimsdescription__addressType_country*)a)->typeLink->assign(s);
			}
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "typeLanguage", 0);
		if (t)
		{
			if (!(((_fimsdescription__addressType_country*)a)->typeLanguage = (std::wstring *)soap_malloc(soap, sizeof(std::wstring))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			wchar_t *s = NULL;
			if (soap_s2wchar(soap, t, &s, 0, -1))
				return NULL;
			if (s)
			{	((_fimsdescription__addressType_country*)a)->typeLanguage = soap_new_std__wstring(soap, -1);
				((_fimsdescription__addressType_country*)a)->typeLanguage->assign(s);
			}
		}
		else if (soap->error)
			return NULL;
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_fimsdescription__addressType_country *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__fimsdescription__addressType_country, 0, sizeof(_fimsdescription__addressType_country), 0, soap_copy__fimsdescription__addressType_country);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int _fimsdescription__addressType_country::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__fimsdescription__addressType_country);
	if (this->soap_out(soap, tag?tag:"fimsdescription:addressType-country", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_fimsdescription__addressType_country::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__fimsdescription__addressType_country(soap, this, tag, type);
}

SOAP_FMAC3 _fimsdescription__addressType_country * SOAP_FMAC4 soap_get__fimsdescription__addressType_country(struct soap *soap, _fimsdescription__addressType_country *p, const char *tag, const char *type)
{
	if ((p = soap_in__fimsdescription__addressType_country(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _fimsdescription__addressType_country * SOAP_FMAC2 soap_instantiate__fimsdescription__addressType_country(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__fimsdescription__addressType_country(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__fimsdescription__addressType_country, n, EDLProvider_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_fimsdescription__addressType_country);
		if (size)
			*size = sizeof(_fimsdescription__addressType_country);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(_fimsdescription__addressType_country, n);
		if (size)
			*size = n * sizeof(_fimsdescription__addressType_country);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (_fimsdescription__addressType_country*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__fimsdescription__addressType_country(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _fimsdescription__addressType_country %p -> %p\n", q, p));
	*(_fimsdescription__addressType_country*)p = *(_fimsdescription__addressType_country*)q;
}

void _fimsdescription__organisationDetailsType_organisationDepartment::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	this->_fimsdescription__organisationDetailsType_organisationDepartment::departmentId = NULL;
}

void _fimsdescription__organisationDetailsType_organisationDepartment::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
#endif
}

int _fimsdescription__organisationDetailsType_organisationDepartment::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__fimsdescription__organisationDetailsType_organisationDepartment(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__fimsdescription__organisationDetailsType_organisationDepartment(struct soap *soap, const char *tag, int id, const _fimsdescription__organisationDetailsType_organisationDepartment *a, const char *type)
{
	if (((_fimsdescription__organisationDetailsType_organisationDepartment*)a)->departmentId)
		soap_set_attr(soap, "departmentId", soap_wchar2s(soap, ((_fimsdescription__organisationDetailsType_organisationDepartment*)a)->departmentId->c_str()), 2);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__fimsdescription__organisationDetailsType_organisationDepartment), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_fimsdescription__organisationDetailsType_organisationDepartment::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__fimsdescription__organisationDetailsType_organisationDepartment(soap, tag, this, type);
}

SOAP_FMAC3 _fimsdescription__organisationDetailsType_organisationDepartment * SOAP_FMAC4 soap_in__fimsdescription__organisationDetailsType_organisationDepartment(struct soap *soap, const char *tag, _fimsdescription__organisationDetailsType_organisationDepartment *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_fimsdescription__organisationDetailsType_organisationDepartment *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__fimsdescription__organisationDetailsType_organisationDepartment, sizeof(_fimsdescription__organisationDetailsType_organisationDepartment), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__fimsdescription__organisationDetailsType_organisationDepartment)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_fimsdescription__organisationDetailsType_organisationDepartment *)a->soap_in(soap, tag, type);
		}
	}
	{	const char *t = soap_attr_value(soap, "departmentId", 0);
		if (t)
		{
			if (!(((_fimsdescription__organisationDetailsType_organisationDepartment*)a)->departmentId = (std::wstring *)soap_malloc(soap, sizeof(std::wstring))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			wchar_t *s = NULL;
			if (soap_s2wchar(soap, t, &s, 0, -1))
				return NULL;
			if (s)
			{	((_fimsdescription__organisationDetailsType_organisationDepartment*)a)->departmentId = soap_new_std__wstring(soap, -1);
				((_fimsdescription__organisationDetailsType_organisationDepartment*)a)->departmentId->assign(s);
			}
		}
		else if (soap->error)
			return NULL;
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_fimsdescription__organisationDetailsType_organisationDepartment *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__fimsdescription__organisationDetailsType_organisationDepartment, 0, sizeof(_fimsdescription__organisationDetailsType_organisationDepartment), 0, soap_copy__fimsdescription__organisationDetailsType_organisationDepartment);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int _fimsdescription__organisationDetailsType_organisationDepartment::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__fimsdescription__organisationDetailsType_organisationDepartment);
	if (this->soap_out(soap, tag?tag:"fimsdescription:organisationDetailsType-organisationDepartment", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_fimsdescription__organisationDetailsType_organisationDepartment::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__fimsdescription__organisationDetailsType_organisationDepartment(soap, this, tag, type);
}

SOAP_FMAC3 _fimsdescription__organisationDetailsType_organisationDepartment * SOAP_FMAC4 soap_get__fimsdescription__organisationDetailsType_organisationDepartment(struct soap *soap, _fimsdescription__organisationDetailsType_organisationDepartment *p, const char *tag, const char *type)
{
	if ((p = soap_in__fimsdescription__organisationDetailsType_organisationDepartment(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _fimsdescription__organisationDetailsType_organisationDepartment * SOAP_FMAC2 soap_instantiate__fimsdescription__organisationDetailsType_organisationDepartment(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__fimsdescription__organisationDetailsType_organisationDepartment(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__fimsdescription__organisationDetailsType_organisationDepartment, n, EDLProvider_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_fimsdescription__organisationDetailsType_organisationDepartment);
		if (size)
			*size = sizeof(_fimsdescription__organisationDetailsType_organisationDepartment);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(_fimsdescription__organisationDetailsType_organisationDepartment, n);
		if (size)
			*size = n * sizeof(_fimsdescription__organisationDetailsType_organisationDepartment);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (_fimsdescription__organisationDetailsType_organisationDepartment*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__fimsdescription__organisationDetailsType_organisationDepartment(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _fimsdescription__organisationDetailsType_organisationDepartment %p -> %p\n", q, p));
	*(_fimsdescription__organisationDetailsType_organisationDepartment*)p = *(_fimsdescription__organisationDetailsType_organisationDepartment*)q;
}

void _fimsdescription__entityType_role::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	this->_fimsdescription__entityType_role::typeLabel = NULL;
	this->_fimsdescription__entityType_role::typeDefinition = NULL;
	this->_fimsdescription__entityType_role::typeLink = NULL;
	this->_fimsdescription__entityType_role::typeLanguage = NULL;
}

void _fimsdescription__entityType_role::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
#endif
}

int _fimsdescription__entityType_role::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__fimsdescription__entityType_role(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__fimsdescription__entityType_role(struct soap *soap, const char *tag, int id, const _fimsdescription__entityType_role *a, const char *type)
{
	if (((_fimsdescription__entityType_role*)a)->typeLabel)
		soap_set_attr(soap, "typeLabel", soap_wchar2s(soap, ((_fimsdescription__entityType_role*)a)->typeLabel->c_str()), 2);
	if (((_fimsdescription__entityType_role*)a)->typeDefinition)
		soap_set_attr(soap, "typeDefinition", soap_wchar2s(soap, ((_fimsdescription__entityType_role*)a)->typeDefinition->c_str()), 2);
	if (((_fimsdescription__entityType_role*)a)->typeLink)
		soap_set_attr(soap, "typeLink", soap_wchar2s(soap, ((_fimsdescription__entityType_role*)a)->typeLink->c_str()), 2);
	if (((_fimsdescription__entityType_role*)a)->typeLanguage)
		soap_set_attr(soap, "typeLanguage", soap_wchar2s(soap, ((_fimsdescription__entityType_role*)a)->typeLanguage->c_str()), 2);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__fimsdescription__entityType_role), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_fimsdescription__entityType_role::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__fimsdescription__entityType_role(soap, tag, this, type);
}

SOAP_FMAC3 _fimsdescription__entityType_role * SOAP_FMAC4 soap_in__fimsdescription__entityType_role(struct soap *soap, const char *tag, _fimsdescription__entityType_role *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_fimsdescription__entityType_role *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__fimsdescription__entityType_role, sizeof(_fimsdescription__entityType_role), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__fimsdescription__entityType_role)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_fimsdescription__entityType_role *)a->soap_in(soap, tag, type);
		}
	}
	{	const char *t = soap_attr_value(soap, "typeLabel", 0);
		if (t)
		{
			if (!(((_fimsdescription__entityType_role*)a)->typeLabel = (std::wstring *)soap_malloc(soap, sizeof(std::wstring))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			wchar_t *s = NULL;
			if (soap_s2wchar(soap, t, &s, 0, -1))
				return NULL;
			if (s)
			{	((_fimsdescription__entityType_role*)a)->typeLabel = soap_new_std__wstring(soap, -1);
				((_fimsdescription__entityType_role*)a)->typeLabel->assign(s);
			}
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "typeDefinition", 0);
		if (t)
		{
			if (!(((_fimsdescription__entityType_role*)a)->typeDefinition = (std::wstring *)soap_malloc(soap, sizeof(std::wstring))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			wchar_t *s = NULL;
			if (soap_s2wchar(soap, t, &s, 0, -1))
				return NULL;
			if (s)
			{	((_fimsdescription__entityType_role*)a)->typeDefinition = soap_new_std__wstring(soap, -1);
				((_fimsdescription__entityType_role*)a)->typeDefinition->assign(s);
			}
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "typeLink", 0);
		if (t)
		{
			if (!(((_fimsdescription__entityType_role*)a)->typeLink = (std::wstring *)soap_malloc(soap, sizeof(std::wstring))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			wchar_t *s = NULL;
			if (soap_s2wchar(soap, t, &s, 0, -1))
				return NULL;
			if (s)
			{	((_fimsdescription__entityType_role*)a)->typeLink = soap_new_std__wstring(soap, -1);
				((_fimsdescription__entityType_role*)a)->typeLink->assign(s);
			}
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "typeLanguage", 0);
		if (t)
		{
			if (!(((_fimsdescription__entityType_role*)a)->typeLanguage = (std::wstring *)soap_malloc(soap, sizeof(std::wstring))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			wchar_t *s = NULL;
			if (soap_s2wchar(soap, t, &s, 0, -1))
				return NULL;
			if (s)
			{	((_fimsdescription__entityType_role*)a)->typeLanguage = soap_new_std__wstring(soap, -1);
				((_fimsdescription__entityType_role*)a)->typeLanguage->assign(s);
			}
		}
		else if (soap->error)
			return NULL;
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_fimsdescription__entityType_role *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__fimsdescription__entityType_role, 0, sizeof(_fimsdescription__entityType_role), 0, soap_copy__fimsdescription__entityType_role);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int _fimsdescription__entityType_role::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__fimsdescription__entityType_role);
	if (this->soap_out(soap, tag?tag:"fimsdescription:entityType-role", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_fimsdescription__entityType_role::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__fimsdescription__entityType_role(soap, this, tag, type);
}

SOAP_FMAC3 _fimsdescription__entityType_role * SOAP_FMAC4 soap_get__fimsdescription__entityType_role(struct soap *soap, _fimsdescription__entityType_role *p, const char *tag, const char *type)
{
	if ((p = soap_in__fimsdescription__entityType_role(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _fimsdescription__entityType_role * SOAP_FMAC2 soap_instantiate__fimsdescription__entityType_role(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__fimsdescription__entityType_role(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__fimsdescription__entityType_role, n, EDLProvider_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_fimsdescription__entityType_role);
		if (size)
			*size = sizeof(_fimsdescription__entityType_role);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(_fimsdescription__entityType_role, n);
		if (size)
			*size = n * sizeof(_fimsdescription__entityType_role);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (_fimsdescription__entityType_role*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__fimsdescription__entityType_role(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _fimsdescription__entityType_role %p -> %p\n", q, p));
	*(_fimsdescription__entityType_role*)p = *(_fimsdescription__entityType_role*)q;
}

void _fimsdescription__dateType_alternative::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	this->_fimsdescription__dateType_alternative::startYear = NULL;
	this->_fimsdescription__dateType_alternative::startDate = NULL;
	this->_fimsdescription__dateType_alternative::startTime = NULL;
	this->_fimsdescription__dateType_alternative::endYear = NULL;
	this->_fimsdescription__dateType_alternative::endDate = NULL;
	this->_fimsdescription__dateType_alternative::endTime = NULL;
	this->_fimsdescription__dateType_alternative::period = NULL;
	this->_fimsdescription__dateType_alternative::typeLabel = NULL;
	this->_fimsdescription__dateType_alternative::typeDefinition = NULL;
	this->_fimsdescription__dateType_alternative::typeLink = NULL;
	this->_fimsdescription__dateType_alternative::typeLanguage = NULL;
}

void _fimsdescription__dateType_alternative::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
#endif
}

int _fimsdescription__dateType_alternative::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__fimsdescription__dateType_alternative(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__fimsdescription__dateType_alternative(struct soap *soap, const char *tag, int id, const _fimsdescription__dateType_alternative *a, const char *type)
{
	if (((_fimsdescription__dateType_alternative*)a)->startYear)
		soap_set_attr(soap, "startYear", soap_wchar2s(soap, ((_fimsdescription__dateType_alternative*)a)->startYear->c_str()), 2);
	if (((_fimsdescription__dateType_alternative*)a)->startDate)
		soap_set_attr(soap, "startDate", soap_wchar2s(soap, ((_fimsdescription__dateType_alternative*)a)->startDate->c_str()), 2);
	if (((_fimsdescription__dateType_alternative*)a)->startTime)
		soap_set_attr(soap, "startTime", soap_wchar2s(soap, ((_fimsdescription__dateType_alternative*)a)->startTime->c_str()), 2);
	if (((_fimsdescription__dateType_alternative*)a)->endYear)
		soap_set_attr(soap, "endYear", soap_wchar2s(soap, ((_fimsdescription__dateType_alternative*)a)->endYear->c_str()), 2);
	if (((_fimsdescription__dateType_alternative*)a)->endDate)
		soap_set_attr(soap, "endDate", soap_wchar2s(soap, ((_fimsdescription__dateType_alternative*)a)->endDate->c_str()), 2);
	if (((_fimsdescription__dateType_alternative*)a)->endTime)
		soap_set_attr(soap, "endTime", soap_wchar2s(soap, ((_fimsdescription__dateType_alternative*)a)->endTime->c_str()), 2);
	if (((_fimsdescription__dateType_alternative*)a)->period)
		soap_set_attr(soap, "period", soap_wchar2s(soap, ((_fimsdescription__dateType_alternative*)a)->period->c_str()), 2);
	if (((_fimsdescription__dateType_alternative*)a)->typeLabel)
		soap_set_attr(soap, "typeLabel", soap_wchar2s(soap, ((_fimsdescription__dateType_alternative*)a)->typeLabel->c_str()), 2);
	if (((_fimsdescription__dateType_alternative*)a)->typeDefinition)
		soap_set_attr(soap, "typeDefinition", soap_wchar2s(soap, ((_fimsdescription__dateType_alternative*)a)->typeDefinition->c_str()), 2);
	if (((_fimsdescription__dateType_alternative*)a)->typeLink)
		soap_set_attr(soap, "typeLink", soap_wchar2s(soap, ((_fimsdescription__dateType_alternative*)a)->typeLink->c_str()), 2);
	if (((_fimsdescription__dateType_alternative*)a)->typeLanguage)
		soap_set_attr(soap, "typeLanguage", soap_wchar2s(soap, ((_fimsdescription__dateType_alternative*)a)->typeLanguage->c_str()), 2);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__fimsdescription__dateType_alternative), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_fimsdescription__dateType_alternative::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__fimsdescription__dateType_alternative(soap, tag, this, type);
}

SOAP_FMAC3 _fimsdescription__dateType_alternative * SOAP_FMAC4 soap_in__fimsdescription__dateType_alternative(struct soap *soap, const char *tag, _fimsdescription__dateType_alternative *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_fimsdescription__dateType_alternative *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__fimsdescription__dateType_alternative, sizeof(_fimsdescription__dateType_alternative), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__fimsdescription__dateType_alternative)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_fimsdescription__dateType_alternative *)a->soap_in(soap, tag, type);
		}
	}
	{	const char *t = soap_attr_value(soap, "startYear", 0);
		if (t)
		{
			if (!(((_fimsdescription__dateType_alternative*)a)->startYear = (std::wstring *)soap_malloc(soap, sizeof(std::wstring))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			wchar_t *s = NULL;
			if (soap_s2wchar(soap, t, &s, 0, -1))
				return NULL;
			if (s)
			{	((_fimsdescription__dateType_alternative*)a)->startYear = soap_new_std__wstring(soap, -1);
				((_fimsdescription__dateType_alternative*)a)->startYear->assign(s);
			}
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "startDate", 0);
		if (t)
		{
			if (!(((_fimsdescription__dateType_alternative*)a)->startDate = (std::wstring *)soap_malloc(soap, sizeof(std::wstring))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			wchar_t *s = NULL;
			if (soap_s2wchar(soap, t, &s, 0, -1))
				return NULL;
			if (s)
			{	((_fimsdescription__dateType_alternative*)a)->startDate = soap_new_std__wstring(soap, -1);
				((_fimsdescription__dateType_alternative*)a)->startDate->assign(s);
			}
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "startTime", 0);
		if (t)
		{
			if (!(((_fimsdescription__dateType_alternative*)a)->startTime = (std::wstring *)soap_malloc(soap, sizeof(std::wstring))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			wchar_t *s = NULL;
			if (soap_s2wchar(soap, t, &s, 0, -1))
				return NULL;
			if (s)
			{	((_fimsdescription__dateType_alternative*)a)->startTime = soap_new_std__wstring(soap, -1);
				((_fimsdescription__dateType_alternative*)a)->startTime->assign(s);
			}
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "endYear", 0);
		if (t)
		{
			if (!(((_fimsdescription__dateType_alternative*)a)->endYear = (std::wstring *)soap_malloc(soap, sizeof(std::wstring))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			wchar_t *s = NULL;
			if (soap_s2wchar(soap, t, &s, 0, -1))
				return NULL;
			if (s)
			{	((_fimsdescription__dateType_alternative*)a)->endYear = soap_new_std__wstring(soap, -1);
				((_fimsdescription__dateType_alternative*)a)->endYear->assign(s);
			}
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "endDate", 0);
		if (t)
		{
			if (!(((_fimsdescription__dateType_alternative*)a)->endDate = (std::wstring *)soap_malloc(soap, sizeof(std::wstring))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			wchar_t *s = NULL;
			if (soap_s2wchar(soap, t, &s, 0, -1))
				return NULL;
			if (s)
			{	((_fimsdescription__dateType_alternative*)a)->endDate = soap_new_std__wstring(soap, -1);
				((_fimsdescription__dateType_alternative*)a)->endDate->assign(s);
			}
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "endTime", 0);
		if (t)
		{
			if (!(((_fimsdescription__dateType_alternative*)a)->endTime = (std::wstring *)soap_malloc(soap, sizeof(std::wstring))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			wchar_t *s = NULL;
			if (soap_s2wchar(soap, t, &s, 0, -1))
				return NULL;
			if (s)
			{	((_fimsdescription__dateType_alternative*)a)->endTime = soap_new_std__wstring(soap, -1);
				((_fimsdescription__dateType_alternative*)a)->endTime->assign(s);
			}
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "period", 0);
		if (t)
		{
			if (!(((_fimsdescription__dateType_alternative*)a)->period = (std::wstring *)soap_malloc(soap, sizeof(std::wstring))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			wchar_t *s = NULL;
			if (soap_s2wchar(soap, t, &s, 0, -1))
				return NULL;
			if (s)
			{	((_fimsdescription__dateType_alternative*)a)->period = soap_new_std__wstring(soap, -1);
				((_fimsdescription__dateType_alternative*)a)->period->assign(s);
			}
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "typeLabel", 0);
		if (t)
		{
			if (!(((_fimsdescription__dateType_alternative*)a)->typeLabel = (std::wstring *)soap_malloc(soap, sizeof(std::wstring))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			wchar_t *s = NULL;
			if (soap_s2wchar(soap, t, &s, 0, -1))
				return NULL;
			if (s)
			{	((_fimsdescription__dateType_alternative*)a)->typeLabel = soap_new_std__wstring(soap, -1);
				((_fimsdescription__dateType_alternative*)a)->typeLabel->assign(s);
			}
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "typeDefinition", 0);
		if (t)
		{
			if (!(((_fimsdescription__dateType_alternative*)a)->typeDefinition = (std::wstring *)soap_malloc(soap, sizeof(std::wstring))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			wchar_t *s = NULL;
			if (soap_s2wchar(soap, t, &s, 0, -1))
				return NULL;
			if (s)
			{	((_fimsdescription__dateType_alternative*)a)->typeDefinition = soap_new_std__wstring(soap, -1);
				((_fimsdescription__dateType_alternative*)a)->typeDefinition->assign(s);
			}
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "typeLink", 0);
		if (t)
		{
			if (!(((_fimsdescription__dateType_alternative*)a)->typeLink = (std::wstring *)soap_malloc(soap, sizeof(std::wstring))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			wchar_t *s = NULL;
			if (soap_s2wchar(soap, t, &s, 0, -1))
				return NULL;
			if (s)
			{	((_fimsdescription__dateType_alternative*)a)->typeLink = soap_new_std__wstring(soap, -1);
				((_fimsdescription__dateType_alternative*)a)->typeLink->assign(s);
			}
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "typeLanguage", 0);
		if (t)
		{
			if (!(((_fimsdescription__dateType_alternative*)a)->typeLanguage = (std::wstring *)soap_malloc(soap, sizeof(std::wstring))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			wchar_t *s = NULL;
			if (soap_s2wchar(soap, t, &s, 0, -1))
				return NULL;
			if (s)
			{	((_fimsdescription__dateType_alternative*)a)->typeLanguage = soap_new_std__wstring(soap, -1);
				((_fimsdescription__dateType_alternative*)a)->typeLanguage->assign(s);
			}
		}
		else if (soap->error)
			return NULL;
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_fimsdescription__dateType_alternative *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__fimsdescription__dateType_alternative, 0, sizeof(_fimsdescription__dateType_alternative), 0, soap_copy__fimsdescription__dateType_alternative);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int _fimsdescription__dateType_alternative::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__fimsdescription__dateType_alternative);
	if (this->soap_out(soap, tag?tag:"fimsdescription:dateType-alternative", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_fimsdescription__dateType_alternative::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__fimsdescription__dateType_alternative(soap, this, tag, type);
}

SOAP_FMAC3 _fimsdescription__dateType_alternative * SOAP_FMAC4 soap_get__fimsdescription__dateType_alternative(struct soap *soap, _fimsdescription__dateType_alternative *p, const char *tag, const char *type)
{
	if ((p = soap_in__fimsdescription__dateType_alternative(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _fimsdescription__dateType_alternative * SOAP_FMAC2 soap_instantiate__fimsdescription__dateType_alternative(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__fimsdescription__dateType_alternative(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__fimsdescription__dateType_alternative, n, EDLProvider_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_fimsdescription__dateType_alternative);
		if (size)
			*size = sizeof(_fimsdescription__dateType_alternative);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(_fimsdescription__dateType_alternative, n);
		if (size)
			*size = n * sizeof(_fimsdescription__dateType_alternative);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (_fimsdescription__dateType_alternative*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__fimsdescription__dateType_alternative(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _fimsdescription__dateType_alternative %p -> %p\n", q, p));
	*(_fimsdescription__dateType_alternative*)p = *(_fimsdescription__dateType_alternative*)q;
}

void _fimsdescription__dateType_issued::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	this->_fimsdescription__dateType_issued::startYear = NULL;
	this->_fimsdescription__dateType_issued::startDate = NULL;
	this->_fimsdescription__dateType_issued::startTime = NULL;
	this->_fimsdescription__dateType_issued::endYear = NULL;
	this->_fimsdescription__dateType_issued::endDate = NULL;
	this->_fimsdescription__dateType_issued::endTime = NULL;
	this->_fimsdescription__dateType_issued::period = NULL;
}

void _fimsdescription__dateType_issued::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
#endif
}

int _fimsdescription__dateType_issued::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__fimsdescription__dateType_issued(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__fimsdescription__dateType_issued(struct soap *soap, const char *tag, int id, const _fimsdescription__dateType_issued *a, const char *type)
{
	if (((_fimsdescription__dateType_issued*)a)->startYear)
		soap_set_attr(soap, "startYear", soap_wchar2s(soap, ((_fimsdescription__dateType_issued*)a)->startYear->c_str()), 2);
	if (((_fimsdescription__dateType_issued*)a)->startDate)
		soap_set_attr(soap, "startDate", soap_wchar2s(soap, ((_fimsdescription__dateType_issued*)a)->startDate->c_str()), 2);
	if (((_fimsdescription__dateType_issued*)a)->startTime)
		soap_set_attr(soap, "startTime", soap_wchar2s(soap, ((_fimsdescription__dateType_issued*)a)->startTime->c_str()), 2);
	if (((_fimsdescription__dateType_issued*)a)->endYear)
		soap_set_attr(soap, "endYear", soap_wchar2s(soap, ((_fimsdescription__dateType_issued*)a)->endYear->c_str()), 2);
	if (((_fimsdescription__dateType_issued*)a)->endDate)
		soap_set_attr(soap, "endDate", soap_wchar2s(soap, ((_fimsdescription__dateType_issued*)a)->endDate->c_str()), 2);
	if (((_fimsdescription__dateType_issued*)a)->endTime)
		soap_set_attr(soap, "endTime", soap_wchar2s(soap, ((_fimsdescription__dateType_issued*)a)->endTime->c_str()), 2);
	if (((_fimsdescription__dateType_issued*)a)->period)
		soap_set_attr(soap, "period", soap_wchar2s(soap, ((_fimsdescription__dateType_issued*)a)->period->c_str()), 2);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__fimsdescription__dateType_issued), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_fimsdescription__dateType_issued::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__fimsdescription__dateType_issued(soap, tag, this, type);
}

SOAP_FMAC3 _fimsdescription__dateType_issued * SOAP_FMAC4 soap_in__fimsdescription__dateType_issued(struct soap *soap, const char *tag, _fimsdescription__dateType_issued *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_fimsdescription__dateType_issued *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__fimsdescription__dateType_issued, sizeof(_fimsdescription__dateType_issued), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__fimsdescription__dateType_issued)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_fimsdescription__dateType_issued *)a->soap_in(soap, tag, type);
		}
	}
	{	const char *t = soap_attr_value(soap, "startYear", 0);
		if (t)
		{
			if (!(((_fimsdescription__dateType_issued*)a)->startYear = (std::wstring *)soap_malloc(soap, sizeof(std::wstring))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			wchar_t *s = NULL;
			if (soap_s2wchar(soap, t, &s, 0, -1))
				return NULL;
			if (s)
			{	((_fimsdescription__dateType_issued*)a)->startYear = soap_new_std__wstring(soap, -1);
				((_fimsdescription__dateType_issued*)a)->startYear->assign(s);
			}
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "startDate", 0);
		if (t)
		{
			if (!(((_fimsdescription__dateType_issued*)a)->startDate = (std::wstring *)soap_malloc(soap, sizeof(std::wstring))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			wchar_t *s = NULL;
			if (soap_s2wchar(soap, t, &s, 0, -1))
				return NULL;
			if (s)
			{	((_fimsdescription__dateType_issued*)a)->startDate = soap_new_std__wstring(soap, -1);
				((_fimsdescription__dateType_issued*)a)->startDate->assign(s);
			}
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "startTime", 0);
		if (t)
		{
			if (!(((_fimsdescription__dateType_issued*)a)->startTime = (std::wstring *)soap_malloc(soap, sizeof(std::wstring))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			wchar_t *s = NULL;
			if (soap_s2wchar(soap, t, &s, 0, -1))
				return NULL;
			if (s)
			{	((_fimsdescription__dateType_issued*)a)->startTime = soap_new_std__wstring(soap, -1);
				((_fimsdescription__dateType_issued*)a)->startTime->assign(s);
			}
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "endYear", 0);
		if (t)
		{
			if (!(((_fimsdescription__dateType_issued*)a)->endYear = (std::wstring *)soap_malloc(soap, sizeof(std::wstring))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			wchar_t *s = NULL;
			if (soap_s2wchar(soap, t, &s, 0, -1))
				return NULL;
			if (s)
			{	((_fimsdescription__dateType_issued*)a)->endYear = soap_new_std__wstring(soap, -1);
				((_fimsdescription__dateType_issued*)a)->endYear->assign(s);
			}
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "endDate", 0);
		if (t)
		{
			if (!(((_fimsdescription__dateType_issued*)a)->endDate = (std::wstring *)soap_malloc(soap, sizeof(std::wstring))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			wchar_t *s = NULL;
			if (soap_s2wchar(soap, t, &s, 0, -1))
				return NULL;
			if (s)
			{	((_fimsdescription__dateType_issued*)a)->endDate = soap_new_std__wstring(soap, -1);
				((_fimsdescription__dateType_issued*)a)->endDate->assign(s);
			}
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "endTime", 0);
		if (t)
		{
			if (!(((_fimsdescription__dateType_issued*)a)->endTime = (std::wstring *)soap_malloc(soap, sizeof(std::wstring))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			wchar_t *s = NULL;
			if (soap_s2wchar(soap, t, &s, 0, -1))
				return NULL;
			if (s)
			{	((_fimsdescription__dateType_issued*)a)->endTime = soap_new_std__wstring(soap, -1);
				((_fimsdescription__dateType_issued*)a)->endTime->assign(s);
			}
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "period", 0);
		if (t)
		{
			if (!(((_fimsdescription__dateType_issued*)a)->period = (std::wstring *)soap_malloc(soap, sizeof(std::wstring))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			wchar_t *s = NULL;
			if (soap_s2wchar(soap, t, &s, 0, -1))
				return NULL;
			if (s)
			{	((_fimsdescription__dateType_issued*)a)->period = soap_new_std__wstring(soap, -1);
				((_fimsdescription__dateType_issued*)a)->period->assign(s);
			}
		}
		else if (soap->error)
			return NULL;
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_fimsdescription__dateType_issued *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__fimsdescription__dateType_issued, 0, sizeof(_fimsdescription__dateType_issued), 0, soap_copy__fimsdescription__dateType_issued);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int _fimsdescription__dateType_issued::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__fimsdescription__dateType_issued);
	if (this->soap_out(soap, tag?tag:"fimsdescription:dateType-issued", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_fimsdescription__dateType_issued::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__fimsdescription__dateType_issued(soap, this, tag, type);
}

SOAP_FMAC3 _fimsdescription__dateType_issued * SOAP_FMAC4 soap_get__fimsdescription__dateType_issued(struct soap *soap, _fimsdescription__dateType_issued *p, const char *tag, const char *type)
{
	if ((p = soap_in__fimsdescription__dateType_issued(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _fimsdescription__dateType_issued * SOAP_FMAC2 soap_instantiate__fimsdescription__dateType_issued(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__fimsdescription__dateType_issued(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__fimsdescription__dateType_issued, n, EDLProvider_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_fimsdescription__dateType_issued);
		if (size)
			*size = sizeof(_fimsdescription__dateType_issued);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(_fimsdescription__dateType_issued, n);
		if (size)
			*size = n * sizeof(_fimsdescription__dateType_issued);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (_fimsdescription__dateType_issued*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__fimsdescription__dateType_issued(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _fimsdescription__dateType_issued %p -> %p\n", q, p));
	*(_fimsdescription__dateType_issued*)p = *(_fimsdescription__dateType_issued*)q;
}

void _fimsdescription__dateType_modified::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	this->_fimsdescription__dateType_modified::startYear = NULL;
	this->_fimsdescription__dateType_modified::startDate = NULL;
	this->_fimsdescription__dateType_modified::startTime = NULL;
	this->_fimsdescription__dateType_modified::endYear = NULL;
	this->_fimsdescription__dateType_modified::endDate = NULL;
	this->_fimsdescription__dateType_modified::endTime = NULL;
	this->_fimsdescription__dateType_modified::period = NULL;
}

void _fimsdescription__dateType_modified::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
#endif
}

int _fimsdescription__dateType_modified::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__fimsdescription__dateType_modified(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__fimsdescription__dateType_modified(struct soap *soap, const char *tag, int id, const _fimsdescription__dateType_modified *a, const char *type)
{
	if (((_fimsdescription__dateType_modified*)a)->startYear)
		soap_set_attr(soap, "startYear", soap_wchar2s(soap, ((_fimsdescription__dateType_modified*)a)->startYear->c_str()), 2);
	if (((_fimsdescription__dateType_modified*)a)->startDate)
		soap_set_attr(soap, "startDate", soap_wchar2s(soap, ((_fimsdescription__dateType_modified*)a)->startDate->c_str()), 2);
	if (((_fimsdescription__dateType_modified*)a)->startTime)
		soap_set_attr(soap, "startTime", soap_wchar2s(soap, ((_fimsdescription__dateType_modified*)a)->startTime->c_str()), 2);
	if (((_fimsdescription__dateType_modified*)a)->endYear)
		soap_set_attr(soap, "endYear", soap_wchar2s(soap, ((_fimsdescription__dateType_modified*)a)->endYear->c_str()), 2);
	if (((_fimsdescription__dateType_modified*)a)->endDate)
		soap_set_attr(soap, "endDate", soap_wchar2s(soap, ((_fimsdescription__dateType_modified*)a)->endDate->c_str()), 2);
	if (((_fimsdescription__dateType_modified*)a)->endTime)
		soap_set_attr(soap, "endTime", soap_wchar2s(soap, ((_fimsdescription__dateType_modified*)a)->endTime->c_str()), 2);
	if (((_fimsdescription__dateType_modified*)a)->period)
		soap_set_attr(soap, "period", soap_wchar2s(soap, ((_fimsdescription__dateType_modified*)a)->period->c_str()), 2);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__fimsdescription__dateType_modified), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_fimsdescription__dateType_modified::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__fimsdescription__dateType_modified(soap, tag, this, type);
}

SOAP_FMAC3 _fimsdescription__dateType_modified * SOAP_FMAC4 soap_in__fimsdescription__dateType_modified(struct soap *soap, const char *tag, _fimsdescription__dateType_modified *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_fimsdescription__dateType_modified *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__fimsdescription__dateType_modified, sizeof(_fimsdescription__dateType_modified), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__fimsdescription__dateType_modified)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_fimsdescription__dateType_modified *)a->soap_in(soap, tag, type);
		}
	}
	{	const char *t = soap_attr_value(soap, "startYear", 0);
		if (t)
		{
			if (!(((_fimsdescription__dateType_modified*)a)->startYear = (std::wstring *)soap_malloc(soap, sizeof(std::wstring))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			wchar_t *s = NULL;
			if (soap_s2wchar(soap, t, &s, 0, -1))
				return NULL;
			if (s)
			{	((_fimsdescription__dateType_modified*)a)->startYear = soap_new_std__wstring(soap, -1);
				((_fimsdescription__dateType_modified*)a)->startYear->assign(s);
			}
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "startDate", 0);
		if (t)
		{
			if (!(((_fimsdescription__dateType_modified*)a)->startDate = (std::wstring *)soap_malloc(soap, sizeof(std::wstring))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			wchar_t *s = NULL;
			if (soap_s2wchar(soap, t, &s, 0, -1))
				return NULL;
			if (s)
			{	((_fimsdescription__dateType_modified*)a)->startDate = soap_new_std__wstring(soap, -1);
				((_fimsdescription__dateType_modified*)a)->startDate->assign(s);
			}
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "startTime", 0);
		if (t)
		{
			if (!(((_fimsdescription__dateType_modified*)a)->startTime = (std::wstring *)soap_malloc(soap, sizeof(std::wstring))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			wchar_t *s = NULL;
			if (soap_s2wchar(soap, t, &s, 0, -1))
				return NULL;
			if (s)
			{	((_fimsdescription__dateType_modified*)a)->startTime = soap_new_std__wstring(soap, -1);
				((_fimsdescription__dateType_modified*)a)->startTime->assign(s);
			}
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "endYear", 0);
		if (t)
		{
			if (!(((_fimsdescription__dateType_modified*)a)->endYear = (std::wstring *)soap_malloc(soap, sizeof(std::wstring))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			wchar_t *s = NULL;
			if (soap_s2wchar(soap, t, &s, 0, -1))
				return NULL;
			if (s)
			{	((_fimsdescription__dateType_modified*)a)->endYear = soap_new_std__wstring(soap, -1);
				((_fimsdescription__dateType_modified*)a)->endYear->assign(s);
			}
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "endDate", 0);
		if (t)
		{
			if (!(((_fimsdescription__dateType_modified*)a)->endDate = (std::wstring *)soap_malloc(soap, sizeof(std::wstring))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			wchar_t *s = NULL;
			if (soap_s2wchar(soap, t, &s, 0, -1))
				return NULL;
			if (s)
			{	((_fimsdescription__dateType_modified*)a)->endDate = soap_new_std__wstring(soap, -1);
				((_fimsdescription__dateType_modified*)a)->endDate->assign(s);
			}
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "endTime", 0);
		if (t)
		{
			if (!(((_fimsdescription__dateType_modified*)a)->endTime = (std::wstring *)soap_malloc(soap, sizeof(std::wstring))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			wchar_t *s = NULL;
			if (soap_s2wchar(soap, t, &s, 0, -1))
				return NULL;
			if (s)
			{	((_fimsdescription__dateType_modified*)a)->endTime = soap_new_std__wstring(soap, -1);
				((_fimsdescription__dateType_modified*)a)->endTime->assign(s);
			}
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "period", 0);
		if (t)
		{
			if (!(((_fimsdescription__dateType_modified*)a)->period = (std::wstring *)soap_malloc(soap, sizeof(std::wstring))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			wchar_t *s = NULL;
			if (soap_s2wchar(soap, t, &s, 0, -1))
				return NULL;
			if (s)
			{	((_fimsdescription__dateType_modified*)a)->period = soap_new_std__wstring(soap, -1);
				((_fimsdescription__dateType_modified*)a)->period->assign(s);
			}
		}
		else if (soap->error)
			return NULL;
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_fimsdescription__dateType_modified *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__fimsdescription__dateType_modified, 0, sizeof(_fimsdescription__dateType_modified), 0, soap_copy__fimsdescription__dateType_modified);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int _fimsdescription__dateType_modified::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__fimsdescription__dateType_modified);
	if (this->soap_out(soap, tag?tag:"fimsdescription:dateType-modified", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_fimsdescription__dateType_modified::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__fimsdescription__dateType_modified(soap, this, tag, type);
}

SOAP_FMAC3 _fimsdescription__dateType_modified * SOAP_FMAC4 soap_get__fimsdescription__dateType_modified(struct soap *soap, _fimsdescription__dateType_modified *p, const char *tag, const char *type)
{
	if ((p = soap_in__fimsdescription__dateType_modified(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _fimsdescription__dateType_modified * SOAP_FMAC2 soap_instantiate__fimsdescription__dateType_modified(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__fimsdescription__dateType_modified(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__fimsdescription__dateType_modified, n, EDLProvider_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_fimsdescription__dateType_modified);
		if (size)
			*size = sizeof(_fimsdescription__dateType_modified);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(_fimsdescription__dateType_modified, n);
		if (size)
			*size = n * sizeof(_fimsdescription__dateType_modified);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (_fimsdescription__dateType_modified*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__fimsdescription__dateType_modified(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _fimsdescription__dateType_modified %p -> %p\n", q, p));
	*(_fimsdescription__dateType_modified*)p = *(_fimsdescription__dateType_modified*)q;
}

void _fimsdescription__dateType_created::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	this->_fimsdescription__dateType_created::startYear = NULL;
	this->_fimsdescription__dateType_created::startDate = NULL;
	this->_fimsdescription__dateType_created::startTime = NULL;
	this->_fimsdescription__dateType_created::endYear = NULL;
	this->_fimsdescription__dateType_created::endDate = NULL;
	this->_fimsdescription__dateType_created::endTime = NULL;
	this->_fimsdescription__dateType_created::period = NULL;
}

void _fimsdescription__dateType_created::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
#endif
}

int _fimsdescription__dateType_created::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__fimsdescription__dateType_created(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__fimsdescription__dateType_created(struct soap *soap, const char *tag, int id, const _fimsdescription__dateType_created *a, const char *type)
{
	if (((_fimsdescription__dateType_created*)a)->startYear)
		soap_set_attr(soap, "startYear", soap_wchar2s(soap, ((_fimsdescription__dateType_created*)a)->startYear->c_str()), 2);
	if (((_fimsdescription__dateType_created*)a)->startDate)
		soap_set_attr(soap, "startDate", soap_wchar2s(soap, ((_fimsdescription__dateType_created*)a)->startDate->c_str()), 2);
	if (((_fimsdescription__dateType_created*)a)->startTime)
		soap_set_attr(soap, "startTime", soap_wchar2s(soap, ((_fimsdescription__dateType_created*)a)->startTime->c_str()), 2);
	if (((_fimsdescription__dateType_created*)a)->endYear)
		soap_set_attr(soap, "endYear", soap_wchar2s(soap, ((_fimsdescription__dateType_created*)a)->endYear->c_str()), 2);
	if (((_fimsdescription__dateType_created*)a)->endDate)
		soap_set_attr(soap, "endDate", soap_wchar2s(soap, ((_fimsdescription__dateType_created*)a)->endDate->c_str()), 2);
	if (((_fimsdescription__dateType_created*)a)->endTime)
		soap_set_attr(soap, "endTime", soap_wchar2s(soap, ((_fimsdescription__dateType_created*)a)->endTime->c_str()), 2);
	if (((_fimsdescription__dateType_created*)a)->period)
		soap_set_attr(soap, "period", soap_wchar2s(soap, ((_fimsdescription__dateType_created*)a)->period->c_str()), 2);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__fimsdescription__dateType_created), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_fimsdescription__dateType_created::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__fimsdescription__dateType_created(soap, tag, this, type);
}

SOAP_FMAC3 _fimsdescription__dateType_created * SOAP_FMAC4 soap_in__fimsdescription__dateType_created(struct soap *soap, const char *tag, _fimsdescription__dateType_created *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_fimsdescription__dateType_created *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__fimsdescription__dateType_created, sizeof(_fimsdescription__dateType_created), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__fimsdescription__dateType_created)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_fimsdescription__dateType_created *)a->soap_in(soap, tag, type);
		}
	}
	{	const char *t = soap_attr_value(soap, "startYear", 0);
		if (t)
		{
			if (!(((_fimsdescription__dateType_created*)a)->startYear = (std::wstring *)soap_malloc(soap, sizeof(std::wstring))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			wchar_t *s = NULL;
			if (soap_s2wchar(soap, t, &s, 0, -1))
				return NULL;
			if (s)
			{	((_fimsdescription__dateType_created*)a)->startYear = soap_new_std__wstring(soap, -1);
				((_fimsdescription__dateType_created*)a)->startYear->assign(s);
			}
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "startDate", 0);
		if (t)
		{
			if (!(((_fimsdescription__dateType_created*)a)->startDate = (std::wstring *)soap_malloc(soap, sizeof(std::wstring))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			wchar_t *s = NULL;
			if (soap_s2wchar(soap, t, &s, 0, -1))
				return NULL;
			if (s)
			{	((_fimsdescription__dateType_created*)a)->startDate = soap_new_std__wstring(soap, -1);
				((_fimsdescription__dateType_created*)a)->startDate->assign(s);
			}
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "startTime", 0);
		if (t)
		{
			if (!(((_fimsdescription__dateType_created*)a)->startTime = (std::wstring *)soap_malloc(soap, sizeof(std::wstring))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			wchar_t *s = NULL;
			if (soap_s2wchar(soap, t, &s, 0, -1))
				return NULL;
			if (s)
			{	((_fimsdescription__dateType_created*)a)->startTime = soap_new_std__wstring(soap, -1);
				((_fimsdescription__dateType_created*)a)->startTime->assign(s);
			}
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "endYear", 0);
		if (t)
		{
			if (!(((_fimsdescription__dateType_created*)a)->endYear = (std::wstring *)soap_malloc(soap, sizeof(std::wstring))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			wchar_t *s = NULL;
			if (soap_s2wchar(soap, t, &s, 0, -1))
				return NULL;
			if (s)
			{	((_fimsdescription__dateType_created*)a)->endYear = soap_new_std__wstring(soap, -1);
				((_fimsdescription__dateType_created*)a)->endYear->assign(s);
			}
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "endDate", 0);
		if (t)
		{
			if (!(((_fimsdescription__dateType_created*)a)->endDate = (std::wstring *)soap_malloc(soap, sizeof(std::wstring))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			wchar_t *s = NULL;
			if (soap_s2wchar(soap, t, &s, 0, -1))
				return NULL;
			if (s)
			{	((_fimsdescription__dateType_created*)a)->endDate = soap_new_std__wstring(soap, -1);
				((_fimsdescription__dateType_created*)a)->endDate->assign(s);
			}
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "endTime", 0);
		if (t)
		{
			if (!(((_fimsdescription__dateType_created*)a)->endTime = (std::wstring *)soap_malloc(soap, sizeof(std::wstring))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			wchar_t *s = NULL;
			if (soap_s2wchar(soap, t, &s, 0, -1))
				return NULL;
			if (s)
			{	((_fimsdescription__dateType_created*)a)->endTime = soap_new_std__wstring(soap, -1);
				((_fimsdescription__dateType_created*)a)->endTime->assign(s);
			}
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "period", 0);
		if (t)
		{
			if (!(((_fimsdescription__dateType_created*)a)->period = (std::wstring *)soap_malloc(soap, sizeof(std::wstring))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			wchar_t *s = NULL;
			if (soap_s2wchar(soap, t, &s, 0, -1))
				return NULL;
			if (s)
			{	((_fimsdescription__dateType_created*)a)->period = soap_new_std__wstring(soap, -1);
				((_fimsdescription__dateType_created*)a)->period->assign(s);
			}
		}
		else if (soap->error)
			return NULL;
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_fimsdescription__dateType_created *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__fimsdescription__dateType_created, 0, sizeof(_fimsdescription__dateType_created), 0, soap_copy__fimsdescription__dateType_created);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int _fimsdescription__dateType_created::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__fimsdescription__dateType_created);
	if (this->soap_out(soap, tag?tag:"fimsdescription:dateType-created", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_fimsdescription__dateType_created::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__fimsdescription__dateType_created(soap, this, tag, type);
}

SOAP_FMAC3 _fimsdescription__dateType_created * SOAP_FMAC4 soap_get__fimsdescription__dateType_created(struct soap *soap, _fimsdescription__dateType_created *p, const char *tag, const char *type)
{
	if ((p = soap_in__fimsdescription__dateType_created(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _fimsdescription__dateType_created * SOAP_FMAC2 soap_instantiate__fimsdescription__dateType_created(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__fimsdescription__dateType_created(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__fimsdescription__dateType_created, n, EDLProvider_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_fimsdescription__dateType_created);
		if (size)
			*size = sizeof(_fimsdescription__dateType_created);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(_fimsdescription__dateType_created, n);
		if (size)
			*size = n * sizeof(_fimsdescription__dateType_created);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (_fimsdescription__dateType_created*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__fimsdescription__dateType_created(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _fimsdescription__dateType_created %p -> %p\n", q, p));
	*(_fimsdescription__dateType_created*)p = *(_fimsdescription__dateType_created*)q;
}

void _fimsdescription__coverageType_spatial_coordinates::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_float(soap, &this->_fimsdescription__coverageType_spatial_coordinates::posy);
	soap_default_float(soap, &this->_fimsdescription__coverageType_spatial_coordinates::posx);
	this->_fimsdescription__coverageType_spatial_coordinates::formatLabel = NULL;
	this->_fimsdescription__coverageType_spatial_coordinates::formatDefinition = NULL;
	this->_fimsdescription__coverageType_spatial_coordinates::formatLink = NULL;
	this->_fimsdescription__coverageType_spatial_coordinates::formatLanguage = NULL;
}

void _fimsdescription__coverageType_spatial_coordinates::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
#endif
}

int _fimsdescription__coverageType_spatial_coordinates::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__fimsdescription__coverageType_spatial_coordinates(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__fimsdescription__coverageType_spatial_coordinates(struct soap *soap, const char *tag, int id, const _fimsdescription__coverageType_spatial_coordinates *a, const char *type)
{
	if (((_fimsdescription__coverageType_spatial_coordinates*)a)->formatLabel)
		soap_set_attr(soap, "formatLabel", soap_wchar2s(soap, ((_fimsdescription__coverageType_spatial_coordinates*)a)->formatLabel->c_str()), 2);
	if (((_fimsdescription__coverageType_spatial_coordinates*)a)->formatDefinition)
		soap_set_attr(soap, "formatDefinition", soap_wchar2s(soap, ((_fimsdescription__coverageType_spatial_coordinates*)a)->formatDefinition->c_str()), 2);
	if (((_fimsdescription__coverageType_spatial_coordinates*)a)->formatLink)
		soap_set_attr(soap, "formatLink", soap_wchar2s(soap, ((_fimsdescription__coverageType_spatial_coordinates*)a)->formatLink->c_str()), 2);
	if (((_fimsdescription__coverageType_spatial_coordinates*)a)->formatLanguage)
		soap_set_attr(soap, "formatLanguage", soap_wchar2s(soap, ((_fimsdescription__coverageType_spatial_coordinates*)a)->formatLanguage->c_str()), 2);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__fimsdescription__coverageType_spatial_coordinates), type))
		return soap->error;
	if (soap_out_float(soap, "fimsdescription:posy", -1, &(a->_fimsdescription__coverageType_spatial_coordinates::posy), ""))
		return soap->error;
	if (soap_out_float(soap, "fimsdescription:posx", -1, &(a->_fimsdescription__coverageType_spatial_coordinates::posx), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_fimsdescription__coverageType_spatial_coordinates::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__fimsdescription__coverageType_spatial_coordinates(soap, tag, this, type);
}

SOAP_FMAC3 _fimsdescription__coverageType_spatial_coordinates * SOAP_FMAC4 soap_in__fimsdescription__coverageType_spatial_coordinates(struct soap *soap, const char *tag, _fimsdescription__coverageType_spatial_coordinates *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_fimsdescription__coverageType_spatial_coordinates *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__fimsdescription__coverageType_spatial_coordinates, sizeof(_fimsdescription__coverageType_spatial_coordinates), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__fimsdescription__coverageType_spatial_coordinates)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_fimsdescription__coverageType_spatial_coordinates *)a->soap_in(soap, tag, type);
		}
	}
	{	const char *t = soap_attr_value(soap, "formatLabel", 0);
		if (t)
		{
			if (!(((_fimsdescription__coverageType_spatial_coordinates*)a)->formatLabel = (std::wstring *)soap_malloc(soap, sizeof(std::wstring))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			wchar_t *s = NULL;
			if (soap_s2wchar(soap, t, &s, 0, -1))
				return NULL;
			if (s)
			{	((_fimsdescription__coverageType_spatial_coordinates*)a)->formatLabel = soap_new_std__wstring(soap, -1);
				((_fimsdescription__coverageType_spatial_coordinates*)a)->formatLabel->assign(s);
			}
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "formatDefinition", 0);
		if (t)
		{
			if (!(((_fimsdescription__coverageType_spatial_coordinates*)a)->formatDefinition = (std::wstring *)soap_malloc(soap, sizeof(std::wstring))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			wchar_t *s = NULL;
			if (soap_s2wchar(soap, t, &s, 0, -1))
				return NULL;
			if (s)
			{	((_fimsdescription__coverageType_spatial_coordinates*)a)->formatDefinition = soap_new_std__wstring(soap, -1);
				((_fimsdescription__coverageType_spatial_coordinates*)a)->formatDefinition->assign(s);
			}
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "formatLink", 0);
		if (t)
		{
			if (!(((_fimsdescription__coverageType_spatial_coordinates*)a)->formatLink = (std::wstring *)soap_malloc(soap, sizeof(std::wstring))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			wchar_t *s = NULL;
			if (soap_s2wchar(soap, t, &s, 0, -1))
				return NULL;
			if (s)
			{	((_fimsdescription__coverageType_spatial_coordinates*)a)->formatLink = soap_new_std__wstring(soap, -1);
				((_fimsdescription__coverageType_spatial_coordinates*)a)->formatLink->assign(s);
			}
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "formatLanguage", 0);
		if (t)
		{
			if (!(((_fimsdescription__coverageType_spatial_coordinates*)a)->formatLanguage = (std::wstring *)soap_malloc(soap, sizeof(std::wstring))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			wchar_t *s = NULL;
			if (soap_s2wchar(soap, t, &s, 0, -1))
				return NULL;
			if (s)
			{	((_fimsdescription__coverageType_spatial_coordinates*)a)->formatLanguage = soap_new_std__wstring(soap, -1);
				((_fimsdescription__coverageType_spatial_coordinates*)a)->formatLanguage->assign(s);
			}
		}
		else if (soap->error)
			return NULL;
	}
	size_t soap_flag_posy1 = 1;
	size_t soap_flag_posx1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_posy1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_float(soap, "fimsdescription:posy", &(a->_fimsdescription__coverageType_spatial_coordinates::posy), "xsd:float"))
				{	soap_flag_posy1--;
					continue;
				}
			if (soap_flag_posx1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_float(soap, "fimsdescription:posx", &(a->_fimsdescription__coverageType_spatial_coordinates::posx), "xsd:float"))
				{	soap_flag_posx1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_fimsdescription__coverageType_spatial_coordinates *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__fimsdescription__coverageType_spatial_coordinates, 0, sizeof(_fimsdescription__coverageType_spatial_coordinates), 0, soap_copy__fimsdescription__coverageType_spatial_coordinates);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_posy1 > 0 || soap_flag_posx1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _fimsdescription__coverageType_spatial_coordinates::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__fimsdescription__coverageType_spatial_coordinates);
	if (this->soap_out(soap, tag?tag:"fimsdescription:coverageType-spatial-coordinates", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_fimsdescription__coverageType_spatial_coordinates::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__fimsdescription__coverageType_spatial_coordinates(soap, this, tag, type);
}

SOAP_FMAC3 _fimsdescription__coverageType_spatial_coordinates * SOAP_FMAC4 soap_get__fimsdescription__coverageType_spatial_coordinates(struct soap *soap, _fimsdescription__coverageType_spatial_coordinates *p, const char *tag, const char *type)
{
	if ((p = soap_in__fimsdescription__coverageType_spatial_coordinates(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _fimsdescription__coverageType_spatial_coordinates * SOAP_FMAC2 soap_instantiate__fimsdescription__coverageType_spatial_coordinates(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__fimsdescription__coverageType_spatial_coordinates(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__fimsdescription__coverageType_spatial_coordinates, n, EDLProvider_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_fimsdescription__coverageType_spatial_coordinates);
		if (size)
			*size = sizeof(_fimsdescription__coverageType_spatial_coordinates);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(_fimsdescription__coverageType_spatial_coordinates, n);
		if (size)
			*size = n * sizeof(_fimsdescription__coverageType_spatial_coordinates);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (_fimsdescription__coverageType_spatial_coordinates*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__fimsdescription__coverageType_spatial_coordinates(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _fimsdescription__coverageType_spatial_coordinates %p -> %p\n", q, p));
	*(_fimsdescription__coverageType_spatial_coordinates*)p = *(_fimsdescription__coverageType_spatial_coordinates*)q;
}

void _fimsdescription__coverageType_spatial_locationName::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	this->_fimsdescription__coverageType_spatial_locationName::typeLabel = NULL;
	this->_fimsdescription__coverageType_spatial_locationName::typeDefinition = NULL;
	this->_fimsdescription__coverageType_spatial_locationName::typeLink = NULL;
	this->_fimsdescription__coverageType_spatial_locationName::typeLanguage = NULL;
}

void _fimsdescription__coverageType_spatial_locationName::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
#endif
}

int _fimsdescription__coverageType_spatial_locationName::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__fimsdescription__coverageType_spatial_locationName(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__fimsdescription__coverageType_spatial_locationName(struct soap *soap, const char *tag, int id, const _fimsdescription__coverageType_spatial_locationName *a, const char *type)
{
	if (((_fimsdescription__coverageType_spatial_locationName*)a)->typeLabel)
		soap_set_attr(soap, "typeLabel", soap_wchar2s(soap, ((_fimsdescription__coverageType_spatial_locationName*)a)->typeLabel->c_str()), 2);
	if (((_fimsdescription__coverageType_spatial_locationName*)a)->typeDefinition)
		soap_set_attr(soap, "typeDefinition", soap_wchar2s(soap, ((_fimsdescription__coverageType_spatial_locationName*)a)->typeDefinition->c_str()), 2);
	if (((_fimsdescription__coverageType_spatial_locationName*)a)->typeLink)
		soap_set_attr(soap, "typeLink", soap_wchar2s(soap, ((_fimsdescription__coverageType_spatial_locationName*)a)->typeLink->c_str()), 2);
	if (((_fimsdescription__coverageType_spatial_locationName*)a)->typeLanguage)
		soap_set_attr(soap, "typeLanguage", soap_wchar2s(soap, ((_fimsdescription__coverageType_spatial_locationName*)a)->typeLanguage->c_str()), 2);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__fimsdescription__coverageType_spatial_locationName), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_fimsdescription__coverageType_spatial_locationName::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__fimsdescription__coverageType_spatial_locationName(soap, tag, this, type);
}

SOAP_FMAC3 _fimsdescription__coverageType_spatial_locationName * SOAP_FMAC4 soap_in__fimsdescription__coverageType_spatial_locationName(struct soap *soap, const char *tag, _fimsdescription__coverageType_spatial_locationName *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_fimsdescription__coverageType_spatial_locationName *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__fimsdescription__coverageType_spatial_locationName, sizeof(_fimsdescription__coverageType_spatial_locationName), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__fimsdescription__coverageType_spatial_locationName)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_fimsdescription__coverageType_spatial_locationName *)a->soap_in(soap, tag, type);
		}
	}
	{	const char *t = soap_attr_value(soap, "typeLabel", 0);
		if (t)
		{
			if (!(((_fimsdescription__coverageType_spatial_locationName*)a)->typeLabel = (std::wstring *)soap_malloc(soap, sizeof(std::wstring))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			wchar_t *s = NULL;
			if (soap_s2wchar(soap, t, &s, 0, -1))
				return NULL;
			if (s)
			{	((_fimsdescription__coverageType_spatial_locationName*)a)->typeLabel = soap_new_std__wstring(soap, -1);
				((_fimsdescription__coverageType_spatial_locationName*)a)->typeLabel->assign(s);
			}
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "typeDefinition", 0);
		if (t)
		{
			if (!(((_fimsdescription__coverageType_spatial_locationName*)a)->typeDefinition = (std::wstring *)soap_malloc(soap, sizeof(std::wstring))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			wchar_t *s = NULL;
			if (soap_s2wchar(soap, t, &s, 0, -1))
				return NULL;
			if (s)
			{	((_fimsdescription__coverageType_spatial_locationName*)a)->typeDefinition = soap_new_std__wstring(soap, -1);
				((_fimsdescription__coverageType_spatial_locationName*)a)->typeDefinition->assign(s);
			}
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "typeLink", 0);
		if (t)
		{
			if (!(((_fimsdescription__coverageType_spatial_locationName*)a)->typeLink = (std::wstring *)soap_malloc(soap, sizeof(std::wstring))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			wchar_t *s = NULL;
			if (soap_s2wchar(soap, t, &s, 0, -1))
				return NULL;
			if (s)
			{	((_fimsdescription__coverageType_spatial_locationName*)a)->typeLink = soap_new_std__wstring(soap, -1);
				((_fimsdescription__coverageType_spatial_locationName*)a)->typeLink->assign(s);
			}
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "typeLanguage", 0);
		if (t)
		{
			if (!(((_fimsdescription__coverageType_spatial_locationName*)a)->typeLanguage = (std::wstring *)soap_malloc(soap, sizeof(std::wstring))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			wchar_t *s = NULL;
			if (soap_s2wchar(soap, t, &s, 0, -1))
				return NULL;
			if (s)
			{	((_fimsdescription__coverageType_spatial_locationName*)a)->typeLanguage = soap_new_std__wstring(soap, -1);
				((_fimsdescription__coverageType_spatial_locationName*)a)->typeLanguage->assign(s);
			}
		}
		else if (soap->error)
			return NULL;
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_fimsdescription__coverageType_spatial_locationName *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__fimsdescription__coverageType_spatial_locationName, 0, sizeof(_fimsdescription__coverageType_spatial_locationName), 0, soap_copy__fimsdescription__coverageType_spatial_locationName);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int _fimsdescription__coverageType_spatial_locationName::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__fimsdescription__coverageType_spatial_locationName);
	if (this->soap_out(soap, tag?tag:"fimsdescription:coverageType-spatial-locationName", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_fimsdescription__coverageType_spatial_locationName::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__fimsdescription__coverageType_spatial_locationName(soap, this, tag, type);
}

SOAP_FMAC3 _fimsdescription__coverageType_spatial_locationName * SOAP_FMAC4 soap_get__fimsdescription__coverageType_spatial_locationName(struct soap *soap, _fimsdescription__coverageType_spatial_locationName *p, const char *tag, const char *type)
{
	if ((p = soap_in__fimsdescription__coverageType_spatial_locationName(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _fimsdescription__coverageType_spatial_locationName * SOAP_FMAC2 soap_instantiate__fimsdescription__coverageType_spatial_locationName(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__fimsdescription__coverageType_spatial_locationName(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__fimsdescription__coverageType_spatial_locationName, n, EDLProvider_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_fimsdescription__coverageType_spatial_locationName);
		if (size)
			*size = sizeof(_fimsdescription__coverageType_spatial_locationName);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(_fimsdescription__coverageType_spatial_locationName, n);
		if (size)
			*size = n * sizeof(_fimsdescription__coverageType_spatial_locationName);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (_fimsdescription__coverageType_spatial_locationName*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__fimsdescription__coverageType_spatial_locationName(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _fimsdescription__coverageType_spatial_locationName %p -> %p\n", q, p));
	*(_fimsdescription__coverageType_spatial_locationName*)p = *(_fimsdescription__coverageType_spatial_locationName*)q;
}

void _fimsdescription__coverageType_spatial::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	this->_fimsdescription__coverageType_spatial::locationName._fimsdescription__coverageType_spatial_locationName::soap_default(soap);
	this->_fimsdescription__coverageType_spatial::coordinates = NULL;
}

void _fimsdescription__coverageType_spatial::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	this->_fimsdescription__coverageType_spatial::locationName.soap_serialize(soap);
	soap_serialize_PointerTo_fimsdescription__coverageType_spatial_coordinates(soap, &this->_fimsdescription__coverageType_spatial::coordinates);
#endif
}

int _fimsdescription__coverageType_spatial::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__fimsdescription__coverageType_spatial(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__fimsdescription__coverageType_spatial(struct soap *soap, const char *tag, int id, const _fimsdescription__coverageType_spatial *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__fimsdescription__coverageType_spatial), type))
		return soap->error;
	if ((a->_fimsdescription__coverageType_spatial::locationName).soap_out(soap, "fimsdescription:locationName", -1, ""))
		return soap->error;
	if (soap_out_PointerTo_fimsdescription__coverageType_spatial_coordinates(soap, "fimsdescription:coordinates", -1, &(a->_fimsdescription__coverageType_spatial::coordinates), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_fimsdescription__coverageType_spatial::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__fimsdescription__coverageType_spatial(soap, tag, this, type);
}

SOAP_FMAC3 _fimsdescription__coverageType_spatial * SOAP_FMAC4 soap_in__fimsdescription__coverageType_spatial(struct soap *soap, const char *tag, _fimsdescription__coverageType_spatial *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_fimsdescription__coverageType_spatial *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__fimsdescription__coverageType_spatial, sizeof(_fimsdescription__coverageType_spatial), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__fimsdescription__coverageType_spatial)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_fimsdescription__coverageType_spatial *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_locationName1 = 1;
	size_t soap_flag_coordinates1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_locationName1 && soap->error == SOAP_TAG_MISMATCH)
				if ((a->_fimsdescription__coverageType_spatial::locationName).soap_in(soap, "fimsdescription:locationName", ""))
				{	soap_flag_locationName1--;
					continue;
				}
			if (soap_flag_coordinates1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_fimsdescription__coverageType_spatial_coordinates(soap, "fimsdescription:coordinates", &(a->_fimsdescription__coverageType_spatial::coordinates), ""))
				{	soap_flag_coordinates1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_fimsdescription__coverageType_spatial *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__fimsdescription__coverageType_spatial, 0, sizeof(_fimsdescription__coverageType_spatial), 0, soap_copy__fimsdescription__coverageType_spatial);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_locationName1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _fimsdescription__coverageType_spatial::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__fimsdescription__coverageType_spatial);
	if (this->soap_out(soap, tag?tag:"fimsdescription:coverageType-spatial", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_fimsdescription__coverageType_spatial::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__fimsdescription__coverageType_spatial(soap, this, tag, type);
}

SOAP_FMAC3 _fimsdescription__coverageType_spatial * SOAP_FMAC4 soap_get__fimsdescription__coverageType_spatial(struct soap *soap, _fimsdescription__coverageType_spatial *p, const char *tag, const char *type)
{
	if ((p = soap_in__fimsdescription__coverageType_spatial(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _fimsdescription__coverageType_spatial * SOAP_FMAC2 soap_instantiate__fimsdescription__coverageType_spatial(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__fimsdescription__coverageType_spatial(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__fimsdescription__coverageType_spatial, n, EDLProvider_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_fimsdescription__coverageType_spatial);
		if (size)
			*size = sizeof(_fimsdescription__coverageType_spatial);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(_fimsdescription__coverageType_spatial, n);
		if (size)
			*size = n * sizeof(_fimsdescription__coverageType_spatial);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (_fimsdescription__coverageType_spatial*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__fimsdescription__coverageType_spatial(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _fimsdescription__coverageType_spatial %p -> %p\n", q, p));
	*(_fimsdescription__coverageType_spatial*)p = *(_fimsdescription__coverageType_spatial*)q;
}

void _fimsdescription__coverageType_temporal::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	this->_fimsdescription__coverageType_temporal::typeLabel = NULL;
	this->_fimsdescription__coverageType_temporal::typeDefinition = NULL;
	this->_fimsdescription__coverageType_temporal::typeLink = NULL;
	this->_fimsdescription__coverageType_temporal::typeLanguage = NULL;
}

void _fimsdescription__coverageType_temporal::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
#endif
}

int _fimsdescription__coverageType_temporal::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__fimsdescription__coverageType_temporal(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__fimsdescription__coverageType_temporal(struct soap *soap, const char *tag, int id, const _fimsdescription__coverageType_temporal *a, const char *type)
{
	if (((_fimsdescription__coverageType_temporal*)a)->typeLabel)
		soap_set_attr(soap, "typeLabel", soap_wchar2s(soap, ((_fimsdescription__coverageType_temporal*)a)->typeLabel->c_str()), 2);
	if (((_fimsdescription__coverageType_temporal*)a)->typeDefinition)
		soap_set_attr(soap, "typeDefinition", soap_wchar2s(soap, ((_fimsdescription__coverageType_temporal*)a)->typeDefinition->c_str()), 2);
	if (((_fimsdescription__coverageType_temporal*)a)->typeLink)
		soap_set_attr(soap, "typeLink", soap_wchar2s(soap, ((_fimsdescription__coverageType_temporal*)a)->typeLink->c_str()), 2);
	if (((_fimsdescription__coverageType_temporal*)a)->typeLanguage)
		soap_set_attr(soap, "typeLanguage", soap_wchar2s(soap, ((_fimsdescription__coverageType_temporal*)a)->typeLanguage->c_str()), 2);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__fimsdescription__coverageType_temporal), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_fimsdescription__coverageType_temporal::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__fimsdescription__coverageType_temporal(soap, tag, this, type);
}

SOAP_FMAC3 _fimsdescription__coverageType_temporal * SOAP_FMAC4 soap_in__fimsdescription__coverageType_temporal(struct soap *soap, const char *tag, _fimsdescription__coverageType_temporal *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_fimsdescription__coverageType_temporal *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__fimsdescription__coverageType_temporal, sizeof(_fimsdescription__coverageType_temporal), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__fimsdescription__coverageType_temporal)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_fimsdescription__coverageType_temporal *)a->soap_in(soap, tag, type);
		}
	}
	{	const char *t = soap_attr_value(soap, "typeLabel", 0);
		if (t)
		{
			if (!(((_fimsdescription__coverageType_temporal*)a)->typeLabel = (std::wstring *)soap_malloc(soap, sizeof(std::wstring))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			wchar_t *s = NULL;
			if (soap_s2wchar(soap, t, &s, 0, -1))
				return NULL;
			if (s)
			{	((_fimsdescription__coverageType_temporal*)a)->typeLabel = soap_new_std__wstring(soap, -1);
				((_fimsdescription__coverageType_temporal*)a)->typeLabel->assign(s);
			}
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "typeDefinition", 0);
		if (t)
		{
			if (!(((_fimsdescription__coverageType_temporal*)a)->typeDefinition = (std::wstring *)soap_malloc(soap, sizeof(std::wstring))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			wchar_t *s = NULL;
			if (soap_s2wchar(soap, t, &s, 0, -1))
				return NULL;
			if (s)
			{	((_fimsdescription__coverageType_temporal*)a)->typeDefinition = soap_new_std__wstring(soap, -1);
				((_fimsdescription__coverageType_temporal*)a)->typeDefinition->assign(s);
			}
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "typeLink", 0);
		if (t)
		{
			if (!(((_fimsdescription__coverageType_temporal*)a)->typeLink = (std::wstring *)soap_malloc(soap, sizeof(std::wstring))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			wchar_t *s = NULL;
			if (soap_s2wchar(soap, t, &s, 0, -1))
				return NULL;
			if (s)
			{	((_fimsdescription__coverageType_temporal*)a)->typeLink = soap_new_std__wstring(soap, -1);
				((_fimsdescription__coverageType_temporal*)a)->typeLink->assign(s);
			}
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "typeLanguage", 0);
		if (t)
		{
			if (!(((_fimsdescription__coverageType_temporal*)a)->typeLanguage = (std::wstring *)soap_malloc(soap, sizeof(std::wstring))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			wchar_t *s = NULL;
			if (soap_s2wchar(soap, t, &s, 0, -1))
				return NULL;
			if (s)
			{	((_fimsdescription__coverageType_temporal*)a)->typeLanguage = soap_new_std__wstring(soap, -1);
				((_fimsdescription__coverageType_temporal*)a)->typeLanguage->assign(s);
			}
		}
		else if (soap->error)
			return NULL;
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_fimsdescription__coverageType_temporal *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__fimsdescription__coverageType_temporal, 0, sizeof(_fimsdescription__coverageType_temporal), 0, soap_copy__fimsdescription__coverageType_temporal);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int _fimsdescription__coverageType_temporal::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__fimsdescription__coverageType_temporal);
	if (this->soap_out(soap, tag?tag:"fimsdescription:coverageType-temporal", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_fimsdescription__coverageType_temporal::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__fimsdescription__coverageType_temporal(soap, this, tag, type);
}

SOAP_FMAC3 _fimsdescription__coverageType_temporal * SOAP_FMAC4 soap_get__fimsdescription__coverageType_temporal(struct soap *soap, _fimsdescription__coverageType_temporal *p, const char *tag, const char *type)
{
	if ((p = soap_in__fimsdescription__coverageType_temporal(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _fimsdescription__coverageType_temporal * SOAP_FMAC2 soap_instantiate__fimsdescription__coverageType_temporal(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__fimsdescription__coverageType_temporal(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__fimsdescription__coverageType_temporal, n, EDLProvider_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_fimsdescription__coverageType_temporal);
		if (size)
			*size = sizeof(_fimsdescription__coverageType_temporal);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(_fimsdescription__coverageType_temporal, n);
		if (size)
			*size = n * sizeof(_fimsdescription__coverageType_temporal);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (_fimsdescription__coverageType_temporal*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__fimsdescription__coverageType_temporal(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _fimsdescription__coverageType_temporal %p -> %p\n", q, p));
	*(_fimsdescription__coverageType_temporal*)p = *(_fimsdescription__coverageType_temporal*)q;
}

void _fimsdescription__typeType_targetAudience::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	this->_fimsdescription__typeType_targetAudience::typeLabel = NULL;
	this->_fimsdescription__typeType_targetAudience::typeDefinition = NULL;
	this->_fimsdescription__typeType_targetAudience::typeLink = NULL;
	this->_fimsdescription__typeType_targetAudience::typeLanguage = NULL;
}

void _fimsdescription__typeType_targetAudience::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
#endif
}

int _fimsdescription__typeType_targetAudience::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__fimsdescription__typeType_targetAudience(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__fimsdescription__typeType_targetAudience(struct soap *soap, const char *tag, int id, const _fimsdescription__typeType_targetAudience *a, const char *type)
{
	if (((_fimsdescription__typeType_targetAudience*)a)->typeLabel)
		soap_set_attr(soap, "typeLabel", soap_wchar2s(soap, ((_fimsdescription__typeType_targetAudience*)a)->typeLabel->c_str()), 2);
	if (((_fimsdescription__typeType_targetAudience*)a)->typeDefinition)
		soap_set_attr(soap, "typeDefinition", soap_wchar2s(soap, ((_fimsdescription__typeType_targetAudience*)a)->typeDefinition->c_str()), 2);
	if (((_fimsdescription__typeType_targetAudience*)a)->typeLink)
		soap_set_attr(soap, "typeLink", soap_wchar2s(soap, ((_fimsdescription__typeType_targetAudience*)a)->typeLink->c_str()), 2);
	if (((_fimsdescription__typeType_targetAudience*)a)->typeLanguage)
		soap_set_attr(soap, "typeLanguage", soap_wchar2s(soap, ((_fimsdescription__typeType_targetAudience*)a)->typeLanguage->c_str()), 2);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__fimsdescription__typeType_targetAudience), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_fimsdescription__typeType_targetAudience::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__fimsdescription__typeType_targetAudience(soap, tag, this, type);
}

SOAP_FMAC3 _fimsdescription__typeType_targetAudience * SOAP_FMAC4 soap_in__fimsdescription__typeType_targetAudience(struct soap *soap, const char *tag, _fimsdescription__typeType_targetAudience *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_fimsdescription__typeType_targetAudience *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__fimsdescription__typeType_targetAudience, sizeof(_fimsdescription__typeType_targetAudience), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__fimsdescription__typeType_targetAudience)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_fimsdescription__typeType_targetAudience *)a->soap_in(soap, tag, type);
		}
	}
	{	const char *t = soap_attr_value(soap, "typeLabel", 0);
		if (t)
		{
			if (!(((_fimsdescription__typeType_targetAudience*)a)->typeLabel = (std::wstring *)soap_malloc(soap, sizeof(std::wstring))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			wchar_t *s = NULL;
			if (soap_s2wchar(soap, t, &s, 0, -1))
				return NULL;
			if (s)
			{	((_fimsdescription__typeType_targetAudience*)a)->typeLabel = soap_new_std__wstring(soap, -1);
				((_fimsdescription__typeType_targetAudience*)a)->typeLabel->assign(s);
			}
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "typeDefinition", 0);
		if (t)
		{
			if (!(((_fimsdescription__typeType_targetAudience*)a)->typeDefinition = (std::wstring *)soap_malloc(soap, sizeof(std::wstring))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			wchar_t *s = NULL;
			if (soap_s2wchar(soap, t, &s, 0, -1))
				return NULL;
			if (s)
			{	((_fimsdescription__typeType_targetAudience*)a)->typeDefinition = soap_new_std__wstring(soap, -1);
				((_fimsdescription__typeType_targetAudience*)a)->typeDefinition->assign(s);
			}
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "typeLink", 0);
		if (t)
		{
			if (!(((_fimsdescription__typeType_targetAudience*)a)->typeLink = (std::wstring *)soap_malloc(soap, sizeof(std::wstring))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			wchar_t *s = NULL;
			if (soap_s2wchar(soap, t, &s, 0, -1))
				return NULL;
			if (s)
			{	((_fimsdescription__typeType_targetAudience*)a)->typeLink = soap_new_std__wstring(soap, -1);
				((_fimsdescription__typeType_targetAudience*)a)->typeLink->assign(s);
			}
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "typeLanguage", 0);
		if (t)
		{
			if (!(((_fimsdescription__typeType_targetAudience*)a)->typeLanguage = (std::wstring *)soap_malloc(soap, sizeof(std::wstring))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			wchar_t *s = NULL;
			if (soap_s2wchar(soap, t, &s, 0, -1))
				return NULL;
			if (s)
			{	((_fimsdescription__typeType_targetAudience*)a)->typeLanguage = soap_new_std__wstring(soap, -1);
				((_fimsdescription__typeType_targetAudience*)a)->typeLanguage->assign(s);
			}
		}
		else if (soap->error)
			return NULL;
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_fimsdescription__typeType_targetAudience *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__fimsdescription__typeType_targetAudience, 0, sizeof(_fimsdescription__typeType_targetAudience), 0, soap_copy__fimsdescription__typeType_targetAudience);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int _fimsdescription__typeType_targetAudience::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__fimsdescription__typeType_targetAudience);
	if (this->soap_out(soap, tag?tag:"fimsdescription:typeType-targetAudience", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_fimsdescription__typeType_targetAudience::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__fimsdescription__typeType_targetAudience(soap, this, tag, type);
}

SOAP_FMAC3 _fimsdescription__typeType_targetAudience * SOAP_FMAC4 soap_get__fimsdescription__typeType_targetAudience(struct soap *soap, _fimsdescription__typeType_targetAudience *p, const char *tag, const char *type)
{
	if ((p = soap_in__fimsdescription__typeType_targetAudience(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _fimsdescription__typeType_targetAudience * SOAP_FMAC2 soap_instantiate__fimsdescription__typeType_targetAudience(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__fimsdescription__typeType_targetAudience(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__fimsdescription__typeType_targetAudience, n, EDLProvider_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_fimsdescription__typeType_targetAudience);
		if (size)
			*size = sizeof(_fimsdescription__typeType_targetAudience);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(_fimsdescription__typeType_targetAudience, n);
		if (size)
			*size = n * sizeof(_fimsdescription__typeType_targetAudience);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (_fimsdescription__typeType_targetAudience*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__fimsdescription__typeType_targetAudience(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _fimsdescription__typeType_targetAudience %p -> %p\n", q, p));
	*(_fimsdescription__typeType_targetAudience*)p = *(_fimsdescription__typeType_targetAudience*)q;
}

void _fimsdescription__typeType_objectType::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	this->_fimsdescription__typeType_objectType::typeLabel = NULL;
	this->_fimsdescription__typeType_objectType::typeDefinition = NULL;
	this->_fimsdescription__typeType_objectType::typeLink = NULL;
	this->_fimsdescription__typeType_objectType::typeLanguage = NULL;
}

void _fimsdescription__typeType_objectType::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
#endif
}

int _fimsdescription__typeType_objectType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__fimsdescription__typeType_objectType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__fimsdescription__typeType_objectType(struct soap *soap, const char *tag, int id, const _fimsdescription__typeType_objectType *a, const char *type)
{
	if (((_fimsdescription__typeType_objectType*)a)->typeLabel)
		soap_set_attr(soap, "typeLabel", soap_wchar2s(soap, ((_fimsdescription__typeType_objectType*)a)->typeLabel->c_str()), 2);
	if (((_fimsdescription__typeType_objectType*)a)->typeDefinition)
		soap_set_attr(soap, "typeDefinition", soap_wchar2s(soap, ((_fimsdescription__typeType_objectType*)a)->typeDefinition->c_str()), 2);
	if (((_fimsdescription__typeType_objectType*)a)->typeLink)
		soap_set_attr(soap, "typeLink", soap_wchar2s(soap, ((_fimsdescription__typeType_objectType*)a)->typeLink->c_str()), 2);
	if (((_fimsdescription__typeType_objectType*)a)->typeLanguage)
		soap_set_attr(soap, "typeLanguage", soap_wchar2s(soap, ((_fimsdescription__typeType_objectType*)a)->typeLanguage->c_str()), 2);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__fimsdescription__typeType_objectType), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_fimsdescription__typeType_objectType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__fimsdescription__typeType_objectType(soap, tag, this, type);
}

SOAP_FMAC3 _fimsdescription__typeType_objectType * SOAP_FMAC4 soap_in__fimsdescription__typeType_objectType(struct soap *soap, const char *tag, _fimsdescription__typeType_objectType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_fimsdescription__typeType_objectType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__fimsdescription__typeType_objectType, sizeof(_fimsdescription__typeType_objectType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__fimsdescription__typeType_objectType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_fimsdescription__typeType_objectType *)a->soap_in(soap, tag, type);
		}
	}
	{	const char *t = soap_attr_value(soap, "typeLabel", 0);
		if (t)
		{
			if (!(((_fimsdescription__typeType_objectType*)a)->typeLabel = (std::wstring *)soap_malloc(soap, sizeof(std::wstring))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			wchar_t *s = NULL;
			if (soap_s2wchar(soap, t, &s, 0, -1))
				return NULL;
			if (s)
			{	((_fimsdescription__typeType_objectType*)a)->typeLabel = soap_new_std__wstring(soap, -1);
				((_fimsdescription__typeType_objectType*)a)->typeLabel->assign(s);
			}
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "typeDefinition", 0);
		if (t)
		{
			if (!(((_fimsdescription__typeType_objectType*)a)->typeDefinition = (std::wstring *)soap_malloc(soap, sizeof(std::wstring))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			wchar_t *s = NULL;
			if (soap_s2wchar(soap, t, &s, 0, -1))
				return NULL;
			if (s)
			{	((_fimsdescription__typeType_objectType*)a)->typeDefinition = soap_new_std__wstring(soap, -1);
				((_fimsdescription__typeType_objectType*)a)->typeDefinition->assign(s);
			}
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "typeLink", 0);
		if (t)
		{
			if (!(((_fimsdescription__typeType_objectType*)a)->typeLink = (std::wstring *)soap_malloc(soap, sizeof(std::wstring))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			wchar_t *s = NULL;
			if (soap_s2wchar(soap, t, &s, 0, -1))
				return NULL;
			if (s)
			{	((_fimsdescription__typeType_objectType*)a)->typeLink = soap_new_std__wstring(soap, -1);
				((_fimsdescription__typeType_objectType*)a)->typeLink->assign(s);
			}
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "typeLanguage", 0);
		if (t)
		{
			if (!(((_fimsdescription__typeType_objectType*)a)->typeLanguage = (std::wstring *)soap_malloc(soap, sizeof(std::wstring))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			wchar_t *s = NULL;
			if (soap_s2wchar(soap, t, &s, 0, -1))
				return NULL;
			if (s)
			{	((_fimsdescription__typeType_objectType*)a)->typeLanguage = soap_new_std__wstring(soap, -1);
				((_fimsdescription__typeType_objectType*)a)->typeLanguage->assign(s);
			}
		}
		else if (soap->error)
			return NULL;
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_fimsdescription__typeType_objectType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__fimsdescription__typeType_objectType, 0, sizeof(_fimsdescription__typeType_objectType), 0, soap_copy__fimsdescription__typeType_objectType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int _fimsdescription__typeType_objectType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__fimsdescription__typeType_objectType);
	if (this->soap_out(soap, tag?tag:"fimsdescription:typeType-objectType", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_fimsdescription__typeType_objectType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__fimsdescription__typeType_objectType(soap, this, tag, type);
}

SOAP_FMAC3 _fimsdescription__typeType_objectType * SOAP_FMAC4 soap_get__fimsdescription__typeType_objectType(struct soap *soap, _fimsdescription__typeType_objectType *p, const char *tag, const char *type)
{
	if ((p = soap_in__fimsdescription__typeType_objectType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _fimsdescription__typeType_objectType * SOAP_FMAC2 soap_instantiate__fimsdescription__typeType_objectType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__fimsdescription__typeType_objectType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__fimsdescription__typeType_objectType, n, EDLProvider_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_fimsdescription__typeType_objectType);
		if (size)
			*size = sizeof(_fimsdescription__typeType_objectType);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(_fimsdescription__typeType_objectType, n);
		if (size)
			*size = n * sizeof(_fimsdescription__typeType_objectType);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (_fimsdescription__typeType_objectType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__fimsdescription__typeType_objectType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _fimsdescription__typeType_objectType %p -> %p\n", q, p));
	*(_fimsdescription__typeType_objectType*)p = *(_fimsdescription__typeType_objectType*)q;
}

void _fimsdescription__typeType_genre::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	this->_fimsdescription__typeType_genre::typeLabel = NULL;
	this->_fimsdescription__typeType_genre::typeDefinition = NULL;
	this->_fimsdescription__typeType_genre::typeLink = NULL;
	this->_fimsdescription__typeType_genre::typeLanguage = NULL;
}

void _fimsdescription__typeType_genre::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
#endif
}

int _fimsdescription__typeType_genre::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__fimsdescription__typeType_genre(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__fimsdescription__typeType_genre(struct soap *soap, const char *tag, int id, const _fimsdescription__typeType_genre *a, const char *type)
{
	if (((_fimsdescription__typeType_genre*)a)->typeLabel)
		soap_set_attr(soap, "typeLabel", soap_wchar2s(soap, ((_fimsdescription__typeType_genre*)a)->typeLabel->c_str()), 2);
	if (((_fimsdescription__typeType_genre*)a)->typeDefinition)
		soap_set_attr(soap, "typeDefinition", soap_wchar2s(soap, ((_fimsdescription__typeType_genre*)a)->typeDefinition->c_str()), 2);
	if (((_fimsdescription__typeType_genre*)a)->typeLink)
		soap_set_attr(soap, "typeLink", soap_wchar2s(soap, ((_fimsdescription__typeType_genre*)a)->typeLink->c_str()), 2);
	if (((_fimsdescription__typeType_genre*)a)->typeLanguage)
		soap_set_attr(soap, "typeLanguage", soap_wchar2s(soap, ((_fimsdescription__typeType_genre*)a)->typeLanguage->c_str()), 2);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__fimsdescription__typeType_genre), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_fimsdescription__typeType_genre::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__fimsdescription__typeType_genre(soap, tag, this, type);
}

SOAP_FMAC3 _fimsdescription__typeType_genre * SOAP_FMAC4 soap_in__fimsdescription__typeType_genre(struct soap *soap, const char *tag, _fimsdescription__typeType_genre *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_fimsdescription__typeType_genre *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__fimsdescription__typeType_genre, sizeof(_fimsdescription__typeType_genre), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__fimsdescription__typeType_genre)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_fimsdescription__typeType_genre *)a->soap_in(soap, tag, type);
		}
	}
	{	const char *t = soap_attr_value(soap, "typeLabel", 0);
		if (t)
		{
			if (!(((_fimsdescription__typeType_genre*)a)->typeLabel = (std::wstring *)soap_malloc(soap, sizeof(std::wstring))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			wchar_t *s = NULL;
			if (soap_s2wchar(soap, t, &s, 0, -1))
				return NULL;
			if (s)
			{	((_fimsdescription__typeType_genre*)a)->typeLabel = soap_new_std__wstring(soap, -1);
				((_fimsdescription__typeType_genre*)a)->typeLabel->assign(s);
			}
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "typeDefinition", 0);
		if (t)
		{
			if (!(((_fimsdescription__typeType_genre*)a)->typeDefinition = (std::wstring *)soap_malloc(soap, sizeof(std::wstring))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			wchar_t *s = NULL;
			if (soap_s2wchar(soap, t, &s, 0, -1))
				return NULL;
			if (s)
			{	((_fimsdescription__typeType_genre*)a)->typeDefinition = soap_new_std__wstring(soap, -1);
				((_fimsdescription__typeType_genre*)a)->typeDefinition->assign(s);
			}
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "typeLink", 0);
		if (t)
		{
			if (!(((_fimsdescription__typeType_genre*)a)->typeLink = (std::wstring *)soap_malloc(soap, sizeof(std::wstring))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			wchar_t *s = NULL;
			if (soap_s2wchar(soap, t, &s, 0, -1))
				return NULL;
			if (s)
			{	((_fimsdescription__typeType_genre*)a)->typeLink = soap_new_std__wstring(soap, -1);
				((_fimsdescription__typeType_genre*)a)->typeLink->assign(s);
			}
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "typeLanguage", 0);
		if (t)
		{
			if (!(((_fimsdescription__typeType_genre*)a)->typeLanguage = (std::wstring *)soap_malloc(soap, sizeof(std::wstring))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			wchar_t *s = NULL;
			if (soap_s2wchar(soap, t, &s, 0, -1))
				return NULL;
			if (s)
			{	((_fimsdescription__typeType_genre*)a)->typeLanguage = soap_new_std__wstring(soap, -1);
				((_fimsdescription__typeType_genre*)a)->typeLanguage->assign(s);
			}
		}
		else if (soap->error)
			return NULL;
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_fimsdescription__typeType_genre *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__fimsdescription__typeType_genre, 0, sizeof(_fimsdescription__typeType_genre), 0, soap_copy__fimsdescription__typeType_genre);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int _fimsdescription__typeType_genre::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__fimsdescription__typeType_genre);
	if (this->soap_out(soap, tag?tag:"fimsdescription:typeType-genre", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_fimsdescription__typeType_genre::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__fimsdescription__typeType_genre(soap, this, tag, type);
}

SOAP_FMAC3 _fimsdescription__typeType_genre * SOAP_FMAC4 soap_get__fimsdescription__typeType_genre(struct soap *soap, _fimsdescription__typeType_genre *p, const char *tag, const char *type)
{
	if ((p = soap_in__fimsdescription__typeType_genre(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _fimsdescription__typeType_genre * SOAP_FMAC2 soap_instantiate__fimsdescription__typeType_genre(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__fimsdescription__typeType_genre(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__fimsdescription__typeType_genre, n, EDLProvider_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_fimsdescription__typeType_genre);
		if (size)
			*size = sizeof(_fimsdescription__typeType_genre);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(_fimsdescription__typeType_genre, n);
		if (size)
			*size = n * sizeof(_fimsdescription__typeType_genre);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (_fimsdescription__typeType_genre*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__fimsdescription__typeType_genre(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _fimsdescription__typeType_genre %p -> %p\n", q, p));
	*(_fimsdescription__typeType_genre*)p = *(_fimsdescription__typeType_genre*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_fims__ResourceIDType(struct soap *soap, const std::wstring *a)
{	(void)soap; (void)a; /* appease -Wall -Werror */
}
SOAP_FMAC3 int SOAP_FMAC4 soap_out_fims__ResourceIDType(struct soap *soap, const char *tag, int id, const std::wstring *s, const char *type)
{
	if ((soap->mode & SOAP_C_NILSTRING) && s->empty())
		return soap_element_null(soap, tag, id, type);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, s, SOAP_TYPE_fims__ResourceIDType), type) || soap_wstring_out(soap, s->c_str(), 0) || soap_element_end_out(soap, tag))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 std::wstring * SOAP_FMAC4 soap_in_fims__ResourceIDType(struct soap *soap, const char *tag, std::wstring *s, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!s)
		s = soap_new_std__wstring(soap, -1);
	if (soap->null)
		if (s)
			s->erase();
	if (soap->body && !*soap->href)
	{	wchar_t *t;
		s = (std::wstring*)soap_class_id_enter(soap, soap->id, s, SOAP_TYPE_fims__ResourceIDType, sizeof(std::wstring), soap->type, soap->arrayType);
		if (s)
		{	if (!(t = soap_wstring_in(soap, 1, 0, -1)))
				return NULL;
			s->assign(t);
		}
	}
	else
		s = (std::wstring*)soap_id_forward(soap, soap->href, soap_class_id_enter(soap, soap->id, s, SOAP_TYPE_fims__ResourceIDType, sizeof(std::wstring), soap->type, soap->arrayType), 0, SOAP_TYPE_fims__ResourceIDType, 0, sizeof(std::wstring), 0, soap_copy_fims__ResourceIDType);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	return s;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_fims__ResourceIDType(struct soap *soap, const std::wstring *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_fims__ResourceIDType);
	if (soap_out_fims__ResourceIDType(soap, tag?tag:"fims:ResourceIDType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::wstring * SOAP_FMAC4 soap_get_fims__ResourceIDType(struct soap *soap, std::wstring *p, const char *tag, const char *type)
{
	if ((p = soap_in_fims__ResourceIDType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_fimstime__TimecodeDuration(struct soap *soap, const std::wstring *a)
{	(void)soap; (void)a; /* appease -Wall -Werror */
}
SOAP_FMAC3 int SOAP_FMAC4 soap_out_fimstime__TimecodeDuration(struct soap *soap, const char *tag, int id, const std::wstring *s, const char *type)
{
	if ((soap->mode & SOAP_C_NILSTRING) && s->empty())
		return soap_element_null(soap, tag, id, type);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, s, SOAP_TYPE_fimstime__TimecodeDuration), type) || soap_wstring_out(soap, s->c_str(), 0) || soap_element_end_out(soap, tag))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 std::wstring * SOAP_FMAC4 soap_in_fimstime__TimecodeDuration(struct soap *soap, const char *tag, std::wstring *s, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!s)
		s = soap_new_std__wstring(soap, -1);
	if (soap->null)
		if (s)
			s->erase();
	if (soap->body && !*soap->href)
	{	wchar_t *t;
		s = (std::wstring*)soap_class_id_enter(soap, soap->id, s, SOAP_TYPE_fimstime__TimecodeDuration, sizeof(std::wstring), soap->type, soap->arrayType);
		if (s)
		{	if (!(t = soap_wstring_in(soap, 1, 0, -1)))
				return NULL;
			s->assign(t);
		}
	}
	else
		s = (std::wstring*)soap_id_forward(soap, soap->href, soap_class_id_enter(soap, soap->id, s, SOAP_TYPE_fimstime__TimecodeDuration, sizeof(std::wstring), soap->type, soap->arrayType), 0, SOAP_TYPE_fimstime__TimecodeDuration, 0, sizeof(std::wstring), 0, soap_copy_fimstime__TimecodeDuration);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	return s;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_fimstime__TimecodeDuration(struct soap *soap, const std::wstring *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_fimstime__TimecodeDuration);
	if (soap_out_fimstime__TimecodeDuration(soap, tag?tag:"fimstime:TimecodeDuration", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::wstring * SOAP_FMAC4 soap_get_fimstime__TimecodeDuration(struct soap *soap, std::wstring *p, const char *tag, const char *type)
{
	if ((p = soap_in_fimstime__TimecodeDuration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_fimstime__Timecode(struct soap *soap, const std::wstring *a)
{	(void)soap; (void)a; /* appease -Wall -Werror */
}
SOAP_FMAC3 int SOAP_FMAC4 soap_out_fimstime__Timecode(struct soap *soap, const char *tag, int id, const std::wstring *s, const char *type)
{
	if ((soap->mode & SOAP_C_NILSTRING) && s->empty())
		return soap_element_null(soap, tag, id, type);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, s, SOAP_TYPE_fimstime__Timecode), type) || soap_wstring_out(soap, s->c_str(), 0) || soap_element_end_out(soap, tag))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 std::wstring * SOAP_FMAC4 soap_in_fimstime__Timecode(struct soap *soap, const char *tag, std::wstring *s, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!s)
		s = soap_new_std__wstring(soap, -1);
	if (soap->null)
		if (s)
			s->erase();
	if (soap->body && !*soap->href)
	{	wchar_t *t;
		s = (std::wstring*)soap_class_id_enter(soap, soap->id, s, SOAP_TYPE_fimstime__Timecode, sizeof(std::wstring), soap->type, soap->arrayType);
		if (s)
		{	if (!(t = soap_wstring_in(soap, 1, 0, -1)))
				return NULL;
			s->assign(t);
		}
	}
	else
		s = (std::wstring*)soap_id_forward(soap, soap->href, soap_class_id_enter(soap, soap->id, s, SOAP_TYPE_fimstime__Timecode, sizeof(std::wstring), soap->type, soap->arrayType), 0, SOAP_TYPE_fimstime__Timecode, 0, sizeof(std::wstring), 0, soap_copy_fimstime__Timecode);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	return s;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_fimstime__Timecode(struct soap *soap, const std::wstring *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_fimstime__Timecode);
	if (soap_out_fimstime__Timecode(soap, tag?tag:"fimstime:Timecode", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::wstring * SOAP_FMAC4 soap_get_fimstime__Timecode(struct soap *soap, std::wstring *p, const char *tag, const char *type)
{
	if ((p = soap_in_fimstime__Timecode(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_fims__RevisionIDType(struct soap *soap, const std::wstring *a)
{	(void)soap; (void)a; /* appease -Wall -Werror */
}
SOAP_FMAC3 int SOAP_FMAC4 soap_out_fims__RevisionIDType(struct soap *soap, const char *tag, int id, const std::wstring *s, const char *type)
{
	if ((soap->mode & SOAP_C_NILSTRING) && s->empty())
		return soap_element_null(soap, tag, id, type);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, s, SOAP_TYPE_fims__RevisionIDType), type) || soap_wstring_out(soap, s->c_str(), 0) || soap_element_end_out(soap, tag))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 std::wstring * SOAP_FMAC4 soap_in_fims__RevisionIDType(struct soap *soap, const char *tag, std::wstring *s, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!s)
		s = soap_new_std__wstring(soap, -1);
	if (soap->null)
		if (s)
			s->erase();
	if (soap->body && !*soap->href)
	{	wchar_t *t;
		s = (std::wstring*)soap_class_id_enter(soap, soap->id, s, SOAP_TYPE_fims__RevisionIDType, sizeof(std::wstring), soap->type, soap->arrayType);
		if (s)
		{	if (!(t = soap_wstring_in(soap, 1, 0, -1)))
				return NULL;
			s->assign(t);
		}
	}
	else
		s = (std::wstring*)soap_id_forward(soap, soap->href, soap_class_id_enter(soap, soap->id, s, SOAP_TYPE_fims__RevisionIDType, sizeof(std::wstring), soap->type, soap->arrayType), 0, SOAP_TYPE_fims__RevisionIDType, 0, sizeof(std::wstring), 0, soap_copy_fims__RevisionIDType);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	return s;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_fims__RevisionIDType(struct soap *soap, const std::wstring *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_fims__RevisionIDType);
	if (soap_out_fims__RevisionIDType(soap, tag?tag:"fims:RevisionIDType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::wstring * SOAP_FMAC4 soap_get_fims__RevisionIDType(struct soap *soap, std::wstring *p, const char *tag, const char *type)
{
	if ((p = soap_in_fims__RevisionIDType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_fims__UID(struct soap *soap, const std::wstring *a)
{	(void)soap; (void)a; /* appease -Wall -Werror */
}
SOAP_FMAC3 int SOAP_FMAC4 soap_out_fims__UID(struct soap *soap, const char *tag, int id, const std::wstring *s, const char *type)
{
	if ((soap->mode & SOAP_C_NILSTRING) && s->empty())
		return soap_element_null(soap, tag, id, type);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, s, SOAP_TYPE_fims__UID), type) || soap_wstring_out(soap, s->c_str(), 0) || soap_element_end_out(soap, tag))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 std::wstring * SOAP_FMAC4 soap_in_fims__UID(struct soap *soap, const char *tag, std::wstring *s, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!s)
		s = soap_new_std__wstring(soap, -1);
	if (soap->null)
		if (s)
			s->erase();
	if (soap->body && !*soap->href)
	{	wchar_t *t;
		s = (std::wstring*)soap_class_id_enter(soap, soap->id, s, SOAP_TYPE_fims__UID, sizeof(std::wstring), soap->type, soap->arrayType);
		if (s)
		{	if (!(t = soap_wstring_in(soap, 1, 0, -1)))
				return NULL;
			s->assign(t);
		}
	}
	else
		s = (std::wstring*)soap_id_forward(soap, soap->href, soap_class_id_enter(soap, soap->id, s, SOAP_TYPE_fims__UID, sizeof(std::wstring), soap->type, soap->arrayType), 0, SOAP_TYPE_fims__UID, 0, sizeof(std::wstring), 0, soap_copy_fims__UID);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	return s;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_fims__UID(struct soap *soap, const std::wstring *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_fims__UID);
	if (soap_out_fims__UID(soap, tag?tag:"fims:UID", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::wstring * SOAP_FMAC4 soap_get_fims__UID(struct soap *soap, std::wstring *p, const char *tag, const char *type)
{
	if ((p = soap_in_fims__UID(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void fimsdescription__partType::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->fimsdescription__bmContentDescriptionType::soap_default(soap);
	this->fimsdescription__partType::partStartTime = NULL;
	this->fimsdescription__partType::partDuration = NULL;
	this->fimsdescription__partType::partId = NULL;
	this->fimsdescription__partType::partName = NULL;
	this->fimsdescription__partType::partDefinition = NULL;
	this->fimsdescription__partType::partNumber = NULL;
	this->fimsdescription__partType::partTotalNumber = NULL;
	this->fimsdescription__partType::typeLabel = NULL;
	this->fimsdescription__partType::typeDefinition = NULL;
	this->fimsdescription__partType::typeLink = NULL;
	this->fimsdescription__partType::typeLanguage = NULL;
}

void fimsdescription__partType::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTofimstime__TimeType(soap, &this->fimsdescription__partType::partStartTime);
	soap_serialize_PointerTofimstime__DurationType(soap, &this->fimsdescription__partType::partDuration);
	this->fimsdescription__bmContentDescriptionType::soap_serialize(soap);
#endif
}

int fimsdescription__partType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_fimsdescription__partType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_fimsdescription__partType(struct soap *soap, const char *tag, int id, const fimsdescription__partType *a, const char *type)
{
	if (((fimsdescription__partType*)a)->partId)
		soap_set_attr(soap, "partId", soap_wchar2s(soap, ((fimsdescription__partType*)a)->partId->c_str()), 2);
	if (((fimsdescription__partType*)a)->partName)
		soap_set_attr(soap, "partName", soap_wchar2s(soap, ((fimsdescription__partType*)a)->partName->c_str()), 2);
	if (((fimsdescription__partType*)a)->partDefinition)
		soap_set_attr(soap, "partDefinition", soap_wchar2s(soap, ((fimsdescription__partType*)a)->partDefinition->c_str()), 2);
	if (((fimsdescription__partType*)a)->partNumber)
		soap_set_attr(soap, "partNumber", soap_wchar2s(soap, ((fimsdescription__partType*)a)->partNumber->c_str()), 2);
	if (((fimsdescription__partType*)a)->partTotalNumber)
		soap_set_attr(soap, "partTotalNumber", soap_wchar2s(soap, ((fimsdescription__partType*)a)->partTotalNumber->c_str()), 2);
	if (((fimsdescription__partType*)a)->typeLabel)
		soap_set_attr(soap, "typeLabel", soap_wchar2s(soap, ((fimsdescription__partType*)a)->typeLabel->c_str()), 2);
	if (((fimsdescription__partType*)a)->typeDefinition)
		soap_set_attr(soap, "typeDefinition", soap_wchar2s(soap, ((fimsdescription__partType*)a)->typeDefinition->c_str()), 2);
	if (((fimsdescription__partType*)a)->typeLink)
		soap_set_attr(soap, "typeLink", soap_wchar2s(soap, ((fimsdescription__partType*)a)->typeLink->c_str()), 2);
	if (((fimsdescription__partType*)a)->typeLanguage)
		soap_set_attr(soap, "typeLanguage", soap_wchar2s(soap, ((fimsdescription__partType*)a)->typeLanguage->c_str()), 2);
	if (((fimsdescription__bmContentDescriptionType*)a)->xml__lang)
		soap_set_attr(soap, "xml:lang", soap_wchar2s(soap, ((fimsdescription__bmContentDescriptionType*)a)->xml__lang->c_str()), 2);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_fimsdescription__partType), "fimsdescription:partType"))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTofimsdescription__textElementType(soap, "fimsdescription:title", -1, &(a->fimsdescription__bmContentDescriptionType::title), ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTofimsdescription__titleType(soap, "fimsdescription:alternativeTitle", -1, &(a->fimsdescription__bmContentDescriptionType::alternativeTitle), ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTofimsdescription__entityType(soap, "fimsdescription:creator", -1, &(a->fimsdescription__bmContentDescriptionType::creator), ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTofimsdescription__subjectType(soap, "fimsdescription:subject", -1, &(a->fimsdescription__bmContentDescriptionType::subject), ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTofimsdescription__descriptionType(soap, "fimsdescription:description", -1, &(a->fimsdescription__bmContentDescriptionType::description), ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTofimsdescription__entityType(soap, "fimsdescription:publisher", -1, &(a->fimsdescription__bmContentDescriptionType::publisher), ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTofimsdescription__entityType(soap, "fimsdescription:contributor", -1, &(a->fimsdescription__bmContentDescriptionType::contributor), ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTofimsdescription__dateType(soap, "fimsdescription:date", -1, &(a->fimsdescription__bmContentDescriptionType::date), ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTofimsdescription__typeType(soap, "fimsdescription:type", -1, &(a->fimsdescription__bmContentDescriptionType::type), ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTofimsdescription__identifierType(soap, "fimsdescription:identifier", -1, &(a->fimsdescription__bmContentDescriptionType::identifier), ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTofimsdescription__languageType(soap, "fimsdescription:language", -1, &(a->fimsdescription__bmContentDescriptionType::language), ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTofimsdescription__relationType(soap, "fimsdescription:relation", -1, &(a->fimsdescription__bmContentDescriptionType::relation), ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTofimsdescription__relationType(soap, "fimsdescription:isVersionOf", -1, &(a->fimsdescription__bmContentDescriptionType::isVersionOf), ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTofimsdescription__relationType(soap, "fimsdescription:hasVersion", -1, &(a->fimsdescription__bmContentDescriptionType::hasVersion), ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTofimsdescription__relationType(soap, "fimsdescription:isReplacedBy", -1, &(a->fimsdescription__bmContentDescriptionType::isReplacedBy), ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTofimsdescription__relationType(soap, "fimsdescription:replaces", -1, &(a->fimsdescription__bmContentDescriptionType::replaces), ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTofimsdescription__relationType(soap, "fimsdescription:isRequiredBy", -1, &(a->fimsdescription__bmContentDescriptionType::isRequiredBy), ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTofimsdescription__relationType(soap, "fimsdescription:requires", -1, &(a->fimsdescription__bmContentDescriptionType::requires), ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTofimsdescription__relationType(soap, "fimsdescription:isPartOf", -1, &(a->fimsdescription__bmContentDescriptionType::isPartOf), ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTofimsdescription__relationType(soap, "fimsdescription:hasPart", -1, &(a->fimsdescription__bmContentDescriptionType::hasPart), ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTofimsdescription__relationType(soap, "fimsdescription:isReferencedBy", -1, &(a->fimsdescription__bmContentDescriptionType::isReferencedBy), ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTofimsdescription__relationType(soap, "fimsdescription:references", -1, &(a->fimsdescription__bmContentDescriptionType::references), ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTofimsdescription__relationType(soap, "fimsdescription:isFormatOf", -1, &(a->fimsdescription__bmContentDescriptionType::isFormatOf), ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTofimsdescription__relationType(soap, "fimsdescription:hasFormat", -1, &(a->fimsdescription__bmContentDescriptionType::hasFormat), ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTofimsdescription__relationType(soap, "fimsdescription:isEpisodeOf", -1, &(a->fimsdescription__bmContentDescriptionType::isEpisodeOf), ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTofimsdescription__relationType(soap, "fimsdescription:isMemberOf", -1, &(a->fimsdescription__bmContentDescriptionType::isMemberOf), ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTofimsdescription__relationType(soap, "fimsdescription:hasMembers", -1, &(a->fimsdescription__bmContentDescriptionType::hasMembers), ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTofimsdescription__coverageType(soap, "fimsdescription:coverage", -1, &(a->fimsdescription__bmContentDescriptionType::coverage), ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTofimsdescription__rightsType(soap, "fimsdescription:rights", -1, &(a->fimsdescription__bmContentDescriptionType::rights), ""))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "fimsdescription:version", -1, &(a->fimsdescription__bmContentDescriptionType::version), ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTofimsdescription__partType(soap, "fimsdescription:part", -1, &(a->fimsdescription__bmContentDescriptionType::part), ""))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_PointerTofimstime__TimeType(soap, "fimsdescription:partStartTime", -1, &(a->fimsdescription__partType::partStartTime), ""))
		return soap->error;
	if (soap_out_PointerTofimstime__DurationType(soap, "fimsdescription:partDuration", -1, &(a->fimsdescription__partType::partDuration), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *fimsdescription__partType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_fimsdescription__partType(soap, tag, this, type);
}

SOAP_FMAC3 fimsdescription__partType * SOAP_FMAC4 soap_in_fimsdescription__partType(struct soap *soap, const char *tag, fimsdescription__partType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (fimsdescription__partType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_fimsdescription__partType, sizeof(fimsdescription__partType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_fimsdescription__partType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (fimsdescription__partType *)a->soap_in(soap, tag, type);
		}
	}
	{	const char *t = soap_attr_value(soap, "partId", 0);
		if (t)
		{
			if (!(((fimsdescription__partType*)a)->partId = (std::wstring *)soap_malloc(soap, sizeof(std::wstring))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			wchar_t *s = NULL;
			if (soap_s2wchar(soap, t, &s, 0, -1))
				return NULL;
			if (s)
			{	((fimsdescription__partType*)a)->partId = soap_new_std__wstring(soap, -1);
				((fimsdescription__partType*)a)->partId->assign(s);
			}
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "partName", 0);
		if (t)
		{
			if (!(((fimsdescription__partType*)a)->partName = (std::wstring *)soap_malloc(soap, sizeof(std::wstring))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			wchar_t *s = NULL;
			if (soap_s2wchar(soap, t, &s, 0, -1))
				return NULL;
			if (s)
			{	((fimsdescription__partType*)a)->partName = soap_new_std__wstring(soap, -1);
				((fimsdescription__partType*)a)->partName->assign(s);
			}
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "partDefinition", 0);
		if (t)
		{
			if (!(((fimsdescription__partType*)a)->partDefinition = (std::wstring *)soap_malloc(soap, sizeof(std::wstring))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			wchar_t *s = NULL;
			if (soap_s2wchar(soap, t, &s, 0, -1))
				return NULL;
			if (s)
			{	((fimsdescription__partType*)a)->partDefinition = soap_new_std__wstring(soap, -1);
				((fimsdescription__partType*)a)->partDefinition->assign(s);
			}
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "partNumber", 0);
		if (t)
		{
			if (!(((fimsdescription__partType*)a)->partNumber = (std::wstring *)soap_malloc(soap, sizeof(std::wstring))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			wchar_t *s = NULL;
			if (soap_s2wchar(soap, t, &s, 0, -1))
				return NULL;
			if (s)
			{	((fimsdescription__partType*)a)->partNumber = soap_new_std__wstring(soap, -1);
				((fimsdescription__partType*)a)->partNumber->assign(s);
			}
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "partTotalNumber", 0);
		if (t)
		{
			if (!(((fimsdescription__partType*)a)->partTotalNumber = (std::wstring *)soap_malloc(soap, sizeof(std::wstring))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			wchar_t *s = NULL;
			if (soap_s2wchar(soap, t, &s, 0, -1))
				return NULL;
			if (s)
			{	((fimsdescription__partType*)a)->partTotalNumber = soap_new_std__wstring(soap, -1);
				((fimsdescription__partType*)a)->partTotalNumber->assign(s);
			}
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "typeLabel", 0);
		if (t)
		{
			if (!(((fimsdescription__partType*)a)->typeLabel = (std::wstring *)soap_malloc(soap, sizeof(std::wstring))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			wchar_t *s = NULL;
			if (soap_s2wchar(soap, t, &s, 0, -1))
				return NULL;
			if (s)
			{	((fimsdescription__partType*)a)->typeLabel = soap_new_std__wstring(soap, -1);
				((fimsdescription__partType*)a)->typeLabel->assign(s);
			}
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "typeDefinition", 0);
		if (t)
		{
			if (!(((fimsdescription__partType*)a)->typeDefinition = (std::wstring *)soap_malloc(soap, sizeof(std::wstring))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			wchar_t *s = NULL;
			if (soap_s2wchar(soap, t, &s, 0, -1))
				return NULL;
			if (s)
			{	((fimsdescription__partType*)a)->typeDefinition = soap_new_std__wstring(soap, -1);
				((fimsdescription__partType*)a)->typeDefinition->assign(s);
			}
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "typeLink", 0);
		if (t)
		{
			if (!(((fimsdescription__partType*)a)->typeLink = (std::wstring *)soap_malloc(soap, sizeof(std::wstring))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			wchar_t *s = NULL;
			if (soap_s2wchar(soap, t, &s, 0, -1))
				return NULL;
			if (s)
			{	((fimsdescription__partType*)a)->typeLink = soap_new_std__wstring(soap, -1);
				((fimsdescription__partType*)a)->typeLink->assign(s);
			}
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "typeLanguage", 0);
		if (t)
		{
			if (!(((fimsdescription__partType*)a)->typeLanguage = (std::wstring *)soap_malloc(soap, sizeof(std::wstring))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			wchar_t *s = NULL;
			if (soap_s2wchar(soap, t, &s, 0, -1))
				return NULL;
			if (s)
			{	((fimsdescription__partType*)a)->typeLanguage = soap_new_std__wstring(soap, -1);
				((fimsdescription__partType*)a)->typeLanguage->assign(s);
			}
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "xml:lang", 0);
		if (t)
		{
			if (!(((fimsdescription__bmContentDescriptionType*)a)->xml__lang = (std::wstring *)soap_malloc(soap, sizeof(std::wstring))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			wchar_t *s = NULL;
			if (soap_s2wchar(soap, t, &s, 0, -1))
				return NULL;
			if (s)
			{	((fimsdescription__bmContentDescriptionType*)a)->xml__lang = soap_new_std__wstring(soap, -1);
				((fimsdescription__bmContentDescriptionType*)a)->xml__lang->assign(s);
			}
		}
		else if (soap->error)
			return NULL;
	}
	size_t soap_flag_version2 = 1;
	size_t soap_flag_partStartTime1 = 1;
	size_t soap_flag_partDuration1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTofimsdescription__textElementType(soap, "fimsdescription:title", &(a->fimsdescription__bmContentDescriptionType::title), "fimsdescription:textElementType"))
					continue;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTofimsdescription__titleType(soap, "fimsdescription:alternativeTitle", &(a->fimsdescription__bmContentDescriptionType::alternativeTitle), "fimsdescription:titleType"))
					continue;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTofimsdescription__entityType(soap, "fimsdescription:creator", &(a->fimsdescription__bmContentDescriptionType::creator), "fimsdescription:entityType"))
					continue;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTofimsdescription__subjectType(soap, "fimsdescription:subject", &(a->fimsdescription__bmContentDescriptionType::subject), "fimsdescription:subjectType"))
					continue;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTofimsdescription__descriptionType(soap, "fimsdescription:description", &(a->fimsdescription__bmContentDescriptionType::description), "fimsdescription:descriptionType"))
					continue;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTofimsdescription__entityType(soap, "fimsdescription:publisher", &(a->fimsdescription__bmContentDescriptionType::publisher), "fimsdescription:entityType"))
					continue;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTofimsdescription__entityType(soap, "fimsdescription:contributor", &(a->fimsdescription__bmContentDescriptionType::contributor), "fimsdescription:entityType"))
					continue;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTofimsdescription__dateType(soap, "fimsdescription:date", &(a->fimsdescription__bmContentDescriptionType::date), "fimsdescription:dateType"))
					continue;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTofimsdescription__typeType(soap, "fimsdescription:type", &(a->fimsdescription__bmContentDescriptionType::type), "fimsdescription:typeType"))
					continue;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTofimsdescription__identifierType(soap, "fimsdescription:identifier", &(a->fimsdescription__bmContentDescriptionType::identifier), "fimsdescription:identifierType"))
					continue;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTofimsdescription__languageType(soap, "fimsdescription:language", &(a->fimsdescription__bmContentDescriptionType::language), "fimsdescription:languageType"))
					continue;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTofimsdescription__relationType(soap, "fimsdescription:relation", &(a->fimsdescription__bmContentDescriptionType::relation), "fimsdescription:relationType"))
					continue;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTofimsdescription__relationType(soap, "fimsdescription:isVersionOf", &(a->fimsdescription__bmContentDescriptionType::isVersionOf), "fimsdescription:relationType"))
					continue;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTofimsdescription__relationType(soap, "fimsdescription:hasVersion", &(a->fimsdescription__bmContentDescriptionType::hasVersion), "fimsdescription:relationType"))
					continue;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTofimsdescription__relationType(soap, "fimsdescription:isReplacedBy", &(a->fimsdescription__bmContentDescriptionType::isReplacedBy), "fimsdescription:relationType"))
					continue;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTofimsdescription__relationType(soap, "fimsdescription:replaces", &(a->fimsdescription__bmContentDescriptionType::replaces), "fimsdescription:relationType"))
					continue;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTofimsdescription__relationType(soap, "fimsdescription:isRequiredBy", &(a->fimsdescription__bmContentDescriptionType::isRequiredBy), "fimsdescription:relationType"))
					continue;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTofimsdescription__relationType(soap, "fimsdescription:requires", &(a->fimsdescription__bmContentDescriptionType::requires), "fimsdescription:relationType"))
					continue;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTofimsdescription__relationType(soap, "fimsdescription:isPartOf", &(a->fimsdescription__bmContentDescriptionType::isPartOf), "fimsdescription:relationType"))
					continue;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTofimsdescription__relationType(soap, "fimsdescription:hasPart", &(a->fimsdescription__bmContentDescriptionType::hasPart), "fimsdescription:relationType"))
					continue;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTofimsdescription__relationType(soap, "fimsdescription:isReferencedBy", &(a->fimsdescription__bmContentDescriptionType::isReferencedBy), "fimsdescription:relationType"))
					continue;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTofimsdescription__relationType(soap, "fimsdescription:references", &(a->fimsdescription__bmContentDescriptionType::references), "fimsdescription:relationType"))
					continue;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTofimsdescription__relationType(soap, "fimsdescription:isFormatOf", &(a->fimsdescription__bmContentDescriptionType::isFormatOf), "fimsdescription:relationType"))
					continue;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTofimsdescription__relationType(soap, "fimsdescription:hasFormat", &(a->fimsdescription__bmContentDescriptionType::hasFormat), "fimsdescription:relationType"))
					continue;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTofimsdescription__relationType(soap, "fimsdescription:isEpisodeOf", &(a->fimsdescription__bmContentDescriptionType::isEpisodeOf), "fimsdescription:relationType"))
					continue;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTofimsdescription__relationType(soap, "fimsdescription:isMemberOf", &(a->fimsdescription__bmContentDescriptionType::isMemberOf), "fimsdescription:relationType"))
					continue;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTofimsdescription__relationType(soap, "fimsdescription:hasMembers", &(a->fimsdescription__bmContentDescriptionType::hasMembers), "fimsdescription:relationType"))
					continue;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTofimsdescription__coverageType(soap, "fimsdescription:coverage", &(a->fimsdescription__bmContentDescriptionType::coverage), "fimsdescription:coverageType"))
					continue;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTofimsdescription__rightsType(soap, "fimsdescription:rights", &(a->fimsdescription__bmContentDescriptionType::rights), "fimsdescription:rightsType"))
					continue;
			if (soap_flag_version2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "fimsdescription:version", &(a->fimsdescription__bmContentDescriptionType::version), "xsd:string"))
				{	soap_flag_version2--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTofimsdescription__partType(soap, "fimsdescription:part", &(a->fimsdescription__bmContentDescriptionType::part), "fimsdescription:partType"))
					continue;
			/* transient soap skipped */
			if (soap_flag_partStartTime1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTofimstime__TimeType(soap, "fimsdescription:partStartTime", &(a->fimsdescription__partType::partStartTime), "fimstime:TimeType"))
				{	soap_flag_partStartTime1--;
					continue;
				}
			if (soap_flag_partDuration1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTofimstime__DurationType(soap, "fimsdescription:partDuration", &(a->fimsdescription__partType::partDuration), "fimstime:DurationType"))
				{	soap_flag_partDuration1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (fimsdescription__partType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_fimsdescription__partType, 0, sizeof(fimsdescription__partType), 0, soap_copy_fimsdescription__partType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int fimsdescription__partType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_fimsdescription__partType);
	if (this->soap_out(soap, tag?tag:"fimsdescription:partType", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *fimsdescription__partType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_fimsdescription__partType(soap, this, tag, type);
}

SOAP_FMAC3 fimsdescription__partType * SOAP_FMAC4 soap_get_fimsdescription__partType(struct soap *soap, fimsdescription__partType *p, const char *tag, const char *type)
{
	if ((p = soap_in_fimsdescription__partType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 fimsdescription__partType * SOAP_FMAC2 soap_instantiate_fimsdescription__partType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_fimsdescription__partType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_fimsdescription__partType, n, EDLProvider_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(fimsdescription__partType);
		if (size)
			*size = sizeof(fimsdescription__partType);
		((fimsdescription__partType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(fimsdescription__partType, n);
		if (size)
			*size = n * sizeof(fimsdescription__partType);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((fimsdescription__partType*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (fimsdescription__partType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_fimsdescription__partType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying fimsdescription__partType %p -> %p\n", q, p));
	*(fimsdescription__partType*)p = *(fimsdescription__partType*)q;
}

void fimsdescription__relationType::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->fimsdescription__relationType::relationIdentifier = NULL;
	soap_default_xsd__anyURI(soap, &this->fimsdescription__relationType::relationLink);
	this->fimsdescription__relationType::runningOrderNumber = NULL;
	this->fimsdescription__relationType::totalNumberOfGroupMembers = NULL;
	this->fimsdescription__relationType::orderedGroupFlag = NULL;
	this->fimsdescription__relationType::note = NULL;
	this->fimsdescription__relationType::typeLabel = NULL;
	this->fimsdescription__relationType::typeDefinition = NULL;
	this->fimsdescription__relationType::typeLink = NULL;
	this->fimsdescription__relationType::typeLanguage = NULL;
	/* transient soap skipped */
}

void fimsdescription__relationType::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTofimsdescription__identifierType(soap, &this->fimsdescription__relationType::relationIdentifier);
	soap_embedded(soap, &this->fimsdescription__relationType::relationLink, SOAP_TYPE_xsd__anyURI);
	soap_serialize_xsd__anyURI(soap, &this->fimsdescription__relationType::relationLink);
	/* transient soap skipped */
#endif
}

int fimsdescription__relationType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_fimsdescription__relationType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_fimsdescription__relationType(struct soap *soap, const char *tag, int id, const fimsdescription__relationType *a, const char *type)
{
	if (((fimsdescription__relationType*)a)->runningOrderNumber)
		soap_set_attr(soap, "runningOrderNumber", soap_wchar2s(soap, ((fimsdescription__relationType*)a)->runningOrderNumber->c_str()), 2);
	if (((fimsdescription__relationType*)a)->totalNumberOfGroupMembers)
		soap_set_attr(soap, "totalNumberOfGroupMembers", soap_wchar2s(soap, ((fimsdescription__relationType*)a)->totalNumberOfGroupMembers->c_str()), 2);
	if (((fimsdescription__relationType*)a)->orderedGroupFlag)
		soap_set_attr(soap, "orderedGroupFlag", soap_bool2s(soap, *((fimsdescription__relationType*)a)->orderedGroupFlag), 1);
	if (((fimsdescription__relationType*)a)->note)
		soap_set_attr(soap, "note", soap_wchar2s(soap, ((fimsdescription__relationType*)a)->note->c_str()), 2);
	if (((fimsdescription__relationType*)a)->typeLabel)
		soap_set_attr(soap, "typeLabel", soap_wchar2s(soap, ((fimsdescription__relationType*)a)->typeLabel->c_str()), 2);
	if (((fimsdescription__relationType*)a)->typeDefinition)
		soap_set_attr(soap, "typeDefinition", soap_wchar2s(soap, ((fimsdescription__relationType*)a)->typeDefinition->c_str()), 2);
	if (((fimsdescription__relationType*)a)->typeLink)
		soap_set_attr(soap, "typeLink", soap_wchar2s(soap, ((fimsdescription__relationType*)a)->typeLink->c_str()), 2);
	if (((fimsdescription__relationType*)a)->typeLanguage)
		soap_set_attr(soap, "typeLanguage", soap_wchar2s(soap, ((fimsdescription__relationType*)a)->typeLanguage->c_str()), 2);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_fimsdescription__relationType), type))
		return soap->error;
	if (a->fimsdescription__relationType::relationIdentifier)
	{	if (soap_out_PointerTofimsdescription__identifierType(soap, "fimsdescription:relationIdentifier", -1, &a->fimsdescription__relationType::relationIdentifier, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "fimsdescription:relationIdentifier"))
		return soap->error;
	if (soap_out_xsd__anyURI(soap, "fimsdescription:relationLink", -1, &(a->fimsdescription__relationType::relationLink), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *fimsdescription__relationType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_fimsdescription__relationType(soap, tag, this, type);
}

SOAP_FMAC3 fimsdescription__relationType * SOAP_FMAC4 soap_in_fimsdescription__relationType(struct soap *soap, const char *tag, fimsdescription__relationType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (fimsdescription__relationType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_fimsdescription__relationType, sizeof(fimsdescription__relationType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_fimsdescription__relationType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (fimsdescription__relationType *)a->soap_in(soap, tag, type);
		}
	}
	{	const char *t = soap_attr_value(soap, "runningOrderNumber", 0);
		if (t)
		{
			if (!(((fimsdescription__relationType*)a)->runningOrderNumber = (std::wstring *)soap_malloc(soap, sizeof(std::wstring))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			wchar_t *s = NULL;
			if (soap_s2wchar(soap, t, &s, 0, -1))
				return NULL;
			if (s)
			{	((fimsdescription__relationType*)a)->runningOrderNumber = soap_new_std__wstring(soap, -1);
				((fimsdescription__relationType*)a)->runningOrderNumber->assign(s);
			}
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "totalNumberOfGroupMembers", 0);
		if (t)
		{
			if (!(((fimsdescription__relationType*)a)->totalNumberOfGroupMembers = (std::wstring *)soap_malloc(soap, sizeof(std::wstring))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			wchar_t *s = NULL;
			if (soap_s2wchar(soap, t, &s, 0, -1))
				return NULL;
			if (s)
			{	((fimsdescription__relationType*)a)->totalNumberOfGroupMembers = soap_new_std__wstring(soap, -1);
				((fimsdescription__relationType*)a)->totalNumberOfGroupMembers->assign(s);
			}
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "orderedGroupFlag", 0);
		if (t)
		{
			if (!(((fimsdescription__relationType*)a)->orderedGroupFlag = (bool *)soap_malloc(soap, sizeof(bool))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2bool(soap, t, ((fimsdescription__relationType*)a)->orderedGroupFlag))
			return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "note", 0);
		if (t)
		{
			if (!(((fimsdescription__relationType*)a)->note = (std::wstring *)soap_malloc(soap, sizeof(std::wstring))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			wchar_t *s = NULL;
			if (soap_s2wchar(soap, t, &s, 0, -1))
				return NULL;
			if (s)
			{	((fimsdescription__relationType*)a)->note = soap_new_std__wstring(soap, -1);
				((fimsdescription__relationType*)a)->note->assign(s);
			}
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "typeLabel", 0);
		if (t)
		{
			if (!(((fimsdescription__relationType*)a)->typeLabel = (std::wstring *)soap_malloc(soap, sizeof(std::wstring))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			wchar_t *s = NULL;
			if (soap_s2wchar(soap, t, &s, 0, -1))
				return NULL;
			if (s)
			{	((fimsdescription__relationType*)a)->typeLabel = soap_new_std__wstring(soap, -1);
				((fimsdescription__relationType*)a)->typeLabel->assign(s);
			}
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "typeDefinition", 0);
		if (t)
		{
			if (!(((fimsdescription__relationType*)a)->typeDefinition = (std::wstring *)soap_malloc(soap, sizeof(std::wstring))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			wchar_t *s = NULL;
			if (soap_s2wchar(soap, t, &s, 0, -1))
				return NULL;
			if (s)
			{	((fimsdescription__relationType*)a)->typeDefinition = soap_new_std__wstring(soap, -1);
				((fimsdescription__relationType*)a)->typeDefinition->assign(s);
			}
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "typeLink", 0);
		if (t)
		{
			if (!(((fimsdescription__relationType*)a)->typeLink = (std::wstring *)soap_malloc(soap, sizeof(std::wstring))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			wchar_t *s = NULL;
			if (soap_s2wchar(soap, t, &s, 0, -1))
				return NULL;
			if (s)
			{	((fimsdescription__relationType*)a)->typeLink = soap_new_std__wstring(soap, -1);
				((fimsdescription__relationType*)a)->typeLink->assign(s);
			}
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "typeLanguage", 0);
		if (t)
		{
			if (!(((fimsdescription__relationType*)a)->typeLanguage = (std::wstring *)soap_malloc(soap, sizeof(std::wstring))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			wchar_t *s = NULL;
			if (soap_s2wchar(soap, t, &s, 0, -1))
				return NULL;
			if (s)
			{	((fimsdescription__relationType*)a)->typeLanguage = soap_new_std__wstring(soap, -1);
				((fimsdescription__relationType*)a)->typeLanguage->assign(s);
			}
		}
		else if (soap->error)
			return NULL;
	}
	size_t soap_flag_relationIdentifier1 = 1;
	size_t soap_flag_relationLink1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_relationIdentifier1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTofimsdescription__identifierType(soap, "fimsdescription:relationIdentifier", &(a->fimsdescription__relationType::relationIdentifier), "fimsdescription:identifierType"))
				{	soap_flag_relationIdentifier1--;
					continue;
				}
			if (soap_flag_relationLink1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__anyURI(soap, "fimsdescription:relationLink", &(a->fimsdescription__relationType::relationLink), "xsd:anyURI"))
				{	soap_flag_relationLink1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (fimsdescription__relationType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_fimsdescription__relationType, 0, sizeof(fimsdescription__relationType), 0, soap_copy_fimsdescription__relationType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_relationIdentifier1 > 0 || soap_flag_relationLink1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int fimsdescription__relationType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_fimsdescription__relationType);
	if (this->soap_out(soap, tag?tag:"fimsdescription:relationType", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *fimsdescription__relationType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_fimsdescription__relationType(soap, this, tag, type);
}

SOAP_FMAC3 fimsdescription__relationType * SOAP_FMAC4 soap_get_fimsdescription__relationType(struct soap *soap, fimsdescription__relationType *p, const char *tag, const char *type)
{
	if ((p = soap_in_fimsdescription__relationType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 fimsdescription__relationType * SOAP_FMAC2 soap_instantiate_fimsdescription__relationType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_fimsdescription__relationType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_fimsdescription__relationType, n, EDLProvider_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(fimsdescription__relationType);
		if (size)
			*size = sizeof(fimsdescription__relationType);
		((fimsdescription__relationType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(fimsdescription__relationType, n);
		if (size)
			*size = n * sizeof(fimsdescription__relationType);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((fimsdescription__relationType*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (fimsdescription__relationType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_fimsdescription__relationType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying fimsdescription__relationType %p -> %p\n", q, p));
	*(fimsdescription__relationType*)p = *(fimsdescription__relationType*)q;
}

void fimsdescription__languageType::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->fimsdescription__languageType::xml__lang = NULL;
	this->fimsdescription__languageType::typeLabel = NULL;
	this->fimsdescription__languageType::typeDefinition = NULL;
	this->fimsdescription__languageType::typeLink = NULL;
	this->fimsdescription__languageType::typeLanguage = NULL;
	/* transient soap skipped */
}

void fimsdescription__languageType::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
#endif
}

int fimsdescription__languageType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_fimsdescription__languageType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_fimsdescription__languageType(struct soap *soap, const char *tag, int id, const fimsdescription__languageType *a, const char *type)
{
	if (((fimsdescription__languageType*)a)->xml__lang)
		soap_set_attr(soap, "xml:lang", soap_wchar2s(soap, ((fimsdescription__languageType*)a)->xml__lang->c_str()), 2);
	if (((fimsdescription__languageType*)a)->typeLabel)
		soap_set_attr(soap, "typeLabel", soap_wchar2s(soap, ((fimsdescription__languageType*)a)->typeLabel->c_str()), 2);
	if (((fimsdescription__languageType*)a)->typeDefinition)
		soap_set_attr(soap, "typeDefinition", soap_wchar2s(soap, ((fimsdescription__languageType*)a)->typeDefinition->c_str()), 2);
	if (((fimsdescription__languageType*)a)->typeLink)
		soap_set_attr(soap, "typeLink", soap_wchar2s(soap, ((fimsdescription__languageType*)a)->typeLink->c_str()), 2);
	if (((fimsdescription__languageType*)a)->typeLanguage)
		soap_set_attr(soap, "typeLanguage", soap_wchar2s(soap, ((fimsdescription__languageType*)a)->typeLanguage->c_str()), 2);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_fimsdescription__languageType), type))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *fimsdescription__languageType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_fimsdescription__languageType(soap, tag, this, type);
}

SOAP_FMAC3 fimsdescription__languageType * SOAP_FMAC4 soap_in_fimsdescription__languageType(struct soap *soap, const char *tag, fimsdescription__languageType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (fimsdescription__languageType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_fimsdescription__languageType, sizeof(fimsdescription__languageType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_fimsdescription__languageType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (fimsdescription__languageType *)a->soap_in(soap, tag, type);
		}
	}
	{	const char *t = soap_attr_value(soap, "xml:lang", 0);
		if (t)
		{
			if (!(((fimsdescription__languageType*)a)->xml__lang = (std::wstring *)soap_malloc(soap, sizeof(std::wstring))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			wchar_t *s = NULL;
			if (soap_s2wchar(soap, t, &s, 0, -1))
				return NULL;
			if (s)
			{	((fimsdescription__languageType*)a)->xml__lang = soap_new_std__wstring(soap, -1);
				((fimsdescription__languageType*)a)->xml__lang->assign(s);
			}
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "typeLabel", 0);
		if (t)
		{
			if (!(((fimsdescription__languageType*)a)->typeLabel = (std::wstring *)soap_malloc(soap, sizeof(std::wstring))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			wchar_t *s = NULL;
			if (soap_s2wchar(soap, t, &s, 0, -1))
				return NULL;
			if (s)
			{	((fimsdescription__languageType*)a)->typeLabel = soap_new_std__wstring(soap, -1);
				((fimsdescription__languageType*)a)->typeLabel->assign(s);
			}
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "typeDefinition", 0);
		if (t)
		{
			if (!(((fimsdescription__languageType*)a)->typeDefinition = (std::wstring *)soap_malloc(soap, sizeof(std::wstring))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			wchar_t *s = NULL;
			if (soap_s2wchar(soap, t, &s, 0, -1))
				return NULL;
			if (s)
			{	((fimsdescription__languageType*)a)->typeDefinition = soap_new_std__wstring(soap, -1);
				((fimsdescription__languageType*)a)->typeDefinition->assign(s);
			}
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "typeLink", 0);
		if (t)
		{
			if (!(((fimsdescription__languageType*)a)->typeLink = (std::wstring *)soap_malloc(soap, sizeof(std::wstring))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			wchar_t *s = NULL;
			if (soap_s2wchar(soap, t, &s, 0, -1))
				return NULL;
			if (s)
			{	((fimsdescription__languageType*)a)->typeLink = soap_new_std__wstring(soap, -1);
				((fimsdescription__languageType*)a)->typeLink->assign(s);
			}
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "typeLanguage", 0);
		if (t)
		{
			if (!(((fimsdescription__languageType*)a)->typeLanguage = (std::wstring *)soap_malloc(soap, sizeof(std::wstring))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			wchar_t *s = NULL;
			if (soap_s2wchar(soap, t, &s, 0, -1))
				return NULL;
			if (s)
			{	((fimsdescription__languageType*)a)->typeLanguage = soap_new_std__wstring(soap, -1);
				((fimsdescription__languageType*)a)->typeLanguage->assign(s);
			}
		}
		else if (soap->error)
			return NULL;
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (fimsdescription__languageType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_fimsdescription__languageType, 0, sizeof(fimsdescription__languageType), 0, soap_copy_fimsdescription__languageType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int fimsdescription__languageType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_fimsdescription__languageType);
	if (this->soap_out(soap, tag?tag:"fimsdescription:languageType", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *fimsdescription__languageType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_fimsdescription__languageType(soap, this, tag, type);
}

SOAP_FMAC3 fimsdescription__languageType * SOAP_FMAC4 soap_get_fimsdescription__languageType(struct soap *soap, fimsdescription__languageType *p, const char *tag, const char *type)
{
	if ((p = soap_in_fimsdescription__languageType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 fimsdescription__languageType * SOAP_FMAC2 soap_instantiate_fimsdescription__languageType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_fimsdescription__languageType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_fimsdescription__languageType, n, EDLProvider_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(fimsdescription__languageType);
		if (size)
			*size = sizeof(fimsdescription__languageType);
		((fimsdescription__languageType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(fimsdescription__languageType, n);
		if (size)
			*size = n * sizeof(fimsdescription__languageType);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((fimsdescription__languageType*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (fimsdescription__languageType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_fimsdescription__languageType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying fimsdescription__languageType %p -> %p\n", q, p));
	*(fimsdescription__languageType*)p = *(fimsdescription__languageType*)q;
}

void fimsdescription__addressType::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTofimsdescription__textElementType(soap, &this->fimsdescription__addressType::addressLine);
	this->fimsdescription__addressType::addressTownCity = NULL;
	this->fimsdescription__addressType::addressCountyState = NULL;
	this->fimsdescription__addressType::addressDeliveryCode = NULL;
	this->fimsdescription__addressType::country = NULL;
	/* transient soap skipped */
}

void fimsdescription__addressType::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfPointerTofimsdescription__textElementType(soap, &this->fimsdescription__addressType::addressLine);
	soap_serialize_PointerTofimsdescription__textElementType(soap, &this->fimsdescription__addressType::addressTownCity);
	soap_serialize_PointerTofimsdescription__textElementType(soap, &this->fimsdescription__addressType::addressCountyState);
	soap_serialize_PointerTostd__wstring(soap, &this->fimsdescription__addressType::addressDeliveryCode);
	soap_serialize_PointerTo_fimsdescription__addressType_country(soap, &this->fimsdescription__addressType::country);
	/* transient soap skipped */
#endif
}

int fimsdescription__addressType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_fimsdescription__addressType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_fimsdescription__addressType(struct soap *soap, const char *tag, int id, const fimsdescription__addressType *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_fimsdescription__addressType), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTofimsdescription__textElementType(soap, "fimsdescription:addressLine", -1, &(a->fimsdescription__addressType::addressLine), ""))
		return soap->error;
	if (soap_out_PointerTofimsdescription__textElementType(soap, "fimsdescription:addressTownCity", -1, &(a->fimsdescription__addressType::addressTownCity), ""))
		return soap->error;
	if (soap_out_PointerTofimsdescription__textElementType(soap, "fimsdescription:addressCountyState", -1, &(a->fimsdescription__addressType::addressCountyState), ""))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "fimsdescription:addressDeliveryCode", -1, &(a->fimsdescription__addressType::addressDeliveryCode), ""))
		return soap->error;
	if (soap_out_PointerTo_fimsdescription__addressType_country(soap, "fimsdescription:country", -1, &(a->fimsdescription__addressType::country), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *fimsdescription__addressType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_fimsdescription__addressType(soap, tag, this, type);
}

SOAP_FMAC3 fimsdescription__addressType * SOAP_FMAC4 soap_in_fimsdescription__addressType(struct soap *soap, const char *tag, fimsdescription__addressType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (fimsdescription__addressType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_fimsdescription__addressType, sizeof(fimsdescription__addressType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_fimsdescription__addressType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (fimsdescription__addressType *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_addressTownCity1 = 1;
	size_t soap_flag_addressCountyState1 = 1;
	size_t soap_flag_addressDeliveryCode1 = 1;
	size_t soap_flag_country1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTofimsdescription__textElementType(soap, "fimsdescription:addressLine", &(a->fimsdescription__addressType::addressLine), "fimsdescription:textElementType"))
					continue;
			if (soap_flag_addressTownCity1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTofimsdescription__textElementType(soap, "fimsdescription:addressTownCity", &(a->fimsdescription__addressType::addressTownCity), "fimsdescription:textElementType"))
				{	soap_flag_addressTownCity1--;
					continue;
				}
			if (soap_flag_addressCountyState1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTofimsdescription__textElementType(soap, "fimsdescription:addressCountyState", &(a->fimsdescription__addressType::addressCountyState), "fimsdescription:textElementType"))
				{	soap_flag_addressCountyState1--;
					continue;
				}
			if (soap_flag_addressDeliveryCode1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "fimsdescription:addressDeliveryCode", &(a->fimsdescription__addressType::addressDeliveryCode), "xsd:string"))
				{	soap_flag_addressDeliveryCode1--;
					continue;
				}
			if (soap_flag_country1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_fimsdescription__addressType_country(soap, "fimsdescription:country", &(a->fimsdescription__addressType::country), ""))
				{	soap_flag_country1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (fimsdescription__addressType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_fimsdescription__addressType, 0, sizeof(fimsdescription__addressType), 0, soap_copy_fimsdescription__addressType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int fimsdescription__addressType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_fimsdescription__addressType);
	if (this->soap_out(soap, tag?tag:"fimsdescription:addressType", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *fimsdescription__addressType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_fimsdescription__addressType(soap, this, tag, type);
}

SOAP_FMAC3 fimsdescription__addressType * SOAP_FMAC4 soap_get_fimsdescription__addressType(struct soap *soap, fimsdescription__addressType *p, const char *tag, const char *type)
{
	if ((p = soap_in_fimsdescription__addressType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 fimsdescription__addressType * SOAP_FMAC2 soap_instantiate_fimsdescription__addressType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_fimsdescription__addressType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_fimsdescription__addressType, n, EDLProvider_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(fimsdescription__addressType);
		if (size)
			*size = sizeof(fimsdescription__addressType);
		((fimsdescription__addressType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(fimsdescription__addressType, n);
		if (size)
			*size = n * sizeof(fimsdescription__addressType);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((fimsdescription__addressType*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (fimsdescription__addressType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_fimsdescription__addressType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying fimsdescription__addressType %p -> %p\n", q, p));
	*(fimsdescription__addressType*)p = *(fimsdescription__addressType*)q;
}

void fimsdescription__detailsType::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfstd__wstring(soap, &this->fimsdescription__detailsType::emailAddress);
	this->fimsdescription__detailsType::webAddress = NULL;
	this->fimsdescription__detailsType::address = NULL;
	this->fimsdescription__detailsType::telephoneNumber = NULL;
	this->fimsdescription__detailsType::mobileTelephoneNumber = NULL;
	this->fimsdescription__detailsType::typeLabel = NULL;
	this->fimsdescription__detailsType::typeDefinition = NULL;
	this->fimsdescription__detailsType::typeLink = NULL;
	this->fimsdescription__detailsType::typeLanguage = NULL;
	/* transient soap skipped */
}

void fimsdescription__detailsType::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfstd__wstring(soap, &this->fimsdescription__detailsType::emailAddress);
	soap_serialize_PointerTostd__wstring(soap, &this->fimsdescription__detailsType::webAddress);
	soap_serialize_PointerTofimsdescription__addressType(soap, &this->fimsdescription__detailsType::address);
	soap_serialize_PointerTostd__wstring(soap, &this->fimsdescription__detailsType::telephoneNumber);
	soap_serialize_PointerTostd__wstring(soap, &this->fimsdescription__detailsType::mobileTelephoneNumber);
	/* transient soap skipped */
#endif
}

int fimsdescription__detailsType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_fimsdescription__detailsType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_fimsdescription__detailsType(struct soap *soap, const char *tag, int id, const fimsdescription__detailsType *a, const char *type)
{
	if (((fimsdescription__detailsType*)a)->typeLabel)
		soap_set_attr(soap, "typeLabel", soap_wchar2s(soap, ((fimsdescription__detailsType*)a)->typeLabel->c_str()), 2);
	if (((fimsdescription__detailsType*)a)->typeDefinition)
		soap_set_attr(soap, "typeDefinition", soap_wchar2s(soap, ((fimsdescription__detailsType*)a)->typeDefinition->c_str()), 2);
	if (((fimsdescription__detailsType*)a)->typeLink)
		soap_set_attr(soap, "typeLink", soap_wchar2s(soap, ((fimsdescription__detailsType*)a)->typeLink->c_str()), 2);
	if (((fimsdescription__detailsType*)a)->typeLanguage)
		soap_set_attr(soap, "typeLanguage", soap_wchar2s(soap, ((fimsdescription__detailsType*)a)->typeLanguage->c_str()), 2);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_fimsdescription__detailsType), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfstd__wstring(soap, "fimsdescription:emailAddress", -1, &(a->fimsdescription__detailsType::emailAddress), ""))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "fimsdescription:webAddress", -1, &(a->fimsdescription__detailsType::webAddress), ""))
		return soap->error;
	if (soap_out_PointerTofimsdescription__addressType(soap, "fimsdescription:address", -1, &(a->fimsdescription__detailsType::address), ""))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "fimsdescription:telephoneNumber", -1, &(a->fimsdescription__detailsType::telephoneNumber), ""))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "fimsdescription:mobileTelephoneNumber", -1, &(a->fimsdescription__detailsType::mobileTelephoneNumber), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *fimsdescription__detailsType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_fimsdescription__detailsType(soap, tag, this, type);
}

SOAP_FMAC3 fimsdescription__detailsType * SOAP_FMAC4 soap_in_fimsdescription__detailsType(struct soap *soap, const char *tag, fimsdescription__detailsType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (fimsdescription__detailsType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_fimsdescription__detailsType, sizeof(fimsdescription__detailsType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_fimsdescription__detailsType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (fimsdescription__detailsType *)a->soap_in(soap, tag, type);
		}
	}
	{	const char *t = soap_attr_value(soap, "typeLabel", 0);
		if (t)
		{
			if (!(((fimsdescription__detailsType*)a)->typeLabel = (std::wstring *)soap_malloc(soap, sizeof(std::wstring))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			wchar_t *s = NULL;
			if (soap_s2wchar(soap, t, &s, 0, -1))
				return NULL;
			if (s)
			{	((fimsdescription__detailsType*)a)->typeLabel = soap_new_std__wstring(soap, -1);
				((fimsdescription__detailsType*)a)->typeLabel->assign(s);
			}
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "typeDefinition", 0);
		if (t)
		{
			if (!(((fimsdescription__detailsType*)a)->typeDefinition = (std::wstring *)soap_malloc(soap, sizeof(std::wstring))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			wchar_t *s = NULL;
			if (soap_s2wchar(soap, t, &s, 0, -1))
				return NULL;
			if (s)
			{	((fimsdescription__detailsType*)a)->typeDefinition = soap_new_std__wstring(soap, -1);
				((fimsdescription__detailsType*)a)->typeDefinition->assign(s);
			}
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "typeLink", 0);
		if (t)
		{
			if (!(((fimsdescription__detailsType*)a)->typeLink = (std::wstring *)soap_malloc(soap, sizeof(std::wstring))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			wchar_t *s = NULL;
			if (soap_s2wchar(soap, t, &s, 0, -1))
				return NULL;
			if (s)
			{	((fimsdescription__detailsType*)a)->typeLink = soap_new_std__wstring(soap, -1);
				((fimsdescription__detailsType*)a)->typeLink->assign(s);
			}
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "typeLanguage", 0);
		if (t)
		{
			if (!(((fimsdescription__detailsType*)a)->typeLanguage = (std::wstring *)soap_malloc(soap, sizeof(std::wstring))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			wchar_t *s = NULL;
			if (soap_s2wchar(soap, t, &s, 0, -1))
				return NULL;
			if (s)
			{	((fimsdescription__detailsType*)a)->typeLanguage = soap_new_std__wstring(soap, -1);
				((fimsdescription__detailsType*)a)->typeLanguage->assign(s);
			}
		}
		else if (soap->error)
			return NULL;
	}
	size_t soap_flag_webAddress1 = 1;
	size_t soap_flag_address1 = 1;
	size_t soap_flag_telephoneNumber1 = 1;
	size_t soap_flag_mobileTelephoneNumber1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfstd__wstring(soap, "fimsdescription:emailAddress", &(a->fimsdescription__detailsType::emailAddress), "xsd:string"))
					continue;
			if (soap_flag_webAddress1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "fimsdescription:webAddress", &(a->fimsdescription__detailsType::webAddress), "xsd:string"))
				{	soap_flag_webAddress1--;
					continue;
				}
			if (soap_flag_address1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTofimsdescription__addressType(soap, "fimsdescription:address", &(a->fimsdescription__detailsType::address), "fimsdescription:addressType"))
				{	soap_flag_address1--;
					continue;
				}
			if (soap_flag_telephoneNumber1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "fimsdescription:telephoneNumber", &(a->fimsdescription__detailsType::telephoneNumber), "xsd:string"))
				{	soap_flag_telephoneNumber1--;
					continue;
				}
			if (soap_flag_mobileTelephoneNumber1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "fimsdescription:mobileTelephoneNumber", &(a->fimsdescription__detailsType::mobileTelephoneNumber), "xsd:string"))
				{	soap_flag_mobileTelephoneNumber1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (fimsdescription__detailsType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_fimsdescription__detailsType, 0, sizeof(fimsdescription__detailsType), 0, soap_copy_fimsdescription__detailsType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int fimsdescription__detailsType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_fimsdescription__detailsType);
	if (this->soap_out(soap, tag?tag:"fimsdescription:detailsType", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *fimsdescription__detailsType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_fimsdescription__detailsType(soap, this, tag, type);
}

SOAP_FMAC3 fimsdescription__detailsType * SOAP_FMAC4 soap_get_fimsdescription__detailsType(struct soap *soap, fimsdescription__detailsType *p, const char *tag, const char *type)
{
	if ((p = soap_in_fimsdescription__detailsType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 fimsdescription__detailsType * SOAP_FMAC2 soap_instantiate_fimsdescription__detailsType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_fimsdescription__detailsType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_fimsdescription__detailsType, n, EDLProvider_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(fimsdescription__detailsType);
		if (size)
			*size = sizeof(fimsdescription__detailsType);
		((fimsdescription__detailsType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(fimsdescription__detailsType, n);
		if (size)
			*size = n * sizeof(fimsdescription__detailsType);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((fimsdescription__detailsType*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (fimsdescription__detailsType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_fimsdescription__detailsType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying fimsdescription__detailsType %p -> %p\n", q, p));
	*(fimsdescription__detailsType*)p = *(fimsdescription__detailsType*)q;
}

void fimsdescription__organisationDetailsType::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTofimsdescription__textElementType(soap, &this->fimsdescription__organisationDetailsType::organisationName);
	soap_default_std__vectorTemplateOfxsd__anyURI(soap, &this->fimsdescription__organisationDetailsType::organisationCode);
	this->fimsdescription__organisationDetailsType::organisationDepartment = NULL;
	soap_default_std__vectorTemplateOfPointerTofimsdescription__detailsType(soap, &this->fimsdescription__organisationDetailsType::details);
	soap_default_std__vectorTemplateOfPointerTofimsdescription__entityType(soap, &this->fimsdescription__organisationDetailsType::contacts);
	this->fimsdescription__organisationDetailsType::organisationId = NULL;
	this->fimsdescription__organisationDetailsType::typeLabel = NULL;
	this->fimsdescription__organisationDetailsType::typeDefinition = NULL;
	this->fimsdescription__organisationDetailsType::typeLink = NULL;
	this->fimsdescription__organisationDetailsType::typeLanguage = NULL;
	/* transient soap skipped */
}

void fimsdescription__organisationDetailsType::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfPointerTofimsdescription__textElementType(soap, &this->fimsdescription__organisationDetailsType::organisationName);
	soap_serialize_std__vectorTemplateOfxsd__anyURI(soap, &this->fimsdescription__organisationDetailsType::organisationCode);
	soap_serialize_PointerTo_fimsdescription__organisationDetailsType_organisationDepartment(soap, &this->fimsdescription__organisationDetailsType::organisationDepartment);
	soap_serialize_std__vectorTemplateOfPointerTofimsdescription__detailsType(soap, &this->fimsdescription__organisationDetailsType::details);
	soap_serialize_std__vectorTemplateOfPointerTofimsdescription__entityType(soap, &this->fimsdescription__organisationDetailsType::contacts);
	/* transient soap skipped */
#endif
}

int fimsdescription__organisationDetailsType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_fimsdescription__organisationDetailsType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_fimsdescription__organisationDetailsType(struct soap *soap, const char *tag, int id, const fimsdescription__organisationDetailsType *a, const char *type)
{
	if (((fimsdescription__organisationDetailsType*)a)->organisationId)
		soap_set_attr(soap, "organisationId", soap_wchar2s(soap, ((fimsdescription__organisationDetailsType*)a)->organisationId->c_str()), 2);
	if (((fimsdescription__organisationDetailsType*)a)->typeLabel)
		soap_set_attr(soap, "typeLabel", soap_wchar2s(soap, ((fimsdescription__organisationDetailsType*)a)->typeLabel->c_str()), 2);
	if (((fimsdescription__organisationDetailsType*)a)->typeDefinition)
		soap_set_attr(soap, "typeDefinition", soap_wchar2s(soap, ((fimsdescription__organisationDetailsType*)a)->typeDefinition->c_str()), 2);
	if (((fimsdescription__organisationDetailsType*)a)->typeLink)
		soap_set_attr(soap, "typeLink", soap_wchar2s(soap, ((fimsdescription__organisationDetailsType*)a)->typeLink->c_str()), 2);
	if (((fimsdescription__organisationDetailsType*)a)->typeLanguage)
		soap_set_attr(soap, "typeLanguage", soap_wchar2s(soap, ((fimsdescription__organisationDetailsType*)a)->typeLanguage->c_str()), 2);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_fimsdescription__organisationDetailsType), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTofimsdescription__textElementType(soap, "fimsdescription:organisationName", -1, &(a->fimsdescription__organisationDetailsType::organisationName), ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfxsd__anyURI(soap, "fimsdescription:organisationCode", -1, &(a->fimsdescription__organisationDetailsType::organisationCode), ""))
		return soap->error;
	if (soap_out_PointerTo_fimsdescription__organisationDetailsType_organisationDepartment(soap, "fimsdescription:organisationDepartment", -1, &(a->fimsdescription__organisationDetailsType::organisationDepartment), ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTofimsdescription__detailsType(soap, "fimsdescription:details", -1, &(a->fimsdescription__organisationDetailsType::details), ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTofimsdescription__entityType(soap, "fimsdescription:contacts", -1, &(a->fimsdescription__organisationDetailsType::contacts), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *fimsdescription__organisationDetailsType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_fimsdescription__organisationDetailsType(soap, tag, this, type);
}

SOAP_FMAC3 fimsdescription__organisationDetailsType * SOAP_FMAC4 soap_in_fimsdescription__organisationDetailsType(struct soap *soap, const char *tag, fimsdescription__organisationDetailsType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (fimsdescription__organisationDetailsType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_fimsdescription__organisationDetailsType, sizeof(fimsdescription__organisationDetailsType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_fimsdescription__organisationDetailsType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (fimsdescription__organisationDetailsType *)a->soap_in(soap, tag, type);
		}
	}
	{	const char *t = soap_attr_value(soap, "organisationId", 0);
		if (t)
		{
			if (!(((fimsdescription__organisationDetailsType*)a)->organisationId = (std::wstring *)soap_malloc(soap, sizeof(std::wstring))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			wchar_t *s = NULL;
			if (soap_s2wchar(soap, t, &s, 0, -1))
				return NULL;
			if (s)
			{	((fimsdescription__organisationDetailsType*)a)->organisationId = soap_new_std__wstring(soap, -1);
				((fimsdescription__organisationDetailsType*)a)->organisationId->assign(s);
			}
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "typeLabel", 0);
		if (t)
		{
			if (!(((fimsdescription__organisationDetailsType*)a)->typeLabel = (std::wstring *)soap_malloc(soap, sizeof(std::wstring))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			wchar_t *s = NULL;
			if (soap_s2wchar(soap, t, &s, 0, -1))
				return NULL;
			if (s)
			{	((fimsdescription__organisationDetailsType*)a)->typeLabel = soap_new_std__wstring(soap, -1);
				((fimsdescription__organisationDetailsType*)a)->typeLabel->assign(s);
			}
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "typeDefinition", 0);
		if (t)
		{
			if (!(((fimsdescription__organisationDetailsType*)a)->typeDefinition = (std::wstring *)soap_malloc(soap, sizeof(std::wstring))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			wchar_t *s = NULL;
			if (soap_s2wchar(soap, t, &s, 0, -1))
				return NULL;
			if (s)
			{	((fimsdescription__organisationDetailsType*)a)->typeDefinition = soap_new_std__wstring(soap, -1);
				((fimsdescription__organisationDetailsType*)a)->typeDefinition->assign(s);
			}
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "typeLink", 0);
		if (t)
		{
			if (!(((fimsdescription__organisationDetailsType*)a)->typeLink = (std::wstring *)soap_malloc(soap, sizeof(std::wstring))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			wchar_t *s = NULL;
			if (soap_s2wchar(soap, t, &s, 0, -1))
				return NULL;
			if (s)
			{	((fimsdescription__organisationDetailsType*)a)->typeLink = soap_new_std__wstring(soap, -1);
				((fimsdescription__organisationDetailsType*)a)->typeLink->assign(s);
			}
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "typeLanguage", 0);
		if (t)
		{
			if (!(((fimsdescription__organisationDetailsType*)a)->typeLanguage = (std::wstring *)soap_malloc(soap, sizeof(std::wstring))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			wchar_t *s = NULL;
			if (soap_s2wchar(soap, t, &s, 0, -1))
				return NULL;
			if (s)
			{	((fimsdescription__organisationDetailsType*)a)->typeLanguage = soap_new_std__wstring(soap, -1);
				((fimsdescription__organisationDetailsType*)a)->typeLanguage->assign(s);
			}
		}
		else if (soap->error)
			return NULL;
	}
	size_t soap_flag_organisationDepartment1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTofimsdescription__textElementType(soap, "fimsdescription:organisationName", &(a->fimsdescription__organisationDetailsType::organisationName), "fimsdescription:textElementType"))
					continue;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfxsd__anyURI(soap, "fimsdescription:organisationCode", &(a->fimsdescription__organisationDetailsType::organisationCode), "xsd:anyURI"))
					continue;
			if (soap_flag_organisationDepartment1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_fimsdescription__organisationDetailsType_organisationDepartment(soap, "fimsdescription:organisationDepartment", &(a->fimsdescription__organisationDetailsType::organisationDepartment), ""))
				{	soap_flag_organisationDepartment1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTofimsdescription__detailsType(soap, "fimsdescription:details", &(a->fimsdescription__organisationDetailsType::details), "fimsdescription:detailsType"))
					continue;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTofimsdescription__entityType(soap, "fimsdescription:contacts", &(a->fimsdescription__organisationDetailsType::contacts), "fimsdescription:entityType"))
					continue;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (fimsdescription__organisationDetailsType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_fimsdescription__organisationDetailsType, 0, sizeof(fimsdescription__organisationDetailsType), 0, soap_copy_fimsdescription__organisationDetailsType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int fimsdescription__organisationDetailsType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_fimsdescription__organisationDetailsType);
	if (this->soap_out(soap, tag?tag:"fimsdescription:organisationDetailsType", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *fimsdescription__organisationDetailsType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_fimsdescription__organisationDetailsType(soap, this, tag, type);
}

SOAP_FMAC3 fimsdescription__organisationDetailsType * SOAP_FMAC4 soap_get_fimsdescription__organisationDetailsType(struct soap *soap, fimsdescription__organisationDetailsType *p, const char *tag, const char *type)
{
	if ((p = soap_in_fimsdescription__organisationDetailsType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 fimsdescription__organisationDetailsType * SOAP_FMAC2 soap_instantiate_fimsdescription__organisationDetailsType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_fimsdescription__organisationDetailsType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_fimsdescription__organisationDetailsType, n, EDLProvider_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(fimsdescription__organisationDetailsType);
		if (size)
			*size = sizeof(fimsdescription__organisationDetailsType);
		((fimsdescription__organisationDetailsType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(fimsdescription__organisationDetailsType, n);
		if (size)
			*size = n * sizeof(fimsdescription__organisationDetailsType);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((fimsdescription__organisationDetailsType*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (fimsdescription__organisationDetailsType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_fimsdescription__organisationDetailsType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying fimsdescription__organisationDetailsType %p -> %p\n", q, p));
	*(fimsdescription__organisationDetailsType*)p = *(fimsdescription__organisationDetailsType*)q;
}

void fimsdescription__contactDetailsType::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->fimsdescription__contactDetailsType::name = NULL;
	this->fimsdescription__contactDetailsType::givenName = NULL;
	this->fimsdescription__contactDetailsType::familyName = NULL;
	soap_default_std__vectorTemplateOfstd__wstring(soap, &this->fimsdescription__contactDetailsType::otherGivenName);
	this->fimsdescription__contactDetailsType::suffix = NULL;
	this->fimsdescription__contactDetailsType::salutation = NULL;
	soap_default_std__vectorTemplateOfPointerTofimsdescription__textElementType(soap, &this->fimsdescription__contactDetailsType::username);
	this->fimsdescription__contactDetailsType::occupation = NULL;
	soap_default_std__vectorTemplateOfPointerTofimsdescription__detailsType(soap, &this->fimsdescription__contactDetailsType::details);
	soap_default_std__vectorTemplateOfPointerTofimsdescription__textElementType(soap, &this->fimsdescription__contactDetailsType::stageName);
	soap_default_std__vectorTemplateOfPointerTofimsdescription__entityType(soap, &this->fimsdescription__contactDetailsType::relatedContacts);
	this->fimsdescription__contactDetailsType::contactId = NULL;
	this->fimsdescription__contactDetailsType::typeLabel = NULL;
	this->fimsdescription__contactDetailsType::typeDefinition = NULL;
	this->fimsdescription__contactDetailsType::typeLink = NULL;
	this->fimsdescription__contactDetailsType::typeLanguage = NULL;
	/* transient soap skipped */
}

void fimsdescription__contactDetailsType::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__wstring(soap, &this->fimsdescription__contactDetailsType::name);
	soap_serialize_PointerTostd__wstring(soap, &this->fimsdescription__contactDetailsType::givenName);
	soap_serialize_PointerTostd__wstring(soap, &this->fimsdescription__contactDetailsType::familyName);
	soap_serialize_std__vectorTemplateOfstd__wstring(soap, &this->fimsdescription__contactDetailsType::otherGivenName);
	soap_serialize_PointerTostd__wstring(soap, &this->fimsdescription__contactDetailsType::suffix);
	soap_serialize_PointerTostd__wstring(soap, &this->fimsdescription__contactDetailsType::salutation);
	soap_serialize_std__vectorTemplateOfPointerTofimsdescription__textElementType(soap, &this->fimsdescription__contactDetailsType::username);
	soap_serialize_PointerTofimsdescription__textElementType(soap, &this->fimsdescription__contactDetailsType::occupation);
	soap_serialize_std__vectorTemplateOfPointerTofimsdescription__detailsType(soap, &this->fimsdescription__contactDetailsType::details);
	soap_serialize_std__vectorTemplateOfPointerTofimsdescription__textElementType(soap, &this->fimsdescription__contactDetailsType::stageName);
	soap_serialize_std__vectorTemplateOfPointerTofimsdescription__entityType(soap, &this->fimsdescription__contactDetailsType::relatedContacts);
	/* transient soap skipped */
#endif
}

int fimsdescription__contactDetailsType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_fimsdescription__contactDetailsType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_fimsdescription__contactDetailsType(struct soap *soap, const char *tag, int id, const fimsdescription__contactDetailsType *a, const char *type)
{
	if (((fimsdescription__contactDetailsType*)a)->contactId)
		soap_set_attr(soap, "contactId", soap_wchar2s(soap, ((fimsdescription__contactDetailsType*)a)->contactId->c_str()), 2);
	if (((fimsdescription__contactDetailsType*)a)->typeLabel)
		soap_set_attr(soap, "typeLabel", soap_wchar2s(soap, ((fimsdescription__contactDetailsType*)a)->typeLabel->c_str()), 2);
	if (((fimsdescription__contactDetailsType*)a)->typeDefinition)
		soap_set_attr(soap, "typeDefinition", soap_wchar2s(soap, ((fimsdescription__contactDetailsType*)a)->typeDefinition->c_str()), 2);
	if (((fimsdescription__contactDetailsType*)a)->typeLink)
		soap_set_attr(soap, "typeLink", soap_wchar2s(soap, ((fimsdescription__contactDetailsType*)a)->typeLink->c_str()), 2);
	if (((fimsdescription__contactDetailsType*)a)->typeLanguage)
		soap_set_attr(soap, "typeLanguage", soap_wchar2s(soap, ((fimsdescription__contactDetailsType*)a)->typeLanguage->c_str()), 2);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_fimsdescription__contactDetailsType), type))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "fimsdescription:name", -1, &(a->fimsdescription__contactDetailsType::name), ""))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "fimsdescription:givenName", -1, &(a->fimsdescription__contactDetailsType::givenName), ""))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "fimsdescription:familyName", -1, &(a->fimsdescription__contactDetailsType::familyName), ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfstd__wstring(soap, "fimsdescription:otherGivenName", -1, &(a->fimsdescription__contactDetailsType::otherGivenName), ""))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "fimsdescription:suffix", -1, &(a->fimsdescription__contactDetailsType::suffix), ""))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "fimsdescription:salutation", -1, &(a->fimsdescription__contactDetailsType::salutation), ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTofimsdescription__textElementType(soap, "fimsdescription:username", -1, &(a->fimsdescription__contactDetailsType::username), ""))
		return soap->error;
	if (soap_out_PointerTofimsdescription__textElementType(soap, "fimsdescription:occupation", -1, &(a->fimsdescription__contactDetailsType::occupation), ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTofimsdescription__detailsType(soap, "fimsdescription:details", -1, &(a->fimsdescription__contactDetailsType::details), ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTofimsdescription__textElementType(soap, "fimsdescription:stageName", -1, &(a->fimsdescription__contactDetailsType::stageName), ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTofimsdescription__entityType(soap, "fimsdescription:relatedContacts", -1, &(a->fimsdescription__contactDetailsType::relatedContacts), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *fimsdescription__contactDetailsType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_fimsdescription__contactDetailsType(soap, tag, this, type);
}

SOAP_FMAC3 fimsdescription__contactDetailsType * SOAP_FMAC4 soap_in_fimsdescription__contactDetailsType(struct soap *soap, const char *tag, fimsdescription__contactDetailsType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (fimsdescription__contactDetailsType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_fimsdescription__contactDetailsType, sizeof(fimsdescription__contactDetailsType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_fimsdescription__contactDetailsType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (fimsdescription__contactDetailsType *)a->soap_in(soap, tag, type);
		}
	}
	{	const char *t = soap_attr_value(soap, "contactId", 0);
		if (t)
		{
			if (!(((fimsdescription__contactDetailsType*)a)->contactId = (std::wstring *)soap_malloc(soap, sizeof(std::wstring))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			wchar_t *s = NULL;
			if (soap_s2wchar(soap, t, &s, 0, -1))
				return NULL;
			if (s)
			{	((fimsdescription__contactDetailsType*)a)->contactId = soap_new_std__wstring(soap, -1);
				((fimsdescription__contactDetailsType*)a)->contactId->assign(s);
			}
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "typeLabel", 0);
		if (t)
		{
			if (!(((fimsdescription__contactDetailsType*)a)->typeLabel = (std::wstring *)soap_malloc(soap, sizeof(std::wstring))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			wchar_t *s = NULL;
			if (soap_s2wchar(soap, t, &s, 0, -1))
				return NULL;
			if (s)
			{	((fimsdescription__contactDetailsType*)a)->typeLabel = soap_new_std__wstring(soap, -1);
				((fimsdescription__contactDetailsType*)a)->typeLabel->assign(s);
			}
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "typeDefinition", 0);
		if (t)
		{
			if (!(((fimsdescription__contactDetailsType*)a)->typeDefinition = (std::wstring *)soap_malloc(soap, sizeof(std::wstring))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			wchar_t *s = NULL;
			if (soap_s2wchar(soap, t, &s, 0, -1))
				return NULL;
			if (s)
			{	((fimsdescription__contactDetailsType*)a)->typeDefinition = soap_new_std__wstring(soap, -1);
				((fimsdescription__contactDetailsType*)a)->typeDefinition->assign(s);
			}
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "typeLink", 0);
		if (t)
		{
			if (!(((fimsdescription__contactDetailsType*)a)->typeLink = (std::wstring *)soap_malloc(soap, sizeof(std::wstring))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			wchar_t *s = NULL;
			if (soap_s2wchar(soap, t, &s, 0, -1))
				return NULL;
			if (s)
			{	((fimsdescription__contactDetailsType*)a)->typeLink = soap_new_std__wstring(soap, -1);
				((fimsdescription__contactDetailsType*)a)->typeLink->assign(s);
			}
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "typeLanguage", 0);
		if (t)
		{
			if (!(((fimsdescription__contactDetailsType*)a)->typeLanguage = (std::wstring *)soap_malloc(soap, sizeof(std::wstring))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			wchar_t *s = NULL;
			if (soap_s2wchar(soap, t, &s, 0, -1))
				return NULL;
			if (s)
			{	((fimsdescription__contactDetailsType*)a)->typeLanguage = soap_new_std__wstring(soap, -1);
				((fimsdescription__contactDetailsType*)a)->typeLanguage->assign(s);
			}
		}
		else if (soap->error)
			return NULL;
	}
	size_t soap_flag_name1 = 1;
	size_t soap_flag_givenName1 = 1;
	size_t soap_flag_familyName1 = 1;
	size_t soap_flag_suffix1 = 1;
	size_t soap_flag_salutation1 = 1;
	size_t soap_flag_occupation1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_name1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "fimsdescription:name", &(a->fimsdescription__contactDetailsType::name), "xsd:string"))
				{	soap_flag_name1--;
					continue;
				}
			if (soap_flag_givenName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "fimsdescription:givenName", &(a->fimsdescription__contactDetailsType::givenName), "xsd:string"))
				{	soap_flag_givenName1--;
					continue;
				}
			if (soap_flag_familyName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "fimsdescription:familyName", &(a->fimsdescription__contactDetailsType::familyName), "xsd:string"))
				{	soap_flag_familyName1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfstd__wstring(soap, "fimsdescription:otherGivenName", &(a->fimsdescription__contactDetailsType::otherGivenName), "xsd:string"))
					continue;
			if (soap_flag_suffix1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "fimsdescription:suffix", &(a->fimsdescription__contactDetailsType::suffix), "xsd:string"))
				{	soap_flag_suffix1--;
					continue;
				}
			if (soap_flag_salutation1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "fimsdescription:salutation", &(a->fimsdescription__contactDetailsType::salutation), "xsd:string"))
				{	soap_flag_salutation1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTofimsdescription__textElementType(soap, "fimsdescription:username", &(a->fimsdescription__contactDetailsType::username), "fimsdescription:textElementType"))
					continue;
			if (soap_flag_occupation1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTofimsdescription__textElementType(soap, "fimsdescription:occupation", &(a->fimsdescription__contactDetailsType::occupation), "fimsdescription:textElementType"))
				{	soap_flag_occupation1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTofimsdescription__detailsType(soap, "fimsdescription:details", &(a->fimsdescription__contactDetailsType::details), "fimsdescription:detailsType"))
					continue;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTofimsdescription__textElementType(soap, "fimsdescription:stageName", &(a->fimsdescription__contactDetailsType::stageName), "fimsdescription:textElementType"))
					continue;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTofimsdescription__entityType(soap, "fimsdescription:relatedContacts", &(a->fimsdescription__contactDetailsType::relatedContacts), "fimsdescription:entityType"))
					continue;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (fimsdescription__contactDetailsType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_fimsdescription__contactDetailsType, 0, sizeof(fimsdescription__contactDetailsType), 0, soap_copy_fimsdescription__contactDetailsType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int fimsdescription__contactDetailsType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_fimsdescription__contactDetailsType);
	if (this->soap_out(soap, tag?tag:"fimsdescription:contactDetailsType", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *fimsdescription__contactDetailsType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_fimsdescription__contactDetailsType(soap, this, tag, type);
}

SOAP_FMAC3 fimsdescription__contactDetailsType * SOAP_FMAC4 soap_get_fimsdescription__contactDetailsType(struct soap *soap, fimsdescription__contactDetailsType *p, const char *tag, const char *type)
{
	if ((p = soap_in_fimsdescription__contactDetailsType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 fimsdescription__contactDetailsType * SOAP_FMAC2 soap_instantiate_fimsdescription__contactDetailsType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_fimsdescription__contactDetailsType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_fimsdescription__contactDetailsType, n, EDLProvider_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(fimsdescription__contactDetailsType);
		if (size)
			*size = sizeof(fimsdescription__contactDetailsType);
		((fimsdescription__contactDetailsType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(fimsdescription__contactDetailsType, n);
		if (size)
			*size = n * sizeof(fimsdescription__contactDetailsType);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((fimsdescription__contactDetailsType*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (fimsdescription__contactDetailsType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_fimsdescription__contactDetailsType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying fimsdescription__contactDetailsType %p -> %p\n", q, p));
	*(fimsdescription__contactDetailsType*)p = *(fimsdescription__contactDetailsType*)q;
}

void fimsdescription__entityType::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTofimsdescription__contactDetailsType(soap, &this->fimsdescription__entityType::contactDetails);
	soap_default_std__vectorTemplateOfPointerTofimsdescription__organisationDetailsType(soap, &this->fimsdescription__entityType::organisationDetails);
	this->fimsdescription__entityType::role = NULL;
	this->fimsdescription__entityType::entityId = NULL;
	/* transient soap skipped */
}

void fimsdescription__entityType::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfPointerTofimsdescription__contactDetailsType(soap, &this->fimsdescription__entityType::contactDetails);
	soap_serialize_std__vectorTemplateOfPointerTofimsdescription__organisationDetailsType(soap, &this->fimsdescription__entityType::organisationDetails);
	soap_serialize_PointerTostd__vectorTemplateOf_fimsdescription__entityType_role(soap, &this->fimsdescription__entityType::role);
	/* transient soap skipped */
#endif
}

int fimsdescription__entityType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_fimsdescription__entityType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_fimsdescription__entityType(struct soap *soap, const char *tag, int id, const fimsdescription__entityType *a, const char *type)
{
	if (((fimsdescription__entityType*)a)->entityId)
		soap_set_attr(soap, "entityId", soap_wchar2s(soap, ((fimsdescription__entityType*)a)->entityId->c_str()), 2);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_fimsdescription__entityType), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTofimsdescription__contactDetailsType(soap, "fimsdescription:contactDetails", -1, &(a->fimsdescription__entityType::contactDetails), ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTofimsdescription__organisationDetailsType(soap, "fimsdescription:organisationDetails", -1, &(a->fimsdescription__entityType::organisationDetails), ""))
		return soap->error;
	if (soap_out_PointerTostd__vectorTemplateOf_fimsdescription__entityType_role(soap, "fimsdescription:role", -1, &(a->fimsdescription__entityType::role), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *fimsdescription__entityType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_fimsdescription__entityType(soap, tag, this, type);
}

SOAP_FMAC3 fimsdescription__entityType * SOAP_FMAC4 soap_in_fimsdescription__entityType(struct soap *soap, const char *tag, fimsdescription__entityType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (fimsdescription__entityType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_fimsdescription__entityType, sizeof(fimsdescription__entityType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_fimsdescription__entityType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (fimsdescription__entityType *)a->soap_in(soap, tag, type);
		}
	}
	{	const char *t = soap_attr_value(soap, "entityId", 0);
		if (t)
		{
			if (!(((fimsdescription__entityType*)a)->entityId = (std::wstring *)soap_malloc(soap, sizeof(std::wstring))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			wchar_t *s = NULL;
			if (soap_s2wchar(soap, t, &s, 0, -1))
				return NULL;
			if (s)
			{	((fimsdescription__entityType*)a)->entityId = soap_new_std__wstring(soap, -1);
				((fimsdescription__entityType*)a)->entityId->assign(s);
			}
		}
		else if (soap->error)
			return NULL;
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTofimsdescription__contactDetailsType(soap, "fimsdescription:contactDetails", &(a->fimsdescription__entityType::contactDetails), "fimsdescription:contactDetailsType"))
					continue;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTofimsdescription__organisationDetailsType(soap, "fimsdescription:organisationDetails", &(a->fimsdescription__entityType::organisationDetails), "fimsdescription:organisationDetailsType"))
					continue;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTostd__vectorTemplateOf_fimsdescription__entityType_role(soap, "fimsdescription:role", &(a->fimsdescription__entityType::role), ""))
					continue;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (fimsdescription__entityType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_fimsdescription__entityType, 0, sizeof(fimsdescription__entityType), 0, soap_copy_fimsdescription__entityType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int fimsdescription__entityType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_fimsdescription__entityType);
	if (this->soap_out(soap, tag?tag:"fimsdescription:entityType", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *fimsdescription__entityType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_fimsdescription__entityType(soap, this, tag, type);
}

SOAP_FMAC3 fimsdescription__entityType * SOAP_FMAC4 soap_get_fimsdescription__entityType(struct soap *soap, fimsdescription__entityType *p, const char *tag, const char *type)
{
	if ((p = soap_in_fimsdescription__entityType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 fimsdescription__entityType * SOAP_FMAC2 soap_instantiate_fimsdescription__entityType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_fimsdescription__entityType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_fimsdescription__entityType, n, EDLProvider_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(fimsdescription__entityType);
		if (size)
			*size = sizeof(fimsdescription__entityType);
		((fimsdescription__entityType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(fimsdescription__entityType, n);
		if (size)
			*size = n * sizeof(fimsdescription__entityType);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((fimsdescription__entityType*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (fimsdescription__entityType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_fimsdescription__entityType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying fimsdescription__entityType %p -> %p\n", q, p));
	*(fimsdescription__entityType*)p = *(fimsdescription__entityType*)q;
}

void fimsdescription__dateType::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->fimsdescription__dateType::created = NULL;
	this->fimsdescription__dateType::modified = NULL;
	this->fimsdescription__dateType::issued = NULL;
	this->fimsdescription__dateType::alternative = NULL;
	/* transient soap skipped */
}

void fimsdescription__dateType::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTo_fimsdescription__dateType_created(soap, &this->fimsdescription__dateType::created);
	soap_serialize_PointerTo_fimsdescription__dateType_modified(soap, &this->fimsdescription__dateType::modified);
	soap_serialize_PointerTo_fimsdescription__dateType_issued(soap, &this->fimsdescription__dateType::issued);
	soap_serialize_PointerTo_fimsdescription__dateType_alternative(soap, &this->fimsdescription__dateType::alternative);
	/* transient soap skipped */
#endif
}

int fimsdescription__dateType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_fimsdescription__dateType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_fimsdescription__dateType(struct soap *soap, const char *tag, int id, const fimsdescription__dateType *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_fimsdescription__dateType), type))
		return soap->error;
	if (soap_out_PointerTo_fimsdescription__dateType_created(soap, "fimsdescription:created", -1, &(a->fimsdescription__dateType::created), ""))
		return soap->error;
	if (soap_out_PointerTo_fimsdescription__dateType_modified(soap, "fimsdescription:modified", -1, &(a->fimsdescription__dateType::modified), ""))
		return soap->error;
	if (soap_out_PointerTo_fimsdescription__dateType_issued(soap, "fimsdescription:issued", -1, &(a->fimsdescription__dateType::issued), ""))
		return soap->error;
	if (soap_out_PointerTo_fimsdescription__dateType_alternative(soap, "fimsdescription:alternative", -1, &(a->fimsdescription__dateType::alternative), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *fimsdescription__dateType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_fimsdescription__dateType(soap, tag, this, type);
}

SOAP_FMAC3 fimsdescription__dateType * SOAP_FMAC4 soap_in_fimsdescription__dateType(struct soap *soap, const char *tag, fimsdescription__dateType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (fimsdescription__dateType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_fimsdescription__dateType, sizeof(fimsdescription__dateType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_fimsdescription__dateType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (fimsdescription__dateType *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_created1 = 1;
	size_t soap_flag_modified1 = 1;
	size_t soap_flag_issued1 = 1;
	size_t soap_flag_alternative1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_created1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_fimsdescription__dateType_created(soap, "fimsdescription:created", &(a->fimsdescription__dateType::created), ""))
				{	soap_flag_created1--;
					continue;
				}
			if (soap_flag_modified1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_fimsdescription__dateType_modified(soap, "fimsdescription:modified", &(a->fimsdescription__dateType::modified), ""))
				{	soap_flag_modified1--;
					continue;
				}
			if (soap_flag_issued1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_fimsdescription__dateType_issued(soap, "fimsdescription:issued", &(a->fimsdescription__dateType::issued), ""))
				{	soap_flag_issued1--;
					continue;
				}
			if (soap_flag_alternative1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_fimsdescription__dateType_alternative(soap, "fimsdescription:alternative", &(a->fimsdescription__dateType::alternative), ""))
				{	soap_flag_alternative1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (fimsdescription__dateType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_fimsdescription__dateType, 0, sizeof(fimsdescription__dateType), 0, soap_copy_fimsdescription__dateType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int fimsdescription__dateType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_fimsdescription__dateType);
	if (this->soap_out(soap, tag?tag:"fimsdescription:dateType", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *fimsdescription__dateType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_fimsdescription__dateType(soap, this, tag, type);
}

SOAP_FMAC3 fimsdescription__dateType * SOAP_FMAC4 soap_get_fimsdescription__dateType(struct soap *soap, fimsdescription__dateType *p, const char *tag, const char *type)
{
	if ((p = soap_in_fimsdescription__dateType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 fimsdescription__dateType * SOAP_FMAC2 soap_instantiate_fimsdescription__dateType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_fimsdescription__dateType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_fimsdescription__dateType, n, EDLProvider_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(fimsdescription__dateType);
		if (size)
			*size = sizeof(fimsdescription__dateType);
		((fimsdescription__dateType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(fimsdescription__dateType, n);
		if (size)
			*size = n * sizeof(fimsdescription__dateType);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((fimsdescription__dateType*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (fimsdescription__dateType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_fimsdescription__dateType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying fimsdescription__dateType %p -> %p\n", q, p));
	*(fimsdescription__dateType*)p = *(fimsdescription__dateType*)q;
}

void fimsdescription__textElementType::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__wstring(soap, &this->fimsdescription__textElementType::__item);
	this->fimsdescription__textElementType::xml__lang = NULL;
	/* transient soap skipped */
}

void fimsdescription__textElementType::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &this->fimsdescription__textElementType::__item, SOAP_TYPE_std__wstring);
	soap_serialize_std__wstring(soap, &this->fimsdescription__textElementType::__item);
	/* transient soap skipped */
#endif
}

int fimsdescription__textElementType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_fimsdescription__textElementType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_fimsdescription__textElementType(struct soap *soap, const char *tag, int id, const fimsdescription__textElementType *a, const char *type)
{
	if (((fimsdescription__textElementType*)a)->xml__lang)
		soap_set_attr(soap, "xml:lang", soap_wchar2s(soap, ((fimsdescription__textElementType*)a)->xml__lang->c_str()), 2);
	return soap_out_std__wstring(soap, tag, id, &a->fimsdescription__textElementType::__item, "");
}

void *fimsdescription__textElementType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_fimsdescription__textElementType(soap, tag, this, type);
}

SOAP_FMAC3 fimsdescription__textElementType * SOAP_FMAC4 soap_in_fimsdescription__textElementType(struct soap *soap, const char *tag, fimsdescription__textElementType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (fimsdescription__textElementType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_fimsdescription__textElementType, sizeof(fimsdescription__textElementType), soap->type, soap->arrayType)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_fimsdescription__textElementType)
			return (fimsdescription__textElementType *)a->soap_in(soap, tag, type);
	}
	{	const char *t = soap_attr_value(soap, "xml:lang", 0);
		if (t)
		{
			if (!(((fimsdescription__textElementType*)a)->xml__lang = (std::wstring *)soap_malloc(soap, sizeof(std::wstring))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			wchar_t *s = NULL;
			if (soap_s2wchar(soap, t, &s, 0, -1))
				return NULL;
			if (s)
			{	((fimsdescription__textElementType*)a)->xml__lang = soap_new_std__wstring(soap, -1);
				((fimsdescription__textElementType*)a)->xml__lang->assign(s);
			}
		}
		else if (soap->error)
			return NULL;
	}
	if (!soap_in_std__wstring(soap, tag, &(a->fimsdescription__textElementType::__item), "fimsdescription:textElementType"))
		return NULL;
	return a;
}

int fimsdescription__textElementType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_fimsdescription__textElementType);
	if (this->soap_out(soap, tag?tag:"fimsdescription:textElementType", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *fimsdescription__textElementType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_fimsdescription__textElementType(soap, this, tag, type);
}

SOAP_FMAC3 fimsdescription__textElementType * SOAP_FMAC4 soap_get_fimsdescription__textElementType(struct soap *soap, fimsdescription__textElementType *p, const char *tag, const char *type)
{
	if ((p = soap_in_fimsdescription__textElementType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 fimsdescription__textElementType * SOAP_FMAC2 soap_instantiate_fimsdescription__textElementType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_fimsdescription__textElementType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_fimsdescription__textElementType, n, EDLProvider_fdelete);
	if (!cp)
		return NULL;
	if (type && !soap_match_tag(soap, type, "fimsdescription:titleType"))
	{	cp->type = SOAP_TYPE_fimsdescription__titleType;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(fimsdescription__titleType);
			if (size)
				*size = sizeof(fimsdescription__titleType);
			((fimsdescription__titleType*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW_ARRAY(fimsdescription__titleType, n);
			if (size)
				*size = n * sizeof(fimsdescription__titleType);
			if (cp->ptr)
				for (int i = 0; i < n; i++)
					((fimsdescription__titleType*)cp->ptr)[i].soap = soap;
		}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		if (!cp->ptr)
			soap->error = SOAP_EOM;
		return (fimsdescription__titleType*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "fimsdescription:subjectType"))
	{	cp->type = SOAP_TYPE_fimsdescription__subjectType;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(fimsdescription__subjectType);
			if (size)
				*size = sizeof(fimsdescription__subjectType);
			((fimsdescription__subjectType*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW_ARRAY(fimsdescription__subjectType, n);
			if (size)
				*size = n * sizeof(fimsdescription__subjectType);
			if (cp->ptr)
				for (int i = 0; i < n; i++)
					((fimsdescription__subjectType*)cp->ptr)[i].soap = soap;
		}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		if (!cp->ptr)
			soap->error = SOAP_EOM;
		return (fimsdescription__subjectType*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "fimsdescription:descriptionType"))
	{	cp->type = SOAP_TYPE_fimsdescription__descriptionType;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(fimsdescription__descriptionType);
			if (size)
				*size = sizeof(fimsdescription__descriptionType);
			((fimsdescription__descriptionType*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW_ARRAY(fimsdescription__descriptionType, n);
			if (size)
				*size = n * sizeof(fimsdescription__descriptionType);
			if (cp->ptr)
				for (int i = 0; i < n; i++)
					((fimsdescription__descriptionType*)cp->ptr)[i].soap = soap;
		}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		if (!cp->ptr)
			soap->error = SOAP_EOM;
		return (fimsdescription__descriptionType*)cp->ptr;
	}
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(fimsdescription__textElementType);
		if (size)
			*size = sizeof(fimsdescription__textElementType);
		((fimsdescription__textElementType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(fimsdescription__textElementType, n);
		if (size)
			*size = n * sizeof(fimsdescription__textElementType);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((fimsdescription__textElementType*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (fimsdescription__textElementType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_fimsdescription__textElementType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying fimsdescription__textElementType %p -> %p\n", q, p));
	*(fimsdescription__textElementType*)p = *(fimsdescription__textElementType*)q;
}

void fimsdescription__rightsType::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTofimsdescription__textElementType(soap, &this->fimsdescription__rightsType::rightsExpression);
	this->fimsdescription__rightsType::rightsLink = NULL;
	this->fimsdescription__rightsType::rightsHolder = NULL;
	this->fimsdescription__rightsType::exploitationIssues = NULL;
	this->fimsdescription__rightsType::coverage = NULL;
	this->fimsdescription__rightsType::rightsClearanceFlag = NULL;
	soap_default_std__vectorTemplateOfPointerTofimsdescription__textElementType(soap, &this->fimsdescription__rightsType::disclaimer);
	soap_default_std__vectorTemplateOfPointerTofimsdescription__identifierType(soap, &this->fimsdescription__rightsType::rightsId);
	soap_default_std__vectorTemplateOfPointerTofimsdescription__contactDetailsType(soap, &this->fimsdescription__rightsType::contactDetails);
	this->fimsdescription__rightsType::typeLabel = NULL;
	this->fimsdescription__rightsType::typeDefinition = NULL;
	this->fimsdescription__rightsType::typeLink = NULL;
	this->fimsdescription__rightsType::typeLanguage = NULL;
	/* transient soap skipped */
}

void fimsdescription__rightsType::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfPointerTofimsdescription__textElementType(soap, &this->fimsdescription__rightsType::rightsExpression);
	soap_serialize_PointerToxsd__anyURI(soap, &this->fimsdescription__rightsType::rightsLink);
	soap_serialize_PointerTofimsdescription__entityType(soap, &this->fimsdescription__rightsType::rightsHolder);
	soap_serialize_PointerTofimsdescription__textElementType(soap, &this->fimsdescription__rightsType::exploitationIssues);
	soap_serialize_PointerTofimsdescription__coverageType(soap, &this->fimsdescription__rightsType::coverage);
	soap_serialize_PointerTobool(soap, &this->fimsdescription__rightsType::rightsClearanceFlag);
	soap_serialize_std__vectorTemplateOfPointerTofimsdescription__textElementType(soap, &this->fimsdescription__rightsType::disclaimer);
	soap_serialize_std__vectorTemplateOfPointerTofimsdescription__identifierType(soap, &this->fimsdescription__rightsType::rightsId);
	soap_serialize_std__vectorTemplateOfPointerTofimsdescription__contactDetailsType(soap, &this->fimsdescription__rightsType::contactDetails);
	/* transient soap skipped */
#endif
}

int fimsdescription__rightsType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_fimsdescription__rightsType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_fimsdescription__rightsType(struct soap *soap, const char *tag, int id, const fimsdescription__rightsType *a, const char *type)
{
	if (((fimsdescription__rightsType*)a)->typeLabel)
		soap_set_attr(soap, "typeLabel", soap_wchar2s(soap, ((fimsdescription__rightsType*)a)->typeLabel->c_str()), 2);
	if (((fimsdescription__rightsType*)a)->typeDefinition)
		soap_set_attr(soap, "typeDefinition", soap_wchar2s(soap, ((fimsdescription__rightsType*)a)->typeDefinition->c_str()), 2);
	if (((fimsdescription__rightsType*)a)->typeLink)
		soap_set_attr(soap, "typeLink", soap_wchar2s(soap, ((fimsdescription__rightsType*)a)->typeLink->c_str()), 2);
	if (((fimsdescription__rightsType*)a)->typeLanguage)
		soap_set_attr(soap, "typeLanguage", soap_wchar2s(soap, ((fimsdescription__rightsType*)a)->typeLanguage->c_str()), 2);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_fimsdescription__rightsType), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTofimsdescription__textElementType(soap, "fimsdescription:rightsExpression", -1, &(a->fimsdescription__rightsType::rightsExpression), ""))
		return soap->error;
	if (soap_out_PointerToxsd__anyURI(soap, "fimsdescription:rightsLink", -1, &(a->fimsdescription__rightsType::rightsLink), ""))
		return soap->error;
	if (soap_out_PointerTofimsdescription__entityType(soap, "fimsdescription:rightsHolder", -1, &(a->fimsdescription__rightsType::rightsHolder), ""))
		return soap->error;
	if (soap_out_PointerTofimsdescription__textElementType(soap, "fimsdescription:exploitationIssues", -1, &(a->fimsdescription__rightsType::exploitationIssues), ""))
		return soap->error;
	if (soap_out_PointerTofimsdescription__coverageType(soap, "fimsdescription:coverage", -1, &(a->fimsdescription__rightsType::coverage), ""))
		return soap->error;
	if (soap_out_PointerTobool(soap, "fimsdescription:rightsClearanceFlag", -1, &(a->fimsdescription__rightsType::rightsClearanceFlag), ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTofimsdescription__textElementType(soap, "fimsdescription:disclaimer", -1, &(a->fimsdescription__rightsType::disclaimer), ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTofimsdescription__identifierType(soap, "fimsdescription:rightsId", -1, &(a->fimsdescription__rightsType::rightsId), ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTofimsdescription__contactDetailsType(soap, "fimsdescription:contactDetails", -1, &(a->fimsdescription__rightsType::contactDetails), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *fimsdescription__rightsType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_fimsdescription__rightsType(soap, tag, this, type);
}

SOAP_FMAC3 fimsdescription__rightsType * SOAP_FMAC4 soap_in_fimsdescription__rightsType(struct soap *soap, const char *tag, fimsdescription__rightsType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (fimsdescription__rightsType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_fimsdescription__rightsType, sizeof(fimsdescription__rightsType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_fimsdescription__rightsType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (fimsdescription__rightsType *)a->soap_in(soap, tag, type);
		}
	}
	{	const char *t = soap_attr_value(soap, "typeLabel", 0);
		if (t)
		{
			if (!(((fimsdescription__rightsType*)a)->typeLabel = (std::wstring *)soap_malloc(soap, sizeof(std::wstring))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			wchar_t *s = NULL;
			if (soap_s2wchar(soap, t, &s, 0, -1))
				return NULL;
			if (s)
			{	((fimsdescription__rightsType*)a)->typeLabel = soap_new_std__wstring(soap, -1);
				((fimsdescription__rightsType*)a)->typeLabel->assign(s);
			}
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "typeDefinition", 0);
		if (t)
		{
			if (!(((fimsdescription__rightsType*)a)->typeDefinition = (std::wstring *)soap_malloc(soap, sizeof(std::wstring))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			wchar_t *s = NULL;
			if (soap_s2wchar(soap, t, &s, 0, -1))
				return NULL;
			if (s)
			{	((fimsdescription__rightsType*)a)->typeDefinition = soap_new_std__wstring(soap, -1);
				((fimsdescription__rightsType*)a)->typeDefinition->assign(s);
			}
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "typeLink", 0);
		if (t)
		{
			if (!(((fimsdescription__rightsType*)a)->typeLink = (std::wstring *)soap_malloc(soap, sizeof(std::wstring))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			wchar_t *s = NULL;
			if (soap_s2wchar(soap, t, &s, 0, -1))
				return NULL;
			if (s)
			{	((fimsdescription__rightsType*)a)->typeLink = soap_new_std__wstring(soap, -1);
				((fimsdescription__rightsType*)a)->typeLink->assign(s);
			}
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "typeLanguage", 0);
		if (t)
		{
			if (!(((fimsdescription__rightsType*)a)->typeLanguage = (std::wstring *)soap_malloc(soap, sizeof(std::wstring))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			wchar_t *s = NULL;
			if (soap_s2wchar(soap, t, &s, 0, -1))
				return NULL;
			if (s)
			{	((fimsdescription__rightsType*)a)->typeLanguage = soap_new_std__wstring(soap, -1);
				((fimsdescription__rightsType*)a)->typeLanguage->assign(s);
			}
		}
		else if (soap->error)
			return NULL;
	}
	size_t soap_flag_rightsLink1 = 1;
	size_t soap_flag_rightsHolder1 = 1;
	size_t soap_flag_exploitationIssues1 = 1;
	size_t soap_flag_coverage1 = 1;
	size_t soap_flag_rightsClearanceFlag1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTofimsdescription__textElementType(soap, "fimsdescription:rightsExpression", &(a->fimsdescription__rightsType::rightsExpression), "fimsdescription:textElementType"))
					continue;
			if (soap_flag_rightsLink1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerToxsd__anyURI(soap, "fimsdescription:rightsLink", &(a->fimsdescription__rightsType::rightsLink), "xsd:anyURI"))
				{	soap_flag_rightsLink1--;
					continue;
				}
			if (soap_flag_rightsHolder1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTofimsdescription__entityType(soap, "fimsdescription:rightsHolder", &(a->fimsdescription__rightsType::rightsHolder), "fimsdescription:entityType"))
				{	soap_flag_rightsHolder1--;
					continue;
				}
			if (soap_flag_exploitationIssues1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTofimsdescription__textElementType(soap, "fimsdescription:exploitationIssues", &(a->fimsdescription__rightsType::exploitationIssues), "fimsdescription:textElementType"))
				{	soap_flag_exploitationIssues1--;
					continue;
				}
			if (soap_flag_coverage1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTofimsdescription__coverageType(soap, "fimsdescription:coverage", &(a->fimsdescription__rightsType::coverage), "fimsdescription:coverageType"))
				{	soap_flag_coverage1--;
					continue;
				}
			if (soap_flag_rightsClearanceFlag1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTobool(soap, "fimsdescription:rightsClearanceFlag", &(a->fimsdescription__rightsType::rightsClearanceFlag), "xsd:boolean"))
				{	soap_flag_rightsClearanceFlag1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTofimsdescription__textElementType(soap, "fimsdescription:disclaimer", &(a->fimsdescription__rightsType::disclaimer), "fimsdescription:textElementType"))
					continue;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTofimsdescription__identifierType(soap, "fimsdescription:rightsId", &(a->fimsdescription__rightsType::rightsId), "fimsdescription:identifierType"))
					continue;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTofimsdescription__contactDetailsType(soap, "fimsdescription:contactDetails", &(a->fimsdescription__rightsType::contactDetails), "fimsdescription:contactDetailsType"))
					continue;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (fimsdescription__rightsType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_fimsdescription__rightsType, 0, sizeof(fimsdescription__rightsType), 0, soap_copy_fimsdescription__rightsType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int fimsdescription__rightsType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_fimsdescription__rightsType);
	if (this->soap_out(soap, tag?tag:"fimsdescription:rightsType", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *fimsdescription__rightsType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_fimsdescription__rightsType(soap, this, tag, type);
}

SOAP_FMAC3 fimsdescription__rightsType * SOAP_FMAC4 soap_get_fimsdescription__rightsType(struct soap *soap, fimsdescription__rightsType *p, const char *tag, const char *type)
{
	if ((p = soap_in_fimsdescription__rightsType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 fimsdescription__rightsType * SOAP_FMAC2 soap_instantiate_fimsdescription__rightsType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_fimsdescription__rightsType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_fimsdescription__rightsType, n, EDLProvider_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(fimsdescription__rightsType);
		if (size)
			*size = sizeof(fimsdescription__rightsType);
		((fimsdescription__rightsType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(fimsdescription__rightsType, n);
		if (size)
			*size = n * sizeof(fimsdescription__rightsType);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((fimsdescription__rightsType*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (fimsdescription__rightsType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_fimsdescription__rightsType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying fimsdescription__rightsType %p -> %p\n", q, p));
	*(fimsdescription__rightsType*)p = *(fimsdescription__rightsType*)q;
}

void fimsdescription__coverageType::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->fimsdescription__coverageType::temporal = NULL;
	this->fimsdescription__coverageType::spatial = NULL;
	/* transient soap skipped */
}

void fimsdescription__coverageType::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTo_fimsdescription__coverageType_temporal(soap, &this->fimsdescription__coverageType::temporal);
	soap_serialize_PointerTo_fimsdescription__coverageType_spatial(soap, &this->fimsdescription__coverageType::spatial);
	/* transient soap skipped */
#endif
}

int fimsdescription__coverageType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_fimsdescription__coverageType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_fimsdescription__coverageType(struct soap *soap, const char *tag, int id, const fimsdescription__coverageType *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_fimsdescription__coverageType), type))
		return soap->error;
	if (soap_out_PointerTo_fimsdescription__coverageType_temporal(soap, "fimsdescription:temporal", -1, &(a->fimsdescription__coverageType::temporal), ""))
		return soap->error;
	if (soap_out_PointerTo_fimsdescription__coverageType_spatial(soap, "fimsdescription:spatial", -1, &(a->fimsdescription__coverageType::spatial), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *fimsdescription__coverageType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_fimsdescription__coverageType(soap, tag, this, type);
}

SOAP_FMAC3 fimsdescription__coverageType * SOAP_FMAC4 soap_in_fimsdescription__coverageType(struct soap *soap, const char *tag, fimsdescription__coverageType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (fimsdescription__coverageType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_fimsdescription__coverageType, sizeof(fimsdescription__coverageType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_fimsdescription__coverageType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (fimsdescription__coverageType *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_temporal1 = 1;
	size_t soap_flag_spatial1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_temporal1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_fimsdescription__coverageType_temporal(soap, "fimsdescription:temporal", &(a->fimsdescription__coverageType::temporal), ""))
				{	soap_flag_temporal1--;
					continue;
				}
			if (soap_flag_spatial1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_fimsdescription__coverageType_spatial(soap, "fimsdescription:spatial", &(a->fimsdescription__coverageType::spatial), ""))
				{	soap_flag_spatial1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (fimsdescription__coverageType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_fimsdescription__coverageType, 0, sizeof(fimsdescription__coverageType), 0, soap_copy_fimsdescription__coverageType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int fimsdescription__coverageType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_fimsdescription__coverageType);
	if (this->soap_out(soap, tag?tag:"fimsdescription:coverageType", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *fimsdescription__coverageType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_fimsdescription__coverageType(soap, this, tag, type);
}

SOAP_FMAC3 fimsdescription__coverageType * SOAP_FMAC4 soap_get_fimsdescription__coverageType(struct soap *soap, fimsdescription__coverageType *p, const char *tag, const char *type)
{
	if ((p = soap_in_fimsdescription__coverageType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 fimsdescription__coverageType * SOAP_FMAC2 soap_instantiate_fimsdescription__coverageType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_fimsdescription__coverageType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_fimsdescription__coverageType, n, EDLProvider_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(fimsdescription__coverageType);
		if (size)
			*size = sizeof(fimsdescription__coverageType);
		((fimsdescription__coverageType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(fimsdescription__coverageType, n);
		if (size)
			*size = n * sizeof(fimsdescription__coverageType);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((fimsdescription__coverageType*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (fimsdescription__coverageType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_fimsdescription__coverageType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying fimsdescription__coverageType %p -> %p\n", q, p));
	*(fimsdescription__coverageType*)p = *(fimsdescription__coverageType*)q;
}

void fimsdescription__descriptionType::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->fimsdescription__textElementType::soap_default(soap);
	this->fimsdescription__descriptionType::typeLabel = NULL;
	this->fimsdescription__descriptionType::typeDefinition = NULL;
	this->fimsdescription__descriptionType::typeLink = NULL;
	this->fimsdescription__descriptionType::typeLanguage = NULL;
}

void fimsdescription__descriptionType::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	this->fimsdescription__textElementType::soap_serialize(soap);
#endif
}

int fimsdescription__descriptionType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_fimsdescription__descriptionType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_fimsdescription__descriptionType(struct soap *soap, const char *tag, int id, const fimsdescription__descriptionType *a, const char *type)
{
	if (((fimsdescription__descriptionType*)a)->typeLabel)
		soap_set_attr(soap, "typeLabel", soap_wchar2s(soap, ((fimsdescription__descriptionType*)a)->typeLabel->c_str()), 2);
	if (((fimsdescription__descriptionType*)a)->typeDefinition)
		soap_set_attr(soap, "typeDefinition", soap_wchar2s(soap, ((fimsdescription__descriptionType*)a)->typeDefinition->c_str()), 2);
	if (((fimsdescription__descriptionType*)a)->typeLink)
		soap_set_attr(soap, "typeLink", soap_wchar2s(soap, ((fimsdescription__descriptionType*)a)->typeLink->c_str()), 2);
	if (((fimsdescription__descriptionType*)a)->typeLanguage)
		soap_set_attr(soap, "typeLanguage", soap_wchar2s(soap, ((fimsdescription__descriptionType*)a)->typeLanguage->c_str()), 2);
	if (((fimsdescription__textElementType*)a)->xml__lang)
		soap_set_attr(soap, "xml:lang", soap_wchar2s(soap, ((fimsdescription__textElementType*)a)->xml__lang->c_str()), 2);
	return soap_out_std__wstring(soap, tag, id, &(a->fimsdescription__textElementType::__item), "fimsdescription:descriptionType");
}

void *fimsdescription__descriptionType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_fimsdescription__descriptionType(soap, tag, this, type);
}

SOAP_FMAC3 fimsdescription__descriptionType * SOAP_FMAC4 soap_in_fimsdescription__descriptionType(struct soap *soap, const char *tag, fimsdescription__descriptionType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (fimsdescription__descriptionType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_fimsdescription__descriptionType, sizeof(fimsdescription__descriptionType), soap->type, soap->arrayType)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_fimsdescription__descriptionType)
			return (fimsdescription__descriptionType *)a->soap_in(soap, tag, type);
	}
	{	const char *t = soap_attr_value(soap, "typeLabel", 0);
		if (t)
		{
			if (!(((fimsdescription__descriptionType*)a)->typeLabel = (std::wstring *)soap_malloc(soap, sizeof(std::wstring))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			wchar_t *s = NULL;
			if (soap_s2wchar(soap, t, &s, 0, -1))
				return NULL;
			if (s)
			{	((fimsdescription__descriptionType*)a)->typeLabel = soap_new_std__wstring(soap, -1);
				((fimsdescription__descriptionType*)a)->typeLabel->assign(s);
			}
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "typeDefinition", 0);
		if (t)
		{
			if (!(((fimsdescription__descriptionType*)a)->typeDefinition = (std::wstring *)soap_malloc(soap, sizeof(std::wstring))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			wchar_t *s = NULL;
			if (soap_s2wchar(soap, t, &s, 0, -1))
				return NULL;
			if (s)
			{	((fimsdescription__descriptionType*)a)->typeDefinition = soap_new_std__wstring(soap, -1);
				((fimsdescription__descriptionType*)a)->typeDefinition->assign(s);
			}
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "typeLink", 0);
		if (t)
		{
			if (!(((fimsdescription__descriptionType*)a)->typeLink = (std::wstring *)soap_malloc(soap, sizeof(std::wstring))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			wchar_t *s = NULL;
			if (soap_s2wchar(soap, t, &s, 0, -1))
				return NULL;
			if (s)
			{	((fimsdescription__descriptionType*)a)->typeLink = soap_new_std__wstring(soap, -1);
				((fimsdescription__descriptionType*)a)->typeLink->assign(s);
			}
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "typeLanguage", 0);
		if (t)
		{
			if (!(((fimsdescription__descriptionType*)a)->typeLanguage = (std::wstring *)soap_malloc(soap, sizeof(std::wstring))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			wchar_t *s = NULL;
			if (soap_s2wchar(soap, t, &s, 0, -1))
				return NULL;
			if (s)
			{	((fimsdescription__descriptionType*)a)->typeLanguage = soap_new_std__wstring(soap, -1);
				((fimsdescription__descriptionType*)a)->typeLanguage->assign(s);
			}
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "xml:lang", 0);
		if (t)
		{
			if (!(((fimsdescription__textElementType*)a)->xml__lang = (std::wstring *)soap_malloc(soap, sizeof(std::wstring))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			wchar_t *s = NULL;
			if (soap_s2wchar(soap, t, &s, 0, -1))
				return NULL;
			if (s)
			{	((fimsdescription__textElementType*)a)->xml__lang = soap_new_std__wstring(soap, -1);
				((fimsdescription__textElementType*)a)->xml__lang->assign(s);
			}
		}
		else if (soap->error)
			return NULL;
	}
	if (!soap_in_std__wstring(soap, tag, &(a->fimsdescription__textElementType::__item), "fimsdescription:descriptionType"))
		return NULL;
	return a;
}

int fimsdescription__descriptionType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_fimsdescription__descriptionType);
	if (this->soap_out(soap, tag?tag:"fimsdescription:descriptionType", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *fimsdescription__descriptionType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_fimsdescription__descriptionType(soap, this, tag, type);
}

SOAP_FMAC3 fimsdescription__descriptionType * SOAP_FMAC4 soap_get_fimsdescription__descriptionType(struct soap *soap, fimsdescription__descriptionType *p, const char *tag, const char *type)
{
	if ((p = soap_in_fimsdescription__descriptionType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 fimsdescription__descriptionType * SOAP_FMAC2 soap_instantiate_fimsdescription__descriptionType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_fimsdescription__descriptionType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_fimsdescription__descriptionType, n, EDLProvider_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(fimsdescription__descriptionType);
		if (size)
			*size = sizeof(fimsdescription__descriptionType);
		((fimsdescription__descriptionType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(fimsdescription__descriptionType, n);
		if (size)
			*size = n * sizeof(fimsdescription__descriptionType);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((fimsdescription__descriptionType*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (fimsdescription__descriptionType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_fimsdescription__descriptionType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying fimsdescription__descriptionType %p -> %p\n", q, p));
	*(fimsdescription__descriptionType*)p = *(fimsdescription__descriptionType*)q;
}

void fimsdescription__typeType::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->fimsdescription__typeType::genre = NULL;
	this->fimsdescription__typeType::objectType = NULL;
	this->fimsdescription__typeType::targetAudience = NULL;
	/* transient soap skipped */
}

void fimsdescription__typeType::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__vectorTemplateOf_fimsdescription__typeType_genre(soap, &this->fimsdescription__typeType::genre);
	soap_serialize_PointerTostd__vectorTemplateOf_fimsdescription__typeType_objectType(soap, &this->fimsdescription__typeType::objectType);
	soap_serialize_PointerTostd__vectorTemplateOf_fimsdescription__typeType_targetAudience(soap, &this->fimsdescription__typeType::targetAudience);
	/* transient soap skipped */
#endif
}

int fimsdescription__typeType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_fimsdescription__typeType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_fimsdescription__typeType(struct soap *soap, const char *tag, int id, const fimsdescription__typeType *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_fimsdescription__typeType), type))
		return soap->error;
	if (soap_out_PointerTostd__vectorTemplateOf_fimsdescription__typeType_genre(soap, "fimsdescription:genre", -1, &(a->fimsdescription__typeType::genre), ""))
		return soap->error;
	if (soap_out_PointerTostd__vectorTemplateOf_fimsdescription__typeType_objectType(soap, "fimsdescription:objectType", -1, &(a->fimsdescription__typeType::objectType), ""))
		return soap->error;
	if (soap_out_PointerTostd__vectorTemplateOf_fimsdescription__typeType_targetAudience(soap, "fimsdescription:targetAudience", -1, &(a->fimsdescription__typeType::targetAudience), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *fimsdescription__typeType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_fimsdescription__typeType(soap, tag, this, type);
}

SOAP_FMAC3 fimsdescription__typeType * SOAP_FMAC4 soap_in_fimsdescription__typeType(struct soap *soap, const char *tag, fimsdescription__typeType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (fimsdescription__typeType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_fimsdescription__typeType, sizeof(fimsdescription__typeType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_fimsdescription__typeType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (fimsdescription__typeType *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTostd__vectorTemplateOf_fimsdescription__typeType_genre(soap, "fimsdescription:genre", &(a->fimsdescription__typeType::genre), ""))
					continue;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTostd__vectorTemplateOf_fimsdescription__typeType_objectType(soap, "fimsdescription:objectType", &(a->fimsdescription__typeType::objectType), ""))
					continue;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTostd__vectorTemplateOf_fimsdescription__typeType_targetAudience(soap, "fimsdescription:targetAudience", &(a->fimsdescription__typeType::targetAudience), ""))
					continue;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (fimsdescription__typeType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_fimsdescription__typeType, 0, sizeof(fimsdescription__typeType), 0, soap_copy_fimsdescription__typeType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int fimsdescription__typeType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_fimsdescription__typeType);
	if (this->soap_out(soap, tag?tag:"fimsdescription:typeType", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *fimsdescription__typeType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_fimsdescription__typeType(soap, this, tag, type);
}

SOAP_FMAC3 fimsdescription__typeType * SOAP_FMAC4 soap_get_fimsdescription__typeType(struct soap *soap, fimsdescription__typeType *p, const char *tag, const char *type)
{
	if ((p = soap_in_fimsdescription__typeType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 fimsdescription__typeType * SOAP_FMAC2 soap_instantiate_fimsdescription__typeType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_fimsdescription__typeType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_fimsdescription__typeType, n, EDLProvider_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(fimsdescription__typeType);
		if (size)
			*size = sizeof(fimsdescription__typeType);
		((fimsdescription__typeType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(fimsdescription__typeType, n);
		if (size)
			*size = n * sizeof(fimsdescription__typeType);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((fimsdescription__typeType*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (fimsdescription__typeType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_fimsdescription__typeType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying fimsdescription__typeType %p -> %p\n", q, p));
	*(fimsdescription__typeType*)p = *(fimsdescription__typeType*)q;
}

void fimsdescription__subjectType::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->fimsdescription__textElementType::soap_default(soap);
	this->fimsdescription__subjectType::typeLabel = NULL;
	this->fimsdescription__subjectType::typeDefinition = NULL;
	this->fimsdescription__subjectType::typeLink = NULL;
	this->fimsdescription__subjectType::typeLanguage = NULL;
}

void fimsdescription__subjectType::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	this->fimsdescription__textElementType::soap_serialize(soap);
#endif
}

int fimsdescription__subjectType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_fimsdescription__subjectType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_fimsdescription__subjectType(struct soap *soap, const char *tag, int id, const fimsdescription__subjectType *a, const char *type)
{
	if (((fimsdescription__subjectType*)a)->typeLabel)
		soap_set_attr(soap, "typeLabel", soap_wchar2s(soap, ((fimsdescription__subjectType*)a)->typeLabel->c_str()), 2);
	if (((fimsdescription__subjectType*)a)->typeDefinition)
		soap_set_attr(soap, "typeDefinition", soap_wchar2s(soap, ((fimsdescription__subjectType*)a)->typeDefinition->c_str()), 2);
	if (((fimsdescription__subjectType*)a)->typeLink)
		soap_set_attr(soap, "typeLink", soap_wchar2s(soap, ((fimsdescription__subjectType*)a)->typeLink->c_str()), 2);
	if (((fimsdescription__subjectType*)a)->typeLanguage)
		soap_set_attr(soap, "typeLanguage", soap_wchar2s(soap, ((fimsdescription__subjectType*)a)->typeLanguage->c_str()), 2);
	if (((fimsdescription__textElementType*)a)->xml__lang)
		soap_set_attr(soap, "xml:lang", soap_wchar2s(soap, ((fimsdescription__textElementType*)a)->xml__lang->c_str()), 2);
	return soap_out_std__wstring(soap, tag, id, &(a->fimsdescription__textElementType::__item), "fimsdescription:subjectType");
}

void *fimsdescription__subjectType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_fimsdescription__subjectType(soap, tag, this, type);
}

SOAP_FMAC3 fimsdescription__subjectType * SOAP_FMAC4 soap_in_fimsdescription__subjectType(struct soap *soap, const char *tag, fimsdescription__subjectType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (fimsdescription__subjectType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_fimsdescription__subjectType, sizeof(fimsdescription__subjectType), soap->type, soap->arrayType)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_fimsdescription__subjectType)
			return (fimsdescription__subjectType *)a->soap_in(soap, tag, type);
	}
	{	const char *t = soap_attr_value(soap, "typeLabel", 0);
		if (t)
		{
			if (!(((fimsdescription__subjectType*)a)->typeLabel = (std::wstring *)soap_malloc(soap, sizeof(std::wstring))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			wchar_t *s = NULL;
			if (soap_s2wchar(soap, t, &s, 0, -1))
				return NULL;
			if (s)
			{	((fimsdescription__subjectType*)a)->typeLabel = soap_new_std__wstring(soap, -1);
				((fimsdescription__subjectType*)a)->typeLabel->assign(s);
			}
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "typeDefinition", 0);
		if (t)
		{
			if (!(((fimsdescription__subjectType*)a)->typeDefinition = (std::wstring *)soap_malloc(soap, sizeof(std::wstring))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			wchar_t *s = NULL;
			if (soap_s2wchar(soap, t, &s, 0, -1))
				return NULL;
			if (s)
			{	((fimsdescription__subjectType*)a)->typeDefinition = soap_new_std__wstring(soap, -1);
				((fimsdescription__subjectType*)a)->typeDefinition->assign(s);
			}
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "typeLink", 0);
		if (t)
		{
			if (!(((fimsdescription__subjectType*)a)->typeLink = (std::wstring *)soap_malloc(soap, sizeof(std::wstring))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			wchar_t *s = NULL;
			if (soap_s2wchar(soap, t, &s, 0, -1))
				return NULL;
			if (s)
			{	((fimsdescription__subjectType*)a)->typeLink = soap_new_std__wstring(soap, -1);
				((fimsdescription__subjectType*)a)->typeLink->assign(s);
			}
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "typeLanguage", 0);
		if (t)
		{
			if (!(((fimsdescription__subjectType*)a)->typeLanguage = (std::wstring *)soap_malloc(soap, sizeof(std::wstring))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			wchar_t *s = NULL;
			if (soap_s2wchar(soap, t, &s, 0, -1))
				return NULL;
			if (s)
			{	((fimsdescription__subjectType*)a)->typeLanguage = soap_new_std__wstring(soap, -1);
				((fimsdescription__subjectType*)a)->typeLanguage->assign(s);
			}
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "xml:lang", 0);
		if (t)
		{
			if (!(((fimsdescription__textElementType*)a)->xml__lang = (std::wstring *)soap_malloc(soap, sizeof(std::wstring))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			wchar_t *s = NULL;
			if (soap_s2wchar(soap, t, &s, 0, -1))
				return NULL;
			if (s)
			{	((fimsdescription__textElementType*)a)->xml__lang = soap_new_std__wstring(soap, -1);
				((fimsdescription__textElementType*)a)->xml__lang->assign(s);
			}
		}
		else if (soap->error)
			return NULL;
	}
	if (!soap_in_std__wstring(soap, tag, &(a->fimsdescription__textElementType::__item), "fimsdescription:subjectType"))
		return NULL;
	return a;
}

int fimsdescription__subjectType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_fimsdescription__subjectType);
	if (this->soap_out(soap, tag?tag:"fimsdescription:subjectType", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *fimsdescription__subjectType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_fimsdescription__subjectType(soap, this, tag, type);
}

SOAP_FMAC3 fimsdescription__subjectType * SOAP_FMAC4 soap_get_fimsdescription__subjectType(struct soap *soap, fimsdescription__subjectType *p, const char *tag, const char *type)
{
	if ((p = soap_in_fimsdescription__subjectType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 fimsdescription__subjectType * SOAP_FMAC2 soap_instantiate_fimsdescription__subjectType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_fimsdescription__subjectType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_fimsdescription__subjectType, n, EDLProvider_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(fimsdescription__subjectType);
		if (size)
			*size = sizeof(fimsdescription__subjectType);
		((fimsdescription__subjectType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(fimsdescription__subjectType, n);
		if (size)
			*size = n * sizeof(fimsdescription__subjectType);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((fimsdescription__subjectType*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (fimsdescription__subjectType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_fimsdescription__subjectType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying fimsdescription__subjectType %p -> %p\n", q, p));
	*(fimsdescription__subjectType*)p = *(fimsdescription__subjectType*)q;
}

void fimsdescription__identifierType::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__wstring(soap, &this->fimsdescription__identifierType::__item);
	this->fimsdescription__identifierType::typeLabel = NULL;
	this->fimsdescription__identifierType::typeDefinition = NULL;
	this->fimsdescription__identifierType::typeLink = NULL;
	this->fimsdescription__identifierType::typeLanguage = NULL;
	this->fimsdescription__identifierType::formatLabel = NULL;
	this->fimsdescription__identifierType::formatDefinition = NULL;
	this->fimsdescription__identifierType::formatLink = NULL;
	this->fimsdescription__identifierType::formatLanguage = NULL;
	/* transient soap skipped */
}

void fimsdescription__identifierType::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &this->fimsdescription__identifierType::__item, SOAP_TYPE_std__wstring);
	soap_serialize_std__wstring(soap, &this->fimsdescription__identifierType::__item);
	/* transient soap skipped */
#endif
}

int fimsdescription__identifierType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_fimsdescription__identifierType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_fimsdescription__identifierType(struct soap *soap, const char *tag, int id, const fimsdescription__identifierType *a, const char *type)
{
	if (((fimsdescription__identifierType*)a)->typeLabel)
		soap_set_attr(soap, "typeLabel", soap_wchar2s(soap, ((fimsdescription__identifierType*)a)->typeLabel->c_str()), 2);
	if (((fimsdescription__identifierType*)a)->typeDefinition)
		soap_set_attr(soap, "typeDefinition", soap_wchar2s(soap, ((fimsdescription__identifierType*)a)->typeDefinition->c_str()), 2);
	if (((fimsdescription__identifierType*)a)->typeLink)
		soap_set_attr(soap, "typeLink", soap_wchar2s(soap, ((fimsdescription__identifierType*)a)->typeLink->c_str()), 2);
	if (((fimsdescription__identifierType*)a)->typeLanguage)
		soap_set_attr(soap, "typeLanguage", soap_wchar2s(soap, ((fimsdescription__identifierType*)a)->typeLanguage->c_str()), 2);
	if (((fimsdescription__identifierType*)a)->formatLabel)
		soap_set_attr(soap, "formatLabel", soap_wchar2s(soap, ((fimsdescription__identifierType*)a)->formatLabel->c_str()), 2);
	if (((fimsdescription__identifierType*)a)->formatDefinition)
		soap_set_attr(soap, "formatDefinition", soap_wchar2s(soap, ((fimsdescription__identifierType*)a)->formatDefinition->c_str()), 2);
	if (((fimsdescription__identifierType*)a)->formatLink)
		soap_set_attr(soap, "formatLink", soap_wchar2s(soap, ((fimsdescription__identifierType*)a)->formatLink->c_str()), 2);
	if (((fimsdescription__identifierType*)a)->formatLanguage)
		soap_set_attr(soap, "formatLanguage", soap_wchar2s(soap, ((fimsdescription__identifierType*)a)->formatLanguage->c_str()), 2);
	return soap_out_std__wstring(soap, tag, id, &a->fimsdescription__identifierType::__item, "");
}

void *fimsdescription__identifierType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_fimsdescription__identifierType(soap, tag, this, type);
}

SOAP_FMAC3 fimsdescription__identifierType * SOAP_FMAC4 soap_in_fimsdescription__identifierType(struct soap *soap, const char *tag, fimsdescription__identifierType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (fimsdescription__identifierType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_fimsdescription__identifierType, sizeof(fimsdescription__identifierType), soap->type, soap->arrayType)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_fimsdescription__identifierType)
			return (fimsdescription__identifierType *)a->soap_in(soap, tag, type);
	}
	{	const char *t = soap_attr_value(soap, "typeLabel", 0);
		if (t)
		{
			if (!(((fimsdescription__identifierType*)a)->typeLabel = (std::wstring *)soap_malloc(soap, sizeof(std::wstring))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			wchar_t *s = NULL;
			if (soap_s2wchar(soap, t, &s, 0, -1))
				return NULL;
			if (s)
			{	((fimsdescription__identifierType*)a)->typeLabel = soap_new_std__wstring(soap, -1);
				((fimsdescription__identifierType*)a)->typeLabel->assign(s);
			}
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "typeDefinition", 0);
		if (t)
		{
			if (!(((fimsdescription__identifierType*)a)->typeDefinition = (std::wstring *)soap_malloc(soap, sizeof(std::wstring))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			wchar_t *s = NULL;
			if (soap_s2wchar(soap, t, &s, 0, -1))
				return NULL;
			if (s)
			{	((fimsdescription__identifierType*)a)->typeDefinition = soap_new_std__wstring(soap, -1);
				((fimsdescription__identifierType*)a)->typeDefinition->assign(s);
			}
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "typeLink", 0);
		if (t)
		{
			if (!(((fimsdescription__identifierType*)a)->typeLink = (std::wstring *)soap_malloc(soap, sizeof(std::wstring))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			wchar_t *s = NULL;
			if (soap_s2wchar(soap, t, &s, 0, -1))
				return NULL;
			if (s)
			{	((fimsdescription__identifierType*)a)->typeLink = soap_new_std__wstring(soap, -1);
				((fimsdescription__identifierType*)a)->typeLink->assign(s);
			}
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "typeLanguage", 0);
		if (t)
		{
			if (!(((fimsdescription__identifierType*)a)->typeLanguage = (std::wstring *)soap_malloc(soap, sizeof(std::wstring))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			wchar_t *s = NULL;
			if (soap_s2wchar(soap, t, &s, 0, -1))
				return NULL;
			if (s)
			{	((fimsdescription__identifierType*)a)->typeLanguage = soap_new_std__wstring(soap, -1);
				((fimsdescription__identifierType*)a)->typeLanguage->assign(s);
			}
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "formatLabel", 0);
		if (t)
		{
			if (!(((fimsdescription__identifierType*)a)->formatLabel = (std::wstring *)soap_malloc(soap, sizeof(std::wstring))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			wchar_t *s = NULL;
			if (soap_s2wchar(soap, t, &s, 0, -1))
				return NULL;
			if (s)
			{	((fimsdescription__identifierType*)a)->formatLabel = soap_new_std__wstring(soap, -1);
				((fimsdescription__identifierType*)a)->formatLabel->assign(s);
			}
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "formatDefinition", 0);
		if (t)
		{
			if (!(((fimsdescription__identifierType*)a)->formatDefinition = (std::wstring *)soap_malloc(soap, sizeof(std::wstring))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			wchar_t *s = NULL;
			if (soap_s2wchar(soap, t, &s, 0, -1))
				return NULL;
			if (s)
			{	((fimsdescription__identifierType*)a)->formatDefinition = soap_new_std__wstring(soap, -1);
				((fimsdescription__identifierType*)a)->formatDefinition->assign(s);
			}
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "formatLink", 0);
		if (t)
		{
			if (!(((fimsdescription__identifierType*)a)->formatLink = (std::wstring *)soap_malloc(soap, sizeof(std::wstring))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			wchar_t *s = NULL;
			if (soap_s2wchar(soap, t, &s, 0, -1))
				return NULL;
			if (s)
			{	((fimsdescription__identifierType*)a)->formatLink = soap_new_std__wstring(soap, -1);
				((fimsdescription__identifierType*)a)->formatLink->assign(s);
			}
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "formatLanguage", 0);
		if (t)
		{
			if (!(((fimsdescription__identifierType*)a)->formatLanguage = (std::wstring *)soap_malloc(soap, sizeof(std::wstring))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			wchar_t *s = NULL;
			if (soap_s2wchar(soap, t, &s, 0, -1))
				return NULL;
			if (s)
			{	((fimsdescription__identifierType*)a)->formatLanguage = soap_new_std__wstring(soap, -1);
				((fimsdescription__identifierType*)a)->formatLanguage->assign(s);
			}
		}
		else if (soap->error)
			return NULL;
	}
	if (!soap_in_std__wstring(soap, tag, &(a->fimsdescription__identifierType::__item), "fimsdescription:identifierType"))
		return NULL;
	return a;
}

int fimsdescription__identifierType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_fimsdescription__identifierType);
	if (this->soap_out(soap, tag?tag:"fimsdescription:identifierType", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *fimsdescription__identifierType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_fimsdescription__identifierType(soap, this, tag, type);
}

SOAP_FMAC3 fimsdescription__identifierType * SOAP_FMAC4 soap_get_fimsdescription__identifierType(struct soap *soap, fimsdescription__identifierType *p, const char *tag, const char *type)
{
	if ((p = soap_in_fimsdescription__identifierType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 fimsdescription__identifierType * SOAP_FMAC2 soap_instantiate_fimsdescription__identifierType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_fimsdescription__identifierType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_fimsdescription__identifierType, n, EDLProvider_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(fimsdescription__identifierType);
		if (size)
			*size = sizeof(fimsdescription__identifierType);
		((fimsdescription__identifierType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(fimsdescription__identifierType, n);
		if (size)
			*size = n * sizeof(fimsdescription__identifierType);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((fimsdescription__identifierType*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (fimsdescription__identifierType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_fimsdescription__identifierType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying fimsdescription__identifierType %p -> %p\n", q, p));
	*(fimsdescription__identifierType*)p = *(fimsdescription__identifierType*)q;
}

void fimsdescription__titleType::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->fimsdescription__textElementType::soap_default(soap);
	this->fimsdescription__titleType::typeLabel = NULL;
	this->fimsdescription__titleType::typeDefinition = NULL;
	this->fimsdescription__titleType::typeLink = NULL;
	this->fimsdescription__titleType::typeLanguage = NULL;
}

void fimsdescription__titleType::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	this->fimsdescription__textElementType::soap_serialize(soap);
#endif
}

int fimsdescription__titleType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_fimsdescription__titleType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_fimsdescription__titleType(struct soap *soap, const char *tag, int id, const fimsdescription__titleType *a, const char *type)
{
	if (((fimsdescription__titleType*)a)->typeLabel)
		soap_set_attr(soap, "typeLabel", soap_wchar2s(soap, ((fimsdescription__titleType*)a)->typeLabel->c_str()), 2);
	if (((fimsdescription__titleType*)a)->typeDefinition)
		soap_set_attr(soap, "typeDefinition", soap_wchar2s(soap, ((fimsdescription__titleType*)a)->typeDefinition->c_str()), 2);
	if (((fimsdescription__titleType*)a)->typeLink)
		soap_set_attr(soap, "typeLink", soap_wchar2s(soap, ((fimsdescription__titleType*)a)->typeLink->c_str()), 2);
	if (((fimsdescription__titleType*)a)->typeLanguage)
		soap_set_attr(soap, "typeLanguage", soap_wchar2s(soap, ((fimsdescription__titleType*)a)->typeLanguage->c_str()), 2);
	if (((fimsdescription__textElementType*)a)->xml__lang)
		soap_set_attr(soap, "xml:lang", soap_wchar2s(soap, ((fimsdescription__textElementType*)a)->xml__lang->c_str()), 2);
	return soap_out_std__wstring(soap, tag, id, &(a->fimsdescription__textElementType::__item), "fimsdescription:titleType");
}

void *fimsdescription__titleType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_fimsdescription__titleType(soap, tag, this, type);
}

SOAP_FMAC3 fimsdescription__titleType * SOAP_FMAC4 soap_in_fimsdescription__titleType(struct soap *soap, const char *tag, fimsdescription__titleType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (fimsdescription__titleType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_fimsdescription__titleType, sizeof(fimsdescription__titleType), soap->type, soap->arrayType)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_fimsdescription__titleType)
			return (fimsdescription__titleType *)a->soap_in(soap, tag, type);
	}
	{	const char *t = soap_attr_value(soap, "typeLabel", 0);
		if (t)
		{
			if (!(((fimsdescription__titleType*)a)->typeLabel = (std::wstring *)soap_malloc(soap, sizeof(std::wstring))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			wchar_t *s = NULL;
			if (soap_s2wchar(soap, t, &s, 0, -1))
				return NULL;
			if (s)
			{	((fimsdescription__titleType*)a)->typeLabel = soap_new_std__wstring(soap, -1);
				((fimsdescription__titleType*)a)->typeLabel->assign(s);
			}
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "typeDefinition", 0);
		if (t)
		{
			if (!(((fimsdescription__titleType*)a)->typeDefinition = (std::wstring *)soap_malloc(soap, sizeof(std::wstring))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			wchar_t *s = NULL;
			if (soap_s2wchar(soap, t, &s, 0, -1))
				return NULL;
			if (s)
			{	((fimsdescription__titleType*)a)->typeDefinition = soap_new_std__wstring(soap, -1);
				((fimsdescription__titleType*)a)->typeDefinition->assign(s);
			}
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "typeLink", 0);
		if (t)
		{
			if (!(((fimsdescription__titleType*)a)->typeLink = (std::wstring *)soap_malloc(soap, sizeof(std::wstring))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			wchar_t *s = NULL;
			if (soap_s2wchar(soap, t, &s, 0, -1))
				return NULL;
			if (s)
			{	((fimsdescription__titleType*)a)->typeLink = soap_new_std__wstring(soap, -1);
				((fimsdescription__titleType*)a)->typeLink->assign(s);
			}
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "typeLanguage", 0);
		if (t)
		{
			if (!(((fimsdescription__titleType*)a)->typeLanguage = (std::wstring *)soap_malloc(soap, sizeof(std::wstring))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			wchar_t *s = NULL;
			if (soap_s2wchar(soap, t, &s, 0, -1))
				return NULL;
			if (s)
			{	((fimsdescription__titleType*)a)->typeLanguage = soap_new_std__wstring(soap, -1);
				((fimsdescription__titleType*)a)->typeLanguage->assign(s);
			}
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "xml:lang", 0);
		if (t)
		{
			if (!(((fimsdescription__textElementType*)a)->xml__lang = (std::wstring *)soap_malloc(soap, sizeof(std::wstring))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			wchar_t *s = NULL;
			if (soap_s2wchar(soap, t, &s, 0, -1))
				return NULL;
			if (s)
			{	((fimsdescription__textElementType*)a)->xml__lang = soap_new_std__wstring(soap, -1);
				((fimsdescription__textElementType*)a)->xml__lang->assign(s);
			}
		}
		else if (soap->error)
			return NULL;
	}
	if (!soap_in_std__wstring(soap, tag, &(a->fimsdescription__textElementType::__item), "fimsdescription:titleType"))
		return NULL;
	return a;
}

int fimsdescription__titleType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_fimsdescription__titleType);
	if (this->soap_out(soap, tag?tag:"fimsdescription:titleType", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *fimsdescription__titleType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_fimsdescription__titleType(soap, this, tag, type);
}

SOAP_FMAC3 fimsdescription__titleType * SOAP_FMAC4 soap_get_fimsdescription__titleType(struct soap *soap, fimsdescription__titleType *p, const char *tag, const char *type)
{
	if ((p = soap_in_fimsdescription__titleType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 fimsdescription__titleType * SOAP_FMAC2 soap_instantiate_fimsdescription__titleType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_fimsdescription__titleType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_fimsdescription__titleType, n, EDLProvider_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(fimsdescription__titleType);
		if (size)
			*size = sizeof(fimsdescription__titleType);
		((fimsdescription__titleType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(fimsdescription__titleType, n);
		if (size)
			*size = n * sizeof(fimsdescription__titleType);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((fimsdescription__titleType*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (fimsdescription__titleType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_fimsdescription__titleType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying fimsdescription__titleType %p -> %p\n", q, p));
	*(fimsdescription__titleType*)p = *(fimsdescription__titleType*)q;
}

void fimsdescription__bmContentDescriptionType::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTofimsdescription__textElementType(soap, &this->fimsdescription__bmContentDescriptionType::title);
	soap_default_std__vectorTemplateOfPointerTofimsdescription__titleType(soap, &this->fimsdescription__bmContentDescriptionType::alternativeTitle);
	soap_default_std__vectorTemplateOfPointerTofimsdescription__entityType(soap, &this->fimsdescription__bmContentDescriptionType::creator);
	soap_default_std__vectorTemplateOfPointerTofimsdescription__subjectType(soap, &this->fimsdescription__bmContentDescriptionType::subject);
	soap_default_std__vectorTemplateOfPointerTofimsdescription__descriptionType(soap, &this->fimsdescription__bmContentDescriptionType::description);
	soap_default_std__vectorTemplateOfPointerTofimsdescription__entityType(soap, &this->fimsdescription__bmContentDescriptionType::publisher);
	soap_default_std__vectorTemplateOfPointerTofimsdescription__entityType(soap, &this->fimsdescription__bmContentDescriptionType::contributor);
	soap_default_std__vectorTemplateOfPointerTofimsdescription__dateType(soap, &this->fimsdescription__bmContentDescriptionType::date);
	soap_default_std__vectorTemplateOfPointerTofimsdescription__typeType(soap, &this->fimsdescription__bmContentDescriptionType::type);
	soap_default_std__vectorTemplateOfPointerTofimsdescription__identifierType(soap, &this->fimsdescription__bmContentDescriptionType::identifier);
	soap_default_std__vectorTemplateOfPointerTofimsdescription__languageType(soap, &this->fimsdescription__bmContentDescriptionType::language);
	soap_default_std__vectorTemplateOfPointerTofimsdescription__relationType(soap, &this->fimsdescription__bmContentDescriptionType::relation);
	soap_default_std__vectorTemplateOfPointerTofimsdescription__relationType(soap, &this->fimsdescription__bmContentDescriptionType::isVersionOf);
	soap_default_std__vectorTemplateOfPointerTofimsdescription__relationType(soap, &this->fimsdescription__bmContentDescriptionType::hasVersion);
	soap_default_std__vectorTemplateOfPointerTofimsdescription__relationType(soap, &this->fimsdescription__bmContentDescriptionType::isReplacedBy);
	soap_default_std__vectorTemplateOfPointerTofimsdescription__relationType(soap, &this->fimsdescription__bmContentDescriptionType::replaces);
	soap_default_std__vectorTemplateOfPointerTofimsdescription__relationType(soap, &this->fimsdescription__bmContentDescriptionType::isRequiredBy);
	soap_default_std__vectorTemplateOfPointerTofimsdescription__relationType(soap, &this->fimsdescription__bmContentDescriptionType::requires);
	soap_default_std__vectorTemplateOfPointerTofimsdescription__relationType(soap, &this->fimsdescription__bmContentDescriptionType::isPartOf);
	soap_default_std__vectorTemplateOfPointerTofimsdescription__relationType(soap, &this->fimsdescription__bmContentDescriptionType::hasPart);
	soap_default_std__vectorTemplateOfPointerTofimsdescription__relationType(soap, &this->fimsdescription__bmContentDescriptionType::isReferencedBy);
	soap_default_std__vectorTemplateOfPointerTofimsdescription__relationType(soap, &this->fimsdescription__bmContentDescriptionType::references);
	soap_default_std__vectorTemplateOfPointerTofimsdescription__relationType(soap, &this->fimsdescription__bmContentDescriptionType::isFormatOf);
	soap_default_std__vectorTemplateOfPointerTofimsdescription__relationType(soap, &this->fimsdescription__bmContentDescriptionType::hasFormat);
	soap_default_std__vectorTemplateOfPointerTofimsdescription__relationType(soap, &this->fimsdescription__bmContentDescriptionType::isEpisodeOf);
	soap_default_std__vectorTemplateOfPointerTofimsdescription__relationType(soap, &this->fimsdescription__bmContentDescriptionType::isMemberOf);
	soap_default_std__vectorTemplateOfPointerTofimsdescription__relationType(soap, &this->fimsdescription__bmContentDescriptionType::hasMembers);
	soap_default_std__vectorTemplateOfPointerTofimsdescription__coverageType(soap, &this->fimsdescription__bmContentDescriptionType::coverage);
	soap_default_std__vectorTemplateOfPointerTofimsdescription__rightsType(soap, &this->fimsdescription__bmContentDescriptionType::rights);
	this->fimsdescription__bmContentDescriptionType::version = NULL;
	soap_default_std__vectorTemplateOfPointerTofimsdescription__partType(soap, &this->fimsdescription__bmContentDescriptionType::part);
	this->fimsdescription__bmContentDescriptionType::xml__lang = NULL;
	/* transient soap skipped */
}

void fimsdescription__bmContentDescriptionType::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfPointerTofimsdescription__textElementType(soap, &this->fimsdescription__bmContentDescriptionType::title);
	soap_serialize_std__vectorTemplateOfPointerTofimsdescription__titleType(soap, &this->fimsdescription__bmContentDescriptionType::alternativeTitle);
	soap_serialize_std__vectorTemplateOfPointerTofimsdescription__entityType(soap, &this->fimsdescription__bmContentDescriptionType::creator);
	soap_serialize_std__vectorTemplateOfPointerTofimsdescription__subjectType(soap, &this->fimsdescription__bmContentDescriptionType::subject);
	soap_serialize_std__vectorTemplateOfPointerTofimsdescription__descriptionType(soap, &this->fimsdescription__bmContentDescriptionType::description);
	soap_serialize_std__vectorTemplateOfPointerTofimsdescription__entityType(soap, &this->fimsdescription__bmContentDescriptionType::publisher);
	soap_serialize_std__vectorTemplateOfPointerTofimsdescription__entityType(soap, &this->fimsdescription__bmContentDescriptionType::contributor);
	soap_serialize_std__vectorTemplateOfPointerTofimsdescription__dateType(soap, &this->fimsdescription__bmContentDescriptionType::date);
	soap_serialize_std__vectorTemplateOfPointerTofimsdescription__typeType(soap, &this->fimsdescription__bmContentDescriptionType::type);
	soap_serialize_std__vectorTemplateOfPointerTofimsdescription__identifierType(soap, &this->fimsdescription__bmContentDescriptionType::identifier);
	soap_serialize_std__vectorTemplateOfPointerTofimsdescription__languageType(soap, &this->fimsdescription__bmContentDescriptionType::language);
	soap_serialize_std__vectorTemplateOfPointerTofimsdescription__relationType(soap, &this->fimsdescription__bmContentDescriptionType::relation);
	soap_serialize_std__vectorTemplateOfPointerTofimsdescription__relationType(soap, &this->fimsdescription__bmContentDescriptionType::isVersionOf);
	soap_serialize_std__vectorTemplateOfPointerTofimsdescription__relationType(soap, &this->fimsdescription__bmContentDescriptionType::hasVersion);
	soap_serialize_std__vectorTemplateOfPointerTofimsdescription__relationType(soap, &this->fimsdescription__bmContentDescriptionType::isReplacedBy);
	soap_serialize_std__vectorTemplateOfPointerTofimsdescription__relationType(soap, &this->fimsdescription__bmContentDescriptionType::replaces);
	soap_serialize_std__vectorTemplateOfPointerTofimsdescription__relationType(soap, &this->fimsdescription__bmContentDescriptionType::isRequiredBy);
	soap_serialize_std__vectorTemplateOfPointerTofimsdescription__relationType(soap, &this->fimsdescription__bmContentDescriptionType::requires);
	soap_serialize_std__vectorTemplateOfPointerTofimsdescription__relationType(soap, &this->fimsdescription__bmContentDescriptionType::isPartOf);
	soap_serialize_std__vectorTemplateOfPointerTofimsdescription__relationType(soap, &this->fimsdescription__bmContentDescriptionType::hasPart);
	soap_serialize_std__vectorTemplateOfPointerTofimsdescription__relationType(soap, &this->fimsdescription__bmContentDescriptionType::isReferencedBy);
	soap_serialize_std__vectorTemplateOfPointerTofimsdescription__relationType(soap, &this->fimsdescription__bmContentDescriptionType::references);
	soap_serialize_std__vectorTemplateOfPointerTofimsdescription__relationType(soap, &this->fimsdescription__bmContentDescriptionType::isFormatOf);
	soap_serialize_std__vectorTemplateOfPointerTofimsdescription__relationType(soap, &this->fimsdescription__bmContentDescriptionType::hasFormat);
	soap_serialize_std__vectorTemplateOfPointerTofimsdescription__relationType(soap, &this->fimsdescription__bmContentDescriptionType::isEpisodeOf);
	soap_serialize_std__vectorTemplateOfPointerTofimsdescription__relationType(soap, &this->fimsdescription__bmContentDescriptionType::isMemberOf);
	soap_serialize_std__vectorTemplateOfPointerTofimsdescription__relationType(soap, &this->fimsdescription__bmContentDescriptionType::hasMembers);
	soap_serialize_std__vectorTemplateOfPointerTofimsdescription__coverageType(soap, &this->fimsdescription__bmContentDescriptionType::coverage);
	soap_serialize_std__vectorTemplateOfPointerTofimsdescription__rightsType(soap, &this->fimsdescription__bmContentDescriptionType::rights);
	soap_serialize_PointerTostd__wstring(soap, &this->fimsdescription__bmContentDescriptionType::version);
	soap_serialize_std__vectorTemplateOfPointerTofimsdescription__partType(soap, &this->fimsdescription__bmContentDescriptionType::part);
	/* transient soap skipped */
#endif
}

int fimsdescription__bmContentDescriptionType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_fimsdescription__bmContentDescriptionType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_fimsdescription__bmContentDescriptionType(struct soap *soap, const char *tag, int id, const fimsdescription__bmContentDescriptionType *a, const char *type)
{
	if (((fimsdescription__bmContentDescriptionType*)a)->xml__lang)
		soap_set_attr(soap, "xml:lang", soap_wchar2s(soap, ((fimsdescription__bmContentDescriptionType*)a)->xml__lang->c_str()), 2);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_fimsdescription__bmContentDescriptionType), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTofimsdescription__textElementType(soap, "fimsdescription:title", -1, &(a->fimsdescription__bmContentDescriptionType::title), ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTofimsdescription__titleType(soap, "fimsdescription:alternativeTitle", -1, &(a->fimsdescription__bmContentDescriptionType::alternativeTitle), ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTofimsdescription__entityType(soap, "fimsdescription:creator", -1, &(a->fimsdescription__bmContentDescriptionType::creator), ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTofimsdescription__subjectType(soap, "fimsdescription:subject", -1, &(a->fimsdescription__bmContentDescriptionType::subject), ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTofimsdescription__descriptionType(soap, "fimsdescription:description", -1, &(a->fimsdescription__bmContentDescriptionType::description), ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTofimsdescription__entityType(soap, "fimsdescription:publisher", -1, &(a->fimsdescription__bmContentDescriptionType::publisher), ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTofimsdescription__entityType(soap, "fimsdescription:contributor", -1, &(a->fimsdescription__bmContentDescriptionType::contributor), ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTofimsdescription__dateType(soap, "fimsdescription:date", -1, &(a->fimsdescription__bmContentDescriptionType::date), ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTofimsdescription__typeType(soap, "fimsdescription:type", -1, &(a->fimsdescription__bmContentDescriptionType::type), ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTofimsdescription__identifierType(soap, "fimsdescription:identifier", -1, &(a->fimsdescription__bmContentDescriptionType::identifier), ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTofimsdescription__languageType(soap, "fimsdescription:language", -1, &(a->fimsdescription__bmContentDescriptionType::language), ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTofimsdescription__relationType(soap, "fimsdescription:relation", -1, &(a->fimsdescription__bmContentDescriptionType::relation), ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTofimsdescription__relationType(soap, "fimsdescription:isVersionOf", -1, &(a->fimsdescription__bmContentDescriptionType::isVersionOf), ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTofimsdescription__relationType(soap, "fimsdescription:hasVersion", -1, &(a->fimsdescription__bmContentDescriptionType::hasVersion), ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTofimsdescription__relationType(soap, "fimsdescription:isReplacedBy", -1, &(a->fimsdescription__bmContentDescriptionType::isReplacedBy), ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTofimsdescription__relationType(soap, "fimsdescription:replaces", -1, &(a->fimsdescription__bmContentDescriptionType::replaces), ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTofimsdescription__relationType(soap, "fimsdescription:isRequiredBy", -1, &(a->fimsdescription__bmContentDescriptionType::isRequiredBy), ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTofimsdescription__relationType(soap, "fimsdescription:requires", -1, &(a->fimsdescription__bmContentDescriptionType::requires), ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTofimsdescription__relationType(soap, "fimsdescription:isPartOf", -1, &(a->fimsdescription__bmContentDescriptionType::isPartOf), ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTofimsdescription__relationType(soap, "fimsdescription:hasPart", -1, &(a->fimsdescription__bmContentDescriptionType::hasPart), ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTofimsdescription__relationType(soap, "fimsdescription:isReferencedBy", -1, &(a->fimsdescription__bmContentDescriptionType::isReferencedBy), ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTofimsdescription__relationType(soap, "fimsdescription:references", -1, &(a->fimsdescription__bmContentDescriptionType::references), ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTofimsdescription__relationType(soap, "fimsdescription:isFormatOf", -1, &(a->fimsdescription__bmContentDescriptionType::isFormatOf), ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTofimsdescription__relationType(soap, "fimsdescription:hasFormat", -1, &(a->fimsdescription__bmContentDescriptionType::hasFormat), ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTofimsdescription__relationType(soap, "fimsdescription:isEpisodeOf", -1, &(a->fimsdescription__bmContentDescriptionType::isEpisodeOf), ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTofimsdescription__relationType(soap, "fimsdescription:isMemberOf", -1, &(a->fimsdescription__bmContentDescriptionType::isMemberOf), ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTofimsdescription__relationType(soap, "fimsdescription:hasMembers", -1, &(a->fimsdescription__bmContentDescriptionType::hasMembers), ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTofimsdescription__coverageType(soap, "fimsdescription:coverage", -1, &(a->fimsdescription__bmContentDescriptionType::coverage), ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTofimsdescription__rightsType(soap, "fimsdescription:rights", -1, &(a->fimsdescription__bmContentDescriptionType::rights), ""))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "fimsdescription:version", -1, &(a->fimsdescription__bmContentDescriptionType::version), ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTofimsdescription__partType(soap, "fimsdescription:part", -1, &(a->fimsdescription__bmContentDescriptionType::part), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *fimsdescription__bmContentDescriptionType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_fimsdescription__bmContentDescriptionType(soap, tag, this, type);
}

SOAP_FMAC3 fimsdescription__bmContentDescriptionType * SOAP_FMAC4 soap_in_fimsdescription__bmContentDescriptionType(struct soap *soap, const char *tag, fimsdescription__bmContentDescriptionType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (fimsdescription__bmContentDescriptionType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_fimsdescription__bmContentDescriptionType, sizeof(fimsdescription__bmContentDescriptionType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_fimsdescription__bmContentDescriptionType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (fimsdescription__bmContentDescriptionType *)a->soap_in(soap, tag, type);
		}
	}
	{	const char *t = soap_attr_value(soap, "xml:lang", 0);
		if (t)
		{
			if (!(((fimsdescription__bmContentDescriptionType*)a)->xml__lang = (std::wstring *)soap_malloc(soap, sizeof(std::wstring))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			wchar_t *s = NULL;
			if (soap_s2wchar(soap, t, &s, 0, -1))
				return NULL;
			if (s)
			{	((fimsdescription__bmContentDescriptionType*)a)->xml__lang = soap_new_std__wstring(soap, -1);
				((fimsdescription__bmContentDescriptionType*)a)->xml__lang->assign(s);
			}
		}
		else if (soap->error)
			return NULL;
	}
	size_t soap_flag_version1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTofimsdescription__textElementType(soap, "fimsdescription:title", &(a->fimsdescription__bmContentDescriptionType::title), "fimsdescription:textElementType"))
					continue;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTofimsdescription__titleType(soap, "fimsdescription:alternativeTitle", &(a->fimsdescription__bmContentDescriptionType::alternativeTitle), "fimsdescription:titleType"))
					continue;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTofimsdescription__entityType(soap, "fimsdescription:creator", &(a->fimsdescription__bmContentDescriptionType::creator), "fimsdescription:entityType"))
					continue;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTofimsdescription__subjectType(soap, "fimsdescription:subject", &(a->fimsdescription__bmContentDescriptionType::subject), "fimsdescription:subjectType"))
					continue;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTofimsdescription__descriptionType(soap, "fimsdescription:description", &(a->fimsdescription__bmContentDescriptionType::description), "fimsdescription:descriptionType"))
					continue;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTofimsdescription__entityType(soap, "fimsdescription:publisher", &(a->fimsdescription__bmContentDescriptionType::publisher), "fimsdescription:entityType"))
					continue;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTofimsdescription__entityType(soap, "fimsdescription:contributor", &(a->fimsdescription__bmContentDescriptionType::contributor), "fimsdescription:entityType"))
					continue;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTofimsdescription__dateType(soap, "fimsdescription:date", &(a->fimsdescription__bmContentDescriptionType::date), "fimsdescription:dateType"))
					continue;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTofimsdescription__typeType(soap, "fimsdescription:type", &(a->fimsdescription__bmContentDescriptionType::type), "fimsdescription:typeType"))
					continue;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTofimsdescription__identifierType(soap, "fimsdescription:identifier", &(a->fimsdescription__bmContentDescriptionType::identifier), "fimsdescription:identifierType"))
					continue;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTofimsdescription__languageType(soap, "fimsdescription:language", &(a->fimsdescription__bmContentDescriptionType::language), "fimsdescription:languageType"))
					continue;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTofimsdescription__relationType(soap, "fimsdescription:relation", &(a->fimsdescription__bmContentDescriptionType::relation), "fimsdescription:relationType"))
					continue;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTofimsdescription__relationType(soap, "fimsdescription:isVersionOf", &(a->fimsdescription__bmContentDescriptionType::isVersionOf), "fimsdescription:relationType"))
					continue;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTofimsdescription__relationType(soap, "fimsdescription:hasVersion", &(a->fimsdescription__bmContentDescriptionType::hasVersion), "fimsdescription:relationType"))
					continue;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTofimsdescription__relationType(soap, "fimsdescription:isReplacedBy", &(a->fimsdescription__bmContentDescriptionType::isReplacedBy), "fimsdescription:relationType"))
					continue;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTofimsdescription__relationType(soap, "fimsdescription:replaces", &(a->fimsdescription__bmContentDescriptionType::replaces), "fimsdescription:relationType"))
					continue;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTofimsdescription__relationType(soap, "fimsdescription:isRequiredBy", &(a->fimsdescription__bmContentDescriptionType::isRequiredBy), "fimsdescription:relationType"))
					continue;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTofimsdescription__relationType(soap, "fimsdescription:requires", &(a->fimsdescription__bmContentDescriptionType::requires), "fimsdescription:relationType"))
					continue;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTofimsdescription__relationType(soap, "fimsdescription:isPartOf", &(a->fimsdescription__bmContentDescriptionType::isPartOf), "fimsdescription:relationType"))
					continue;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTofimsdescription__relationType(soap, "fimsdescription:hasPart", &(a->fimsdescription__bmContentDescriptionType::hasPart), "fimsdescription:relationType"))
					continue;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTofimsdescription__relationType(soap, "fimsdescription:isReferencedBy", &(a->fimsdescription__bmContentDescriptionType::isReferencedBy), "fimsdescription:relationType"))
					continue;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTofimsdescription__relationType(soap, "fimsdescription:references", &(a->fimsdescription__bmContentDescriptionType::references), "fimsdescription:relationType"))
					continue;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTofimsdescription__relationType(soap, "fimsdescription:isFormatOf", &(a->fimsdescription__bmContentDescriptionType::isFormatOf), "fimsdescription:relationType"))
					continue;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTofimsdescription__relationType(soap, "fimsdescription:hasFormat", &(a->fimsdescription__bmContentDescriptionType::hasFormat), "fimsdescription:relationType"))
					continue;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTofimsdescription__relationType(soap, "fimsdescription:isEpisodeOf", &(a->fimsdescription__bmContentDescriptionType::isEpisodeOf), "fimsdescription:relationType"))
					continue;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTofimsdescription__relationType(soap, "fimsdescription:isMemberOf", &(a->fimsdescription__bmContentDescriptionType::isMemberOf), "fimsdescription:relationType"))
					continue;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTofimsdescription__relationType(soap, "fimsdescription:hasMembers", &(a->fimsdescription__bmContentDescriptionType::hasMembers), "fimsdescription:relationType"))
					continue;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTofimsdescription__coverageType(soap, "fimsdescription:coverage", &(a->fimsdescription__bmContentDescriptionType::coverage), "fimsdescription:coverageType"))
					continue;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTofimsdescription__rightsType(soap, "fimsdescription:rights", &(a->fimsdescription__bmContentDescriptionType::rights), "fimsdescription:rightsType"))
					continue;
			if (soap_flag_version1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "fimsdescription:version", &(a->fimsdescription__bmContentDescriptionType::version), "xsd:string"))
				{	soap_flag_version1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTofimsdescription__partType(soap, "fimsdescription:part", &(a->fimsdescription__bmContentDescriptionType::part), "fimsdescription:partType"))
					continue;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (fimsdescription__bmContentDescriptionType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_fimsdescription__bmContentDescriptionType, 0, sizeof(fimsdescription__bmContentDescriptionType), 0, soap_copy_fimsdescription__bmContentDescriptionType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int fimsdescription__bmContentDescriptionType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_fimsdescription__bmContentDescriptionType);
	if (this->soap_out(soap, tag?tag:"fimsdescription:bmContentDescriptionType", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *fimsdescription__bmContentDescriptionType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_fimsdescription__bmContentDescriptionType(soap, this, tag, type);
}

SOAP_FMAC3 fimsdescription__bmContentDescriptionType * SOAP_FMAC4 soap_get_fimsdescription__bmContentDescriptionType(struct soap *soap, fimsdescription__bmContentDescriptionType *p, const char *tag, const char *type)
{
	if ((p = soap_in_fimsdescription__bmContentDescriptionType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 fimsdescription__bmContentDescriptionType * SOAP_FMAC2 soap_instantiate_fimsdescription__bmContentDescriptionType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_fimsdescription__bmContentDescriptionType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_fimsdescription__bmContentDescriptionType, n, EDLProvider_fdelete);
	if (!cp)
		return NULL;
	if (type && !soap_match_tag(soap, type, "fimsdescription:partType"))
	{	cp->type = SOAP_TYPE_fimsdescription__partType;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(fimsdescription__partType);
			if (size)
				*size = sizeof(fimsdescription__partType);
			((fimsdescription__partType*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW_ARRAY(fimsdescription__partType, n);
			if (size)
				*size = n * sizeof(fimsdescription__partType);
			if (cp->ptr)
				for (int i = 0; i < n; i++)
					((fimsdescription__partType*)cp->ptr)[i].soap = soap;
		}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		if (!cp->ptr)
			soap->error = SOAP_EOM;
		return (fimsdescription__partType*)cp->ptr;
	}
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(fimsdescription__bmContentDescriptionType);
		if (size)
			*size = sizeof(fimsdescription__bmContentDescriptionType);
		((fimsdescription__bmContentDescriptionType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(fimsdescription__bmContentDescriptionType, n);
		if (size)
			*size = n * sizeof(fimsdescription__bmContentDescriptionType);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((fimsdescription__bmContentDescriptionType*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (fimsdescription__bmContentDescriptionType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_fimsdescription__bmContentDescriptionType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying fimsdescription__bmContentDescriptionType %p -> %p\n", q, p));
	*(fimsdescription__bmContentDescriptionType*)p = *(fimsdescription__bmContentDescriptionType*)q;
}

void fimstime__EditUnitNumberType::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_LONG64(soap, &this->fimstime__EditUnitNumberType::__item);
	soap_default_xsd__positiveInteger(soap, &this->fimstime__EditUnitNumberType::editRate);
	soap_default_xsd__positiveInteger(soap, &this->fimstime__EditUnitNumberType::factorNumerator);
	soap_default_xsd__positiveInteger(soap, &this->fimstime__EditUnitNumberType::factorDenominator);
	/* transient soap skipped */
}

void fimstime__EditUnitNumberType::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
#endif
}

int fimstime__EditUnitNumberType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_fimstime__EditUnitNumberType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_fimstime__EditUnitNumberType(struct soap *soap, const char *tag, int id, const fimstime__EditUnitNumberType *a, const char *type)
{
	soap_set_attr(soap, "editRate", soap_wchar2s(soap, ((fimstime__EditUnitNumberType*)a)->editRate.c_str()), 2);
	soap_set_attr(soap, "factorNumerator", soap_wchar2s(soap, ((fimstime__EditUnitNumberType*)a)->factorNumerator.c_str()), 2);
	soap_set_attr(soap, "factorDenominator", soap_wchar2s(soap, ((fimstime__EditUnitNumberType*)a)->factorDenominator.c_str()), 2);
	return soap_out_LONG64(soap, tag, id, &a->fimstime__EditUnitNumberType::__item, "");
}

void *fimstime__EditUnitNumberType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_fimstime__EditUnitNumberType(soap, tag, this, type);
}

SOAP_FMAC3 fimstime__EditUnitNumberType * SOAP_FMAC4 soap_in_fimstime__EditUnitNumberType(struct soap *soap, const char *tag, fimstime__EditUnitNumberType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (fimstime__EditUnitNumberType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_fimstime__EditUnitNumberType, sizeof(fimstime__EditUnitNumberType), soap->type, soap->arrayType)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_fimstime__EditUnitNumberType)
			return (fimstime__EditUnitNumberType *)a->soap_in(soap, tag, type);
	}
	{	const char *t = soap_attr_value(soap, "editRate", 1);
		if (t)
		{	wchar_t *s;
			if (soap_s2wchar(soap, t, &s, 0, -1))
				return NULL;
			((fimstime__EditUnitNumberType*)a)->editRate.assign(s);
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "factorNumerator", 1);
		if (t)
		{	wchar_t *s;
			if (soap_s2wchar(soap, t, &s, 0, -1))
				return NULL;
			((fimstime__EditUnitNumberType*)a)->factorNumerator.assign(s);
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "factorDenominator", 1);
		if (t)
		{	wchar_t *s;
			if (soap_s2wchar(soap, t, &s, 0, -1))
				return NULL;
			((fimstime__EditUnitNumberType*)a)->factorDenominator.assign(s);
		}
		else if (soap->error)
			return NULL;
	}
	if (!soap_in_LONG64(soap, tag, &(a->fimstime__EditUnitNumberType::__item), "fimstime:EditUnitNumberType"))
		return NULL;
	return a;
}

int fimstime__EditUnitNumberType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_fimstime__EditUnitNumberType);
	if (this->soap_out(soap, tag?tag:"fimstime:EditUnitNumberType", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *fimstime__EditUnitNumberType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_fimstime__EditUnitNumberType(soap, this, tag, type);
}

SOAP_FMAC3 fimstime__EditUnitNumberType * SOAP_FMAC4 soap_get_fimstime__EditUnitNumberType(struct soap *soap, fimstime__EditUnitNumberType *p, const char *tag, const char *type)
{
	if ((p = soap_in_fimstime__EditUnitNumberType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 fimstime__EditUnitNumberType * SOAP_FMAC2 soap_instantiate_fimstime__EditUnitNumberType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_fimstime__EditUnitNumberType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_fimstime__EditUnitNumberType, n, EDLProvider_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(fimstime__EditUnitNumberType);
		if (size)
			*size = sizeof(fimstime__EditUnitNumberType);
		((fimstime__EditUnitNumberType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(fimstime__EditUnitNumberType, n);
		if (size)
			*size = n * sizeof(fimstime__EditUnitNumberType);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((fimstime__EditUnitNumberType*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (fimstime__EditUnitNumberType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_fimstime__EditUnitNumberType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying fimstime__EditUnitNumberType %p -> %p\n", q, p));
	*(fimstime__EditUnitNumberType*)p = *(fimstime__EditUnitNumberType*)q;
}

void fimstime__TimeType::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->fimstime__TimeType::__union_TimeType = 0;
	/* transient soap skipped */
}

void fimstime__TimeType::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize__fimstime__union_TimeType(soap, this->fimstime__TimeType::__union_TimeType, &this->fimstime__TimeType::union_TimeType);
	/* transient soap skipped */
#endif
}

int fimstime__TimeType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_fimstime__TimeType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_fimstime__TimeType(struct soap *soap, const char *tag, int id, const fimstime__TimeType *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_fimstime__TimeType), type))
		return soap->error;
	if (soap_out__fimstime__union_TimeType(soap, a->fimstime__TimeType::__union_TimeType, &a->fimstime__TimeType::union_TimeType))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *fimstime__TimeType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_fimstime__TimeType(soap, tag, this, type);
}

SOAP_FMAC3 fimstime__TimeType * SOAP_FMAC4 soap_in_fimstime__TimeType(struct soap *soap, const char *tag, fimstime__TimeType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (fimstime__TimeType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_fimstime__TimeType, sizeof(fimstime__TimeType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	a->soap_default(soap);
	if (!tag || *tag == '-' || (soap->body && !*soap->href))
	{
		if (!soap_in__fimstime__union_TimeType(soap, &a->__union_TimeType, &a->union_TimeType))
			return NULL;
		if (tag && *tag != '-')
		{	soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_TAG_MISMATCH || soap_element_end_in(soap, tag))
				return NULL;
		}
	}
	else
	{	a = (fimstime__TimeType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_fimstime__TimeType, 0, sizeof(fimstime__TimeType), 0, soap_copy_fimstime__TimeType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int fimstime__TimeType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_fimstime__TimeType);
	if (this->soap_out(soap, tag?tag:"fimstime:TimeType", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *fimstime__TimeType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_fimstime__TimeType(soap, this, tag, type);
}

SOAP_FMAC3 fimstime__TimeType * SOAP_FMAC4 soap_get_fimstime__TimeType(struct soap *soap, fimstime__TimeType *p, const char *tag, const char *type)
{
	if ((p = soap_in_fimstime__TimeType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 fimstime__TimeType * SOAP_FMAC2 soap_instantiate_fimstime__TimeType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_fimstime__TimeType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_fimstime__TimeType, n, EDLProvider_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(fimstime__TimeType);
		if (size)
			*size = sizeof(fimstime__TimeType);
		((fimstime__TimeType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(fimstime__TimeType, n);
		if (size)
			*size = n * sizeof(fimstime__TimeType);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((fimstime__TimeType*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (fimstime__TimeType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_fimstime__TimeType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying fimstime__TimeType %p -> %p\n", q, p));
	*(fimstime__TimeType*)p = *(fimstime__TimeType*)q;
}

void fimstime__DurationType::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->fimstime__DurationType::__union_DurationType = 0;
	/* transient soap skipped */
}

void fimstime__DurationType::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize__fimstime__union_DurationType(soap, this->fimstime__DurationType::__union_DurationType, &this->fimstime__DurationType::union_DurationType);
	/* transient soap skipped */
#endif
}

int fimstime__DurationType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_fimstime__DurationType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_fimstime__DurationType(struct soap *soap, const char *tag, int id, const fimstime__DurationType *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_fimstime__DurationType), type))
		return soap->error;
	if (soap_out__fimstime__union_DurationType(soap, a->fimstime__DurationType::__union_DurationType, &a->fimstime__DurationType::union_DurationType))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *fimstime__DurationType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_fimstime__DurationType(soap, tag, this, type);
}

SOAP_FMAC3 fimstime__DurationType * SOAP_FMAC4 soap_in_fimstime__DurationType(struct soap *soap, const char *tag, fimstime__DurationType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (fimstime__DurationType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_fimstime__DurationType, sizeof(fimstime__DurationType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	a->soap_default(soap);
	if (!tag || *tag == '-' || (soap->body && !*soap->href))
	{
		if (!soap_in__fimstime__union_DurationType(soap, &a->__union_DurationType, &a->union_DurationType))
			return NULL;
		if (tag && *tag != '-')
		{	soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_TAG_MISMATCH || soap_element_end_in(soap, tag))
				return NULL;
		}
	}
	else
	{	a = (fimstime__DurationType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_fimstime__DurationType, 0, sizeof(fimstime__DurationType), 0, soap_copy_fimstime__DurationType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int fimstime__DurationType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_fimstime__DurationType);
	if (this->soap_out(soap, tag?tag:"fimstime:DurationType", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *fimstime__DurationType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_fimstime__DurationType(soap, this, tag, type);
}

SOAP_FMAC3 fimstime__DurationType * SOAP_FMAC4 soap_get_fimstime__DurationType(struct soap *soap, fimstime__DurationType *p, const char *tag, const char *type)
{
	if ((p = soap_in_fimstime__DurationType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 fimstime__DurationType * SOAP_FMAC2 soap_instantiate_fimstime__DurationType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_fimstime__DurationType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_fimstime__DurationType, n, EDLProvider_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(fimstime__DurationType);
		if (size)
			*size = sizeof(fimstime__DurationType);
		((fimstime__DurationType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(fimstime__DurationType, n);
		if (size)
			*size = n * sizeof(fimstime__DurationType);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((fimstime__DurationType*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (fimstime__DurationType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_fimstime__DurationType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying fimstime__DurationType %p -> %p\n", q, p));
	*(fimstime__DurationType*)p = *(fimstime__DurationType*)q;
}

void _fims__formatCollection::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_fims__formatCollection::videoFormat = NULL;
	this->_fims__formatCollection::audioFormat = NULL;
	this->_fims__formatCollection::dataFormat = NULL;
	this->_fims__formatCollection::containerFormat = NULL;
	/* transient soap skipped */
}

void _fims__formatCollection::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTofims__VideoFormatType(soap, &this->_fims__formatCollection::videoFormat);
	soap_serialize_PointerTofims__AudioFormatType(soap, &this->_fims__formatCollection::audioFormat);
	soap_serialize_PointerTofims__DataFormatType(soap, &this->_fims__formatCollection::dataFormat);
	soap_serialize_PointerTofims__ContainerFormatType(soap, &this->_fims__formatCollection::containerFormat);
	/* transient soap skipped */
#endif
}

int _fims__formatCollection::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__fims__formatCollection(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__fims__formatCollection(struct soap *soap, const char *tag, int id, const _fims__formatCollection *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__fims__formatCollection), type))
		return soap->error;
	if (soap_out_PointerTofims__VideoFormatType(soap, "fims:videoFormat", -1, &(a->_fims__formatCollection::videoFormat), ""))
		return soap->error;
	if (soap_out_PointerTofims__AudioFormatType(soap, "fims:audioFormat", -1, &(a->_fims__formatCollection::audioFormat), ""))
		return soap->error;
	if (soap_out_PointerTofims__DataFormatType(soap, "fims:dataFormat", -1, &(a->_fims__formatCollection::dataFormat), ""))
		return soap->error;
	if (soap_out_PointerTofims__ContainerFormatType(soap, "fims:containerFormat", -1, &(a->_fims__formatCollection::containerFormat), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_fims__formatCollection::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__fims__formatCollection(soap, tag, this, type);
}

SOAP_FMAC3 _fims__formatCollection * SOAP_FMAC4 soap_in__fims__formatCollection(struct soap *soap, const char *tag, _fims__formatCollection *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_fims__formatCollection *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__fims__formatCollection, sizeof(_fims__formatCollection), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__fims__formatCollection)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_fims__formatCollection *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_videoFormat1 = 1;
	size_t soap_flag_audioFormat1 = 1;
	size_t soap_flag_dataFormat1 = 1;
	size_t soap_flag_containerFormat1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_videoFormat1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTofims__VideoFormatType(soap, "fims:videoFormat", &(a->_fims__formatCollection::videoFormat), "fims:VideoFormatType"))
				{	soap_flag_videoFormat1--;
					continue;
				}
			if (soap_flag_audioFormat1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTofims__AudioFormatType(soap, "fims:audioFormat", &(a->_fims__formatCollection::audioFormat), "fims:AudioFormatType"))
				{	soap_flag_audioFormat1--;
					continue;
				}
			if (soap_flag_dataFormat1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTofims__DataFormatType(soap, "fims:dataFormat", &(a->_fims__formatCollection::dataFormat), "fims:DataFormatType"))
				{	soap_flag_dataFormat1--;
					continue;
				}
			if (soap_flag_containerFormat1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTofims__ContainerFormatType(soap, "fims:containerFormat", &(a->_fims__formatCollection::containerFormat), "fims:ContainerFormatType"))
				{	soap_flag_containerFormat1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_fims__formatCollection *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__fims__formatCollection, 0, sizeof(_fims__formatCollection), 0, soap_copy__fims__formatCollection);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int _fims__formatCollection::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__fims__formatCollection);
	if (this->soap_out(soap, tag?tag:"fims:formatCollection", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_fims__formatCollection::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__fims__formatCollection(soap, this, tag, type);
}

SOAP_FMAC3 _fims__formatCollection * SOAP_FMAC4 soap_get__fims__formatCollection(struct soap *soap, _fims__formatCollection *p, const char *tag, const char *type)
{
	if ((p = soap_in__fims__formatCollection(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _fims__formatCollection * SOAP_FMAC2 soap_instantiate__fims__formatCollection(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__fims__formatCollection(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__fims__formatCollection, n, EDLProvider_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_fims__formatCollection);
		if (size)
			*size = sizeof(_fims__formatCollection);
		((_fims__formatCollection*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(_fims__formatCollection, n);
		if (size)
			*size = n * sizeof(_fims__formatCollection);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((_fims__formatCollection*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (_fims__formatCollection*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__fims__formatCollection(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _fims__formatCollection %p -> %p\n", q, p));
	*(_fims__formatCollection*)p = *(_fims__formatCollection*)q;
}

void fims__SystemPerformanceEventsType::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTofims__SystemPerformanceEventType(soap, &this->fims__SystemPerformanceEventsType::systemPerformanceEvent);
	soap_default_std__vectorTemplateOf_XML(soap, &this->fims__SystemPerformanceEventsType::__any);
	this->fims__SystemPerformanceEventsType::__anyAttribute = NULL;
	/* transient soap skipped */
}

void fims__SystemPerformanceEventsType::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfPointerTofims__SystemPerformanceEventType(soap, &this->fims__SystemPerformanceEventsType::systemPerformanceEvent);
	soap_serialize_std__vectorTemplateOf_XML(soap, &this->fims__SystemPerformanceEventsType::__any);
	/* transient soap skipped */
#endif
}

int fims__SystemPerformanceEventsType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_fims__SystemPerformanceEventsType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_fims__SystemPerformanceEventsType(struct soap *soap, const char *tag, int id, const fims__SystemPerformanceEventsType *a, const char *type)
{
	if (((fims__SystemPerformanceEventsType*)a)->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", ((fims__SystemPerformanceEventsType*)a)->__anyAttribute, 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_fims__SystemPerformanceEventsType), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTofims__SystemPerformanceEventType(soap, "fims:systemPerformanceEvent", -1, &(a->fims__SystemPerformanceEventsType::systemPerformanceEvent), ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOf_XML(soap, "-any", -1, &(a->fims__SystemPerformanceEventsType::__any), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *fims__SystemPerformanceEventsType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_fims__SystemPerformanceEventsType(soap, tag, this, type);
}

SOAP_FMAC3 fims__SystemPerformanceEventsType * SOAP_FMAC4 soap_in_fims__SystemPerformanceEventsType(struct soap *soap, const char *tag, fims__SystemPerformanceEventsType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (fims__SystemPerformanceEventsType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_fims__SystemPerformanceEventsType, sizeof(fims__SystemPerformanceEventsType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_fims__SystemPerformanceEventsType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (fims__SystemPerformanceEventsType *)a->soap_in(soap, tag, type);
		}
	}
	if (soap_s2string(soap, soap_attr_value(soap, "-anyAttribute", 0), &((fims__SystemPerformanceEventsType*)a)->__anyAttribute, 0, -1))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTofims__SystemPerformanceEventType(soap, "fims:systemPerformanceEvent", &(a->fims__SystemPerformanceEventsType::systemPerformanceEvent), "fims:SystemPerformanceEventType"))
					continue;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOf_XML(soap, "-any", &(a->fims__SystemPerformanceEventsType::__any), ""))
					continue;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (fims__SystemPerformanceEventsType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_fims__SystemPerformanceEventsType, 0, sizeof(fims__SystemPerformanceEventsType), 0, soap_copy_fims__SystemPerformanceEventsType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (a->fims__SystemPerformanceEventsType::systemPerformanceEvent.size() < 1))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int fims__SystemPerformanceEventsType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_fims__SystemPerformanceEventsType);
	if (this->soap_out(soap, tag?tag:"fims:SystemPerformanceEventsType", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *fims__SystemPerformanceEventsType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_fims__SystemPerformanceEventsType(soap, this, tag, type);
}

SOAP_FMAC3 fims__SystemPerformanceEventsType * SOAP_FMAC4 soap_get_fims__SystemPerformanceEventsType(struct soap *soap, fims__SystemPerformanceEventsType *p, const char *tag, const char *type)
{
	if ((p = soap_in_fims__SystemPerformanceEventsType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 fims__SystemPerformanceEventsType * SOAP_FMAC2 soap_instantiate_fims__SystemPerformanceEventsType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_fims__SystemPerformanceEventsType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_fims__SystemPerformanceEventsType, n, EDLProvider_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(fims__SystemPerformanceEventsType);
		if (size)
			*size = sizeof(fims__SystemPerformanceEventsType);
		((fims__SystemPerformanceEventsType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(fims__SystemPerformanceEventsType, n);
		if (size)
			*size = n * sizeof(fims__SystemPerformanceEventsType);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((fims__SystemPerformanceEventsType*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (fims__SystemPerformanceEventsType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_fims__SystemPerformanceEventsType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying fims__SystemPerformanceEventsType %p -> %p\n", q, p));
	*(fims__SystemPerformanceEventsType*)p = *(fims__SystemPerformanceEventsType*)q;
}

void fims__SystemPerformanceEventType::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->fims__SystemEventType::soap_default(soap);
	this->fims__SystemPerformanceEventType::TBD = NULL;
}

void fims__SystemPerformanceEventType::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__wstring(soap, &this->fims__SystemPerformanceEventType::TBD);
	this->fims__SystemEventType::soap_serialize(soap);
#endif
}

int fims__SystemPerformanceEventType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_fims__SystemPerformanceEventType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_fims__SystemPerformanceEventType(struct soap *soap, const char *tag, int id, const fims__SystemPerformanceEventType *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_fims__SystemPerformanceEventType), "fims:SystemPerformanceEventType"))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_PointerTostd__wstring(soap, "fims:TBD", -1, &(a->fims__SystemPerformanceEventType::TBD), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *fims__SystemPerformanceEventType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_fims__SystemPerformanceEventType(soap, tag, this, type);
}

SOAP_FMAC3 fims__SystemPerformanceEventType * SOAP_FMAC4 soap_in_fims__SystemPerformanceEventType(struct soap *soap, const char *tag, fims__SystemPerformanceEventType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (fims__SystemPerformanceEventType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_fims__SystemPerformanceEventType, sizeof(fims__SystemPerformanceEventType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_fims__SystemPerformanceEventType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (fims__SystemPerformanceEventType *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_TBD1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap_flag_TBD1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "fims:TBD", &(a->fims__SystemPerformanceEventType::TBD), "xsd:string"))
				{	soap_flag_TBD1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (fims__SystemPerformanceEventType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_fims__SystemPerformanceEventType, 0, sizeof(fims__SystemPerformanceEventType), 0, soap_copy_fims__SystemPerformanceEventType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int fims__SystemPerformanceEventType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_fims__SystemPerformanceEventType);
	if (this->soap_out(soap, tag?tag:"fims:SystemPerformanceEventType", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *fims__SystemPerformanceEventType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_fims__SystemPerformanceEventType(soap, this, tag, type);
}

SOAP_FMAC3 fims__SystemPerformanceEventType * SOAP_FMAC4 soap_get_fims__SystemPerformanceEventType(struct soap *soap, fims__SystemPerformanceEventType *p, const char *tag, const char *type)
{
	if ((p = soap_in_fims__SystemPerformanceEventType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 fims__SystemPerformanceEventType * SOAP_FMAC2 soap_instantiate_fims__SystemPerformanceEventType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_fims__SystemPerformanceEventType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_fims__SystemPerformanceEventType, n, EDLProvider_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(fims__SystemPerformanceEventType);
		if (size)
			*size = sizeof(fims__SystemPerformanceEventType);
		((fims__SystemPerformanceEventType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(fims__SystemPerformanceEventType, n);
		if (size)
			*size = n * sizeof(fims__SystemPerformanceEventType);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((fims__SystemPerformanceEventType*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (fims__SystemPerformanceEventType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_fims__SystemPerformanceEventType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying fims__SystemPerformanceEventType %p -> %p\n", q, p));
	*(fims__SystemPerformanceEventType*)p = *(fims__SystemPerformanceEventType*)q;
}

void fims__SystemExceptionEventsType::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTofims__SystemExceptionEventType(soap, &this->fims__SystemExceptionEventsType::systemExceptionEvent);
	soap_default_std__vectorTemplateOf_XML(soap, &this->fims__SystemExceptionEventsType::__any);
	this->fims__SystemExceptionEventsType::__anyAttribute = NULL;
	/* transient soap skipped */
}

void fims__SystemExceptionEventsType::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfPointerTofims__SystemExceptionEventType(soap, &this->fims__SystemExceptionEventsType::systemExceptionEvent);
	soap_serialize_std__vectorTemplateOf_XML(soap, &this->fims__SystemExceptionEventsType::__any);
	/* transient soap skipped */
#endif
}

int fims__SystemExceptionEventsType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_fims__SystemExceptionEventsType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_fims__SystemExceptionEventsType(struct soap *soap, const char *tag, int id, const fims__SystemExceptionEventsType *a, const char *type)
{
	if (((fims__SystemExceptionEventsType*)a)->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", ((fims__SystemExceptionEventsType*)a)->__anyAttribute, 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_fims__SystemExceptionEventsType), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTofims__SystemExceptionEventType(soap, "fims:systemExceptionEvent", -1, &(a->fims__SystemExceptionEventsType::systemExceptionEvent), ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOf_XML(soap, "-any", -1, &(a->fims__SystemExceptionEventsType::__any), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *fims__SystemExceptionEventsType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_fims__SystemExceptionEventsType(soap, tag, this, type);
}

SOAP_FMAC3 fims__SystemExceptionEventsType * SOAP_FMAC4 soap_in_fims__SystemExceptionEventsType(struct soap *soap, const char *tag, fims__SystemExceptionEventsType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (fims__SystemExceptionEventsType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_fims__SystemExceptionEventsType, sizeof(fims__SystemExceptionEventsType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_fims__SystemExceptionEventsType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (fims__SystemExceptionEventsType *)a->soap_in(soap, tag, type);
		}
	}
	if (soap_s2string(soap, soap_attr_value(soap, "-anyAttribute", 0), &((fims__SystemExceptionEventsType*)a)->__anyAttribute, 0, -1))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTofims__SystemExceptionEventType(soap, "fims:systemExceptionEvent", &(a->fims__SystemExceptionEventsType::systemExceptionEvent), "fims:SystemExceptionEventType"))
					continue;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOf_XML(soap, "-any", &(a->fims__SystemExceptionEventsType::__any), ""))
					continue;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (fims__SystemExceptionEventsType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_fims__SystemExceptionEventsType, 0, sizeof(fims__SystemExceptionEventsType), 0, soap_copy_fims__SystemExceptionEventsType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (a->fims__SystemExceptionEventsType::systemExceptionEvent.size() < 1))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int fims__SystemExceptionEventsType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_fims__SystemExceptionEventsType);
	if (this->soap_out(soap, tag?tag:"fims:SystemExceptionEventsType", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *fims__SystemExceptionEventsType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_fims__SystemExceptionEventsType(soap, this, tag, type);
}

SOAP_FMAC3 fims__SystemExceptionEventsType * SOAP_FMAC4 soap_get_fims__SystemExceptionEventsType(struct soap *soap, fims__SystemExceptionEventsType *p, const char *tag, const char *type)
{
	if ((p = soap_in_fims__SystemExceptionEventsType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 fims__SystemExceptionEventsType * SOAP_FMAC2 soap_instantiate_fims__SystemExceptionEventsType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_fims__SystemExceptionEventsType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_fims__SystemExceptionEventsType, n, EDLProvider_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(fims__SystemExceptionEventsType);
		if (size)
			*size = sizeof(fims__SystemExceptionEventsType);
		((fims__SystemExceptionEventsType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(fims__SystemExceptionEventsType, n);
		if (size)
			*size = n * sizeof(fims__SystemExceptionEventsType);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((fims__SystemExceptionEventsType*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (fims__SystemExceptionEventsType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_fims__SystemExceptionEventsType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying fims__SystemExceptionEventsType %p -> %p\n", q, p));
	*(fims__SystemExceptionEventsType*)p = *(fims__SystemExceptionEventsType*)q;
}

void fims__SystemExceptionEventType::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->fims__SystemEventType::soap_default(soap);
	this->fims__SystemExceptionEventType::errorCode = NULL;
	this->fims__SystemExceptionEventType::errorTitle = NULL;
	this->fims__SystemExceptionEventType::errorDescription = NULL;
	this->fims__SystemExceptionEventType::errorDateTime = NULL;
}

void fims__SystemExceptionEventType::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__wstring(soap, &this->fims__SystemExceptionEventType::errorCode);
	soap_serialize_PointerTostd__wstring(soap, &this->fims__SystemExceptionEventType::errorTitle);
	soap_serialize_PointerTostd__wstring(soap, &this->fims__SystemExceptionEventType::errorDescription);
	soap_serialize_PointerTotime(soap, &this->fims__SystemExceptionEventType::errorDateTime);
	this->fims__SystemEventType::soap_serialize(soap);
#endif
}

int fims__SystemExceptionEventType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_fims__SystemExceptionEventType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_fims__SystemExceptionEventType(struct soap *soap, const char *tag, int id, const fims__SystemExceptionEventType *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_fims__SystemExceptionEventType), "fims:SystemExceptionEventType"))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_PointerTostd__wstring(soap, "fims:errorCode", -1, &(a->fims__SystemExceptionEventType::errorCode), ""))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "fims:errorTitle", -1, &(a->fims__SystemExceptionEventType::errorTitle), ""))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "fims:errorDescription", -1, &(a->fims__SystemExceptionEventType::errorDescription), ""))
		return soap->error;
	if (soap_out_PointerTotime(soap, "fims:errorDateTime", -1, &(a->fims__SystemExceptionEventType::errorDateTime), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *fims__SystemExceptionEventType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_fims__SystemExceptionEventType(soap, tag, this, type);
}

SOAP_FMAC3 fims__SystemExceptionEventType * SOAP_FMAC4 soap_in_fims__SystemExceptionEventType(struct soap *soap, const char *tag, fims__SystemExceptionEventType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (fims__SystemExceptionEventType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_fims__SystemExceptionEventType, sizeof(fims__SystemExceptionEventType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_fims__SystemExceptionEventType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (fims__SystemExceptionEventType *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_errorCode1 = 1;
	size_t soap_flag_errorTitle1 = 1;
	size_t soap_flag_errorDescription1 = 1;
	size_t soap_flag_errorDateTime1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap_flag_errorCode1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "fims:errorCode", &(a->fims__SystemExceptionEventType::errorCode), "xsd:string"))
				{	soap_flag_errorCode1--;
					continue;
				}
			if (soap_flag_errorTitle1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "fims:errorTitle", &(a->fims__SystemExceptionEventType::errorTitle), "xsd:string"))
				{	soap_flag_errorTitle1--;
					continue;
				}
			if (soap_flag_errorDescription1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "fims:errorDescription", &(a->fims__SystemExceptionEventType::errorDescription), "xsd:string"))
				{	soap_flag_errorDescription1--;
					continue;
				}
			if (soap_flag_errorDateTime1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTotime(soap, "fims:errorDateTime", &(a->fims__SystemExceptionEventType::errorDateTime), "xsd:dateTime"))
				{	soap_flag_errorDateTime1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (fims__SystemExceptionEventType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_fims__SystemExceptionEventType, 0, sizeof(fims__SystemExceptionEventType), 0, soap_copy_fims__SystemExceptionEventType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int fims__SystemExceptionEventType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_fims__SystemExceptionEventType);
	if (this->soap_out(soap, tag?tag:"fims:SystemExceptionEventType", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *fims__SystemExceptionEventType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_fims__SystemExceptionEventType(soap, this, tag, type);
}

SOAP_FMAC3 fims__SystemExceptionEventType * SOAP_FMAC4 soap_get_fims__SystemExceptionEventType(struct soap *soap, fims__SystemExceptionEventType *p, const char *tag, const char *type)
{
	if ((p = soap_in_fims__SystemExceptionEventType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 fims__SystemExceptionEventType * SOAP_FMAC2 soap_instantiate_fims__SystemExceptionEventType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_fims__SystemExceptionEventType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_fims__SystemExceptionEventType, n, EDLProvider_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(fims__SystemExceptionEventType);
		if (size)
			*size = sizeof(fims__SystemExceptionEventType);
		((fims__SystemExceptionEventType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(fims__SystemExceptionEventType, n);
		if (size)
			*size = n * sizeof(fims__SystemExceptionEventType);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((fims__SystemExceptionEventType*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (fims__SystemExceptionEventType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_fims__SystemExceptionEventType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying fims__SystemExceptionEventType %p -> %p\n", q, p));
	*(fims__SystemExceptionEventType*)p = *(fims__SystemExceptionEventType*)q;
}

void fims__SystemEventsType::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTofims__SystemEventType(soap, &this->fims__SystemEventsType::systemEvent);
	soap_default_std__vectorTemplateOf_XML(soap, &this->fims__SystemEventsType::__any);
	this->fims__SystemEventsType::__anyAttribute = NULL;
	/* transient soap skipped */
}

void fims__SystemEventsType::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfPointerTofims__SystemEventType(soap, &this->fims__SystemEventsType::systemEvent);
	soap_serialize_std__vectorTemplateOf_XML(soap, &this->fims__SystemEventsType::__any);
	/* transient soap skipped */
#endif
}

int fims__SystemEventsType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_fims__SystemEventsType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_fims__SystemEventsType(struct soap *soap, const char *tag, int id, const fims__SystemEventsType *a, const char *type)
{
	if (((fims__SystemEventsType*)a)->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", ((fims__SystemEventsType*)a)->__anyAttribute, 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_fims__SystemEventsType), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTofims__SystemEventType(soap, "fims:systemEvent", -1, &(a->fims__SystemEventsType::systemEvent), ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOf_XML(soap, "-any", -1, &(a->fims__SystemEventsType::__any), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *fims__SystemEventsType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_fims__SystemEventsType(soap, tag, this, type);
}

SOAP_FMAC3 fims__SystemEventsType * SOAP_FMAC4 soap_in_fims__SystemEventsType(struct soap *soap, const char *tag, fims__SystemEventsType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (fims__SystemEventsType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_fims__SystemEventsType, sizeof(fims__SystemEventsType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_fims__SystemEventsType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (fims__SystemEventsType *)a->soap_in(soap, tag, type);
		}
	}
	if (soap_s2string(soap, soap_attr_value(soap, "-anyAttribute", 0), &((fims__SystemEventsType*)a)->__anyAttribute, 0, -1))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTofims__SystemEventType(soap, "fims:systemEvent", &(a->fims__SystemEventsType::systemEvent), "fims:SystemEventType"))
					continue;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOf_XML(soap, "-any", &(a->fims__SystemEventsType::__any), ""))
					continue;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (fims__SystemEventsType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_fims__SystemEventsType, 0, sizeof(fims__SystemEventsType), 0, soap_copy_fims__SystemEventsType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (a->fims__SystemEventsType::systemEvent.size() < 1))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int fims__SystemEventsType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_fims__SystemEventsType);
	if (this->soap_out(soap, tag?tag:"fims:SystemEventsType", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *fims__SystemEventsType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_fims__SystemEventsType(soap, this, tag, type);
}

SOAP_FMAC3 fims__SystemEventsType * SOAP_FMAC4 soap_get_fims__SystemEventsType(struct soap *soap, fims__SystemEventsType *p, const char *tag, const char *type)
{
	if ((p = soap_in_fims__SystemEventsType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 fims__SystemEventsType * SOAP_FMAC2 soap_instantiate_fims__SystemEventsType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_fims__SystemEventsType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_fims__SystemEventsType, n, EDLProvider_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(fims__SystemEventsType);
		if (size)
			*size = sizeof(fims__SystemEventsType);
		((fims__SystemEventsType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(fims__SystemEventsType, n);
		if (size)
			*size = n * sizeof(fims__SystemEventsType);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((fims__SystemEventsType*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (fims__SystemEventsType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_fims__SystemEventsType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying fims__SystemEventsType %p -> %p\n", q, p));
	*(fims__SystemEventsType*)p = *(fims__SystemEventsType*)q;
}

void fims__SystemEventType::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->fims__EventPayloadType::soap_default(soap);
}

void fims__SystemEventType::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	this->fims__EventPayloadType::soap_serialize(soap);
#endif
}

int fims__SystemEventType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_fims__SystemEventType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_fims__SystemEventType(struct soap *soap, const char *tag, int id, const fims__SystemEventType *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_fims__SystemEventType), "fims:SystemEventType"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *fims__SystemEventType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_fims__SystemEventType(soap, tag, this, type);
}

SOAP_FMAC3 fims__SystemEventType * SOAP_FMAC4 soap_in_fims__SystemEventType(struct soap *soap, const char *tag, fims__SystemEventType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (fims__SystemEventType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_fims__SystemEventType, sizeof(fims__SystemEventType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_fims__SystemEventType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (fims__SystemEventType *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (fims__SystemEventType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_fims__SystemEventType, 0, sizeof(fims__SystemEventType), 0, soap_copy_fims__SystemEventType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int fims__SystemEventType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_fims__SystemEventType);
	if (this->soap_out(soap, tag?tag:"fims:SystemEventType", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *fims__SystemEventType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_fims__SystemEventType(soap, this, tag, type);
}

SOAP_FMAC3 fims__SystemEventType * SOAP_FMAC4 soap_get_fims__SystemEventType(struct soap *soap, fims__SystemEventType *p, const char *tag, const char *type)
{
	if ((p = soap_in_fims__SystemEventType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 fims__SystemEventType * SOAP_FMAC2 soap_instantiate_fims__SystemEventType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_fims__SystemEventType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_fims__SystemEventType, n, EDLProvider_fdelete);
	if (!cp)
		return NULL;
	if (type && !soap_match_tag(soap, type, "fims:SystemExceptionEventType"))
	{	cp->type = SOAP_TYPE_fims__SystemExceptionEventType;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(fims__SystemExceptionEventType);
			if (size)
				*size = sizeof(fims__SystemExceptionEventType);
			((fims__SystemExceptionEventType*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW_ARRAY(fims__SystemExceptionEventType, n);
			if (size)
				*size = n * sizeof(fims__SystemExceptionEventType);
			if (cp->ptr)
				for (int i = 0; i < n; i++)
					((fims__SystemExceptionEventType*)cp->ptr)[i].soap = soap;
		}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		if (!cp->ptr)
			soap->error = SOAP_EOM;
		return (fims__SystemExceptionEventType*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "fims:SystemPerformanceEventType"))
	{	cp->type = SOAP_TYPE_fims__SystemPerformanceEventType;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(fims__SystemPerformanceEventType);
			if (size)
				*size = sizeof(fims__SystemPerformanceEventType);
			((fims__SystemPerformanceEventType*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW_ARRAY(fims__SystemPerformanceEventType, n);
			if (size)
				*size = n * sizeof(fims__SystemPerformanceEventType);
			if (cp->ptr)
				for (int i = 0; i < n; i++)
					((fims__SystemPerformanceEventType*)cp->ptr)[i].soap = soap;
		}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		if (!cp->ptr)
			soap->error = SOAP_EOM;
		return (fims__SystemPerformanceEventType*)cp->ptr;
	}
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(fims__SystemEventType);
		if (size)
			*size = sizeof(fims__SystemEventType);
		((fims__SystemEventType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(fims__SystemEventType, n);
		if (size)
			*size = n * sizeof(fims__SystemEventType);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((fims__SystemEventType*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (fims__SystemEventType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_fims__SystemEventType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying fims__SystemEventType %p -> %p\n", q, p));
	*(fims__SystemEventType*)p = *(fims__SystemEventType*)q;
}

void fims__ContentCustomEventsType::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTofims__ContentCustomEventType(soap, &this->fims__ContentCustomEventsType::contentCustomEvent);
	soap_default_std__vectorTemplateOf_XML(soap, &this->fims__ContentCustomEventsType::__any);
	this->fims__ContentCustomEventsType::__anyAttribute = NULL;
	/* transient soap skipped */
}

void fims__ContentCustomEventsType::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfPointerTofims__ContentCustomEventType(soap, &this->fims__ContentCustomEventsType::contentCustomEvent);
	soap_serialize_std__vectorTemplateOf_XML(soap, &this->fims__ContentCustomEventsType::__any);
	/* transient soap skipped */
#endif
}

int fims__ContentCustomEventsType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_fims__ContentCustomEventsType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_fims__ContentCustomEventsType(struct soap *soap, const char *tag, int id, const fims__ContentCustomEventsType *a, const char *type)
{
	if (((fims__ContentCustomEventsType*)a)->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", ((fims__ContentCustomEventsType*)a)->__anyAttribute, 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_fims__ContentCustomEventsType), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTofims__ContentCustomEventType(soap, "fims:contentCustomEvent", -1, &(a->fims__ContentCustomEventsType::contentCustomEvent), ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOf_XML(soap, "-any", -1, &(a->fims__ContentCustomEventsType::__any), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *fims__ContentCustomEventsType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_fims__ContentCustomEventsType(soap, tag, this, type);
}

SOAP_FMAC3 fims__ContentCustomEventsType * SOAP_FMAC4 soap_in_fims__ContentCustomEventsType(struct soap *soap, const char *tag, fims__ContentCustomEventsType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (fims__ContentCustomEventsType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_fims__ContentCustomEventsType, sizeof(fims__ContentCustomEventsType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_fims__ContentCustomEventsType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (fims__ContentCustomEventsType *)a->soap_in(soap, tag, type);
		}
	}
	if (soap_s2string(soap, soap_attr_value(soap, "-anyAttribute", 0), &((fims__ContentCustomEventsType*)a)->__anyAttribute, 0, -1))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTofims__ContentCustomEventType(soap, "fims:contentCustomEvent", &(a->fims__ContentCustomEventsType::contentCustomEvent), "fims:ContentCustomEventType"))
					continue;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOf_XML(soap, "-any", &(a->fims__ContentCustomEventsType::__any), ""))
					continue;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (fims__ContentCustomEventsType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_fims__ContentCustomEventsType, 0, sizeof(fims__ContentCustomEventsType), 0, soap_copy_fims__ContentCustomEventsType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (a->fims__ContentCustomEventsType::contentCustomEvent.size() < 1))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int fims__ContentCustomEventsType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_fims__ContentCustomEventsType);
	if (this->soap_out(soap, tag?tag:"fims:ContentCustomEventsType", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *fims__ContentCustomEventsType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_fims__ContentCustomEventsType(soap, this, tag, type);
}

SOAP_FMAC3 fims__ContentCustomEventsType * SOAP_FMAC4 soap_get_fims__ContentCustomEventsType(struct soap *soap, fims__ContentCustomEventsType *p, const char *tag, const char *type)
{
	if ((p = soap_in_fims__ContentCustomEventsType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 fims__ContentCustomEventsType * SOAP_FMAC2 soap_instantiate_fims__ContentCustomEventsType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_fims__ContentCustomEventsType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_fims__ContentCustomEventsType, n, EDLProvider_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(fims__ContentCustomEventsType);
		if (size)
			*size = sizeof(fims__ContentCustomEventsType);
		((fims__ContentCustomEventsType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(fims__ContentCustomEventsType, n);
		if (size)
			*size = n * sizeof(fims__ContentCustomEventsType);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((fims__ContentCustomEventsType*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (fims__ContentCustomEventsType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_fims__ContentCustomEventsType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying fims__ContentCustomEventsType %p -> %p\n", q, p));
	*(fims__ContentCustomEventsType*)p = *(fims__ContentCustomEventsType*)q;
}

void fims__ContentCustomEventType::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->fims__ContentEventType::soap_default(soap);
	this->fims__ContentCustomEventType::templateID = NULL;
	this->fims__ContentCustomEventType::customEventTemplate = NULL;
}

void fims__ContentCustomEventType::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTofims__ResourceIDType(soap, &this->fims__ContentCustomEventType::templateID);
	soap_serialize_PointerTofims__CustomEventTemplateType(soap, &this->fims__ContentCustomEventType::customEventTemplate);
	this->fims__ContentEventType::soap_serialize(soap);
#endif
}

int fims__ContentCustomEventType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_fims__ContentCustomEventType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_fims__ContentCustomEventType(struct soap *soap, const char *tag, int id, const fims__ContentCustomEventType *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_fims__ContentCustomEventType), "fims:ContentCustomEventType"))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_PointerTofims__ResourceReferenceType(soap, "fims:targetResourceReference", -1, &(a->fims__ContentEventType::targetResourceReference), ""))
		return soap->error;
	if (soap_out_PointerTofims__ExtensionGroup(soap, "fims:ExtensionGroup", -1, &(a->fims__ContentEventType::ExtensionGroup), ""))
		return soap->error;
	if (soap_out_PointerTofims__ResourceIDType(soap, "fims:templateID", -1, &(a->fims__ContentCustomEventType::templateID), ""))
		return soap->error;
	if (soap_out_PointerTofims__CustomEventTemplateType(soap, "fims:customEventTemplate", -1, &(a->fims__ContentCustomEventType::customEventTemplate), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *fims__ContentCustomEventType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_fims__ContentCustomEventType(soap, tag, this, type);
}

SOAP_FMAC3 fims__ContentCustomEventType * SOAP_FMAC4 soap_in_fims__ContentCustomEventType(struct soap *soap, const char *tag, fims__ContentCustomEventType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (fims__ContentCustomEventType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_fims__ContentCustomEventType, sizeof(fims__ContentCustomEventType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_fims__ContentCustomEventType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (fims__ContentCustomEventType *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_targetResourceReference2 = 1;
	size_t soap_flag_ExtensionGroup2 = 1;
	size_t soap_flag_templateID1 = 1;
	size_t soap_flag_customEventTemplate1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap_flag_targetResourceReference2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTofims__ResourceReferenceType(soap, "fims:targetResourceReference", &(a->fims__ContentEventType::targetResourceReference), "fims:ResourceReferenceType"))
				{	soap_flag_targetResourceReference2--;
					continue;
				}
			if (soap_flag_ExtensionGroup2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTofims__ExtensionGroup(soap, "fims:ExtensionGroup", &(a->fims__ContentEventType::ExtensionGroup), "fims:ExtensionGroup"))
				{	soap_flag_ExtensionGroup2--;
					continue;
				}
			if (soap_flag_templateID1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTofims__ResourceIDType(soap, "fims:templateID", &(a->fims__ContentCustomEventType::templateID), "fims:ResourceIDType"))
				{	soap_flag_templateID1--;
					continue;
				}
			if (soap_flag_customEventTemplate1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTofims__CustomEventTemplateType(soap, "fims:customEventTemplate", &(a->fims__ContentCustomEventType::customEventTemplate), "fims:CustomEventTemplateType"))
				{	soap_flag_customEventTemplate1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (fims__ContentCustomEventType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_fims__ContentCustomEventType, 0, sizeof(fims__ContentCustomEventType), 0, soap_copy_fims__ContentCustomEventType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int fims__ContentCustomEventType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_fims__ContentCustomEventType);
	if (this->soap_out(soap, tag?tag:"fims:ContentCustomEventType", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *fims__ContentCustomEventType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_fims__ContentCustomEventType(soap, this, tag, type);
}

SOAP_FMAC3 fims__ContentCustomEventType * SOAP_FMAC4 soap_get_fims__ContentCustomEventType(struct soap *soap, fims__ContentCustomEventType *p, const char *tag, const char *type)
{
	if ((p = soap_in_fims__ContentCustomEventType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 fims__ContentCustomEventType * SOAP_FMAC2 soap_instantiate_fims__ContentCustomEventType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_fims__ContentCustomEventType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_fims__ContentCustomEventType, n, EDLProvider_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(fims__ContentCustomEventType);
		if (size)
			*size = sizeof(fims__ContentCustomEventType);
		((fims__ContentCustomEventType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(fims__ContentCustomEventType, n);
		if (size)
			*size = n * sizeof(fims__ContentCustomEventType);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((fims__ContentCustomEventType*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (fims__ContentCustomEventType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_fims__ContentCustomEventType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying fims__ContentCustomEventType %p -> %p\n", q, p));
	*(fims__ContentCustomEventType*)p = *(fims__ContentCustomEventType*)q;
}

void fims__ContentStatusEventsType::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTofims__ContentStatusEventType(soap, &this->fims__ContentStatusEventsType::contentStatusEvent);
	soap_default_std__vectorTemplateOf_XML(soap, &this->fims__ContentStatusEventsType::__any);
	this->fims__ContentStatusEventsType::__anyAttribute = NULL;
	/* transient soap skipped */
}

void fims__ContentStatusEventsType::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfPointerTofims__ContentStatusEventType(soap, &this->fims__ContentStatusEventsType::contentStatusEvent);
	soap_serialize_std__vectorTemplateOf_XML(soap, &this->fims__ContentStatusEventsType::__any);
	/* transient soap skipped */
#endif
}

int fims__ContentStatusEventsType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_fims__ContentStatusEventsType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_fims__ContentStatusEventsType(struct soap *soap, const char *tag, int id, const fims__ContentStatusEventsType *a, const char *type)
{
	if (((fims__ContentStatusEventsType*)a)->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", ((fims__ContentStatusEventsType*)a)->__anyAttribute, 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_fims__ContentStatusEventsType), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTofims__ContentStatusEventType(soap, "fims:contentStatusEvent", -1, &(a->fims__ContentStatusEventsType::contentStatusEvent), ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOf_XML(soap, "-any", -1, &(a->fims__ContentStatusEventsType::__any), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *fims__ContentStatusEventsType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_fims__ContentStatusEventsType(soap, tag, this, type);
}

SOAP_FMAC3 fims__ContentStatusEventsType * SOAP_FMAC4 soap_in_fims__ContentStatusEventsType(struct soap *soap, const char *tag, fims__ContentStatusEventsType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (fims__ContentStatusEventsType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_fims__ContentStatusEventsType, sizeof(fims__ContentStatusEventsType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_fims__ContentStatusEventsType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (fims__ContentStatusEventsType *)a->soap_in(soap, tag, type);
		}
	}
	if (soap_s2string(soap, soap_attr_value(soap, "-anyAttribute", 0), &((fims__ContentStatusEventsType*)a)->__anyAttribute, 0, -1))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTofims__ContentStatusEventType(soap, "fims:contentStatusEvent", &(a->fims__ContentStatusEventsType::contentStatusEvent), "fims:ContentStatusEventType"))
					continue;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOf_XML(soap, "-any", &(a->fims__ContentStatusEventsType::__any), ""))
					continue;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (fims__ContentStatusEventsType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_fims__ContentStatusEventsType, 0, sizeof(fims__ContentStatusEventsType), 0, soap_copy_fims__ContentStatusEventsType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (a->fims__ContentStatusEventsType::contentStatusEvent.size() < 1))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int fims__ContentStatusEventsType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_fims__ContentStatusEventsType);
	if (this->soap_out(soap, tag?tag:"fims:ContentStatusEventsType", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *fims__ContentStatusEventsType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_fims__ContentStatusEventsType(soap, this, tag, type);
}

SOAP_FMAC3 fims__ContentStatusEventsType * SOAP_FMAC4 soap_get_fims__ContentStatusEventsType(struct soap *soap, fims__ContentStatusEventsType *p, const char *tag, const char *type)
{
	if ((p = soap_in_fims__ContentStatusEventsType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 fims__ContentStatusEventsType * SOAP_FMAC2 soap_instantiate_fims__ContentStatusEventsType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_fims__ContentStatusEventsType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_fims__ContentStatusEventsType, n, EDLProvider_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(fims__ContentStatusEventsType);
		if (size)
			*size = sizeof(fims__ContentStatusEventsType);
		((fims__ContentStatusEventsType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(fims__ContentStatusEventsType, n);
		if (size)
			*size = n * sizeof(fims__ContentStatusEventsType);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((fims__ContentStatusEventsType*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (fims__ContentStatusEventsType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_fims__ContentStatusEventsType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying fims__ContentStatusEventsType %p -> %p\n", q, p));
	*(fims__ContentStatusEventsType*)p = *(fims__ContentStatusEventsType*)q;
}

void fims__ContentStatusEventType::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->fims__ContentEventType::soap_default(soap);
}

void fims__ContentStatusEventType::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	this->fims__ContentEventType::soap_serialize(soap);
#endif
}

int fims__ContentStatusEventType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_fims__ContentStatusEventType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_fims__ContentStatusEventType(struct soap *soap, const char *tag, int id, const fims__ContentStatusEventType *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_fims__ContentStatusEventType), "fims:ContentStatusEventType"))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_PointerTofims__ResourceReferenceType(soap, "fims:targetResourceReference", -1, &(a->fims__ContentEventType::targetResourceReference), ""))
		return soap->error;
	if (soap_out_PointerTofims__ExtensionGroup(soap, "fims:ExtensionGroup", -1, &(a->fims__ContentEventType::ExtensionGroup), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *fims__ContentStatusEventType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_fims__ContentStatusEventType(soap, tag, this, type);
}

SOAP_FMAC3 fims__ContentStatusEventType * SOAP_FMAC4 soap_in_fims__ContentStatusEventType(struct soap *soap, const char *tag, fims__ContentStatusEventType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (fims__ContentStatusEventType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_fims__ContentStatusEventType, sizeof(fims__ContentStatusEventType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_fims__ContentStatusEventType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (fims__ContentStatusEventType *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_targetResourceReference2 = 1;
	size_t soap_flag_ExtensionGroup2 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap_flag_targetResourceReference2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTofims__ResourceReferenceType(soap, "fims:targetResourceReference", &(a->fims__ContentEventType::targetResourceReference), "fims:ResourceReferenceType"))
				{	soap_flag_targetResourceReference2--;
					continue;
				}
			if (soap_flag_ExtensionGroup2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTofims__ExtensionGroup(soap, "fims:ExtensionGroup", &(a->fims__ContentEventType::ExtensionGroup), "fims:ExtensionGroup"))
				{	soap_flag_ExtensionGroup2--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (fims__ContentStatusEventType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_fims__ContentStatusEventType, 0, sizeof(fims__ContentStatusEventType), 0, soap_copy_fims__ContentStatusEventType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int fims__ContentStatusEventType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_fims__ContentStatusEventType);
	if (this->soap_out(soap, tag?tag:"fims:ContentStatusEventType", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *fims__ContentStatusEventType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_fims__ContentStatusEventType(soap, this, tag, type);
}

SOAP_FMAC3 fims__ContentStatusEventType * SOAP_FMAC4 soap_get_fims__ContentStatusEventType(struct soap *soap, fims__ContentStatusEventType *p, const char *tag, const char *type)
{
	if ((p = soap_in_fims__ContentStatusEventType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 fims__ContentStatusEventType * SOAP_FMAC2 soap_instantiate_fims__ContentStatusEventType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_fims__ContentStatusEventType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_fims__ContentStatusEventType, n, EDLProvider_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(fims__ContentStatusEventType);
		if (size)
			*size = sizeof(fims__ContentStatusEventType);
		((fims__ContentStatusEventType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(fims__ContentStatusEventType, n);
		if (size)
			*size = n * sizeof(fims__ContentStatusEventType);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((fims__ContentStatusEventType*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (fims__ContentStatusEventType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_fims__ContentStatusEventType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying fims__ContentStatusEventType %p -> %p\n", q, p));
	*(fims__ContentStatusEventType*)p = *(fims__ContentStatusEventType*)q;
}

void fims__ContentEventsType::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTofims__ContentEventType(soap, &this->fims__ContentEventsType::contentEvent);
	soap_default_std__vectorTemplateOf_XML(soap, &this->fims__ContentEventsType::__any);
	this->fims__ContentEventsType::__anyAttribute = NULL;
	/* transient soap skipped */
}

void fims__ContentEventsType::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfPointerTofims__ContentEventType(soap, &this->fims__ContentEventsType::contentEvent);
	soap_serialize_std__vectorTemplateOf_XML(soap, &this->fims__ContentEventsType::__any);
	/* transient soap skipped */
#endif
}

int fims__ContentEventsType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_fims__ContentEventsType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_fims__ContentEventsType(struct soap *soap, const char *tag, int id, const fims__ContentEventsType *a, const char *type)
{
	if (((fims__ContentEventsType*)a)->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", ((fims__ContentEventsType*)a)->__anyAttribute, 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_fims__ContentEventsType), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTofims__ContentEventType(soap, "fims:contentEvent", -1, &(a->fims__ContentEventsType::contentEvent), ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOf_XML(soap, "-any", -1, &(a->fims__ContentEventsType::__any), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *fims__ContentEventsType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_fims__ContentEventsType(soap, tag, this, type);
}

SOAP_FMAC3 fims__ContentEventsType * SOAP_FMAC4 soap_in_fims__ContentEventsType(struct soap *soap, const char *tag, fims__ContentEventsType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (fims__ContentEventsType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_fims__ContentEventsType, sizeof(fims__ContentEventsType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_fims__ContentEventsType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (fims__ContentEventsType *)a->soap_in(soap, tag, type);
		}
	}
	if (soap_s2string(soap, soap_attr_value(soap, "-anyAttribute", 0), &((fims__ContentEventsType*)a)->__anyAttribute, 0, -1))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTofims__ContentEventType(soap, "fims:contentEvent", &(a->fims__ContentEventsType::contentEvent), "fims:ContentEventType"))
					continue;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOf_XML(soap, "-any", &(a->fims__ContentEventsType::__any), ""))
					continue;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (fims__ContentEventsType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_fims__ContentEventsType, 0, sizeof(fims__ContentEventsType), 0, soap_copy_fims__ContentEventsType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (a->fims__ContentEventsType::contentEvent.size() < 1))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int fims__ContentEventsType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_fims__ContentEventsType);
	if (this->soap_out(soap, tag?tag:"fims:ContentEventsType", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *fims__ContentEventsType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_fims__ContentEventsType(soap, this, tag, type);
}

SOAP_FMAC3 fims__ContentEventsType * SOAP_FMAC4 soap_get_fims__ContentEventsType(struct soap *soap, fims__ContentEventsType *p, const char *tag, const char *type)
{
	if ((p = soap_in_fims__ContentEventsType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 fims__ContentEventsType * SOAP_FMAC2 soap_instantiate_fims__ContentEventsType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_fims__ContentEventsType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_fims__ContentEventsType, n, EDLProvider_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(fims__ContentEventsType);
		if (size)
			*size = sizeof(fims__ContentEventsType);
		((fims__ContentEventsType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(fims__ContentEventsType, n);
		if (size)
			*size = n * sizeof(fims__ContentEventsType);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((fims__ContentEventsType*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (fims__ContentEventsType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_fims__ContentEventsType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying fims__ContentEventsType %p -> %p\n", q, p));
	*(fims__ContentEventsType*)p = *(fims__ContentEventsType*)q;
}

void fims__ContentEventType::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->fims__EventPayloadType::soap_default(soap);
	this->fims__ContentEventType::targetResourceReference = NULL;
	this->fims__ContentEventType::ExtensionGroup = NULL;
}

void fims__ContentEventType::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTofims__ResourceReferenceType(soap, &this->fims__ContentEventType::targetResourceReference);
	soap_serialize_PointerTofims__ExtensionGroup(soap, &this->fims__ContentEventType::ExtensionGroup);
	this->fims__EventPayloadType::soap_serialize(soap);
#endif
}

int fims__ContentEventType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_fims__ContentEventType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_fims__ContentEventType(struct soap *soap, const char *tag, int id, const fims__ContentEventType *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_fims__ContentEventType), "fims:ContentEventType"))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_PointerTofims__ResourceReferenceType(soap, "fims:targetResourceReference", -1, &(a->fims__ContentEventType::targetResourceReference), ""))
		return soap->error;
	if (soap_out_PointerTofims__ExtensionGroup(soap, "fims:ExtensionGroup", -1, &(a->fims__ContentEventType::ExtensionGroup), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *fims__ContentEventType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_fims__ContentEventType(soap, tag, this, type);
}

SOAP_FMAC3 fims__ContentEventType * SOAP_FMAC4 soap_in_fims__ContentEventType(struct soap *soap, const char *tag, fims__ContentEventType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (fims__ContentEventType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_fims__ContentEventType, sizeof(fims__ContentEventType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_fims__ContentEventType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (fims__ContentEventType *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_targetResourceReference1 = 1;
	size_t soap_flag_ExtensionGroup1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap_flag_targetResourceReference1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTofims__ResourceReferenceType(soap, "fims:targetResourceReference", &(a->fims__ContentEventType::targetResourceReference), "fims:ResourceReferenceType"))
				{	soap_flag_targetResourceReference1--;
					continue;
				}
			if (soap_flag_ExtensionGroup1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTofims__ExtensionGroup(soap, "fims:ExtensionGroup", &(a->fims__ContentEventType::ExtensionGroup), "fims:ExtensionGroup"))
				{	soap_flag_ExtensionGroup1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (fims__ContentEventType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_fims__ContentEventType, 0, sizeof(fims__ContentEventType), 0, soap_copy_fims__ContentEventType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int fims__ContentEventType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_fims__ContentEventType);
	if (this->soap_out(soap, tag?tag:"fims:ContentEventType", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *fims__ContentEventType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_fims__ContentEventType(soap, this, tag, type);
}

SOAP_FMAC3 fims__ContentEventType * SOAP_FMAC4 soap_get_fims__ContentEventType(struct soap *soap, fims__ContentEventType *p, const char *tag, const char *type)
{
	if ((p = soap_in_fims__ContentEventType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 fims__ContentEventType * SOAP_FMAC2 soap_instantiate_fims__ContentEventType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_fims__ContentEventType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_fims__ContentEventType, n, EDLProvider_fdelete);
	if (!cp)
		return NULL;
	if (type && !soap_match_tag(soap, type, "fims:ContentStatusEventType"))
	{	cp->type = SOAP_TYPE_fims__ContentStatusEventType;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(fims__ContentStatusEventType);
			if (size)
				*size = sizeof(fims__ContentStatusEventType);
			((fims__ContentStatusEventType*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW_ARRAY(fims__ContentStatusEventType, n);
			if (size)
				*size = n * sizeof(fims__ContentStatusEventType);
			if (cp->ptr)
				for (int i = 0; i < n; i++)
					((fims__ContentStatusEventType*)cp->ptr)[i].soap = soap;
		}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		if (!cp->ptr)
			soap->error = SOAP_EOM;
		return (fims__ContentStatusEventType*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "fims:ContentCustomEventType"))
	{	cp->type = SOAP_TYPE_fims__ContentCustomEventType;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(fims__ContentCustomEventType);
			if (size)
				*size = sizeof(fims__ContentCustomEventType);
			((fims__ContentCustomEventType*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW_ARRAY(fims__ContentCustomEventType, n);
			if (size)
				*size = n * sizeof(fims__ContentCustomEventType);
			if (cp->ptr)
				for (int i = 0; i < n; i++)
					((fims__ContentCustomEventType*)cp->ptr)[i].soap = soap;
		}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		if (!cp->ptr)
			soap->error = SOAP_EOM;
		return (fims__ContentCustomEventType*)cp->ptr;
	}
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(fims__ContentEventType);
		if (size)
			*size = sizeof(fims__ContentEventType);
		((fims__ContentEventType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(fims__ContentEventType, n);
		if (size)
			*size = n * sizeof(fims__ContentEventType);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((fims__ContentEventType*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (fims__ContentEventType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_fims__ContentEventType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying fims__ContentEventType %p -> %p\n", q, p));
	*(fims__ContentEventType*)p = *(fims__ContentEventType*)q;
}

void fims__EventPayloadsType::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTofims__EventPayloadType(soap, &this->fims__EventPayloadsType::eventPayload);
	soap_default_std__vectorTemplateOf_XML(soap, &this->fims__EventPayloadsType::__any);
	this->fims__EventPayloadsType::__anyAttribute = NULL;
	/* transient soap skipped */
}

void fims__EventPayloadsType::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfPointerTofims__EventPayloadType(soap, &this->fims__EventPayloadsType::eventPayload);
	soap_serialize_std__vectorTemplateOf_XML(soap, &this->fims__EventPayloadsType::__any);
	/* transient soap skipped */
#endif
}

int fims__EventPayloadsType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_fims__EventPayloadsType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_fims__EventPayloadsType(struct soap *soap, const char *tag, int id, const fims__EventPayloadsType *a, const char *type)
{
	if (((fims__EventPayloadsType*)a)->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", ((fims__EventPayloadsType*)a)->__anyAttribute, 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_fims__EventPayloadsType), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTofims__EventPayloadType(soap, "fims:eventPayload", -1, &(a->fims__EventPayloadsType::eventPayload), ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOf_XML(soap, "-any", -1, &(a->fims__EventPayloadsType::__any), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *fims__EventPayloadsType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_fims__EventPayloadsType(soap, tag, this, type);
}

SOAP_FMAC3 fims__EventPayloadsType * SOAP_FMAC4 soap_in_fims__EventPayloadsType(struct soap *soap, const char *tag, fims__EventPayloadsType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (fims__EventPayloadsType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_fims__EventPayloadsType, sizeof(fims__EventPayloadsType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_fims__EventPayloadsType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (fims__EventPayloadsType *)a->soap_in(soap, tag, type);
		}
	}
	if (soap_s2string(soap, soap_attr_value(soap, "-anyAttribute", 0), &((fims__EventPayloadsType*)a)->__anyAttribute, 0, -1))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTofims__EventPayloadType(soap, "fims:eventPayload", &(a->fims__EventPayloadsType::eventPayload), "fims:EventPayloadType"))
					continue;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOf_XML(soap, "-any", &(a->fims__EventPayloadsType::__any), ""))
					continue;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (fims__EventPayloadsType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_fims__EventPayloadsType, 0, sizeof(fims__EventPayloadsType), 0, soap_copy_fims__EventPayloadsType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (a->fims__EventPayloadsType::eventPayload.size() < 1))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int fims__EventPayloadsType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_fims__EventPayloadsType);
	if (this->soap_out(soap, tag?tag:"fims:EventPayloadsType", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *fims__EventPayloadsType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_fims__EventPayloadsType(soap, this, tag, type);
}

SOAP_FMAC3 fims__EventPayloadsType * SOAP_FMAC4 soap_get_fims__EventPayloadsType(struct soap *soap, fims__EventPayloadsType *p, const char *tag, const char *type)
{
	if ((p = soap_in_fims__EventPayloadsType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 fims__EventPayloadsType * SOAP_FMAC2 soap_instantiate_fims__EventPayloadsType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_fims__EventPayloadsType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_fims__EventPayloadsType, n, EDLProvider_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(fims__EventPayloadsType);
		if (size)
			*size = sizeof(fims__EventPayloadsType);
		((fims__EventPayloadsType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(fims__EventPayloadsType, n);
		if (size)
			*size = n * sizeof(fims__EventPayloadsType);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((fims__EventPayloadsType*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (fims__EventPayloadsType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_fims__EventPayloadsType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying fims__EventPayloadsType %p -> %p\n", q, p));
	*(fims__EventPayloadsType*)p = *(fims__EventPayloadsType*)q;
}

void fims__EventPayloadType::soap_default(struct soap *soap)
{
	this->soap = soap;
	/* transient soap skipped */
}

void fims__EventPayloadType::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
#endif
}

int fims__EventPayloadType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_fims__EventPayloadType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_fims__EventPayloadType(struct soap *soap, const char *tag, int id, const fims__EventPayloadType *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_fims__EventPayloadType), type))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *fims__EventPayloadType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_fims__EventPayloadType(soap, tag, this, type);
}

SOAP_FMAC3 fims__EventPayloadType * SOAP_FMAC4 soap_in_fims__EventPayloadType(struct soap *soap, const char *tag, fims__EventPayloadType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (fims__EventPayloadType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_fims__EventPayloadType, sizeof(fims__EventPayloadType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_fims__EventPayloadType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (fims__EventPayloadType *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (fims__EventPayloadType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_fims__EventPayloadType, 0, sizeof(fims__EventPayloadType), 0, soap_copy_fims__EventPayloadType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int fims__EventPayloadType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_fims__EventPayloadType);
	if (this->soap_out(soap, tag?tag:"fims:EventPayloadType", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *fims__EventPayloadType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_fims__EventPayloadType(soap, this, tag, type);
}

SOAP_FMAC3 fims__EventPayloadType * SOAP_FMAC4 soap_get_fims__EventPayloadType(struct soap *soap, fims__EventPayloadType *p, const char *tag, const char *type)
{
	if ((p = soap_in_fims__EventPayloadType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 fims__EventPayloadType * SOAP_FMAC2 soap_instantiate_fims__EventPayloadType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_fims__EventPayloadType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_fims__EventPayloadType, n, EDLProvider_fdelete);
	if (!cp)
		return NULL;
	if (type && !soap_match_tag(soap, type, "fims:ContentEventType"))
	{	cp->type = SOAP_TYPE_fims__ContentEventType;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(fims__ContentEventType);
			if (size)
				*size = sizeof(fims__ContentEventType);
			((fims__ContentEventType*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW_ARRAY(fims__ContentEventType, n);
			if (size)
				*size = n * sizeof(fims__ContentEventType);
			if (cp->ptr)
				for (int i = 0; i < n; i++)
					((fims__ContentEventType*)cp->ptr)[i].soap = soap;
		}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		if (!cp->ptr)
			soap->error = SOAP_EOM;
		return (fims__ContentEventType*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "fims:SystemEventType"))
	{	cp->type = SOAP_TYPE_fims__SystemEventType;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(fims__SystemEventType);
			if (size)
				*size = sizeof(fims__SystemEventType);
			((fims__SystemEventType*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW_ARRAY(fims__SystemEventType, n);
			if (size)
				*size = n * sizeof(fims__SystemEventType);
			if (cp->ptr)
				for (int i = 0; i < n; i++)
					((fims__SystemEventType*)cp->ptr)[i].soap = soap;
		}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		if (!cp->ptr)
			soap->error = SOAP_EOM;
		return (fims__SystemEventType*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "fims:ContentStatusEventType"))
	{	cp->type = SOAP_TYPE_fims__ContentStatusEventType;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(fims__ContentStatusEventType);
			if (size)
				*size = sizeof(fims__ContentStatusEventType);
			((fims__ContentStatusEventType*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW_ARRAY(fims__ContentStatusEventType, n);
			if (size)
				*size = n * sizeof(fims__ContentStatusEventType);
			if (cp->ptr)
				for (int i = 0; i < n; i++)
					((fims__ContentStatusEventType*)cp->ptr)[i].soap = soap;
		}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		if (!cp->ptr)
			soap->error = SOAP_EOM;
		return (fims__ContentStatusEventType*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "fims:ContentCustomEventType"))
	{	cp->type = SOAP_TYPE_fims__ContentCustomEventType;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(fims__ContentCustomEventType);
			if (size)
				*size = sizeof(fims__ContentCustomEventType);
			((fims__ContentCustomEventType*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW_ARRAY(fims__ContentCustomEventType, n);
			if (size)
				*size = n * sizeof(fims__ContentCustomEventType);
			if (cp->ptr)
				for (int i = 0; i < n; i++)
					((fims__ContentCustomEventType*)cp->ptr)[i].soap = soap;
		}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		if (!cp->ptr)
			soap->error = SOAP_EOM;
		return (fims__ContentCustomEventType*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "fims:SystemExceptionEventType"))
	{	cp->type = SOAP_TYPE_fims__SystemExceptionEventType;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(fims__SystemExceptionEventType);
			if (size)
				*size = sizeof(fims__SystemExceptionEventType);
			((fims__SystemExceptionEventType*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW_ARRAY(fims__SystemExceptionEventType, n);
			if (size)
				*size = n * sizeof(fims__SystemExceptionEventType);
			if (cp->ptr)
				for (int i = 0; i < n; i++)
					((fims__SystemExceptionEventType*)cp->ptr)[i].soap = soap;
		}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		if (!cp->ptr)
			soap->error = SOAP_EOM;
		return (fims__SystemExceptionEventType*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "fims:SystemPerformanceEventType"))
	{	cp->type = SOAP_TYPE_fims__SystemPerformanceEventType;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(fims__SystemPerformanceEventType);
			if (size)
				*size = sizeof(fims__SystemPerformanceEventType);
			((fims__SystemPerformanceEventType*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW_ARRAY(fims__SystemPerformanceEventType, n);
			if (size)
				*size = n * sizeof(fims__SystemPerformanceEventType);
			if (cp->ptr)
				for (int i = 0; i < n; i++)
					((fims__SystemPerformanceEventType*)cp->ptr)[i].soap = soap;
		}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		if (!cp->ptr)
			soap->error = SOAP_EOM;
		return (fims__SystemPerformanceEventType*)cp->ptr;
	}
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(fims__EventPayloadType);
		if (size)
			*size = sizeof(fims__EventPayloadType);
		((fims__EventPayloadType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(fims__EventPayloadType, n);
		if (size)
			*size = n * sizeof(fims__EventPayloadType);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((fims__EventPayloadType*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (fims__EventPayloadType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_fims__EventPayloadType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying fims__EventPayloadType %p -> %p\n", q, p));
	*(fims__EventPayloadType*)p = *(fims__EventPayloadType*)q;
}

void fims__EventEnvelopesType::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTofims__EventEnvelopeType(soap, &this->fims__EventEnvelopesType::eventEnvelope);
	soap_default_std__vectorTemplateOf_XML(soap, &this->fims__EventEnvelopesType::__any);
	this->fims__EventEnvelopesType::__anyAttribute = NULL;
	/* transient soap skipped */
}

void fims__EventEnvelopesType::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfPointerTofims__EventEnvelopeType(soap, &this->fims__EventEnvelopesType::eventEnvelope);
	soap_serialize_std__vectorTemplateOf_XML(soap, &this->fims__EventEnvelopesType::__any);
	/* transient soap skipped */
#endif
}

int fims__EventEnvelopesType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_fims__EventEnvelopesType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_fims__EventEnvelopesType(struct soap *soap, const char *tag, int id, const fims__EventEnvelopesType *a, const char *type)
{
	if (((fims__EventEnvelopesType*)a)->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", ((fims__EventEnvelopesType*)a)->__anyAttribute, 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_fims__EventEnvelopesType), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTofims__EventEnvelopeType(soap, "fims:eventEnvelope", -1, &(a->fims__EventEnvelopesType::eventEnvelope), ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOf_XML(soap, "-any", -1, &(a->fims__EventEnvelopesType::__any), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *fims__EventEnvelopesType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_fims__EventEnvelopesType(soap, tag, this, type);
}

SOAP_FMAC3 fims__EventEnvelopesType * SOAP_FMAC4 soap_in_fims__EventEnvelopesType(struct soap *soap, const char *tag, fims__EventEnvelopesType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (fims__EventEnvelopesType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_fims__EventEnvelopesType, sizeof(fims__EventEnvelopesType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_fims__EventEnvelopesType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (fims__EventEnvelopesType *)a->soap_in(soap, tag, type);
		}
	}
	if (soap_s2string(soap, soap_attr_value(soap, "-anyAttribute", 0), &((fims__EventEnvelopesType*)a)->__anyAttribute, 0, -1))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTofims__EventEnvelopeType(soap, "fims:eventEnvelope", &(a->fims__EventEnvelopesType::eventEnvelope), "fims:EventEnvelopeType"))
					continue;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOf_XML(soap, "-any", &(a->fims__EventEnvelopesType::__any), ""))
					continue;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (fims__EventEnvelopesType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_fims__EventEnvelopesType, 0, sizeof(fims__EventEnvelopesType), 0, soap_copy_fims__EventEnvelopesType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (a->fims__EventEnvelopesType::eventEnvelope.size() < 1))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int fims__EventEnvelopesType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_fims__EventEnvelopesType);
	if (this->soap_out(soap, tag?tag:"fims:EventEnvelopesType", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *fims__EventEnvelopesType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_fims__EventEnvelopesType(soap, this, tag, type);
}

SOAP_FMAC3 fims__EventEnvelopesType * SOAP_FMAC4 soap_get_fims__EventEnvelopesType(struct soap *soap, fims__EventEnvelopesType *p, const char *tag, const char *type)
{
	if ((p = soap_in_fims__EventEnvelopesType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 fims__EventEnvelopesType * SOAP_FMAC2 soap_instantiate_fims__EventEnvelopesType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_fims__EventEnvelopesType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_fims__EventEnvelopesType, n, EDLProvider_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(fims__EventEnvelopesType);
		if (size)
			*size = sizeof(fims__EventEnvelopesType);
		((fims__EventEnvelopesType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(fims__EventEnvelopesType, n);
		if (size)
			*size = n * sizeof(fims__EventEnvelopesType);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((fims__EventEnvelopesType*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (fims__EventEnvelopesType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_fims__EventEnvelopesType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying fims__EventEnvelopesType %p -> %p\n", q, p));
	*(fims__EventEnvelopesType*)p = *(fims__EventEnvelopesType*)q;
}

void fims__EventEnvelopeType::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->fims__EventEnvelopeType::timestamp = NULL;
	this->fims__EventEnvelopeType::eventType = NULL;
	this->fims__EventEnvelopeType::eventSubType = NULL;
	this->fims__EventEnvelopeType::eventClassification = NULL;
	this->fims__EventEnvelopeType::eventPayload = NULL;
	soap_default_fims__CurrentVersion(soap, &this->fims__EventEnvelopeType::version);
	/* transient soap skipped */
}

void fims__EventEnvelopeType::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTotime(soap, &this->fims__EventEnvelopeType::timestamp);
	soap_serialize_PointerTofims__EventType(soap, &this->fims__EventEnvelopeType::eventType);
	soap_serialize_PointerTofims__EventSubType(soap, &this->fims__EventEnvelopeType::eventSubType);
	soap_serialize_PointerTofims__EventClassificationType(soap, &this->fims__EventEnvelopeType::eventClassification);
	soap_serialize_PointerTofims__EventPayloadType(soap, &this->fims__EventEnvelopeType::eventPayload);
	/* transient soap skipped */
#endif
}

int fims__EventEnvelopeType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_fims__EventEnvelopeType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_fims__EventEnvelopeType(struct soap *soap, const char *tag, int id, const fims__EventEnvelopeType *a, const char *type)
{
	soap_set_attr(soap, "version", soap_fims__CurrentVersion2s(soap, ((fims__EventEnvelopeType*)a)->version), 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_fims__EventEnvelopeType), type))
		return soap->error;
	if (soap_out_PointerTotime(soap, "fims:timestamp", -1, &(a->fims__EventEnvelopeType::timestamp), ""))
		return soap->error;
	if (soap_out_PointerTofims__EventType(soap, "fims:eventType", -1, &(a->fims__EventEnvelopeType::eventType), ""))
		return soap->error;
	if (soap_out_PointerTofims__EventSubType(soap, "fims:eventSubType", -1, &(a->fims__EventEnvelopeType::eventSubType), ""))
		return soap->error;
	if (soap_out_PointerTofims__EventClassificationType(soap, "fims:eventClassification", -1, &(a->fims__EventEnvelopeType::eventClassification), ""))
		return soap->error;
	if (soap_out_PointerTofims__EventPayloadType(soap, "fims:eventPayload", -1, &(a->fims__EventEnvelopeType::eventPayload), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *fims__EventEnvelopeType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_fims__EventEnvelopeType(soap, tag, this, type);
}

SOAP_FMAC3 fims__EventEnvelopeType * SOAP_FMAC4 soap_in_fims__EventEnvelopeType(struct soap *soap, const char *tag, fims__EventEnvelopeType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (fims__EventEnvelopeType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_fims__EventEnvelopeType, sizeof(fims__EventEnvelopeType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_fims__EventEnvelopeType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (fims__EventEnvelopeType *)a->soap_in(soap, tag, type);
		}
	}
	if (soap_s2fims__CurrentVersion(soap, soap_attr_value(soap, "version", 1), &((fims__EventEnvelopeType*)a)->version))
		return NULL;
	size_t soap_flag_timestamp1 = 1;
	size_t soap_flag_eventType1 = 1;
	size_t soap_flag_eventSubType1 = 1;
	size_t soap_flag_eventClassification1 = 1;
	size_t soap_flag_eventPayload1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_timestamp1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTotime(soap, "fims:timestamp", &(a->fims__EventEnvelopeType::timestamp), "xsd:dateTime"))
				{	soap_flag_timestamp1--;
					continue;
				}
			if (soap_flag_eventType1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTofims__EventType(soap, "fims:eventType", &(a->fims__EventEnvelopeType::eventType), "fims:EventType"))
				{	soap_flag_eventType1--;
					continue;
				}
			if (soap_flag_eventSubType1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTofims__EventSubType(soap, "fims:eventSubType", &(a->fims__EventEnvelopeType::eventSubType), "fims:EventSubType"))
				{	soap_flag_eventSubType1--;
					continue;
				}
			if (soap_flag_eventClassification1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTofims__EventClassificationType(soap, "fims:eventClassification", &(a->fims__EventEnvelopeType::eventClassification), "fims:EventClassificationType"))
				{	soap_flag_eventClassification1--;
					continue;
				}
			if (soap_flag_eventPayload1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTofims__EventPayloadType(soap, "fims:eventPayload", &(a->fims__EventEnvelopeType::eventPayload), "fims:EventPayloadType"))
				{	soap_flag_eventPayload1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (fims__EventEnvelopeType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_fims__EventEnvelopeType, 0, sizeof(fims__EventEnvelopeType), 0, soap_copy_fims__EventEnvelopeType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int fims__EventEnvelopeType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_fims__EventEnvelopeType);
	if (this->soap_out(soap, tag?tag:"fims:EventEnvelopeType", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *fims__EventEnvelopeType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_fims__EventEnvelopeType(soap, this, tag, type);
}

SOAP_FMAC3 fims__EventEnvelopeType * SOAP_FMAC4 soap_get_fims__EventEnvelopeType(struct soap *soap, fims__EventEnvelopeType *p, const char *tag, const char *type)
{
	if ((p = soap_in_fims__EventEnvelopeType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 fims__EventEnvelopeType * SOAP_FMAC2 soap_instantiate_fims__EventEnvelopeType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_fims__EventEnvelopeType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_fims__EventEnvelopeType, n, EDLProvider_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(fims__EventEnvelopeType);
		if (size)
			*size = sizeof(fims__EventEnvelopeType);
		((fims__EventEnvelopeType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(fims__EventEnvelopeType, n);
		if (size)
			*size = n * sizeof(fims__EventEnvelopeType);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((fims__EventEnvelopeType*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (fims__EventEnvelopeType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_fims__EventEnvelopeType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying fims__EventEnvelopeType %p -> %p\n", q, p));
	*(fims__EventEnvelopeType*)p = *(fims__EventEnvelopeType*)q;
}

void fims__CustomEventTemplatesType::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTofims__CustomEventTemplateType(soap, &this->fims__CustomEventTemplatesType::customEventTemplate);
	soap_default_std__vectorTemplateOf_XML(soap, &this->fims__CustomEventTemplatesType::__any);
	this->fims__CustomEventTemplatesType::__anyAttribute = NULL;
	/* transient soap skipped */
}

void fims__CustomEventTemplatesType::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfPointerTofims__CustomEventTemplateType(soap, &this->fims__CustomEventTemplatesType::customEventTemplate);
	soap_serialize_std__vectorTemplateOf_XML(soap, &this->fims__CustomEventTemplatesType::__any);
	/* transient soap skipped */
#endif
}

int fims__CustomEventTemplatesType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_fims__CustomEventTemplatesType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_fims__CustomEventTemplatesType(struct soap *soap, const char *tag, int id, const fims__CustomEventTemplatesType *a, const char *type)
{
	if (((fims__CustomEventTemplatesType*)a)->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", ((fims__CustomEventTemplatesType*)a)->__anyAttribute, 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_fims__CustomEventTemplatesType), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTofims__CustomEventTemplateType(soap, "fims:customEventTemplate", -1, &(a->fims__CustomEventTemplatesType::customEventTemplate), ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOf_XML(soap, "-any", -1, &(a->fims__CustomEventTemplatesType::__any), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *fims__CustomEventTemplatesType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_fims__CustomEventTemplatesType(soap, tag, this, type);
}

SOAP_FMAC3 fims__CustomEventTemplatesType * SOAP_FMAC4 soap_in_fims__CustomEventTemplatesType(struct soap *soap, const char *tag, fims__CustomEventTemplatesType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (fims__CustomEventTemplatesType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_fims__CustomEventTemplatesType, sizeof(fims__CustomEventTemplatesType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_fims__CustomEventTemplatesType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (fims__CustomEventTemplatesType *)a->soap_in(soap, tag, type);
		}
	}
	if (soap_s2string(soap, soap_attr_value(soap, "-anyAttribute", 0), &((fims__CustomEventTemplatesType*)a)->__anyAttribute, 0, -1))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTofims__CustomEventTemplateType(soap, "fims:customEventTemplate", &(a->fims__CustomEventTemplatesType::customEventTemplate), "fims:CustomEventTemplateType"))
					continue;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOf_XML(soap, "-any", &(a->fims__CustomEventTemplatesType::__any), ""))
					continue;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (fims__CustomEventTemplatesType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_fims__CustomEventTemplatesType, 0, sizeof(fims__CustomEventTemplatesType), 0, soap_copy_fims__CustomEventTemplatesType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (a->fims__CustomEventTemplatesType::customEventTemplate.size() < 1))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int fims__CustomEventTemplatesType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_fims__CustomEventTemplatesType);
	if (this->soap_out(soap, tag?tag:"fims:CustomEventTemplatesType", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *fims__CustomEventTemplatesType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_fims__CustomEventTemplatesType(soap, this, tag, type);
}

SOAP_FMAC3 fims__CustomEventTemplatesType * SOAP_FMAC4 soap_get_fims__CustomEventTemplatesType(struct soap *soap, fims__CustomEventTemplatesType *p, const char *tag, const char *type)
{
	if ((p = soap_in_fims__CustomEventTemplatesType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 fims__CustomEventTemplatesType * SOAP_FMAC2 soap_instantiate_fims__CustomEventTemplatesType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_fims__CustomEventTemplatesType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_fims__CustomEventTemplatesType, n, EDLProvider_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(fims__CustomEventTemplatesType);
		if (size)
			*size = sizeof(fims__CustomEventTemplatesType);
		((fims__CustomEventTemplatesType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(fims__CustomEventTemplatesType, n);
		if (size)
			*size = n * sizeof(fims__CustomEventTemplatesType);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((fims__CustomEventTemplatesType*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (fims__CustomEventTemplatesType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_fims__CustomEventTemplatesType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying fims__CustomEventTemplatesType %p -> %p\n", q, p));
	*(fims__CustomEventTemplatesType*)p = *(fims__CustomEventTemplatesType*)q;
}

void fims__CustomEventTemplateType::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->fims__CustomEventTemplateType::templateID = NULL;
	soap_default_std__wstring(soap, &this->fims__CustomEventTemplateType::name);
	this->fims__CustomEventTemplateType::parameters = NULL;
	/* transient soap skipped */
}

void fims__CustomEventTemplateType::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTofims__ResourceIDType(soap, &this->fims__CustomEventTemplateType::templateID);
	soap_embedded(soap, &this->fims__CustomEventTemplateType::name, SOAP_TYPE_std__wstring);
	soap_serialize_std__wstring(soap, &this->fims__CustomEventTemplateType::name);
	soap_serialize_PointerTofims__QueryExpressionsType(soap, &this->fims__CustomEventTemplateType::parameters);
	/* transient soap skipped */
#endif
}

int fims__CustomEventTemplateType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_fims__CustomEventTemplateType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_fims__CustomEventTemplateType(struct soap *soap, const char *tag, int id, const fims__CustomEventTemplateType *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_fims__CustomEventTemplateType), type))
		return soap->error;
	if (soap_out_PointerTofims__ResourceIDType(soap, "fims:templateID", -1, &(a->fims__CustomEventTemplateType::templateID), ""))
		return soap->error;
	if (soap_out_std__wstring(soap, "fims:name", -1, &(a->fims__CustomEventTemplateType::name), ""))
		return soap->error;
	if (soap_out_PointerTofims__QueryExpressionsType(soap, "fims:parameters", -1, &(a->fims__CustomEventTemplateType::parameters), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *fims__CustomEventTemplateType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_fims__CustomEventTemplateType(soap, tag, this, type);
}

SOAP_FMAC3 fims__CustomEventTemplateType * SOAP_FMAC4 soap_in_fims__CustomEventTemplateType(struct soap *soap, const char *tag, fims__CustomEventTemplateType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (fims__CustomEventTemplateType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_fims__CustomEventTemplateType, sizeof(fims__CustomEventTemplateType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_fims__CustomEventTemplateType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (fims__CustomEventTemplateType *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_templateID1 = 1;
	size_t soap_flag_name1 = 1;
	size_t soap_flag_parameters1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_templateID1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTofims__ResourceIDType(soap, "fims:templateID", &(a->fims__CustomEventTemplateType::templateID), "fims:ResourceIDType"))
				{	soap_flag_templateID1--;
					continue;
				}
			if (soap_flag_name1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__wstring(soap, "fims:name", &(a->fims__CustomEventTemplateType::name), "xsd:string"))
				{	soap_flag_name1--;
					continue;
				}
			if (soap_flag_parameters1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTofims__QueryExpressionsType(soap, "fims:parameters", &(a->fims__CustomEventTemplateType::parameters), "fims:QueryExpressionsType"))
				{	soap_flag_parameters1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (fims__CustomEventTemplateType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_fims__CustomEventTemplateType, 0, sizeof(fims__CustomEventTemplateType), 0, soap_copy_fims__CustomEventTemplateType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_name1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int fims__CustomEventTemplateType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_fims__CustomEventTemplateType);
	if (this->soap_out(soap, tag?tag:"fims:CustomEventTemplateType", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *fims__CustomEventTemplateType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_fims__CustomEventTemplateType(soap, this, tag, type);
}

SOAP_FMAC3 fims__CustomEventTemplateType * SOAP_FMAC4 soap_get_fims__CustomEventTemplateType(struct soap *soap, fims__CustomEventTemplateType *p, const char *tag, const char *type)
{
	if ((p = soap_in_fims__CustomEventTemplateType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 fims__CustomEventTemplateType * SOAP_FMAC2 soap_instantiate_fims__CustomEventTemplateType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_fims__CustomEventTemplateType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_fims__CustomEventTemplateType, n, EDLProvider_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(fims__CustomEventTemplateType);
		if (size)
			*size = sizeof(fims__CustomEventTemplateType);
		((fims__CustomEventTemplateType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(fims__CustomEventTemplateType, n);
		if (size)
			*size = n * sizeof(fims__CustomEventTemplateType);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((fims__CustomEventTemplateType*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (fims__CustomEventTemplateType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_fims__CustomEventTemplateType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying fims__CustomEventTemplateType %p -> %p\n", q, p));
	*(fims__CustomEventTemplateType*)p = *(fims__CustomEventTemplateType*)q;
}

void fims__QueryGroupsType::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTofims__QueryGroupType(soap, &this->fims__QueryGroupsType::queryGroup);
	soap_default_std__vectorTemplateOf_XML(soap, &this->fims__QueryGroupsType::__any);
	this->fims__QueryGroupsType::__anyAttribute = NULL;
	/* transient soap skipped */
}

void fims__QueryGroupsType::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfPointerTofims__QueryGroupType(soap, &this->fims__QueryGroupsType::queryGroup);
	soap_serialize_std__vectorTemplateOf_XML(soap, &this->fims__QueryGroupsType::__any);
	/* transient soap skipped */
#endif
}

int fims__QueryGroupsType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_fims__QueryGroupsType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_fims__QueryGroupsType(struct soap *soap, const char *tag, int id, const fims__QueryGroupsType *a, const char *type)
{
	if (((fims__QueryGroupsType*)a)->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", ((fims__QueryGroupsType*)a)->__anyAttribute, 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_fims__QueryGroupsType), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTofims__QueryGroupType(soap, "fims:queryGroup", -1, &(a->fims__QueryGroupsType::queryGroup), ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOf_XML(soap, "-any", -1, &(a->fims__QueryGroupsType::__any), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *fims__QueryGroupsType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_fims__QueryGroupsType(soap, tag, this, type);
}

SOAP_FMAC3 fims__QueryGroupsType * SOAP_FMAC4 soap_in_fims__QueryGroupsType(struct soap *soap, const char *tag, fims__QueryGroupsType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (fims__QueryGroupsType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_fims__QueryGroupsType, sizeof(fims__QueryGroupsType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_fims__QueryGroupsType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (fims__QueryGroupsType *)a->soap_in(soap, tag, type);
		}
	}
	if (soap_s2string(soap, soap_attr_value(soap, "-anyAttribute", 0), &((fims__QueryGroupsType*)a)->__anyAttribute, 0, -1))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTofims__QueryGroupType(soap, "fims:queryGroup", &(a->fims__QueryGroupsType::queryGroup), "fims:QueryGroupType"))
					continue;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOf_XML(soap, "-any", &(a->fims__QueryGroupsType::__any), ""))
					continue;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (fims__QueryGroupsType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_fims__QueryGroupsType, 0, sizeof(fims__QueryGroupsType), 0, soap_copy_fims__QueryGroupsType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (a->fims__QueryGroupsType::queryGroup.size() < 1))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int fims__QueryGroupsType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_fims__QueryGroupsType);
	if (this->soap_out(soap, tag?tag:"fims:QueryGroupsType", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *fims__QueryGroupsType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_fims__QueryGroupsType(soap, this, tag, type);
}

SOAP_FMAC3 fims__QueryGroupsType * SOAP_FMAC4 soap_get_fims__QueryGroupsType(struct soap *soap, fims__QueryGroupsType *p, const char *tag, const char *type)
{
	if ((p = soap_in_fims__QueryGroupsType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 fims__QueryGroupsType * SOAP_FMAC2 soap_instantiate_fims__QueryGroupsType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_fims__QueryGroupsType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_fims__QueryGroupsType, n, EDLProvider_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(fims__QueryGroupsType);
		if (size)
			*size = sizeof(fims__QueryGroupsType);
		((fims__QueryGroupsType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(fims__QueryGroupsType, n);
		if (size)
			*size = n * sizeof(fims__QueryGroupsType);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((fims__QueryGroupsType*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (fims__QueryGroupsType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_fims__QueryGroupsType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying fims__QueryGroupsType %p -> %p\n", q, p));
	*(fims__QueryGroupsType*)p = *(fims__QueryGroupsType*)q;
}

void fims__QueryGroupType::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->fims__QueryGroupType::parameters = NULL;
	this->fims__QueryGroupType::groups = NULL;
	this->fims__QueryGroupType::__union_QueryGroupType = 0;
	/* transient soap skipped */
}

void fims__QueryGroupType::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTofims__QueryParametersType(soap, &this->fims__QueryGroupType::parameters);
	soap_serialize_PointerTofims__QueryGroupsType(soap, &this->fims__QueryGroupType::groups);
	soap_serialize__fims__union_QueryGroupType(soap, this->fims__QueryGroupType::__union_QueryGroupType, &this->fims__QueryGroupType::union_QueryGroupType);
	/* transient soap skipped */
#endif
}

int fims__QueryGroupType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_fims__QueryGroupType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_fims__QueryGroupType(struct soap *soap, const char *tag, int id, const fims__QueryGroupType *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_fims__QueryGroupType), type))
		return soap->error;
	if (soap_out_PointerTofims__QueryParametersType(soap, "fims:parameters", -1, &(a->fims__QueryGroupType::parameters), ""))
		return soap->error;
	if (soap_out_PointerTofims__QueryGroupsType(soap, "fims:groups", -1, &(a->fims__QueryGroupType::groups), ""))
		return soap->error;
	if (soap_out__fims__union_QueryGroupType(soap, a->fims__QueryGroupType::__union_QueryGroupType, &a->fims__QueryGroupType::union_QueryGroupType))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *fims__QueryGroupType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_fims__QueryGroupType(soap, tag, this, type);
}

SOAP_FMAC3 fims__QueryGroupType * SOAP_FMAC4 soap_in_fims__QueryGroupType(struct soap *soap, const char *tag, fims__QueryGroupType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (fims__QueryGroupType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_fims__QueryGroupType, sizeof(fims__QueryGroupType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_fims__QueryGroupType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (fims__QueryGroupType *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_parameters1 = 1;
	size_t soap_flag_groups1 = 1;
	size_t soap_flag_union_QueryGroupType1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_parameters1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTofims__QueryParametersType(soap, "fims:parameters", &(a->fims__QueryGroupType::parameters), "fims:QueryParametersType"))
				{	soap_flag_parameters1--;
					continue;
				}
			if (soap_flag_groups1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTofims__QueryGroupsType(soap, "fims:groups", &(a->fims__QueryGroupType::groups), "fims:QueryGroupsType"))
				{	soap_flag_groups1--;
					continue;
				}
			if (soap_flag_union_QueryGroupType1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in__fims__union_QueryGroupType(soap, &a->fims__QueryGroupType::__union_QueryGroupType, &a->fims__QueryGroupType::union_QueryGroupType))
				{	soap_flag_union_QueryGroupType1 = 0;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (fims__QueryGroupType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_fims__QueryGroupType, 0, sizeof(fims__QueryGroupType), 0, soap_copy_fims__QueryGroupType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int fims__QueryGroupType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_fims__QueryGroupType);
	if (this->soap_out(soap, tag?tag:"fims:QueryGroupType", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *fims__QueryGroupType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_fims__QueryGroupType(soap, this, tag, type);
}

SOAP_FMAC3 fims__QueryGroupType * SOAP_FMAC4 soap_get_fims__QueryGroupType(struct soap *soap, fims__QueryGroupType *p, const char *tag, const char *type)
{
	if ((p = soap_in_fims__QueryGroupType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 fims__QueryGroupType * SOAP_FMAC2 soap_instantiate_fims__QueryGroupType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_fims__QueryGroupType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_fims__QueryGroupType, n, EDLProvider_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(fims__QueryGroupType);
		if (size)
			*size = sizeof(fims__QueryGroupType);
		((fims__QueryGroupType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(fims__QueryGroupType, n);
		if (size)
			*size = n * sizeof(fims__QueryGroupType);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((fims__QueryGroupType*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (fims__QueryGroupType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_fims__QueryGroupType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying fims__QueryGroupType %p -> %p\n", q, p));
	*(fims__QueryGroupType*)p = *(fims__QueryGroupType*)q;
}

void fims__CustomQueryGroupOperatorsType::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTofims__CustomQueryGroupOperatorType(soap, &this->fims__CustomQueryGroupOperatorsType::customQueryGroupOperator);
	soap_default_std__vectorTemplateOf_XML(soap, &this->fims__CustomQueryGroupOperatorsType::__any);
	this->fims__CustomQueryGroupOperatorsType::__anyAttribute = NULL;
	/* transient soap skipped */
}

void fims__CustomQueryGroupOperatorsType::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfPointerTofims__CustomQueryGroupOperatorType(soap, &this->fims__CustomQueryGroupOperatorsType::customQueryGroupOperator);
	soap_serialize_std__vectorTemplateOf_XML(soap, &this->fims__CustomQueryGroupOperatorsType::__any);
	/* transient soap skipped */
#endif
}

int fims__CustomQueryGroupOperatorsType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_fims__CustomQueryGroupOperatorsType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_fims__CustomQueryGroupOperatorsType(struct soap *soap, const char *tag, int id, const fims__CustomQueryGroupOperatorsType *a, const char *type)
{
	if (((fims__CustomQueryGroupOperatorsType*)a)->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", ((fims__CustomQueryGroupOperatorsType*)a)->__anyAttribute, 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_fims__CustomQueryGroupOperatorsType), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTofims__CustomQueryGroupOperatorType(soap, "fims:customQueryGroupOperator", -1, &(a->fims__CustomQueryGroupOperatorsType::customQueryGroupOperator), ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOf_XML(soap, "-any", -1, &(a->fims__CustomQueryGroupOperatorsType::__any), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *fims__CustomQueryGroupOperatorsType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_fims__CustomQueryGroupOperatorsType(soap, tag, this, type);
}

SOAP_FMAC3 fims__CustomQueryGroupOperatorsType * SOAP_FMAC4 soap_in_fims__CustomQueryGroupOperatorsType(struct soap *soap, const char *tag, fims__CustomQueryGroupOperatorsType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (fims__CustomQueryGroupOperatorsType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_fims__CustomQueryGroupOperatorsType, sizeof(fims__CustomQueryGroupOperatorsType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_fims__CustomQueryGroupOperatorsType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (fims__CustomQueryGroupOperatorsType *)a->soap_in(soap, tag, type);
		}
	}
	if (soap_s2string(soap, soap_attr_value(soap, "-anyAttribute", 0), &((fims__CustomQueryGroupOperatorsType*)a)->__anyAttribute, 0, -1))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTofims__CustomQueryGroupOperatorType(soap, "fims:customQueryGroupOperator", &(a->fims__CustomQueryGroupOperatorsType::customQueryGroupOperator), "fims:CustomQueryGroupOperatorType"))
					continue;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOf_XML(soap, "-any", &(a->fims__CustomQueryGroupOperatorsType::__any), ""))
					continue;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (fims__CustomQueryGroupOperatorsType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_fims__CustomQueryGroupOperatorsType, 0, sizeof(fims__CustomQueryGroupOperatorsType), 0, soap_copy_fims__CustomQueryGroupOperatorsType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (a->fims__CustomQueryGroupOperatorsType::customQueryGroupOperator.size() < 1))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int fims__CustomQueryGroupOperatorsType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_fims__CustomQueryGroupOperatorsType);
	if (this->soap_out(soap, tag?tag:"fims:CustomQueryGroupOperatorsType", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *fims__CustomQueryGroupOperatorsType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_fims__CustomQueryGroupOperatorsType(soap, this, tag, type);
}

SOAP_FMAC3 fims__CustomQueryGroupOperatorsType * SOAP_FMAC4 soap_get_fims__CustomQueryGroupOperatorsType(struct soap *soap, fims__CustomQueryGroupOperatorsType *p, const char *tag, const char *type)
{
	if ((p = soap_in_fims__CustomQueryGroupOperatorsType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 fims__CustomQueryGroupOperatorsType * SOAP_FMAC2 soap_instantiate_fims__CustomQueryGroupOperatorsType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_fims__CustomQueryGroupOperatorsType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_fims__CustomQueryGroupOperatorsType, n, EDLProvider_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(fims__CustomQueryGroupOperatorsType);
		if (size)
			*size = sizeof(fims__CustomQueryGroupOperatorsType);
		((fims__CustomQueryGroupOperatorsType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(fims__CustomQueryGroupOperatorsType, n);
		if (size)
			*size = n * sizeof(fims__CustomQueryGroupOperatorsType);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((fims__CustomQueryGroupOperatorsType*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (fims__CustomQueryGroupOperatorsType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_fims__CustomQueryGroupOperatorsType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying fims__CustomQueryGroupOperatorsType %p -> %p\n", q, p));
	*(fims__CustomQueryGroupOperatorsType*)p = *(fims__CustomQueryGroupOperatorsType*)q;
}

void fims__CustomQueryGroupOperatorType::soap_default(struct soap *soap)
{
	this->soap = soap;
	/* transient soap skipped */
}

void fims__CustomQueryGroupOperatorType::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
#endif
}

int fims__CustomQueryGroupOperatorType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_fims__CustomQueryGroupOperatorType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_fims__CustomQueryGroupOperatorType(struct soap *soap, const char *tag, int id, const fims__CustomQueryGroupOperatorType *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_fims__CustomQueryGroupOperatorType), type))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *fims__CustomQueryGroupOperatorType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_fims__CustomQueryGroupOperatorType(soap, tag, this, type);
}

SOAP_FMAC3 fims__CustomQueryGroupOperatorType * SOAP_FMAC4 soap_in_fims__CustomQueryGroupOperatorType(struct soap *soap, const char *tag, fims__CustomQueryGroupOperatorType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (fims__CustomQueryGroupOperatorType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_fims__CustomQueryGroupOperatorType, sizeof(fims__CustomQueryGroupOperatorType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_fims__CustomQueryGroupOperatorType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (fims__CustomQueryGroupOperatorType *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (fims__CustomQueryGroupOperatorType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_fims__CustomQueryGroupOperatorType, 0, sizeof(fims__CustomQueryGroupOperatorType), 0, soap_copy_fims__CustomQueryGroupOperatorType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int fims__CustomQueryGroupOperatorType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_fims__CustomQueryGroupOperatorType);
	if (this->soap_out(soap, tag?tag:"fims:CustomQueryGroupOperatorType", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *fims__CustomQueryGroupOperatorType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_fims__CustomQueryGroupOperatorType(soap, this, tag, type);
}

SOAP_FMAC3 fims__CustomQueryGroupOperatorType * SOAP_FMAC4 soap_get_fims__CustomQueryGroupOperatorType(struct soap *soap, fims__CustomQueryGroupOperatorType *p, const char *tag, const char *type)
{
	if ((p = soap_in_fims__CustomQueryGroupOperatorType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 fims__CustomQueryGroupOperatorType * SOAP_FMAC2 soap_instantiate_fims__CustomQueryGroupOperatorType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_fims__CustomQueryGroupOperatorType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_fims__CustomQueryGroupOperatorType, n, EDLProvider_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(fims__CustomQueryGroupOperatorType);
		if (size)
			*size = sizeof(fims__CustomQueryGroupOperatorType);
		((fims__CustomQueryGroupOperatorType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(fims__CustomQueryGroupOperatorType, n);
		if (size)
			*size = n * sizeof(fims__CustomQueryGroupOperatorType);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((fims__CustomQueryGroupOperatorType*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (fims__CustomQueryGroupOperatorType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_fims__CustomQueryGroupOperatorType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying fims__CustomQueryGroupOperatorType %p -> %p\n", q, p));
	*(fims__CustomQueryGroupOperatorType*)p = *(fims__CustomQueryGroupOperatorType*)q;
}

void fims__QueryParametersType::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTofims__QueryParameterType(soap, &this->fims__QueryParametersType::queryParameter);
	soap_default_std__vectorTemplateOf_XML(soap, &this->fims__QueryParametersType::__any);
	this->fims__QueryParametersType::__anyAttribute = NULL;
	/* transient soap skipped */
}

void fims__QueryParametersType::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfPointerTofims__QueryParameterType(soap, &this->fims__QueryParametersType::queryParameter);
	soap_serialize_std__vectorTemplateOf_XML(soap, &this->fims__QueryParametersType::__any);
	/* transient soap skipped */
#endif
}

int fims__QueryParametersType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_fims__QueryParametersType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_fims__QueryParametersType(struct soap *soap, const char *tag, int id, const fims__QueryParametersType *a, const char *type)
{
	if (((fims__QueryParametersType*)a)->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", ((fims__QueryParametersType*)a)->__anyAttribute, 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_fims__QueryParametersType), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTofims__QueryParameterType(soap, "fims:queryParameter", -1, &(a->fims__QueryParametersType::queryParameter), ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOf_XML(soap, "-any", -1, &(a->fims__QueryParametersType::__any), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *fims__QueryParametersType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_fims__QueryParametersType(soap, tag, this, type);
}

SOAP_FMAC3 fims__QueryParametersType * SOAP_FMAC4 soap_in_fims__QueryParametersType(struct soap *soap, const char *tag, fims__QueryParametersType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (fims__QueryParametersType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_fims__QueryParametersType, sizeof(fims__QueryParametersType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_fims__QueryParametersType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (fims__QueryParametersType *)a->soap_in(soap, tag, type);
		}
	}
	if (soap_s2string(soap, soap_attr_value(soap, "-anyAttribute", 0), &((fims__QueryParametersType*)a)->__anyAttribute, 0, -1))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTofims__QueryParameterType(soap, "fims:queryParameter", &(a->fims__QueryParametersType::queryParameter), "fims:QueryParameterType"))
					continue;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOf_XML(soap, "-any", &(a->fims__QueryParametersType::__any), ""))
					continue;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (fims__QueryParametersType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_fims__QueryParametersType, 0, sizeof(fims__QueryParametersType), 0, soap_copy_fims__QueryParametersType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (a->fims__QueryParametersType::queryParameter.size() < 1))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int fims__QueryParametersType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_fims__QueryParametersType);
	if (this->soap_out(soap, tag?tag:"fims:QueryParametersType", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *fims__QueryParametersType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_fims__QueryParametersType(soap, this, tag, type);
}

SOAP_FMAC3 fims__QueryParametersType * SOAP_FMAC4 soap_get_fims__QueryParametersType(struct soap *soap, fims__QueryParametersType *p, const char *tag, const char *type)
{
	if ((p = soap_in_fims__QueryParametersType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 fims__QueryParametersType * SOAP_FMAC2 soap_instantiate_fims__QueryParametersType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_fims__QueryParametersType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_fims__QueryParametersType, n, EDLProvider_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(fims__QueryParametersType);
		if (size)
			*size = sizeof(fims__QueryParametersType);
		((fims__QueryParametersType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(fims__QueryParametersType, n);
		if (size)
			*size = n * sizeof(fims__QueryParametersType);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((fims__QueryParametersType*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (fims__QueryParametersType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_fims__QueryParametersType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying fims__QueryParametersType %p -> %p\n", q, p));
	*(fims__QueryParametersType*)p = *(fims__QueryParametersType*)q;
}

void fims__QueryParameterType::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__wstring(soap, &this->fims__QueryParameterType::name);
	this->fims__QueryParameterType::caseSensitive = NULL;
	this->fims__QueryParameterType::__union_QueryParameterType = 0;
	this->fims__QueryParameterType::__union_QueryParameterType_ = 0;
	/* transient soap skipped */
}

void fims__QueryParameterType::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &this->fims__QueryParameterType::name, SOAP_TYPE_std__wstring);
	soap_serialize_std__wstring(soap, &this->fims__QueryParameterType::name);
	soap_serialize_PointerTobool(soap, &this->fims__QueryParameterType::caseSensitive);
	soap_serialize__fims__union_QueryParameterType(soap, this->fims__QueryParameterType::__union_QueryParameterType, &this->fims__QueryParameterType::union_QueryParameterType);
	soap_serialize__fims__union_QueryParameterType_(soap, this->fims__QueryParameterType::__union_QueryParameterType_, &this->fims__QueryParameterType::union_QueryParameterType_);
	/* transient soap skipped */
#endif
}

int fims__QueryParameterType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_fims__QueryParameterType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_fims__QueryParameterType(struct soap *soap, const char *tag, int id, const fims__QueryParameterType *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_fims__QueryParameterType), type))
		return soap->error;
	if (soap_out_std__wstring(soap, "fims:name", -1, &(a->fims__QueryParameterType::name), ""))
		return soap->error;
	if (soap_out_PointerTobool(soap, "fims:caseSensitive", -1, &(a->fims__QueryParameterType::caseSensitive), ""))
		return soap->error;
	if (soap_out__fims__union_QueryParameterType(soap, a->fims__QueryParameterType::__union_QueryParameterType, &a->fims__QueryParameterType::union_QueryParameterType))
		return soap->error;
	if (soap_out__fims__union_QueryParameterType_(soap, a->fims__QueryParameterType::__union_QueryParameterType_, &a->fims__QueryParameterType::union_QueryParameterType_))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *fims__QueryParameterType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_fims__QueryParameterType(soap, tag, this, type);
}

SOAP_FMAC3 fims__QueryParameterType * SOAP_FMAC4 soap_in_fims__QueryParameterType(struct soap *soap, const char *tag, fims__QueryParameterType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (fims__QueryParameterType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_fims__QueryParameterType, sizeof(fims__QueryParameterType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_fims__QueryParameterType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (fims__QueryParameterType *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_name1 = 1;
	size_t soap_flag_caseSensitive1 = 1;
	size_t soap_flag_union_QueryParameterType1 = 1;
	size_t soap_flag_union_QueryParameterType_1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_name1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__wstring(soap, "fims:name", &(a->fims__QueryParameterType::name), "xsd:string"))
				{	soap_flag_name1--;
					continue;
				}
			if (soap_flag_caseSensitive1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTobool(soap, "fims:caseSensitive", &(a->fims__QueryParameterType::caseSensitive), "xsd:boolean"))
				{	soap_flag_caseSensitive1--;
					continue;
				}
			if (soap_flag_union_QueryParameterType1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in__fims__union_QueryParameterType(soap, &a->fims__QueryParameterType::__union_QueryParameterType, &a->fims__QueryParameterType::union_QueryParameterType))
				{	soap_flag_union_QueryParameterType1 = 0;
					continue;
				}
			if (soap_flag_union_QueryParameterType_1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in__fims__union_QueryParameterType_(soap, &a->fims__QueryParameterType::__union_QueryParameterType_, &a->fims__QueryParameterType::union_QueryParameterType_))
				{	soap_flag_union_QueryParameterType_1 = 0;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (fims__QueryParameterType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_fims__QueryParameterType, 0, sizeof(fims__QueryParameterType), 0, soap_copy_fims__QueryParameterType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_name1 > 0 || soap_flag_union_QueryParameterType_1))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int fims__QueryParameterType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_fims__QueryParameterType);
	if (this->soap_out(soap, tag?tag:"fims:QueryParameterType", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *fims__QueryParameterType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_fims__QueryParameterType(soap, this, tag, type);
}

SOAP_FMAC3 fims__QueryParameterType * SOAP_FMAC4 soap_get_fims__QueryParameterType(struct soap *soap, fims__QueryParameterType *p, const char *tag, const char *type)
{
	if ((p = soap_in_fims__QueryParameterType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 fims__QueryParameterType * SOAP_FMAC2 soap_instantiate_fims__QueryParameterType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_fims__QueryParameterType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_fims__QueryParameterType, n, EDLProvider_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(fims__QueryParameterType);
		if (size)
			*size = sizeof(fims__QueryParameterType);
		((fims__QueryParameterType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(fims__QueryParameterType, n);
		if (size)
			*size = n * sizeof(fims__QueryParameterType);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((fims__QueryParameterType*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (fims__QueryParameterType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_fims__QueryParameterType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying fims__QueryParameterType %p -> %p\n", q, p));
	*(fims__QueryParameterType*)p = *(fims__QueryParameterType*)q;
}

void fims__CustomQueryParameterOperatorsType::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTofims__CustomQueryParameterOperatorType(soap, &this->fims__CustomQueryParameterOperatorsType::customQueryParameterOperator);
	soap_default_std__vectorTemplateOf_XML(soap, &this->fims__CustomQueryParameterOperatorsType::__any);
	this->fims__CustomQueryParameterOperatorsType::__anyAttribute = NULL;
	/* transient soap skipped */
}

void fims__CustomQueryParameterOperatorsType::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfPointerTofims__CustomQueryParameterOperatorType(soap, &this->fims__CustomQueryParameterOperatorsType::customQueryParameterOperator);
	soap_serialize_std__vectorTemplateOf_XML(soap, &this->fims__CustomQueryParameterOperatorsType::__any);
	/* transient soap skipped */
#endif
}

int fims__CustomQueryParameterOperatorsType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_fims__CustomQueryParameterOperatorsType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_fims__CustomQueryParameterOperatorsType(struct soap *soap, const char *tag, int id, const fims__CustomQueryParameterOperatorsType *a, const char *type)
{
	if (((fims__CustomQueryParameterOperatorsType*)a)->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", ((fims__CustomQueryParameterOperatorsType*)a)->__anyAttribute, 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_fims__CustomQueryParameterOperatorsType), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTofims__CustomQueryParameterOperatorType(soap, "fims:customQueryParameterOperator", -1, &(a->fims__CustomQueryParameterOperatorsType::customQueryParameterOperator), ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOf_XML(soap, "-any", -1, &(a->fims__CustomQueryParameterOperatorsType::__any), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *fims__CustomQueryParameterOperatorsType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_fims__CustomQueryParameterOperatorsType(soap, tag, this, type);
}

SOAP_FMAC3 fims__CustomQueryParameterOperatorsType * SOAP_FMAC4 soap_in_fims__CustomQueryParameterOperatorsType(struct soap *soap, const char *tag, fims__CustomQueryParameterOperatorsType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (fims__CustomQueryParameterOperatorsType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_fims__CustomQueryParameterOperatorsType, sizeof(fims__CustomQueryParameterOperatorsType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_fims__CustomQueryParameterOperatorsType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (fims__CustomQueryParameterOperatorsType *)a->soap_in(soap, tag, type);
		}
	}
	if (soap_s2string(soap, soap_attr_value(soap, "-anyAttribute", 0), &((fims__CustomQueryParameterOperatorsType*)a)->__anyAttribute, 0, -1))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTofims__CustomQueryParameterOperatorType(soap, "fims:customQueryParameterOperator", &(a->fims__CustomQueryParameterOperatorsType::customQueryParameterOperator), "fims:CustomQueryParameterOperatorType"))
					continue;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOf_XML(soap, "-any", &(a->fims__CustomQueryParameterOperatorsType::__any), ""))
					continue;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (fims__CustomQueryParameterOperatorsType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_fims__CustomQueryParameterOperatorsType, 0, sizeof(fims__CustomQueryParameterOperatorsType), 0, soap_copy_fims__CustomQueryParameterOperatorsType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (a->fims__CustomQueryParameterOperatorsType::customQueryParameterOperator.size() < 1))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int fims__CustomQueryParameterOperatorsType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_fims__CustomQueryParameterOperatorsType);
	if (this->soap_out(soap, tag?tag:"fims:CustomQueryParameterOperatorsType", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *fims__CustomQueryParameterOperatorsType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_fims__CustomQueryParameterOperatorsType(soap, this, tag, type);
}

SOAP_FMAC3 fims__CustomQueryParameterOperatorsType * SOAP_FMAC4 soap_get_fims__CustomQueryParameterOperatorsType(struct soap *soap, fims__CustomQueryParameterOperatorsType *p, const char *tag, const char *type)
{
	if ((p = soap_in_fims__CustomQueryParameterOperatorsType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 fims__CustomQueryParameterOperatorsType * SOAP_FMAC2 soap_instantiate_fims__CustomQueryParameterOperatorsType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_fims__CustomQueryParameterOperatorsType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_fims__CustomQueryParameterOperatorsType, n, EDLProvider_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(fims__CustomQueryParameterOperatorsType);
		if (size)
			*size = sizeof(fims__CustomQueryParameterOperatorsType);
		((fims__CustomQueryParameterOperatorsType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(fims__CustomQueryParameterOperatorsType, n);
		if (size)
			*size = n * sizeof(fims__CustomQueryParameterOperatorsType);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((fims__CustomQueryParameterOperatorsType*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (fims__CustomQueryParameterOperatorsType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_fims__CustomQueryParameterOperatorsType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying fims__CustomQueryParameterOperatorsType %p -> %p\n", q, p));
	*(fims__CustomQueryParameterOperatorsType*)p = *(fims__CustomQueryParameterOperatorsType*)q;
}

void fims__CustomQueryParameterOperatorType::soap_default(struct soap *soap)
{
	this->soap = soap;
	/* transient soap skipped */
}

void fims__CustomQueryParameterOperatorType::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
#endif
}

int fims__CustomQueryParameterOperatorType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_fims__CustomQueryParameterOperatorType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_fims__CustomQueryParameterOperatorType(struct soap *soap, const char *tag, int id, const fims__CustomQueryParameterOperatorType *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_fims__CustomQueryParameterOperatorType), type))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *fims__CustomQueryParameterOperatorType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_fims__CustomQueryParameterOperatorType(soap, tag, this, type);
}

SOAP_FMAC3 fims__CustomQueryParameterOperatorType * SOAP_FMAC4 soap_in_fims__CustomQueryParameterOperatorType(struct soap *soap, const char *tag, fims__CustomQueryParameterOperatorType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (fims__CustomQueryParameterOperatorType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_fims__CustomQueryParameterOperatorType, sizeof(fims__CustomQueryParameterOperatorType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_fims__CustomQueryParameterOperatorType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (fims__CustomQueryParameterOperatorType *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (fims__CustomQueryParameterOperatorType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_fims__CustomQueryParameterOperatorType, 0, sizeof(fims__CustomQueryParameterOperatorType), 0, soap_copy_fims__CustomQueryParameterOperatorType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int fims__CustomQueryParameterOperatorType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_fims__CustomQueryParameterOperatorType);
	if (this->soap_out(soap, tag?tag:"fims:CustomQueryParameterOperatorType", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *fims__CustomQueryParameterOperatorType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_fims__CustomQueryParameterOperatorType(soap, this, tag, type);
}

SOAP_FMAC3 fims__CustomQueryParameterOperatorType * SOAP_FMAC4 soap_get_fims__CustomQueryParameterOperatorType(struct soap *soap, fims__CustomQueryParameterOperatorType *p, const char *tag, const char *type)
{
	if ((p = soap_in_fims__CustomQueryParameterOperatorType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 fims__CustomQueryParameterOperatorType * SOAP_FMAC2 soap_instantiate_fims__CustomQueryParameterOperatorType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_fims__CustomQueryParameterOperatorType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_fims__CustomQueryParameterOperatorType, n, EDLProvider_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(fims__CustomQueryParameterOperatorType);
		if (size)
			*size = sizeof(fims__CustomQueryParameterOperatorType);
		((fims__CustomQueryParameterOperatorType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(fims__CustomQueryParameterOperatorType, n);
		if (size)
			*size = n * sizeof(fims__CustomQueryParameterOperatorType);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((fims__CustomQueryParameterOperatorType*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (fims__CustomQueryParameterOperatorType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_fims__CustomQueryParameterOperatorType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying fims__CustomQueryParameterOperatorType %p -> %p\n", q, p));
	*(fims__CustomQueryParameterOperatorType*)p = *(fims__CustomQueryParameterOperatorType*)q;
}

void fims__QueryExpressionsType::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTofims__QueryExpressionType(soap, &this->fims__QueryExpressionsType::queryExpression);
	soap_default_std__vectorTemplateOf_XML(soap, &this->fims__QueryExpressionsType::__any);
	this->fims__QueryExpressionsType::__anyAttribute = NULL;
	/* transient soap skipped */
}

void fims__QueryExpressionsType::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfPointerTofims__QueryExpressionType(soap, &this->fims__QueryExpressionsType::queryExpression);
	soap_serialize_std__vectorTemplateOf_XML(soap, &this->fims__QueryExpressionsType::__any);
	/* transient soap skipped */
#endif
}

int fims__QueryExpressionsType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_fims__QueryExpressionsType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_fims__QueryExpressionsType(struct soap *soap, const char *tag, int id, const fims__QueryExpressionsType *a, const char *type)
{
	if (((fims__QueryExpressionsType*)a)->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", ((fims__QueryExpressionsType*)a)->__anyAttribute, 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_fims__QueryExpressionsType), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTofims__QueryExpressionType(soap, "fims:queryExpression", -1, &(a->fims__QueryExpressionsType::queryExpression), ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOf_XML(soap, "-any", -1, &(a->fims__QueryExpressionsType::__any), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *fims__QueryExpressionsType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_fims__QueryExpressionsType(soap, tag, this, type);
}

SOAP_FMAC3 fims__QueryExpressionsType * SOAP_FMAC4 soap_in_fims__QueryExpressionsType(struct soap *soap, const char *tag, fims__QueryExpressionsType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (fims__QueryExpressionsType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_fims__QueryExpressionsType, sizeof(fims__QueryExpressionsType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_fims__QueryExpressionsType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (fims__QueryExpressionsType *)a->soap_in(soap, tag, type);
		}
	}
	if (soap_s2string(soap, soap_attr_value(soap, "-anyAttribute", 0), &((fims__QueryExpressionsType*)a)->__anyAttribute, 0, -1))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTofims__QueryExpressionType(soap, "fims:queryExpression", &(a->fims__QueryExpressionsType::queryExpression), "fims:QueryExpressionType"))
					continue;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOf_XML(soap, "-any", &(a->fims__QueryExpressionsType::__any), ""))
					continue;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (fims__QueryExpressionsType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_fims__QueryExpressionsType, 0, sizeof(fims__QueryExpressionsType), 0, soap_copy_fims__QueryExpressionsType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (a->fims__QueryExpressionsType::queryExpression.size() < 1))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int fims__QueryExpressionsType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_fims__QueryExpressionsType);
	if (this->soap_out(soap, tag?tag:"fims:QueryExpressionsType", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *fims__QueryExpressionsType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_fims__QueryExpressionsType(soap, this, tag, type);
}

SOAP_FMAC3 fims__QueryExpressionsType * SOAP_FMAC4 soap_get_fims__QueryExpressionsType(struct soap *soap, fims__QueryExpressionsType *p, const char *tag, const char *type)
{
	if ((p = soap_in_fims__QueryExpressionsType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 fims__QueryExpressionsType * SOAP_FMAC2 soap_instantiate_fims__QueryExpressionsType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_fims__QueryExpressionsType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_fims__QueryExpressionsType, n, EDLProvider_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(fims__QueryExpressionsType);
		if (size)
			*size = sizeof(fims__QueryExpressionsType);
		((fims__QueryExpressionsType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(fims__QueryExpressionsType, n);
		if (size)
			*size = n * sizeof(fims__QueryExpressionsType);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((fims__QueryExpressionsType*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (fims__QueryExpressionsType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_fims__QueryExpressionsType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying fims__QueryExpressionsType %p -> %p\n", q, p));
	*(fims__QueryExpressionsType*)p = *(fims__QueryExpressionsType*)q;
}

void fims__QueryExpressionType::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->fims__QueryExpressionType::__union_QueryExpressionType = 0;
	/* transient soap skipped */
}

void fims__QueryExpressionType::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize__fims__union_QueryExpressionType(soap, this->fims__QueryExpressionType::__union_QueryExpressionType, &this->fims__QueryExpressionType::union_QueryExpressionType);
	/* transient soap skipped */
#endif
}

int fims__QueryExpressionType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_fims__QueryExpressionType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_fims__QueryExpressionType(struct soap *soap, const char *tag, int id, const fims__QueryExpressionType *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_fims__QueryExpressionType), type))
		return soap->error;
	if (soap_out__fims__union_QueryExpressionType(soap, a->fims__QueryExpressionType::__union_QueryExpressionType, &a->fims__QueryExpressionType::union_QueryExpressionType))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *fims__QueryExpressionType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_fims__QueryExpressionType(soap, tag, this, type);
}

SOAP_FMAC3 fims__QueryExpressionType * SOAP_FMAC4 soap_in_fims__QueryExpressionType(struct soap *soap, const char *tag, fims__QueryExpressionType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (fims__QueryExpressionType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_fims__QueryExpressionType, sizeof(fims__QueryExpressionType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	a->soap_default(soap);
	if (!tag || *tag == '-' || (soap->body && !*soap->href))
	{
		if (!soap_in__fims__union_QueryExpressionType(soap, &a->__union_QueryExpressionType, &a->union_QueryExpressionType))
			return NULL;
		if (tag && *tag != '-')
		{	soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_TAG_MISMATCH || soap_element_end_in(soap, tag))
				return NULL;
		}
	}
	else
	{	a = (fims__QueryExpressionType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_fims__QueryExpressionType, 0, sizeof(fims__QueryExpressionType), 0, soap_copy_fims__QueryExpressionType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int fims__QueryExpressionType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_fims__QueryExpressionType);
	if (this->soap_out(soap, tag?tag:"fims:QueryExpressionType", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *fims__QueryExpressionType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_fims__QueryExpressionType(soap, this, tag, type);
}

SOAP_FMAC3 fims__QueryExpressionType * SOAP_FMAC4 soap_get_fims__QueryExpressionType(struct soap *soap, fims__QueryExpressionType *p, const char *tag, const char *type)
{
	if ((p = soap_in_fims__QueryExpressionType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 fims__QueryExpressionType * SOAP_FMAC2 soap_instantiate_fims__QueryExpressionType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_fims__QueryExpressionType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_fims__QueryExpressionType, n, EDLProvider_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(fims__QueryExpressionType);
		if (size)
			*size = sizeof(fims__QueryExpressionType);
		((fims__QueryExpressionType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(fims__QueryExpressionType, n);
		if (size)
			*size = n * sizeof(fims__QueryExpressionType);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((fims__QueryExpressionType*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (fims__QueryExpressionType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_fims__QueryExpressionType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying fims__QueryExpressionType %p -> %p\n", q, p));
	*(fims__QueryExpressionType*)p = *(fims__QueryExpressionType*)q;
}

void fims__SuperLockTokensType::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTofims__SuperLockTokenType(soap, &this->fims__SuperLockTokensType::superLockToken);
	soap_default_std__vectorTemplateOf_XML(soap, &this->fims__SuperLockTokensType::__any);
	this->fims__SuperLockTokensType::__anyAttribute = NULL;
	/* transient soap skipped */
}

void fims__SuperLockTokensType::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfPointerTofims__SuperLockTokenType(soap, &this->fims__SuperLockTokensType::superLockToken);
	soap_serialize_std__vectorTemplateOf_XML(soap, &this->fims__SuperLockTokensType::__any);
	/* transient soap skipped */
#endif
}

int fims__SuperLockTokensType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_fims__SuperLockTokensType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_fims__SuperLockTokensType(struct soap *soap, const char *tag, int id, const fims__SuperLockTokensType *a, const char *type)
{
	if (((fims__SuperLockTokensType*)a)->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", ((fims__SuperLockTokensType*)a)->__anyAttribute, 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_fims__SuperLockTokensType), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTofims__SuperLockTokenType(soap, "fims:superLockToken", -1, &(a->fims__SuperLockTokensType::superLockToken), ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOf_XML(soap, "-any", -1, &(a->fims__SuperLockTokensType::__any), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *fims__SuperLockTokensType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_fims__SuperLockTokensType(soap, tag, this, type);
}

SOAP_FMAC3 fims__SuperLockTokensType * SOAP_FMAC4 soap_in_fims__SuperLockTokensType(struct soap *soap, const char *tag, fims__SuperLockTokensType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (fims__SuperLockTokensType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_fims__SuperLockTokensType, sizeof(fims__SuperLockTokensType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_fims__SuperLockTokensType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (fims__SuperLockTokensType *)a->soap_in(soap, tag, type);
		}
	}
	if (soap_s2string(soap, soap_attr_value(soap, "-anyAttribute", 0), &((fims__SuperLockTokensType*)a)->__anyAttribute, 0, -1))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTofims__SuperLockTokenType(soap, "fims:superLockToken", &(a->fims__SuperLockTokensType::superLockToken), "fims:SuperLockTokenType"))
					continue;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOf_XML(soap, "-any", &(a->fims__SuperLockTokensType::__any), ""))
					continue;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (fims__SuperLockTokensType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_fims__SuperLockTokensType, 0, sizeof(fims__SuperLockTokensType), 0, soap_copy_fims__SuperLockTokensType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (a->fims__SuperLockTokensType::superLockToken.size() < 1))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int fims__SuperLockTokensType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_fims__SuperLockTokensType);
	if (this->soap_out(soap, tag?tag:"fims:SuperLockTokensType", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *fims__SuperLockTokensType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_fims__SuperLockTokensType(soap, this, tag, type);
}

SOAP_FMAC3 fims__SuperLockTokensType * SOAP_FMAC4 soap_get_fims__SuperLockTokensType(struct soap *soap, fims__SuperLockTokensType *p, const char *tag, const char *type)
{
	if ((p = soap_in_fims__SuperLockTokensType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 fims__SuperLockTokensType * SOAP_FMAC2 soap_instantiate_fims__SuperLockTokensType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_fims__SuperLockTokensType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_fims__SuperLockTokensType, n, EDLProvider_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(fims__SuperLockTokensType);
		if (size)
			*size = sizeof(fims__SuperLockTokensType);
		((fims__SuperLockTokensType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(fims__SuperLockTokensType, n);
		if (size)
			*size = n * sizeof(fims__SuperLockTokensType);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((fims__SuperLockTokensType*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (fims__SuperLockTokensType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_fims__SuperLockTokensType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying fims__SuperLockTokensType %p -> %p\n", q, p));
	*(fims__SuperLockTokensType*)p = *(fims__SuperLockTokensType*)q;
}

void fims__SuperLockTokenType::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->fims__ResourceType::soap_default(soap);
	this->fims__SuperLockTokenType::userName = NULL;
}

void fims__SuperLockTokenType::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__wstring(soap, &this->fims__SuperLockTokenType::userName);
	this->fims__ResourceType::soap_serialize(soap);
#endif
}

int fims__SuperLockTokenType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_fims__SuperLockTokenType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_fims__SuperLockTokenType(struct soap *soap, const char *tag, int id, const fims__SuperLockTokenType *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_fims__SuperLockTokenType), "fims:SuperLockTokenType"))
		return soap->error;
	if (soap_out_fims__ResourceIDType(soap, "fims:resourceID", -1, &(a->fims__ResourceReferenceType::resourceID), ""))
		return soap->error;
	if (soap_out_PointerTofims__RevisionIDType(soap, "fims:revisionID", -1, &(a->fims__ResourceReferenceType::revisionID), ""))
		return soap->error;
	if (soap_out_PointerToxsd__anyURI(soap, "fims:location", -1, &(a->fims__ResourceReferenceType::location), ""))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_PointerTotime(soap, "fims:resourceCreationDate", -1, &(a->fims__ResourceType::resourceCreationDate), ""))
		return soap->error;
	if (soap_out_PointerTotime(soap, "fims:resourceModifiedDate", -1, &(a->fims__ResourceType::resourceModifiedDate), ""))
		return soap->error;
	if (soap_out_PointerTobool(soap, "fims:serviceGeneratedElement", -1, &(a->fims__ResourceType::serviceGeneratedElement), ""))
		return soap->error;
	if (soap_out_PointerTobool(soap, "fims:isFullyPopulated", -1, &(a->fims__ResourceType::isFullyPopulated), ""))
		return soap->error;
	if (soap_out_PointerTofims__AsyncEndpointType(soap, "fims:notifyAt", -1, &(a->fims__ResourceType::notifyAt), ""))
		return soap->error;
	if (soap_out_PointerTofims__ExtensionGroup(soap, "fims:ExtensionGroup", -1, &(a->fims__ResourceType::ExtensionGroup), ""))
		return soap->error;
	if (soap_out_PointerTofims__ExtensionAttributes(soap, "fims:ExtensionAttributes", -1, &(a->fims__ResourceType::ExtensionAttributes), ""))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "fims:userName", -1, &(a->fims__SuperLockTokenType::userName), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *fims__SuperLockTokenType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_fims__SuperLockTokenType(soap, tag, this, type);
}

SOAP_FMAC3 fims__SuperLockTokenType * SOAP_FMAC4 soap_in_fims__SuperLockTokenType(struct soap *soap, const char *tag, fims__SuperLockTokenType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (fims__SuperLockTokenType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_fims__SuperLockTokenType, sizeof(fims__SuperLockTokenType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_fims__SuperLockTokenType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (fims__SuperLockTokenType *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_resourceID3 = 1;
	size_t soap_flag_revisionID3 = 1;
	size_t soap_flag_location3 = 1;
	size_t soap_flag_resourceCreationDate2 = 1;
	size_t soap_flag_resourceModifiedDate2 = 1;
	size_t soap_flag_serviceGeneratedElement2 = 1;
	size_t soap_flag_isFullyPopulated2 = 1;
	size_t soap_flag_notifyAt2 = 1;
	size_t soap_flag_ExtensionGroup2 = 1;
	size_t soap_flag_ExtensionAttributes2 = 1;
	size_t soap_flag_userName1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_resourceID3 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_fims__ResourceIDType(soap, "fims:resourceID", &(a->fims__ResourceReferenceType::resourceID), "fims:ResourceIDType"))
				{	soap_flag_resourceID3--;
					continue;
				}
			if (soap_flag_revisionID3 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTofims__RevisionIDType(soap, "fims:revisionID", &(a->fims__ResourceReferenceType::revisionID), "fims:RevisionIDType"))
				{	soap_flag_revisionID3--;
					continue;
				}
			if (soap_flag_location3 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerToxsd__anyURI(soap, "fims:location", &(a->fims__ResourceReferenceType::location), "xsd:anyURI"))
				{	soap_flag_location3--;
					continue;
				}
			/* transient soap skipped */
			if (soap_flag_resourceCreationDate2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTotime(soap, "fims:resourceCreationDate", &(a->fims__ResourceType::resourceCreationDate), "xsd:dateTime"))
				{	soap_flag_resourceCreationDate2--;
					continue;
				}
			if (soap_flag_resourceModifiedDate2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTotime(soap, "fims:resourceModifiedDate", &(a->fims__ResourceType::resourceModifiedDate), "xsd:dateTime"))
				{	soap_flag_resourceModifiedDate2--;
					continue;
				}
			if (soap_flag_serviceGeneratedElement2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTobool(soap, "fims:serviceGeneratedElement", &(a->fims__ResourceType::serviceGeneratedElement), "xsd:boolean"))
				{	soap_flag_serviceGeneratedElement2--;
					continue;
				}
			if (soap_flag_isFullyPopulated2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTobool(soap, "fims:isFullyPopulated", &(a->fims__ResourceType::isFullyPopulated), "xsd:boolean"))
				{	soap_flag_isFullyPopulated2--;
					continue;
				}
			if (soap_flag_notifyAt2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTofims__AsyncEndpointType(soap, "fims:notifyAt", &(a->fims__ResourceType::notifyAt), "fims:AsyncEndpointType"))
				{	soap_flag_notifyAt2--;
					continue;
				}
			if (soap_flag_ExtensionGroup2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTofims__ExtensionGroup(soap, "fims:ExtensionGroup", &(a->fims__ResourceType::ExtensionGroup), "fims:ExtensionGroup"))
				{	soap_flag_ExtensionGroup2--;
					continue;
				}
			if (soap_flag_ExtensionAttributes2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTofims__ExtensionAttributes(soap, "fims:ExtensionAttributes", &(a->fims__ResourceType::ExtensionAttributes), "fims:ExtensionAttributes"))
				{	soap_flag_ExtensionAttributes2--;
					continue;
				}
			if (soap_flag_userName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "fims:userName", &(a->fims__SuperLockTokenType::userName), "xsd:string"))
				{	soap_flag_userName1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (fims__SuperLockTokenType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_fims__SuperLockTokenType, 0, sizeof(fims__SuperLockTokenType), 0, soap_copy_fims__SuperLockTokenType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_resourceID3 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int fims__SuperLockTokenType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_fims__SuperLockTokenType);
	if (this->soap_out(soap, tag?tag:"fims:SuperLockTokenType", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *fims__SuperLockTokenType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_fims__SuperLockTokenType(soap, this, tag, type);
}

SOAP_FMAC3 fims__SuperLockTokenType * SOAP_FMAC4 soap_get_fims__SuperLockTokenType(struct soap *soap, fims__SuperLockTokenType *p, const char *tag, const char *type)
{
	if ((p = soap_in_fims__SuperLockTokenType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 fims__SuperLockTokenType * SOAP_FMAC2 soap_instantiate_fims__SuperLockTokenType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_fims__SuperLockTokenType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_fims__SuperLockTokenType, n, EDLProvider_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(fims__SuperLockTokenType);
		if (size)
			*size = sizeof(fims__SuperLockTokenType);
		((fims__SuperLockTokenType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(fims__SuperLockTokenType, n);
		if (size)
			*size = n * sizeof(fims__SuperLockTokenType);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((fims__SuperLockTokenType*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (fims__SuperLockTokenType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_fims__SuperLockTokenType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying fims__SuperLockTokenType %p -> %p\n", q, p));
	*(fims__SuperLockTokenType*)p = *(fims__SuperLockTokenType*)q;
}

void fims__LockTokensType::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTofims__LockTokenType(soap, &this->fims__LockTokensType::lockToken);
	soap_default_std__vectorTemplateOf_XML(soap, &this->fims__LockTokensType::__any);
	this->fims__LockTokensType::__anyAttribute = NULL;
	/* transient soap skipped */
}

void fims__LockTokensType::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfPointerTofims__LockTokenType(soap, &this->fims__LockTokensType::lockToken);
	soap_serialize_std__vectorTemplateOf_XML(soap, &this->fims__LockTokensType::__any);
	/* transient soap skipped */
#endif
}

int fims__LockTokensType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_fims__LockTokensType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_fims__LockTokensType(struct soap *soap, const char *tag, int id, const fims__LockTokensType *a, const char *type)
{
	if (((fims__LockTokensType*)a)->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", ((fims__LockTokensType*)a)->__anyAttribute, 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_fims__LockTokensType), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTofims__LockTokenType(soap, "fims:lockToken", -1, &(a->fims__LockTokensType::lockToken), ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOf_XML(soap, "-any", -1, &(a->fims__LockTokensType::__any), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *fims__LockTokensType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_fims__LockTokensType(soap, tag, this, type);
}

SOAP_FMAC3 fims__LockTokensType * SOAP_FMAC4 soap_in_fims__LockTokensType(struct soap *soap, const char *tag, fims__LockTokensType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (fims__LockTokensType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_fims__LockTokensType, sizeof(fims__LockTokensType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_fims__LockTokensType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (fims__LockTokensType *)a->soap_in(soap, tag, type);
		}
	}
	if (soap_s2string(soap, soap_attr_value(soap, "-anyAttribute", 0), &((fims__LockTokensType*)a)->__anyAttribute, 0, -1))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTofims__LockTokenType(soap, "fims:lockToken", &(a->fims__LockTokensType::lockToken), "fims:LockTokenType"))
					continue;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOf_XML(soap, "-any", &(a->fims__LockTokensType::__any), ""))
					continue;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (fims__LockTokensType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_fims__LockTokensType, 0, sizeof(fims__LockTokensType), 0, soap_copy_fims__LockTokensType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (a->fims__LockTokensType::lockToken.size() < 1))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int fims__LockTokensType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_fims__LockTokensType);
	if (this->soap_out(soap, tag?tag:"fims:LockTokensType", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *fims__LockTokensType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_fims__LockTokensType(soap, this, tag, type);
}

SOAP_FMAC3 fims__LockTokensType * SOAP_FMAC4 soap_get_fims__LockTokensType(struct soap *soap, fims__LockTokensType *p, const char *tag, const char *type)
{
	if ((p = soap_in_fims__LockTokensType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 fims__LockTokensType * SOAP_FMAC2 soap_instantiate_fims__LockTokensType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_fims__LockTokensType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_fims__LockTokensType, n, EDLProvider_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(fims__LockTokensType);
		if (size)
			*size = sizeof(fims__LockTokensType);
		((fims__LockTokensType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(fims__LockTokensType, n);
		if (size)
			*size = n * sizeof(fims__LockTokensType);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((fims__LockTokensType*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (fims__LockTokensType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_fims__LockTokensType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying fims__LockTokensType %p -> %p\n", q, p));
	*(fims__LockTokensType*)p = *(fims__LockTokensType*)q;
}

void fims__LockTokenType::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->fims__ResourceType::soap_default(soap);
	this->fims__LockTokenType::userName = NULL;
	this->fims__LockTokenType::expiration = NULL;
	this->fims__LockTokenType::resourceReferences = NULL;
}

void fims__LockTokenType::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__wstring(soap, &this->fims__LockTokenType::userName);
	soap_serialize_PointerTotime(soap, &this->fims__LockTokenType::expiration);
	soap_serialize_PointerTofims__ResourceReferencesType(soap, &this->fims__LockTokenType::resourceReferences);
	this->fims__ResourceType::soap_serialize(soap);
#endif
}

int fims__LockTokenType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_fims__LockTokenType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_fims__LockTokenType(struct soap *soap, const char *tag, int id, const fims__LockTokenType *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_fims__LockTokenType), "fims:LockTokenType"))
		return soap->error;
	if (soap_out_fims__ResourceIDType(soap, "fims:resourceID", -1, &(a->fims__ResourceReferenceType::resourceID), ""))
		return soap->error;
	if (soap_out_PointerTofims__RevisionIDType(soap, "fims:revisionID", -1, &(a->fims__ResourceReferenceType::revisionID), ""))
		return soap->error;
	if (soap_out_PointerToxsd__anyURI(soap, "fims:location", -1, &(a->fims__ResourceReferenceType::location), ""))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_PointerTotime(soap, "fims:resourceCreationDate", -1, &(a->fims__ResourceType::resourceCreationDate), ""))
		return soap->error;
	if (soap_out_PointerTotime(soap, "fims:resourceModifiedDate", -1, &(a->fims__ResourceType::resourceModifiedDate), ""))
		return soap->error;
	if (soap_out_PointerTobool(soap, "fims:serviceGeneratedElement", -1, &(a->fims__ResourceType::serviceGeneratedElement), ""))
		return soap->error;
	if (soap_out_PointerTobool(soap, "fims:isFullyPopulated", -1, &(a->fims__ResourceType::isFullyPopulated), ""))
		return soap->error;
	if (soap_out_PointerTofims__AsyncEndpointType(soap, "fims:notifyAt", -1, &(a->fims__ResourceType::notifyAt), ""))
		return soap->error;
	if (soap_out_PointerTofims__ExtensionGroup(soap, "fims:ExtensionGroup", -1, &(a->fims__ResourceType::ExtensionGroup), ""))
		return soap->error;
	if (soap_out_PointerTofims__ExtensionAttributes(soap, "fims:ExtensionAttributes", -1, &(a->fims__ResourceType::ExtensionAttributes), ""))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "fims:userName", -1, &(a->fims__LockTokenType::userName), ""))
		return soap->error;
	if (soap_out_PointerTotime(soap, "fims:expiration", -1, &(a->fims__LockTokenType::expiration), ""))
		return soap->error;
	if (soap_out_PointerTofims__ResourceReferencesType(soap, "fims:resourceReferences", -1, &(a->fims__LockTokenType::resourceReferences), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *fims__LockTokenType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_fims__LockTokenType(soap, tag, this, type);
}

SOAP_FMAC3 fims__LockTokenType * SOAP_FMAC4 soap_in_fims__LockTokenType(struct soap *soap, const char *tag, fims__LockTokenType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (fims__LockTokenType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_fims__LockTokenType, sizeof(fims__LockTokenType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_fims__LockTokenType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (fims__LockTokenType *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_resourceID3 = 1;
	size_t soap_flag_revisionID3 = 1;
	size_t soap_flag_location3 = 1;
	size_t soap_flag_resourceCreationDate2 = 1;
	size_t soap_flag_resourceModifiedDate2 = 1;
	size_t soap_flag_serviceGeneratedElement2 = 1;
	size_t soap_flag_isFullyPopulated2 = 1;
	size_t soap_flag_notifyAt2 = 1;
	size_t soap_flag_ExtensionGroup2 = 1;
	size_t soap_flag_ExtensionAttributes2 = 1;
	size_t soap_flag_userName1 = 1;
	size_t soap_flag_expiration1 = 1;
	size_t soap_flag_resourceReferences1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_resourceID3 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_fims__ResourceIDType(soap, "fims:resourceID", &(a->fims__ResourceReferenceType::resourceID), "fims:ResourceIDType"))
				{	soap_flag_resourceID3--;
					continue;
				}
			if (soap_flag_revisionID3 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTofims__RevisionIDType(soap, "fims:revisionID", &(a->fims__ResourceReferenceType::revisionID), "fims:RevisionIDType"))
				{	soap_flag_revisionID3--;
					continue;
				}
			if (soap_flag_location3 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerToxsd__anyURI(soap, "fims:location", &(a->fims__ResourceReferenceType::location), "xsd:anyURI"))
				{	soap_flag_location3--;
					continue;
				}
			/* transient soap skipped */
			if (soap_flag_resourceCreationDate2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTotime(soap, "fims:resourceCreationDate", &(a->fims__ResourceType::resourceCreationDate), "xsd:dateTime"))
				{	soap_flag_resourceCreationDate2--;
					continue;
				}
			if (soap_flag_resourceModifiedDate2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTotime(soap, "fims:resourceModifiedDate", &(a->fims__ResourceType::resourceModifiedDate), "xsd:dateTime"))
				{	soap_flag_resourceModifiedDate2--;
					continue;
				}
			if (soap_flag_serviceGeneratedElement2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTobool(soap, "fims:serviceGeneratedElement", &(a->fims__ResourceType::serviceGeneratedElement), "xsd:boolean"))
				{	soap_flag_serviceGeneratedElement2--;
					continue;
				}
			if (soap_flag_isFullyPopulated2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTobool(soap, "fims:isFullyPopulated", &(a->fims__ResourceType::isFullyPopulated), "xsd:boolean"))
				{	soap_flag_isFullyPopulated2--;
					continue;
				}
			if (soap_flag_notifyAt2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTofims__AsyncEndpointType(soap, "fims:notifyAt", &(a->fims__ResourceType::notifyAt), "fims:AsyncEndpointType"))
				{	soap_flag_notifyAt2--;
					continue;
				}
			if (soap_flag_ExtensionGroup2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTofims__ExtensionGroup(soap, "fims:ExtensionGroup", &(a->fims__ResourceType::ExtensionGroup), "fims:ExtensionGroup"))
				{	soap_flag_ExtensionGroup2--;
					continue;
				}
			if (soap_flag_ExtensionAttributes2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTofims__ExtensionAttributes(soap, "fims:ExtensionAttributes", &(a->fims__ResourceType::ExtensionAttributes), "fims:ExtensionAttributes"))
				{	soap_flag_ExtensionAttributes2--;
					continue;
				}
			if (soap_flag_userName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "fims:userName", &(a->fims__LockTokenType::userName), "xsd:string"))
				{	soap_flag_userName1--;
					continue;
				}
			if (soap_flag_expiration1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTotime(soap, "fims:expiration", &(a->fims__LockTokenType::expiration), "xsd:dateTime"))
				{	soap_flag_expiration1--;
					continue;
				}
			if (soap_flag_resourceReferences1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTofims__ResourceReferencesType(soap, "fims:resourceReferences", &(a->fims__LockTokenType::resourceReferences), "fims:ResourceReferencesType"))
				{	soap_flag_resourceReferences1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (fims__LockTokenType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_fims__LockTokenType, 0, sizeof(fims__LockTokenType), 0, soap_copy_fims__LockTokenType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_resourceID3 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int fims__LockTokenType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_fims__LockTokenType);
	if (this->soap_out(soap, tag?tag:"fims:LockTokenType", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *fims__LockTokenType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_fims__LockTokenType(soap, this, tag, type);
}

SOAP_FMAC3 fims__LockTokenType * SOAP_FMAC4 soap_get_fims__LockTokenType(struct soap *soap, fims__LockTokenType *p, const char *tag, const char *type)
{
	if ((p = soap_in_fims__LockTokenType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 fims__LockTokenType * SOAP_FMAC2 soap_instantiate_fims__LockTokenType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_fims__LockTokenType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_fims__LockTokenType, n, EDLProvider_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(fims__LockTokenType);
		if (size)
			*size = sizeof(fims__LockTokenType);
		((fims__LockTokenType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(fims__LockTokenType, n);
		if (size)
			*size = n * sizeof(fims__LockTokenType);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((fims__LockTokenType*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (fims__LockTokenType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_fims__LockTokenType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying fims__LockTokenType %p -> %p\n", q, p));
	*(fims__LockTokenType*)p = *(fims__LockTokenType*)q;
}

void fims__CredentialsType::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTofims__CredentialType(soap, &this->fims__CredentialsType::credential);
	soap_default_std__vectorTemplateOf_XML(soap, &this->fims__CredentialsType::__any);
	this->fims__CredentialsType::__anyAttribute = NULL;
	/* transient soap skipped */
}

void fims__CredentialsType::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfPointerTofims__CredentialType(soap, &this->fims__CredentialsType::credential);
	soap_serialize_std__vectorTemplateOf_XML(soap, &this->fims__CredentialsType::__any);
	/* transient soap skipped */
#endif
}

int fims__CredentialsType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_fims__CredentialsType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_fims__CredentialsType(struct soap *soap, const char *tag, int id, const fims__CredentialsType *a, const char *type)
{
	if (((fims__CredentialsType*)a)->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", ((fims__CredentialsType*)a)->__anyAttribute, 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_fims__CredentialsType), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTofims__CredentialType(soap, "fims:credential", -1, &(a->fims__CredentialsType::credential), ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOf_XML(soap, "-any", -1, &(a->fims__CredentialsType::__any), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *fims__CredentialsType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_fims__CredentialsType(soap, tag, this, type);
}

SOAP_FMAC3 fims__CredentialsType * SOAP_FMAC4 soap_in_fims__CredentialsType(struct soap *soap, const char *tag, fims__CredentialsType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (fims__CredentialsType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_fims__CredentialsType, sizeof(fims__CredentialsType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_fims__CredentialsType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (fims__CredentialsType *)a->soap_in(soap, tag, type);
		}
	}
	if (soap_s2string(soap, soap_attr_value(soap, "-anyAttribute", 0), &((fims__CredentialsType*)a)->__anyAttribute, 0, -1))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTofims__CredentialType(soap, "fims:credential", &(a->fims__CredentialsType::credential), "fims:CredentialType"))
					continue;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOf_XML(soap, "-any", &(a->fims__CredentialsType::__any), ""))
					continue;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (fims__CredentialsType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_fims__CredentialsType, 0, sizeof(fims__CredentialsType), 0, soap_copy_fims__CredentialsType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (a->fims__CredentialsType::credential.size() < 1))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int fims__CredentialsType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_fims__CredentialsType);
	if (this->soap_out(soap, tag?tag:"fims:CredentialsType", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *fims__CredentialsType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_fims__CredentialsType(soap, this, tag, type);
}

SOAP_FMAC3 fims__CredentialsType * SOAP_FMAC4 soap_get_fims__CredentialsType(struct soap *soap, fims__CredentialsType *p, const char *tag, const char *type)
{
	if ((p = soap_in_fims__CredentialsType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 fims__CredentialsType * SOAP_FMAC2 soap_instantiate_fims__CredentialsType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_fims__CredentialsType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_fims__CredentialsType, n, EDLProvider_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(fims__CredentialsType);
		if (size)
			*size = sizeof(fims__CredentialsType);
		((fims__CredentialsType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(fims__CredentialsType, n);
		if (size)
			*size = n * sizeof(fims__CredentialsType);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((fims__CredentialsType*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (fims__CredentialsType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_fims__CredentialsType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying fims__CredentialsType %p -> %p\n", q, p));
	*(fims__CredentialsType*)p = *(fims__CredentialsType*)q;
}

void fims__CredentialType::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->fims__CredentialType::userName = NULL;
	this->fims__CredentialType::password = NULL;
	this->fims__CredentialType::sessionToken = NULL;
	this->fims__CredentialType::ExtensionGroup = NULL;
	this->fims__CredentialType::ExtensionAttributes = NULL;
	/* transient soap skipped */
}

void fims__CredentialType::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__wstring(soap, &this->fims__CredentialType::userName);
	soap_serialize_PointerTostd__wstring(soap, &this->fims__CredentialType::password);
	soap_serialize_PointerTostd__wstring(soap, &this->fims__CredentialType::sessionToken);
	soap_serialize_PointerTofims__ExtensionGroup(soap, &this->fims__CredentialType::ExtensionGroup);
	soap_serialize_PointerTofims__ExtensionAttributes(soap, &this->fims__CredentialType::ExtensionAttributes);
	/* transient soap skipped */
#endif
}

int fims__CredentialType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_fims__CredentialType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_fims__CredentialType(struct soap *soap, const char *tag, int id, const fims__CredentialType *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_fims__CredentialType), type))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "fims:userName", -1, &(a->fims__CredentialType::userName), ""))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "fims:password", -1, &(a->fims__CredentialType::password), ""))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "fims:sessionToken", -1, &(a->fims__CredentialType::sessionToken), ""))
		return soap->error;
	if (soap_out_PointerTofims__ExtensionGroup(soap, "fims:ExtensionGroup", -1, &(a->fims__CredentialType::ExtensionGroup), ""))
		return soap->error;
	if (soap_out_PointerTofims__ExtensionAttributes(soap, "fims:ExtensionAttributes", -1, &(a->fims__CredentialType::ExtensionAttributes), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *fims__CredentialType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_fims__CredentialType(soap, tag, this, type);
}

SOAP_FMAC3 fims__CredentialType * SOAP_FMAC4 soap_in_fims__CredentialType(struct soap *soap, const char *tag, fims__CredentialType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (fims__CredentialType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_fims__CredentialType, sizeof(fims__CredentialType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_fims__CredentialType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (fims__CredentialType *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_userName1 = 1;
	size_t soap_flag_password1 = 1;
	size_t soap_flag_sessionToken1 = 1;
	size_t soap_flag_ExtensionGroup1 = 1;
	size_t soap_flag_ExtensionAttributes1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_userName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "fims:userName", &(a->fims__CredentialType::userName), "xsd:string"))
				{	soap_flag_userName1--;
					continue;
				}
			if (soap_flag_password1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "fims:password", &(a->fims__CredentialType::password), "xsd:string"))
				{	soap_flag_password1--;
					continue;
				}
			if (soap_flag_sessionToken1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "fims:sessionToken", &(a->fims__CredentialType::sessionToken), "xsd:string"))
				{	soap_flag_sessionToken1--;
					continue;
				}
			if (soap_flag_ExtensionGroup1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTofims__ExtensionGroup(soap, "fims:ExtensionGroup", &(a->fims__CredentialType::ExtensionGroup), "fims:ExtensionGroup"))
				{	soap_flag_ExtensionGroup1--;
					continue;
				}
			if (soap_flag_ExtensionAttributes1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTofims__ExtensionAttributes(soap, "fims:ExtensionAttributes", &(a->fims__CredentialType::ExtensionAttributes), "fims:ExtensionAttributes"))
				{	soap_flag_ExtensionAttributes1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (fims__CredentialType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_fims__CredentialType, 0, sizeof(fims__CredentialType), 0, soap_copy_fims__CredentialType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int fims__CredentialType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_fims__CredentialType);
	if (this->soap_out(soap, tag?tag:"fims:CredentialType", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *fims__CredentialType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_fims__CredentialType(soap, this, tag, type);
}

SOAP_FMAC3 fims__CredentialType * SOAP_FMAC4 soap_get_fims__CredentialType(struct soap *soap, fims__CredentialType *p, const char *tag, const char *type)
{
	if ((p = soap_in_fims__CredentialType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 fims__CredentialType * SOAP_FMAC2 soap_instantiate_fims__CredentialType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_fims__CredentialType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_fims__CredentialType, n, EDLProvider_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(fims__CredentialType);
		if (size)
			*size = sizeof(fims__CredentialType);
		((fims__CredentialType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(fims__CredentialType, n);
		if (size)
			*size = n * sizeof(fims__CredentialType);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((fims__CredentialType*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (fims__CredentialType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_fims__CredentialType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying fims__CredentialType %p -> %p\n", q, p));
	*(fims__CredentialType*)p = *(fims__CredentialType*)q;
}

void fims__BMEssenceLocatorStatusesType::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTofims__BMEssenceLocatorStatusType(soap, &this->fims__BMEssenceLocatorStatusesType::bmEssenceLocatorStatus);
	soap_default_std__vectorTemplateOf_XML(soap, &this->fims__BMEssenceLocatorStatusesType::__any);
	this->fims__BMEssenceLocatorStatusesType::__anyAttribute = NULL;
	/* transient soap skipped */
}

void fims__BMEssenceLocatorStatusesType::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfPointerTofims__BMEssenceLocatorStatusType(soap, &this->fims__BMEssenceLocatorStatusesType::bmEssenceLocatorStatus);
	soap_serialize_std__vectorTemplateOf_XML(soap, &this->fims__BMEssenceLocatorStatusesType::__any);
	/* transient soap skipped */
#endif
}

int fims__BMEssenceLocatorStatusesType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_fims__BMEssenceLocatorStatusesType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_fims__BMEssenceLocatorStatusesType(struct soap *soap, const char *tag, int id, const fims__BMEssenceLocatorStatusesType *a, const char *type)
{
	if (((fims__BMEssenceLocatorStatusesType*)a)->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", ((fims__BMEssenceLocatorStatusesType*)a)->__anyAttribute, 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_fims__BMEssenceLocatorStatusesType), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTofims__BMEssenceLocatorStatusType(soap, "fims:bmEssenceLocatorStatus", -1, &(a->fims__BMEssenceLocatorStatusesType::bmEssenceLocatorStatus), ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOf_XML(soap, "-any", -1, &(a->fims__BMEssenceLocatorStatusesType::__any), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *fims__BMEssenceLocatorStatusesType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_fims__BMEssenceLocatorStatusesType(soap, tag, this, type);
}

SOAP_FMAC3 fims__BMEssenceLocatorStatusesType * SOAP_FMAC4 soap_in_fims__BMEssenceLocatorStatusesType(struct soap *soap, const char *tag, fims__BMEssenceLocatorStatusesType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (fims__BMEssenceLocatorStatusesType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_fims__BMEssenceLocatorStatusesType, sizeof(fims__BMEssenceLocatorStatusesType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_fims__BMEssenceLocatorStatusesType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (fims__BMEssenceLocatorStatusesType *)a->soap_in(soap, tag, type);
		}
	}
	if (soap_s2string(soap, soap_attr_value(soap, "-anyAttribute", 0), &((fims__BMEssenceLocatorStatusesType*)a)->__anyAttribute, 0, -1))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTofims__BMEssenceLocatorStatusType(soap, "fims:bmEssenceLocatorStatus", &(a->fims__BMEssenceLocatorStatusesType::bmEssenceLocatorStatus), "fims:BMEssenceLocatorStatusType"))
					continue;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOf_XML(soap, "-any", &(a->fims__BMEssenceLocatorStatusesType::__any), ""))
					continue;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (fims__BMEssenceLocatorStatusesType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_fims__BMEssenceLocatorStatusesType, 0, sizeof(fims__BMEssenceLocatorStatusesType), 0, soap_copy_fims__BMEssenceLocatorStatusesType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (a->fims__BMEssenceLocatorStatusesType::bmEssenceLocatorStatus.size() < 1))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int fims__BMEssenceLocatorStatusesType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_fims__BMEssenceLocatorStatusesType);
	if (this->soap_out(soap, tag?tag:"fims:BMEssenceLocatorStatusesType", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *fims__BMEssenceLocatorStatusesType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_fims__BMEssenceLocatorStatusesType(soap, this, tag, type);
}

SOAP_FMAC3 fims__BMEssenceLocatorStatusesType * SOAP_FMAC4 soap_get_fims__BMEssenceLocatorStatusesType(struct soap *soap, fims__BMEssenceLocatorStatusesType *p, const char *tag, const char *type)
{
	if ((p = soap_in_fims__BMEssenceLocatorStatusesType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 fims__BMEssenceLocatorStatusesType * SOAP_FMAC2 soap_instantiate_fims__BMEssenceLocatorStatusesType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_fims__BMEssenceLocatorStatusesType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_fims__BMEssenceLocatorStatusesType, n, EDLProvider_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(fims__BMEssenceLocatorStatusesType);
		if (size)
			*size = sizeof(fims__BMEssenceLocatorStatusesType);
		((fims__BMEssenceLocatorStatusesType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(fims__BMEssenceLocatorStatusesType, n);
		if (size)
			*size = n * sizeof(fims__BMEssenceLocatorStatusesType);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((fims__BMEssenceLocatorStatusesType*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (fims__BMEssenceLocatorStatusesType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_fims__BMEssenceLocatorStatusesType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying fims__BMEssenceLocatorStatusesType %p -> %p\n", q, p));
	*(fims__BMEssenceLocatorStatusesType*)p = *(fims__BMEssenceLocatorStatusesType*)q;
}

void fims__BMEssenceLocatorStatusType::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->fims__ResourceType::soap_default(soap);
	soap_default_fims__BMStatusType(soap, &this->fims__BMEssenceLocatorStatusType::status);
	this->fims__BMEssenceLocatorStatusType::subStatus = NULL;
}

void fims__BMEssenceLocatorStatusType::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTofims__BMCustomStatusExtensionType(soap, &this->fims__BMEssenceLocatorStatusType::subStatus);
	this->fims__ResourceType::soap_serialize(soap);
#endif
}

int fims__BMEssenceLocatorStatusType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_fims__BMEssenceLocatorStatusType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_fims__BMEssenceLocatorStatusType(struct soap *soap, const char *tag, int id, const fims__BMEssenceLocatorStatusType *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_fims__BMEssenceLocatorStatusType), "fims:BMEssenceLocatorStatusType"))
		return soap->error;
	if (soap_out_fims__ResourceIDType(soap, "fims:resourceID", -1, &(a->fims__ResourceReferenceType::resourceID), ""))
		return soap->error;
	if (soap_out_PointerTofims__RevisionIDType(soap, "fims:revisionID", -1, &(a->fims__ResourceReferenceType::revisionID), ""))
		return soap->error;
	if (soap_out_PointerToxsd__anyURI(soap, "fims:location", -1, &(a->fims__ResourceReferenceType::location), ""))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_PointerTotime(soap, "fims:resourceCreationDate", -1, &(a->fims__ResourceType::resourceCreationDate), ""))
		return soap->error;
	if (soap_out_PointerTotime(soap, "fims:resourceModifiedDate", -1, &(a->fims__ResourceType::resourceModifiedDate), ""))
		return soap->error;
	if (soap_out_PointerTobool(soap, "fims:serviceGeneratedElement", -1, &(a->fims__ResourceType::serviceGeneratedElement), ""))
		return soap->error;
	if (soap_out_PointerTobool(soap, "fims:isFullyPopulated", -1, &(a->fims__ResourceType::isFullyPopulated), ""))
		return soap->error;
	if (soap_out_PointerTofims__AsyncEndpointType(soap, "fims:notifyAt", -1, &(a->fims__ResourceType::notifyAt), ""))
		return soap->error;
	if (soap_out_PointerTofims__ExtensionGroup(soap, "fims:ExtensionGroup", -1, &(a->fims__ResourceType::ExtensionGroup), ""))
		return soap->error;
	if (soap_out_PointerTofims__ExtensionAttributes(soap, "fims:ExtensionAttributes", -1, &(a->fims__ResourceType::ExtensionAttributes), ""))
		return soap->error;
	if (soap_out_fims__BMStatusType(soap, "fims:status", -1, &(a->fims__BMEssenceLocatorStatusType::status), ""))
		return soap->error;
	if (soap_out_PointerTofims__BMCustomStatusExtensionType(soap, "fims:subStatus", -1, &(a->fims__BMEssenceLocatorStatusType::subStatus), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *fims__BMEssenceLocatorStatusType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_fims__BMEssenceLocatorStatusType(soap, tag, this, type);
}

SOAP_FMAC3 fims__BMEssenceLocatorStatusType * SOAP_FMAC4 soap_in_fims__BMEssenceLocatorStatusType(struct soap *soap, const char *tag, fims__BMEssenceLocatorStatusType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (fims__BMEssenceLocatorStatusType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_fims__BMEssenceLocatorStatusType, sizeof(fims__BMEssenceLocatorStatusType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_fims__BMEssenceLocatorStatusType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (fims__BMEssenceLocatorStatusType *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_resourceID3 = 1;
	size_t soap_flag_revisionID3 = 1;
	size_t soap_flag_location3 = 1;
	size_t soap_flag_resourceCreationDate2 = 1;
	size_t soap_flag_resourceModifiedDate2 = 1;
	size_t soap_flag_serviceGeneratedElement2 = 1;
	size_t soap_flag_isFullyPopulated2 = 1;
	size_t soap_flag_notifyAt2 = 1;
	size_t soap_flag_ExtensionGroup2 = 1;
	size_t soap_flag_ExtensionAttributes2 = 1;
	size_t soap_flag_status1 = 1;
	size_t soap_flag_subStatus1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_resourceID3 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_fims__ResourceIDType(soap, "fims:resourceID", &(a->fims__ResourceReferenceType::resourceID), "fims:ResourceIDType"))
				{	soap_flag_resourceID3--;
					continue;
				}
			if (soap_flag_revisionID3 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTofims__RevisionIDType(soap, "fims:revisionID", &(a->fims__ResourceReferenceType::revisionID), "fims:RevisionIDType"))
				{	soap_flag_revisionID3--;
					continue;
				}
			if (soap_flag_location3 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerToxsd__anyURI(soap, "fims:location", &(a->fims__ResourceReferenceType::location), "xsd:anyURI"))
				{	soap_flag_location3--;
					continue;
				}
			/* transient soap skipped */
			if (soap_flag_resourceCreationDate2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTotime(soap, "fims:resourceCreationDate", &(a->fims__ResourceType::resourceCreationDate), "xsd:dateTime"))
				{	soap_flag_resourceCreationDate2--;
					continue;
				}
			if (soap_flag_resourceModifiedDate2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTotime(soap, "fims:resourceModifiedDate", &(a->fims__ResourceType::resourceModifiedDate), "xsd:dateTime"))
				{	soap_flag_resourceModifiedDate2--;
					continue;
				}
			if (soap_flag_serviceGeneratedElement2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTobool(soap, "fims:serviceGeneratedElement", &(a->fims__ResourceType::serviceGeneratedElement), "xsd:boolean"))
				{	soap_flag_serviceGeneratedElement2--;
					continue;
				}
			if (soap_flag_isFullyPopulated2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTobool(soap, "fims:isFullyPopulated", &(a->fims__ResourceType::isFullyPopulated), "xsd:boolean"))
				{	soap_flag_isFullyPopulated2--;
					continue;
				}
			if (soap_flag_notifyAt2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTofims__AsyncEndpointType(soap, "fims:notifyAt", &(a->fims__ResourceType::notifyAt), "fims:AsyncEndpointType"))
				{	soap_flag_notifyAt2--;
					continue;
				}
			if (soap_flag_ExtensionGroup2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTofims__ExtensionGroup(soap, "fims:ExtensionGroup", &(a->fims__ResourceType::ExtensionGroup), "fims:ExtensionGroup"))
				{	soap_flag_ExtensionGroup2--;
					continue;
				}
			if (soap_flag_ExtensionAttributes2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTofims__ExtensionAttributes(soap, "fims:ExtensionAttributes", &(a->fims__ResourceType::ExtensionAttributes), "fims:ExtensionAttributes"))
				{	soap_flag_ExtensionAttributes2--;
					continue;
				}
			if (soap_flag_status1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_fims__BMStatusType(soap, "fims:status", &(a->fims__BMEssenceLocatorStatusType::status), "fims:BMStatusType"))
				{	soap_flag_status1--;
					continue;
				}
			if (soap_flag_subStatus1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTofims__BMCustomStatusExtensionType(soap, "fims:subStatus", &(a->fims__BMEssenceLocatorStatusType::subStatus), "fims:BMCustomStatusExtensionType"))
				{	soap_flag_subStatus1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (fims__BMEssenceLocatorStatusType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_fims__BMEssenceLocatorStatusType, 0, sizeof(fims__BMEssenceLocatorStatusType), 0, soap_copy_fims__BMEssenceLocatorStatusType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_resourceID3 > 0 || soap_flag_status1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int fims__BMEssenceLocatorStatusType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_fims__BMEssenceLocatorStatusType);
	if (this->soap_out(soap, tag?tag:"fims:BMEssenceLocatorStatusType", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *fims__BMEssenceLocatorStatusType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_fims__BMEssenceLocatorStatusType(soap, this, tag, type);
}

SOAP_FMAC3 fims__BMEssenceLocatorStatusType * SOAP_FMAC4 soap_get_fims__BMEssenceLocatorStatusType(struct soap *soap, fims__BMEssenceLocatorStatusType *p, const char *tag, const char *type)
{
	if ((p = soap_in_fims__BMEssenceLocatorStatusType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 fims__BMEssenceLocatorStatusType * SOAP_FMAC2 soap_instantiate_fims__BMEssenceLocatorStatusType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_fims__BMEssenceLocatorStatusType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_fims__BMEssenceLocatorStatusType, n, EDLProvider_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(fims__BMEssenceLocatorStatusType);
		if (size)
			*size = sizeof(fims__BMEssenceLocatorStatusType);
		((fims__BMEssenceLocatorStatusType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(fims__BMEssenceLocatorStatusType, n);
		if (size)
			*size = n * sizeof(fims__BMEssenceLocatorStatusType);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((fims__BMEssenceLocatorStatusType*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (fims__BMEssenceLocatorStatusType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_fims__BMEssenceLocatorStatusType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying fims__BMEssenceLocatorStatusType %p -> %p\n", q, p));
	*(fims__BMEssenceLocatorStatusType*)p = *(fims__BMEssenceLocatorStatusType*)q;
}

void fims__BMContentStatusesType::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTofims__BMContentStatusType(soap, &this->fims__BMContentStatusesType::bmContentStatus);
	soap_default_std__vectorTemplateOf_XML(soap, &this->fims__BMContentStatusesType::__any);
	this->fims__BMContentStatusesType::__anyAttribute = NULL;
	/* transient soap skipped */
}

void fims__BMContentStatusesType::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfPointerTofims__BMContentStatusType(soap, &this->fims__BMContentStatusesType::bmContentStatus);
	soap_serialize_std__vectorTemplateOf_XML(soap, &this->fims__BMContentStatusesType::__any);
	/* transient soap skipped */
#endif
}

int fims__BMContentStatusesType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_fims__BMContentStatusesType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_fims__BMContentStatusesType(struct soap *soap, const char *tag, int id, const fims__BMContentStatusesType *a, const char *type)
{
	if (((fims__BMContentStatusesType*)a)->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", ((fims__BMContentStatusesType*)a)->__anyAttribute, 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_fims__BMContentStatusesType), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTofims__BMContentStatusType(soap, "fims:bmContentStatus", -1, &(a->fims__BMContentStatusesType::bmContentStatus), ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOf_XML(soap, "-any", -1, &(a->fims__BMContentStatusesType::__any), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *fims__BMContentStatusesType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_fims__BMContentStatusesType(soap, tag, this, type);
}

SOAP_FMAC3 fims__BMContentStatusesType * SOAP_FMAC4 soap_in_fims__BMContentStatusesType(struct soap *soap, const char *tag, fims__BMContentStatusesType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (fims__BMContentStatusesType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_fims__BMContentStatusesType, sizeof(fims__BMContentStatusesType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_fims__BMContentStatusesType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (fims__BMContentStatusesType *)a->soap_in(soap, tag, type);
		}
	}
	if (soap_s2string(soap, soap_attr_value(soap, "-anyAttribute", 0), &((fims__BMContentStatusesType*)a)->__anyAttribute, 0, -1))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTofims__BMContentStatusType(soap, "fims:bmContentStatus", &(a->fims__BMContentStatusesType::bmContentStatus), "fims:BMContentStatusType"))
					continue;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOf_XML(soap, "-any", &(a->fims__BMContentStatusesType::__any), ""))
					continue;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (fims__BMContentStatusesType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_fims__BMContentStatusesType, 0, sizeof(fims__BMContentStatusesType), 0, soap_copy_fims__BMContentStatusesType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (a->fims__BMContentStatusesType::bmContentStatus.size() < 1))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int fims__BMContentStatusesType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_fims__BMContentStatusesType);
	if (this->soap_out(soap, tag?tag:"fims:BMContentStatusesType", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *fims__BMContentStatusesType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_fims__BMContentStatusesType(soap, this, tag, type);
}

SOAP_FMAC3 fims__BMContentStatusesType * SOAP_FMAC4 soap_get_fims__BMContentStatusesType(struct soap *soap, fims__BMContentStatusesType *p, const char *tag, const char *type)
{
	if ((p = soap_in_fims__BMContentStatusesType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 fims__BMContentStatusesType * SOAP_FMAC2 soap_instantiate_fims__BMContentStatusesType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_fims__BMContentStatusesType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_fims__BMContentStatusesType, n, EDLProvider_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(fims__BMContentStatusesType);
		if (size)
			*size = sizeof(fims__BMContentStatusesType);
		((fims__BMContentStatusesType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(fims__BMContentStatusesType, n);
		if (size)
			*size = n * sizeof(fims__BMContentStatusesType);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((fims__BMContentStatusesType*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (fims__BMContentStatusesType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_fims__BMContentStatusesType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying fims__BMContentStatusesType %p -> %p\n", q, p));
	*(fims__BMContentStatusesType*)p = *(fims__BMContentStatusesType*)q;
}

void fims__BMContentStatusType::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->fims__ResourceType::soap_default(soap);
	soap_default_fims__BMStatusType(soap, &this->fims__BMContentStatusType::status);
	this->fims__BMContentStatusType::subStatus = NULL;
}

void fims__BMContentStatusType::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTofims__BMCustomStatusExtensionType(soap, &this->fims__BMContentStatusType::subStatus);
	this->fims__ResourceType::soap_serialize(soap);
#endif
}

int fims__BMContentStatusType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_fims__BMContentStatusType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_fims__BMContentStatusType(struct soap *soap, const char *tag, int id, const fims__BMContentStatusType *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_fims__BMContentStatusType), "fims:BMContentStatusType"))
		return soap->error;
	if (soap_out_fims__ResourceIDType(soap, "fims:resourceID", -1, &(a->fims__ResourceReferenceType::resourceID), ""))
		return soap->error;
	if (soap_out_PointerTofims__RevisionIDType(soap, "fims:revisionID", -1, &(a->fims__ResourceReferenceType::revisionID), ""))
		return soap->error;
	if (soap_out_PointerToxsd__anyURI(soap, "fims:location", -1, &(a->fims__ResourceReferenceType::location), ""))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_PointerTotime(soap, "fims:resourceCreationDate", -1, &(a->fims__ResourceType::resourceCreationDate), ""))
		return soap->error;
	if (soap_out_PointerTotime(soap, "fims:resourceModifiedDate", -1, &(a->fims__ResourceType::resourceModifiedDate), ""))
		return soap->error;
	if (soap_out_PointerTobool(soap, "fims:serviceGeneratedElement", -1, &(a->fims__ResourceType::serviceGeneratedElement), ""))
		return soap->error;
	if (soap_out_PointerTobool(soap, "fims:isFullyPopulated", -1, &(a->fims__ResourceType::isFullyPopulated), ""))
		return soap->error;
	if (soap_out_PointerTofims__AsyncEndpointType(soap, "fims:notifyAt", -1, &(a->fims__ResourceType::notifyAt), ""))
		return soap->error;
	if (soap_out_PointerTofims__ExtensionGroup(soap, "fims:ExtensionGroup", -1, &(a->fims__ResourceType::ExtensionGroup), ""))
		return soap->error;
	if (soap_out_PointerTofims__ExtensionAttributes(soap, "fims:ExtensionAttributes", -1, &(a->fims__ResourceType::ExtensionAttributes), ""))
		return soap->error;
	if (soap_out_fims__BMStatusType(soap, "fims:status", -1, &(a->fims__BMContentStatusType::status), ""))
		return soap->error;
	if (soap_out_PointerTofims__BMCustomStatusExtensionType(soap, "fims:subStatus", -1, &(a->fims__BMContentStatusType::subStatus), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *fims__BMContentStatusType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_fims__BMContentStatusType(soap, tag, this, type);
}

SOAP_FMAC3 fims__BMContentStatusType * SOAP_FMAC4 soap_in_fims__BMContentStatusType(struct soap *soap, const char *tag, fims__BMContentStatusType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (fims__BMContentStatusType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_fims__BMContentStatusType, sizeof(fims__BMContentStatusType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_fims__BMContentStatusType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (fims__BMContentStatusType *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_resourceID3 = 1;
	size_t soap_flag_revisionID3 = 1;
	size_t soap_flag_location3 = 1;
	size_t soap_flag_resourceCreationDate2 = 1;
	size_t soap_flag_resourceModifiedDate2 = 1;
	size_t soap_flag_serviceGeneratedElement2 = 1;
	size_t soap_flag_isFullyPopulated2 = 1;
	size_t soap_flag_notifyAt2 = 1;
	size_t soap_flag_ExtensionGroup2 = 1;
	size_t soap_flag_ExtensionAttributes2 = 1;
	size_t soap_flag_status1 = 1;
	size_t soap_flag_subStatus1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_resourceID3 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_fims__ResourceIDType(soap, "fims:resourceID", &(a->fims__ResourceReferenceType::resourceID), "fims:ResourceIDType"))
				{	soap_flag_resourceID3--;
					continue;
				}
			if (soap_flag_revisionID3 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTofims__RevisionIDType(soap, "fims:revisionID", &(a->fims__ResourceReferenceType::revisionID), "fims:RevisionIDType"))
				{	soap_flag_revisionID3--;
					continue;
				}
			if (soap_flag_location3 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerToxsd__anyURI(soap, "fims:location", &(a->fims__ResourceReferenceType::location), "xsd:anyURI"))
				{	soap_flag_location3--;
					continue;
				}
			/* transient soap skipped */
			if (soap_flag_resourceCreationDate2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTotime(soap, "fims:resourceCreationDate", &(a->fims__ResourceType::resourceCreationDate), "xsd:dateTime"))
				{	soap_flag_resourceCreationDate2--;
					continue;
				}
			if (soap_flag_resourceModifiedDate2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTotime(soap, "fims:resourceModifiedDate", &(a->fims__ResourceType::resourceModifiedDate), "xsd:dateTime"))
				{	soap_flag_resourceModifiedDate2--;
					continue;
				}
			if (soap_flag_serviceGeneratedElement2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTobool(soap, "fims:serviceGeneratedElement", &(a->fims__ResourceType::serviceGeneratedElement), "xsd:boolean"))
				{	soap_flag_serviceGeneratedElement2--;
					continue;
				}
			if (soap_flag_isFullyPopulated2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTobool(soap, "fims:isFullyPopulated", &(a->fims__ResourceType::isFullyPopulated), "xsd:boolean"))
				{	soap_flag_isFullyPopulated2--;
					continue;
				}
			if (soap_flag_notifyAt2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTofims__AsyncEndpointType(soap, "fims:notifyAt", &(a->fims__ResourceType::notifyAt), "fims:AsyncEndpointType"))
				{	soap_flag_notifyAt2--;
					continue;
				}
			if (soap_flag_ExtensionGroup2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTofims__ExtensionGroup(soap, "fims:ExtensionGroup", &(a->fims__ResourceType::ExtensionGroup), "fims:ExtensionGroup"))
				{	soap_flag_ExtensionGroup2--;
					continue;
				}
			if (soap_flag_ExtensionAttributes2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTofims__ExtensionAttributes(soap, "fims:ExtensionAttributes", &(a->fims__ResourceType::ExtensionAttributes), "fims:ExtensionAttributes"))
				{	soap_flag_ExtensionAttributes2--;
					continue;
				}
			if (soap_flag_status1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_fims__BMStatusType(soap, "fims:status", &(a->fims__BMContentStatusType::status), "fims:BMStatusType"))
				{	soap_flag_status1--;
					continue;
				}
			if (soap_flag_subStatus1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTofims__BMCustomStatusExtensionType(soap, "fims:subStatus", &(a->fims__BMContentStatusType::subStatus), "fims:BMCustomStatusExtensionType"))
				{	soap_flag_subStatus1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (fims__BMContentStatusType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_fims__BMContentStatusType, 0, sizeof(fims__BMContentStatusType), 0, soap_copy_fims__BMContentStatusType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_resourceID3 > 0 || soap_flag_status1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int fims__BMContentStatusType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_fims__BMContentStatusType);
	if (this->soap_out(soap, tag?tag:"fims:BMContentStatusType", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *fims__BMContentStatusType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_fims__BMContentStatusType(soap, this, tag, type);
}

SOAP_FMAC3 fims__BMContentStatusType * SOAP_FMAC4 soap_get_fims__BMContentStatusType(struct soap *soap, fims__BMContentStatusType *p, const char *tag, const char *type)
{
	if ((p = soap_in_fims__BMContentStatusType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 fims__BMContentStatusType * SOAP_FMAC2 soap_instantiate_fims__BMContentStatusType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_fims__BMContentStatusType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_fims__BMContentStatusType, n, EDLProvider_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(fims__BMContentStatusType);
		if (size)
			*size = sizeof(fims__BMContentStatusType);
		((fims__BMContentStatusType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(fims__BMContentStatusType, n);
		if (size)
			*size = n * sizeof(fims__BMContentStatusType);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((fims__BMContentStatusType*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (fims__BMContentStatusType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_fims__BMContentStatusType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying fims__BMContentStatusType %p -> %p\n", q, p));
	*(fims__BMContentStatusType*)p = *(fims__BMContentStatusType*)q;
}

void fims__BMCustomStatusExtensionsType::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTofims__BMCustomStatusExtensionType(soap, &this->fims__BMCustomStatusExtensionsType::bmCustomStatusExtension);
	soap_default_std__vectorTemplateOf_XML(soap, &this->fims__BMCustomStatusExtensionsType::__any);
	this->fims__BMCustomStatusExtensionsType::__anyAttribute = NULL;
	/* transient soap skipped */
}

void fims__BMCustomStatusExtensionsType::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfPointerTofims__BMCustomStatusExtensionType(soap, &this->fims__BMCustomStatusExtensionsType::bmCustomStatusExtension);
	soap_serialize_std__vectorTemplateOf_XML(soap, &this->fims__BMCustomStatusExtensionsType::__any);
	/* transient soap skipped */
#endif
}

int fims__BMCustomStatusExtensionsType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_fims__BMCustomStatusExtensionsType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_fims__BMCustomStatusExtensionsType(struct soap *soap, const char *tag, int id, const fims__BMCustomStatusExtensionsType *a, const char *type)
{
	if (((fims__BMCustomStatusExtensionsType*)a)->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", ((fims__BMCustomStatusExtensionsType*)a)->__anyAttribute, 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_fims__BMCustomStatusExtensionsType), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTofims__BMCustomStatusExtensionType(soap, "fims:bmCustomStatusExtension", -1, &(a->fims__BMCustomStatusExtensionsType::bmCustomStatusExtension), ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOf_XML(soap, "-any", -1, &(a->fims__BMCustomStatusExtensionsType::__any), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *fims__BMCustomStatusExtensionsType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_fims__BMCustomStatusExtensionsType(soap, tag, this, type);
}

SOAP_FMAC3 fims__BMCustomStatusExtensionsType * SOAP_FMAC4 soap_in_fims__BMCustomStatusExtensionsType(struct soap *soap, const char *tag, fims__BMCustomStatusExtensionsType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (fims__BMCustomStatusExtensionsType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_fims__BMCustomStatusExtensionsType, sizeof(fims__BMCustomStatusExtensionsType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_fims__BMCustomStatusExtensionsType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (fims__BMCustomStatusExtensionsType *)a->soap_in(soap, tag, type);
		}
	}
	if (soap_s2string(soap, soap_attr_value(soap, "-anyAttribute", 0), &((fims__BMCustomStatusExtensionsType*)a)->__anyAttribute, 0, -1))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTofims__BMCustomStatusExtensionType(soap, "fims:bmCustomStatusExtension", &(a->fims__BMCustomStatusExtensionsType::bmCustomStatusExtension), "fims:BMCustomStatusExtensionType"))
					continue;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOf_XML(soap, "-any", &(a->fims__BMCustomStatusExtensionsType::__any), ""))
					continue;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (fims__BMCustomStatusExtensionsType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_fims__BMCustomStatusExtensionsType, 0, sizeof(fims__BMCustomStatusExtensionsType), 0, soap_copy_fims__BMCustomStatusExtensionsType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (a->fims__BMCustomStatusExtensionsType::bmCustomStatusExtension.size() < 1))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int fims__BMCustomStatusExtensionsType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_fims__BMCustomStatusExtensionsType);
	if (this->soap_out(soap, tag?tag:"fims:BMCustomStatusExtensionsType", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *fims__BMCustomStatusExtensionsType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_fims__BMCustomStatusExtensionsType(soap, this, tag, type);
}

SOAP_FMAC3 fims__BMCustomStatusExtensionsType * SOAP_FMAC4 soap_get_fims__BMCustomStatusExtensionsType(struct soap *soap, fims__BMCustomStatusExtensionsType *p, const char *tag, const char *type)
{
	if ((p = soap_in_fims__BMCustomStatusExtensionsType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 fims__BMCustomStatusExtensionsType * SOAP_FMAC2 soap_instantiate_fims__BMCustomStatusExtensionsType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_fims__BMCustomStatusExtensionsType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_fims__BMCustomStatusExtensionsType, n, EDLProvider_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(fims__BMCustomStatusExtensionsType);
		if (size)
			*size = sizeof(fims__BMCustomStatusExtensionsType);
		((fims__BMCustomStatusExtensionsType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(fims__BMCustomStatusExtensionsType, n);
		if (size)
			*size = n * sizeof(fims__BMCustomStatusExtensionsType);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((fims__BMCustomStatusExtensionsType*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (fims__BMCustomStatusExtensionsType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_fims__BMCustomStatusExtensionsType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying fims__BMCustomStatusExtensionsType %p -> %p\n", q, p));
	*(fims__BMCustomStatusExtensionsType*)p = *(fims__BMCustomStatusExtensionsType*)q;
}

void fims__BMCustomStatusExtensionType::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->fims__ResourceType::soap_default(soap);
	soap_default_std__wstring(soap, &this->fims__BMCustomStatusExtensionType::code);
	this->fims__BMCustomStatusExtensionType::description = NULL;
}

void fims__BMCustomStatusExtensionType::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &this->fims__BMCustomStatusExtensionType::code, SOAP_TYPE_std__wstring);
	soap_serialize_std__wstring(soap, &this->fims__BMCustomStatusExtensionType::code);
	soap_serialize_PointerTostd__wstring(soap, &this->fims__BMCustomStatusExtensionType::description);
	this->fims__ResourceType::soap_serialize(soap);
#endif
}

int fims__BMCustomStatusExtensionType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_fims__BMCustomStatusExtensionType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_fims__BMCustomStatusExtensionType(struct soap *soap, const char *tag, int id, const fims__BMCustomStatusExtensionType *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_fims__BMCustomStatusExtensionType), "fims:BMCustomStatusExtensionType"))
		return soap->error;
	if (soap_out_fims__ResourceIDType(soap, "fims:resourceID", -1, &(a->fims__ResourceReferenceType::resourceID), ""))
		return soap->error;
	if (soap_out_PointerTofims__RevisionIDType(soap, "fims:revisionID", -1, &(a->fims__ResourceReferenceType::revisionID), ""))
		return soap->error;
	if (soap_out_PointerToxsd__anyURI(soap, "fims:location", -1, &(a->fims__ResourceReferenceType::location), ""))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_PointerTotime(soap, "fims:resourceCreationDate", -1, &(a->fims__ResourceType::resourceCreationDate), ""))
		return soap->error;
	if (soap_out_PointerTotime(soap, "fims:resourceModifiedDate", -1, &(a->fims__ResourceType::resourceModifiedDate), ""))
		return soap->error;
	if (soap_out_PointerTobool(soap, "fims:serviceGeneratedElement", -1, &(a->fims__ResourceType::serviceGeneratedElement), ""))
		return soap->error;
	if (soap_out_PointerTobool(soap, "fims:isFullyPopulated", -1, &(a->fims__ResourceType::isFullyPopulated), ""))
		return soap->error;
	if (soap_out_PointerTofims__AsyncEndpointType(soap, "fims:notifyAt", -1, &(a->fims__ResourceType::notifyAt), ""))
		return soap->error;
	if (soap_out_PointerTofims__ExtensionGroup(soap, "fims:ExtensionGroup", -1, &(a->fims__ResourceType::ExtensionGroup), ""))
		return soap->error;
	if (soap_out_PointerTofims__ExtensionAttributes(soap, "fims:ExtensionAttributes", -1, &(a->fims__ResourceType::ExtensionAttributes), ""))
		return soap->error;
	if (soap_out_std__wstring(soap, "fims:code", -1, &(a->fims__BMCustomStatusExtensionType::code), ""))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "fims:description", -1, &(a->fims__BMCustomStatusExtensionType::description), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *fims__BMCustomStatusExtensionType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_fims__BMCustomStatusExtensionType(soap, tag, this, type);
}

SOAP_FMAC3 fims__BMCustomStatusExtensionType * SOAP_FMAC4 soap_in_fims__BMCustomStatusExtensionType(struct soap *soap, const char *tag, fims__BMCustomStatusExtensionType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (fims__BMCustomStatusExtensionType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_fims__BMCustomStatusExtensionType, sizeof(fims__BMCustomStatusExtensionType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_fims__BMCustomStatusExtensionType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (fims__BMCustomStatusExtensionType *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_resourceID3 = 1;
	size_t soap_flag_revisionID3 = 1;
	size_t soap_flag_location3 = 1;
	size_t soap_flag_resourceCreationDate2 = 1;
	size_t soap_flag_resourceModifiedDate2 = 1;
	size_t soap_flag_serviceGeneratedElement2 = 1;
	size_t soap_flag_isFullyPopulated2 = 1;
	size_t soap_flag_notifyAt2 = 1;
	size_t soap_flag_ExtensionGroup2 = 1;
	size_t soap_flag_ExtensionAttributes2 = 1;
	size_t soap_flag_code1 = 1;
	size_t soap_flag_description1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_resourceID3 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_fims__ResourceIDType(soap, "fims:resourceID", &(a->fims__ResourceReferenceType::resourceID), "fims:ResourceIDType"))
				{	soap_flag_resourceID3--;
					continue;
				}
			if (soap_flag_revisionID3 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTofims__RevisionIDType(soap, "fims:revisionID", &(a->fims__ResourceReferenceType::revisionID), "fims:RevisionIDType"))
				{	soap_flag_revisionID3--;
					continue;
				}
			if (soap_flag_location3 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerToxsd__anyURI(soap, "fims:location", &(a->fims__ResourceReferenceType::location), "xsd:anyURI"))
				{	soap_flag_location3--;
					continue;
				}
			/* transient soap skipped */
			if (soap_flag_resourceCreationDate2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTotime(soap, "fims:resourceCreationDate", &(a->fims__ResourceType::resourceCreationDate), "xsd:dateTime"))
				{	soap_flag_resourceCreationDate2--;
					continue;
				}
			if (soap_flag_resourceModifiedDate2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTotime(soap, "fims:resourceModifiedDate", &(a->fims__ResourceType::resourceModifiedDate), "xsd:dateTime"))
				{	soap_flag_resourceModifiedDate2--;
					continue;
				}
			if (soap_flag_serviceGeneratedElement2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTobool(soap, "fims:serviceGeneratedElement", &(a->fims__ResourceType::serviceGeneratedElement), "xsd:boolean"))
				{	soap_flag_serviceGeneratedElement2--;
					continue;
				}
			if (soap_flag_isFullyPopulated2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTobool(soap, "fims:isFullyPopulated", &(a->fims__ResourceType::isFullyPopulated), "xsd:boolean"))
				{	soap_flag_isFullyPopulated2--;
					continue;
				}
			if (soap_flag_notifyAt2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTofims__AsyncEndpointType(soap, "fims:notifyAt", &(a->fims__ResourceType::notifyAt), "fims:AsyncEndpointType"))
				{	soap_flag_notifyAt2--;
					continue;
				}
			if (soap_flag_ExtensionGroup2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTofims__ExtensionGroup(soap, "fims:ExtensionGroup", &(a->fims__ResourceType::ExtensionGroup), "fims:ExtensionGroup"))
				{	soap_flag_ExtensionGroup2--;
					continue;
				}
			if (soap_flag_ExtensionAttributes2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTofims__ExtensionAttributes(soap, "fims:ExtensionAttributes", &(a->fims__ResourceType::ExtensionAttributes), "fims:ExtensionAttributes"))
				{	soap_flag_ExtensionAttributes2--;
					continue;
				}
			if (soap_flag_code1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__wstring(soap, "fims:code", &(a->fims__BMCustomStatusExtensionType::code), "xsd:string"))
				{	soap_flag_code1--;
					continue;
				}
			if (soap_flag_description1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "fims:description", &(a->fims__BMCustomStatusExtensionType::description), "xsd:string"))
				{	soap_flag_description1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (fims__BMCustomStatusExtensionType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_fims__BMCustomStatusExtensionType, 0, sizeof(fims__BMCustomStatusExtensionType), 0, soap_copy_fims__BMCustomStatusExtensionType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_resourceID3 > 0 || soap_flag_code1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int fims__BMCustomStatusExtensionType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_fims__BMCustomStatusExtensionType);
	if (this->soap_out(soap, tag?tag:"fims:BMCustomStatusExtensionType", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *fims__BMCustomStatusExtensionType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_fims__BMCustomStatusExtensionType(soap, this, tag, type);
}

SOAP_FMAC3 fims__BMCustomStatusExtensionType * SOAP_FMAC4 soap_get_fims__BMCustomStatusExtensionType(struct soap *soap, fims__BMCustomStatusExtensionType *p, const char *tag, const char *type)
{
	if ((p = soap_in_fims__BMCustomStatusExtensionType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 fims__BMCustomStatusExtensionType * SOAP_FMAC2 soap_instantiate_fims__BMCustomStatusExtensionType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_fims__BMCustomStatusExtensionType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_fims__BMCustomStatusExtensionType, n, EDLProvider_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(fims__BMCustomStatusExtensionType);
		if (size)
			*size = sizeof(fims__BMCustomStatusExtensionType);
		((fims__BMCustomStatusExtensionType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(fims__BMCustomStatusExtensionType, n);
		if (size)
			*size = n * sizeof(fims__BMCustomStatusExtensionType);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((fims__BMCustomStatusExtensionType*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (fims__BMCustomStatusExtensionType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_fims__BMCustomStatusExtensionType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying fims__BMCustomStatusExtensionType %p -> %p\n", q, p));
	*(fims__BMCustomStatusExtensionType*)p = *(fims__BMCustomStatusExtensionType*)q;
}

void fims__CustomValuesType::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTofims__CustomValueType(soap, &this->fims__CustomValuesType::customValue);
	soap_default_std__vectorTemplateOf_XML(soap, &this->fims__CustomValuesType::__any);
	this->fims__CustomValuesType::__anyAttribute = NULL;
	/* transient soap skipped */
}

void fims__CustomValuesType::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfPointerTofims__CustomValueType(soap, &this->fims__CustomValuesType::customValue);
	soap_serialize_std__vectorTemplateOf_XML(soap, &this->fims__CustomValuesType::__any);
	/* transient soap skipped */
#endif
}

int fims__CustomValuesType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_fims__CustomValuesType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_fims__CustomValuesType(struct soap *soap, const char *tag, int id, const fims__CustomValuesType *a, const char *type)
{
	if (((fims__CustomValuesType*)a)->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", ((fims__CustomValuesType*)a)->__anyAttribute, 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_fims__CustomValuesType), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTofims__CustomValueType(soap, "fims:customValue", -1, &(a->fims__CustomValuesType::customValue), ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOf_XML(soap, "-any", -1, &(a->fims__CustomValuesType::__any), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *fims__CustomValuesType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_fims__CustomValuesType(soap, tag, this, type);
}

SOAP_FMAC3 fims__CustomValuesType * SOAP_FMAC4 soap_in_fims__CustomValuesType(struct soap *soap, const char *tag, fims__CustomValuesType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (fims__CustomValuesType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_fims__CustomValuesType, sizeof(fims__CustomValuesType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_fims__CustomValuesType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (fims__CustomValuesType *)a->soap_in(soap, tag, type);
		}
	}
	if (soap_s2string(soap, soap_attr_value(soap, "-anyAttribute", 0), &((fims__CustomValuesType*)a)->__anyAttribute, 0, -1))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTofims__CustomValueType(soap, "fims:customValue", &(a->fims__CustomValuesType::customValue), "fims:CustomValueType"))
					continue;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOf_XML(soap, "-any", &(a->fims__CustomValuesType::__any), ""))
					continue;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (fims__CustomValuesType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_fims__CustomValuesType, 0, sizeof(fims__CustomValuesType), 0, soap_copy_fims__CustomValuesType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (a->fims__CustomValuesType::customValue.size() < 1))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int fims__CustomValuesType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_fims__CustomValuesType);
	if (this->soap_out(soap, tag?tag:"fims:CustomValuesType", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *fims__CustomValuesType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_fims__CustomValuesType(soap, this, tag, type);
}

SOAP_FMAC3 fims__CustomValuesType * SOAP_FMAC4 soap_get_fims__CustomValuesType(struct soap *soap, fims__CustomValuesType *p, const char *tag, const char *type)
{
	if ((p = soap_in_fims__CustomValuesType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 fims__CustomValuesType * SOAP_FMAC2 soap_instantiate_fims__CustomValuesType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_fims__CustomValuesType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_fims__CustomValuesType, n, EDLProvider_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(fims__CustomValuesType);
		if (size)
			*size = sizeof(fims__CustomValuesType);
		((fims__CustomValuesType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(fims__CustomValuesType, n);
		if (size)
			*size = n * sizeof(fims__CustomValuesType);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((fims__CustomValuesType*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (fims__CustomValuesType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_fims__CustomValuesType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying fims__CustomValuesType %p -> %p\n", q, p));
	*(fims__CustomValuesType*)p = *(fims__CustomValuesType*)q;
}

void fims__CustomValueType::soap_default(struct soap *soap)
{
	this->soap = soap;
	/* transient soap skipped */
}

void fims__CustomValueType::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
#endif
}

int fims__CustomValueType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_fims__CustomValueType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_fims__CustomValueType(struct soap *soap, const char *tag, int id, const fims__CustomValueType *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_fims__CustomValueType), type))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *fims__CustomValueType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_fims__CustomValueType(soap, tag, this, type);
}

SOAP_FMAC3 fims__CustomValueType * SOAP_FMAC4 soap_in_fims__CustomValueType(struct soap *soap, const char *tag, fims__CustomValueType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (fims__CustomValueType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_fims__CustomValueType, sizeof(fims__CustomValueType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_fims__CustomValueType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (fims__CustomValueType *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (fims__CustomValueType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_fims__CustomValueType, 0, sizeof(fims__CustomValueType), 0, soap_copy_fims__CustomValueType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int fims__CustomValueType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_fims__CustomValueType);
	if (this->soap_out(soap, tag?tag:"fims:CustomValueType", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *fims__CustomValueType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_fims__CustomValueType(soap, this, tag, type);
}

SOAP_FMAC3 fims__CustomValueType * SOAP_FMAC4 soap_get_fims__CustomValueType(struct soap *soap, fims__CustomValueType *p, const char *tag, const char *type)
{
	if ((p = soap_in_fims__CustomValueType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 fims__CustomValueType * SOAP_FMAC2 soap_instantiate_fims__CustomValueType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_fims__CustomValueType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_fims__CustomValueType, n, EDLProvider_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(fims__CustomValueType);
		if (size)
			*size = sizeof(fims__CustomValueType);
		((fims__CustomValueType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(fims__CustomValueType, n);
		if (size)
			*size = n * sizeof(fims__CustomValueType);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((fims__CustomValueType*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (fims__CustomValueType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_fims__CustomValueType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying fims__CustomValueType %p -> %p\n", q, p));
	*(fims__CustomValueType*)p = *(fims__CustomValueType*)q;
}

void fims__ResourceReferencesType::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTofims__ResourceReferenceType(soap, &this->fims__ResourceReferencesType::resourceReference);
	soap_default_std__vectorTemplateOf_XML(soap, &this->fims__ResourceReferencesType::__any);
	this->fims__ResourceReferencesType::__anyAttribute = NULL;
	/* transient soap skipped */
}

void fims__ResourceReferencesType::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfPointerTofims__ResourceReferenceType(soap, &this->fims__ResourceReferencesType::resourceReference);
	soap_serialize_std__vectorTemplateOf_XML(soap, &this->fims__ResourceReferencesType::__any);
	/* transient soap skipped */
#endif
}

int fims__ResourceReferencesType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_fims__ResourceReferencesType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_fims__ResourceReferencesType(struct soap *soap, const char *tag, int id, const fims__ResourceReferencesType *a, const char *type)
{
	if (((fims__ResourceReferencesType*)a)->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", ((fims__ResourceReferencesType*)a)->__anyAttribute, 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_fims__ResourceReferencesType), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTofims__ResourceReferenceType(soap, "fims:resourceReference", -1, &(a->fims__ResourceReferencesType::resourceReference), ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOf_XML(soap, "-any", -1, &(a->fims__ResourceReferencesType::__any), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *fims__ResourceReferencesType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_fims__ResourceReferencesType(soap, tag, this, type);
}

SOAP_FMAC3 fims__ResourceReferencesType * SOAP_FMAC4 soap_in_fims__ResourceReferencesType(struct soap *soap, const char *tag, fims__ResourceReferencesType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (fims__ResourceReferencesType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_fims__ResourceReferencesType, sizeof(fims__ResourceReferencesType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_fims__ResourceReferencesType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (fims__ResourceReferencesType *)a->soap_in(soap, tag, type);
		}
	}
	if (soap_s2string(soap, soap_attr_value(soap, "-anyAttribute", 0), &((fims__ResourceReferencesType*)a)->__anyAttribute, 0, -1))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTofims__ResourceReferenceType(soap, "fims:resourceReference", &(a->fims__ResourceReferencesType::resourceReference), "fims:ResourceReferenceType"))
					continue;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOf_XML(soap, "-any", &(a->fims__ResourceReferencesType::__any), ""))
					continue;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (fims__ResourceReferencesType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_fims__ResourceReferencesType, 0, sizeof(fims__ResourceReferencesType), 0, soap_copy_fims__ResourceReferencesType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (a->fims__ResourceReferencesType::resourceReference.size() < 1))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int fims__ResourceReferencesType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_fims__ResourceReferencesType);
	if (this->soap_out(soap, tag?tag:"fims:ResourceReferencesType", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *fims__ResourceReferencesType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_fims__ResourceReferencesType(soap, this, tag, type);
}

SOAP_FMAC3 fims__ResourceReferencesType * SOAP_FMAC4 soap_get_fims__ResourceReferencesType(struct soap *soap, fims__ResourceReferencesType *p, const char *tag, const char *type)
{
	if ((p = soap_in_fims__ResourceReferencesType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 fims__ResourceReferencesType * SOAP_FMAC2 soap_instantiate_fims__ResourceReferencesType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_fims__ResourceReferencesType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_fims__ResourceReferencesType, n, EDLProvider_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(fims__ResourceReferencesType);
		if (size)
			*size = sizeof(fims__ResourceReferencesType);
		((fims__ResourceReferencesType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(fims__ResourceReferencesType, n);
		if (size)
			*size = n * sizeof(fims__ResourceReferencesType);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((fims__ResourceReferencesType*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (fims__ResourceReferencesType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_fims__ResourceReferencesType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying fims__ResourceReferencesType %p -> %p\n", q, p));
	*(fims__ResourceReferencesType*)p = *(fims__ResourceReferencesType*)q;
}

void fims__DescriptionsType::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTofims__DescriptionType(soap, &this->fims__DescriptionsType::description);
	soap_default_std__vectorTemplateOf_XML(soap, &this->fims__DescriptionsType::__any);
	this->fims__DescriptionsType::__anyAttribute = NULL;
	/* transient soap skipped */
}

void fims__DescriptionsType::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfPointerTofims__DescriptionType(soap, &this->fims__DescriptionsType::description);
	soap_serialize_std__vectorTemplateOf_XML(soap, &this->fims__DescriptionsType::__any);
	/* transient soap skipped */
#endif
}

int fims__DescriptionsType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_fims__DescriptionsType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_fims__DescriptionsType(struct soap *soap, const char *tag, int id, const fims__DescriptionsType *a, const char *type)
{
	if (((fims__DescriptionsType*)a)->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", ((fims__DescriptionsType*)a)->__anyAttribute, 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_fims__DescriptionsType), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTofims__DescriptionType(soap, "fims:description", -1, &(a->fims__DescriptionsType::description), ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOf_XML(soap, "-any", -1, &(a->fims__DescriptionsType::__any), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *fims__DescriptionsType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_fims__DescriptionsType(soap, tag, this, type);
}

SOAP_FMAC3 fims__DescriptionsType * SOAP_FMAC4 soap_in_fims__DescriptionsType(struct soap *soap, const char *tag, fims__DescriptionsType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (fims__DescriptionsType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_fims__DescriptionsType, sizeof(fims__DescriptionsType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_fims__DescriptionsType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (fims__DescriptionsType *)a->soap_in(soap, tag, type);
		}
	}
	if (soap_s2string(soap, soap_attr_value(soap, "-anyAttribute", 0), &((fims__DescriptionsType*)a)->__anyAttribute, 0, -1))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTofims__DescriptionType(soap, "fims:description", &(a->fims__DescriptionsType::description), "fims:DescriptionType"))
					continue;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOf_XML(soap, "-any", &(a->fims__DescriptionsType::__any), ""))
					continue;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (fims__DescriptionsType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_fims__DescriptionsType, 0, sizeof(fims__DescriptionsType), 0, soap_copy_fims__DescriptionsType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (a->fims__DescriptionsType::description.size() < 1))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int fims__DescriptionsType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_fims__DescriptionsType);
	if (this->soap_out(soap, tag?tag:"fims:DescriptionsType", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *fims__DescriptionsType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_fims__DescriptionsType(soap, this, tag, type);
}

SOAP_FMAC3 fims__DescriptionsType * SOAP_FMAC4 soap_get_fims__DescriptionsType(struct soap *soap, fims__DescriptionsType *p, const char *tag, const char *type)
{
	if ((p = soap_in_fims__DescriptionsType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 fims__DescriptionsType * SOAP_FMAC2 soap_instantiate_fims__DescriptionsType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_fims__DescriptionsType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_fims__DescriptionsType, n, EDLProvider_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(fims__DescriptionsType);
		if (size)
			*size = sizeof(fims__DescriptionsType);
		((fims__DescriptionsType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(fims__DescriptionsType, n);
		if (size)
			*size = n * sizeof(fims__DescriptionsType);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((fims__DescriptionsType*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (fims__DescriptionsType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_fims__DescriptionsType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying fims__DescriptionsType %p -> %p\n", q, p));
	*(fims__DescriptionsType*)p = *(fims__DescriptionsType*)q;
}

void fims__BMEssenceLocatorsType::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTofims__BMEssenceLocatorType(soap, &this->fims__BMEssenceLocatorsType::bmEssenceLocator);
	soap_default_std__vectorTemplateOf_XML(soap, &this->fims__BMEssenceLocatorsType::__any);
	this->fims__BMEssenceLocatorsType::__anyAttribute = NULL;
	/* transient soap skipped */
}

void fims__BMEssenceLocatorsType::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfPointerTofims__BMEssenceLocatorType(soap, &this->fims__BMEssenceLocatorsType::bmEssenceLocator);
	soap_serialize_std__vectorTemplateOf_XML(soap, &this->fims__BMEssenceLocatorsType::__any);
	/* transient soap skipped */
#endif
}

int fims__BMEssenceLocatorsType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_fims__BMEssenceLocatorsType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_fims__BMEssenceLocatorsType(struct soap *soap, const char *tag, int id, const fims__BMEssenceLocatorsType *a, const char *type)
{
	if (((fims__BMEssenceLocatorsType*)a)->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", ((fims__BMEssenceLocatorsType*)a)->__anyAttribute, 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_fims__BMEssenceLocatorsType), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTofims__BMEssenceLocatorType(soap, "fims:bmEssenceLocator", -1, &(a->fims__BMEssenceLocatorsType::bmEssenceLocator), ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOf_XML(soap, "-any", -1, &(a->fims__BMEssenceLocatorsType::__any), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *fims__BMEssenceLocatorsType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_fims__BMEssenceLocatorsType(soap, tag, this, type);
}

SOAP_FMAC3 fims__BMEssenceLocatorsType * SOAP_FMAC4 soap_in_fims__BMEssenceLocatorsType(struct soap *soap, const char *tag, fims__BMEssenceLocatorsType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (fims__BMEssenceLocatorsType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_fims__BMEssenceLocatorsType, sizeof(fims__BMEssenceLocatorsType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_fims__BMEssenceLocatorsType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (fims__BMEssenceLocatorsType *)a->soap_in(soap, tag, type);
		}
	}
	if (soap_s2string(soap, soap_attr_value(soap, "-anyAttribute", 0), &((fims__BMEssenceLocatorsType*)a)->__anyAttribute, 0, -1))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTofims__BMEssenceLocatorType(soap, "fims:bmEssenceLocator", &(a->fims__BMEssenceLocatorsType::bmEssenceLocator), "fims:BMEssenceLocatorType"))
					continue;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOf_XML(soap, "-any", &(a->fims__BMEssenceLocatorsType::__any), ""))
					continue;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (fims__BMEssenceLocatorsType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_fims__BMEssenceLocatorsType, 0, sizeof(fims__BMEssenceLocatorsType), 0, soap_copy_fims__BMEssenceLocatorsType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (a->fims__BMEssenceLocatorsType::bmEssenceLocator.size() < 1))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int fims__BMEssenceLocatorsType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_fims__BMEssenceLocatorsType);
	if (this->soap_out(soap, tag?tag:"fims:BMEssenceLocatorsType", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *fims__BMEssenceLocatorsType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_fims__BMEssenceLocatorsType(soap, this, tag, type);
}

SOAP_FMAC3 fims__BMEssenceLocatorsType * SOAP_FMAC4 soap_get_fims__BMEssenceLocatorsType(struct soap *soap, fims__BMEssenceLocatorsType *p, const char *tag, const char *type)
{
	if ((p = soap_in_fims__BMEssenceLocatorsType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 fims__BMEssenceLocatorsType * SOAP_FMAC2 soap_instantiate_fims__BMEssenceLocatorsType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_fims__BMEssenceLocatorsType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_fims__BMEssenceLocatorsType, n, EDLProvider_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(fims__BMEssenceLocatorsType);
		if (size)
			*size = sizeof(fims__BMEssenceLocatorsType);
		((fims__BMEssenceLocatorsType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(fims__BMEssenceLocatorsType, n);
		if (size)
			*size = n * sizeof(fims__BMEssenceLocatorsType);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((fims__BMEssenceLocatorsType*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (fims__BMEssenceLocatorsType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_fims__BMEssenceLocatorsType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying fims__BMEssenceLocatorsType %p -> %p\n", q, p));
	*(fims__BMEssenceLocatorsType*)p = *(fims__BMEssenceLocatorsType*)q;
}

void fims__BMContentFormatsType::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTofims__BMContentFormatType(soap, &this->fims__BMContentFormatsType::bmContentFormat);
	soap_default_std__vectorTemplateOf_XML(soap, &this->fims__BMContentFormatsType::__any);
	this->fims__BMContentFormatsType::__anyAttribute = NULL;
	/* transient soap skipped */
}

void fims__BMContentFormatsType::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfPointerTofims__BMContentFormatType(soap, &this->fims__BMContentFormatsType::bmContentFormat);
	soap_serialize_std__vectorTemplateOf_XML(soap, &this->fims__BMContentFormatsType::__any);
	/* transient soap skipped */
#endif
}

int fims__BMContentFormatsType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_fims__BMContentFormatsType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_fims__BMContentFormatsType(struct soap *soap, const char *tag, int id, const fims__BMContentFormatsType *a, const char *type)
{
	if (((fims__BMContentFormatsType*)a)->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", ((fims__BMContentFormatsType*)a)->__anyAttribute, 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_fims__BMContentFormatsType), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTofims__BMContentFormatType(soap, "fims:bmContentFormat", -1, &(a->fims__BMContentFormatsType::bmContentFormat), ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOf_XML(soap, "-any", -1, &(a->fims__BMContentFormatsType::__any), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *fims__BMContentFormatsType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_fims__BMContentFormatsType(soap, tag, this, type);
}

SOAP_FMAC3 fims__BMContentFormatsType * SOAP_FMAC4 soap_in_fims__BMContentFormatsType(struct soap *soap, const char *tag, fims__BMContentFormatsType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (fims__BMContentFormatsType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_fims__BMContentFormatsType, sizeof(fims__BMContentFormatsType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_fims__BMContentFormatsType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (fims__BMContentFormatsType *)a->soap_in(soap, tag, type);
		}
	}
	if (soap_s2string(soap, soap_attr_value(soap, "-anyAttribute", 0), &((fims__BMContentFormatsType*)a)->__anyAttribute, 0, -1))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTofims__BMContentFormatType(soap, "fims:bmContentFormat", &(a->fims__BMContentFormatsType::bmContentFormat), "fims:BMContentFormatType"))
					continue;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOf_XML(soap, "-any", &(a->fims__BMContentFormatsType::__any), ""))
					continue;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (fims__BMContentFormatsType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_fims__BMContentFormatsType, 0, sizeof(fims__BMContentFormatsType), 0, soap_copy_fims__BMContentFormatsType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (a->fims__BMContentFormatsType::bmContentFormat.size() < 1))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int fims__BMContentFormatsType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_fims__BMContentFormatsType);
	if (this->soap_out(soap, tag?tag:"fims:BMContentFormatsType", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *fims__BMContentFormatsType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_fims__BMContentFormatsType(soap, this, tag, type);
}

SOAP_FMAC3 fims__BMContentFormatsType * SOAP_FMAC4 soap_get_fims__BMContentFormatsType(struct soap *soap, fims__BMContentFormatsType *p, const char *tag, const char *type)
{
	if ((p = soap_in_fims__BMContentFormatsType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 fims__BMContentFormatsType * SOAP_FMAC2 soap_instantiate_fims__BMContentFormatsType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_fims__BMContentFormatsType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_fims__BMContentFormatsType, n, EDLProvider_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(fims__BMContentFormatsType);
		if (size)
			*size = sizeof(fims__BMContentFormatsType);
		((fims__BMContentFormatsType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(fims__BMContentFormatsType, n);
		if (size)
			*size = n * sizeof(fims__BMContentFormatsType);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((fims__BMContentFormatsType*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (fims__BMContentFormatsType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_fims__BMContentFormatsType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying fims__BMContentFormatsType %p -> %p\n", q, p));
	*(fims__BMContentFormatsType*)p = *(fims__BMContentFormatsType*)q;
}

void fims__BMContentsType::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTofims__BMContentType(soap, &this->fims__BMContentsType::bmContent);
	soap_default_std__vectorTemplateOf_XML(soap, &this->fims__BMContentsType::__any);
	this->fims__BMContentsType::__anyAttribute = NULL;
	/* transient soap skipped */
}

void fims__BMContentsType::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfPointerTofims__BMContentType(soap, &this->fims__BMContentsType::bmContent);
	soap_serialize_std__vectorTemplateOf_XML(soap, &this->fims__BMContentsType::__any);
	/* transient soap skipped */
#endif
}

int fims__BMContentsType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_fims__BMContentsType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_fims__BMContentsType(struct soap *soap, const char *tag, int id, const fims__BMContentsType *a, const char *type)
{
	if (((fims__BMContentsType*)a)->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", ((fims__BMContentsType*)a)->__anyAttribute, 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_fims__BMContentsType), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTofims__BMContentType(soap, "fims:bmContent", -1, &(a->fims__BMContentsType::bmContent), ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOf_XML(soap, "-any", -1, &(a->fims__BMContentsType::__any), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *fims__BMContentsType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_fims__BMContentsType(soap, tag, this, type);
}

SOAP_FMAC3 fims__BMContentsType * SOAP_FMAC4 soap_in_fims__BMContentsType(struct soap *soap, const char *tag, fims__BMContentsType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (fims__BMContentsType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_fims__BMContentsType, sizeof(fims__BMContentsType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_fims__BMContentsType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (fims__BMContentsType *)a->soap_in(soap, tag, type);
		}
	}
	if (soap_s2string(soap, soap_attr_value(soap, "-anyAttribute", 0), &((fims__BMContentsType*)a)->__anyAttribute, 0, -1))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTofims__BMContentType(soap, "fims:bmContent", &(a->fims__BMContentsType::bmContent), "fims:BMContentType"))
					continue;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOf_XML(soap, "-any", &(a->fims__BMContentsType::__any), ""))
					continue;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (fims__BMContentsType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_fims__BMContentsType, 0, sizeof(fims__BMContentsType), 0, soap_copy_fims__BMContentsType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (a->fims__BMContentsType::bmContent.size() < 1))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int fims__BMContentsType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_fims__BMContentsType);
	if (this->soap_out(soap, tag?tag:"fims:BMContentsType", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *fims__BMContentsType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_fims__BMContentsType(soap, this, tag, type);
}

SOAP_FMAC3 fims__BMContentsType * SOAP_FMAC4 soap_get_fims__BMContentsType(struct soap *soap, fims__BMContentsType *p, const char *tag, const char *type)
{
	if ((p = soap_in_fims__BMContentsType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 fims__BMContentsType * SOAP_FMAC2 soap_instantiate_fims__BMContentsType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_fims__BMContentsType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_fims__BMContentsType, n, EDLProvider_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(fims__BMContentsType);
		if (size)
			*size = sizeof(fims__BMContentsType);
		((fims__BMContentsType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(fims__BMContentsType, n);
		if (size)
			*size = n * sizeof(fims__BMContentsType);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((fims__BMContentsType*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (fims__BMContentsType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_fims__BMContentsType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying fims__BMContentsType %p -> %p\n", q, p));
	*(fims__BMContentsType*)p = *(fims__BMContentsType*)q;
}

void fims__BMObjectsType::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTofims__BMObjectType(soap, &this->fims__BMObjectsType::bmObject);
	soap_default_std__vectorTemplateOf_XML(soap, &this->fims__BMObjectsType::__any);
	this->fims__BMObjectsType::__anyAttribute = NULL;
	/* transient soap skipped */
}

void fims__BMObjectsType::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfPointerTofims__BMObjectType(soap, &this->fims__BMObjectsType::bmObject);
	soap_serialize_std__vectorTemplateOf_XML(soap, &this->fims__BMObjectsType::__any);
	/* transient soap skipped */
#endif
}

int fims__BMObjectsType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_fims__BMObjectsType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_fims__BMObjectsType(struct soap *soap, const char *tag, int id, const fims__BMObjectsType *a, const char *type)
{
	if (((fims__BMObjectsType*)a)->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", ((fims__BMObjectsType*)a)->__anyAttribute, 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_fims__BMObjectsType), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTofims__BMObjectType(soap, "fims:bmObject", -1, &(a->fims__BMObjectsType::bmObject), ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOf_XML(soap, "-any", -1, &(a->fims__BMObjectsType::__any), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *fims__BMObjectsType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_fims__BMObjectsType(soap, tag, this, type);
}

SOAP_FMAC3 fims__BMObjectsType * SOAP_FMAC4 soap_in_fims__BMObjectsType(struct soap *soap, const char *tag, fims__BMObjectsType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (fims__BMObjectsType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_fims__BMObjectsType, sizeof(fims__BMObjectsType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_fims__BMObjectsType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (fims__BMObjectsType *)a->soap_in(soap, tag, type);
		}
	}
	if (soap_s2string(soap, soap_attr_value(soap, "-anyAttribute", 0), &((fims__BMObjectsType*)a)->__anyAttribute, 0, -1))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTofims__BMObjectType(soap, "fims:bmObject", &(a->fims__BMObjectsType::bmObject), "fims:BMObjectType"))
					continue;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOf_XML(soap, "-any", &(a->fims__BMObjectsType::__any), ""))
					continue;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (fims__BMObjectsType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_fims__BMObjectsType, 0, sizeof(fims__BMObjectsType), 0, soap_copy_fims__BMObjectsType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (a->fims__BMObjectsType::bmObject.size() < 1))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int fims__BMObjectsType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_fims__BMObjectsType);
	if (this->soap_out(soap, tag?tag:"fims:BMObjectsType", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *fims__BMObjectsType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_fims__BMObjectsType(soap, this, tag, type);
}

SOAP_FMAC3 fims__BMObjectsType * SOAP_FMAC4 soap_get_fims__BMObjectsType(struct soap *soap, fims__BMObjectsType *p, const char *tag, const char *type)
{
	if ((p = soap_in_fims__BMObjectsType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 fims__BMObjectsType * SOAP_FMAC2 soap_instantiate_fims__BMObjectsType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_fims__BMObjectsType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_fims__BMObjectsType, n, EDLProvider_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(fims__BMObjectsType);
		if (size)
			*size = sizeof(fims__BMObjectsType);
		((fims__BMObjectsType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(fims__BMObjectsType, n);
		if (size)
			*size = n * sizeof(fims__BMObjectsType);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((fims__BMObjectsType*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (fims__BMObjectsType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_fims__BMObjectsType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying fims__BMObjectsType %p -> %p\n", q, p));
	*(fims__BMObjectsType*)p = *(fims__BMObjectsType*)q;
}

void fims__DataFormatsType::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTofims__DataFormatType(soap, &this->fims__DataFormatsType::dataFormat);
	soap_default_std__vectorTemplateOf_XML(soap, &this->fims__DataFormatsType::__any);
	this->fims__DataFormatsType::__anyAttribute = NULL;
	/* transient soap skipped */
}

void fims__DataFormatsType::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfPointerTofims__DataFormatType(soap, &this->fims__DataFormatsType::dataFormat);
	soap_serialize_std__vectorTemplateOf_XML(soap, &this->fims__DataFormatsType::__any);
	/* transient soap skipped */
#endif
}

int fims__DataFormatsType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_fims__DataFormatsType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_fims__DataFormatsType(struct soap *soap, const char *tag, int id, const fims__DataFormatsType *a, const char *type)
{
	if (((fims__DataFormatsType*)a)->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", ((fims__DataFormatsType*)a)->__anyAttribute, 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_fims__DataFormatsType), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTofims__DataFormatType(soap, "fims:dataFormat", -1, &(a->fims__DataFormatsType::dataFormat), ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOf_XML(soap, "-any", -1, &(a->fims__DataFormatsType::__any), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *fims__DataFormatsType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_fims__DataFormatsType(soap, tag, this, type);
}

SOAP_FMAC3 fims__DataFormatsType * SOAP_FMAC4 soap_in_fims__DataFormatsType(struct soap *soap, const char *tag, fims__DataFormatsType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (fims__DataFormatsType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_fims__DataFormatsType, sizeof(fims__DataFormatsType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_fims__DataFormatsType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (fims__DataFormatsType *)a->soap_in(soap, tag, type);
		}
	}
	if (soap_s2string(soap, soap_attr_value(soap, "-anyAttribute", 0), &((fims__DataFormatsType*)a)->__anyAttribute, 0, -1))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTofims__DataFormatType(soap, "fims:dataFormat", &(a->fims__DataFormatsType::dataFormat), "fims:DataFormatType"))
					continue;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOf_XML(soap, "-any", &(a->fims__DataFormatsType::__any), ""))
					continue;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (fims__DataFormatsType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_fims__DataFormatsType, 0, sizeof(fims__DataFormatsType), 0, soap_copy_fims__DataFormatsType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (a->fims__DataFormatsType::dataFormat.size() < 1))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int fims__DataFormatsType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_fims__DataFormatsType);
	if (this->soap_out(soap, tag?tag:"fims:DataFormatsType", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *fims__DataFormatsType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_fims__DataFormatsType(soap, this, tag, type);
}

SOAP_FMAC3 fims__DataFormatsType * SOAP_FMAC4 soap_get_fims__DataFormatsType(struct soap *soap, fims__DataFormatsType *p, const char *tag, const char *type)
{
	if ((p = soap_in_fims__DataFormatsType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 fims__DataFormatsType * SOAP_FMAC2 soap_instantiate_fims__DataFormatsType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_fims__DataFormatsType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_fims__DataFormatsType, n, EDLProvider_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(fims__DataFormatsType);
		if (size)
			*size = sizeof(fims__DataFormatsType);
		((fims__DataFormatsType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(fims__DataFormatsType, n);
		if (size)
			*size = n * sizeof(fims__DataFormatsType);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((fims__DataFormatsType*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (fims__DataFormatsType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_fims__DataFormatsType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying fims__DataFormatsType %p -> %p\n", q, p));
	*(fims__DataFormatsType*)p = *(fims__DataFormatsType*)q;
}

void fims__ContainerFormatsType::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTofims__ContainerFormatType(soap, &this->fims__ContainerFormatsType::containerFormat);
	soap_default_std__vectorTemplateOf_XML(soap, &this->fims__ContainerFormatsType::__any);
	this->fims__ContainerFormatsType::__anyAttribute = NULL;
	/* transient soap skipped */
}

void fims__ContainerFormatsType::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfPointerTofims__ContainerFormatType(soap, &this->fims__ContainerFormatsType::containerFormat);
	soap_serialize_std__vectorTemplateOf_XML(soap, &this->fims__ContainerFormatsType::__any);
	/* transient soap skipped */
#endif
}

int fims__ContainerFormatsType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_fims__ContainerFormatsType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_fims__ContainerFormatsType(struct soap *soap, const char *tag, int id, const fims__ContainerFormatsType *a, const char *type)
{
	if (((fims__ContainerFormatsType*)a)->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", ((fims__ContainerFormatsType*)a)->__anyAttribute, 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_fims__ContainerFormatsType), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTofims__ContainerFormatType(soap, "fims:containerFormat", -1, &(a->fims__ContainerFormatsType::containerFormat), ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOf_XML(soap, "-any", -1, &(a->fims__ContainerFormatsType::__any), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *fims__ContainerFormatsType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_fims__ContainerFormatsType(soap, tag, this, type);
}

SOAP_FMAC3 fims__ContainerFormatsType * SOAP_FMAC4 soap_in_fims__ContainerFormatsType(struct soap *soap, const char *tag, fims__ContainerFormatsType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (fims__ContainerFormatsType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_fims__ContainerFormatsType, sizeof(fims__ContainerFormatsType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_fims__ContainerFormatsType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (fims__ContainerFormatsType *)a->soap_in(soap, tag, type);
		}
	}
	if (soap_s2string(soap, soap_attr_value(soap, "-anyAttribute", 0), &((fims__ContainerFormatsType*)a)->__anyAttribute, 0, -1))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTofims__ContainerFormatType(soap, "fims:containerFormat", &(a->fims__ContainerFormatsType::containerFormat), "fims:ContainerFormatType"))
					continue;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOf_XML(soap, "-any", &(a->fims__ContainerFormatsType::__any), ""))
					continue;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (fims__ContainerFormatsType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_fims__ContainerFormatsType, 0, sizeof(fims__ContainerFormatsType), 0, soap_copy_fims__ContainerFormatsType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (a->fims__ContainerFormatsType::containerFormat.size() < 1))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int fims__ContainerFormatsType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_fims__ContainerFormatsType);
	if (this->soap_out(soap, tag?tag:"fims:ContainerFormatsType", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *fims__ContainerFormatsType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_fims__ContainerFormatsType(soap, this, tag, type);
}

SOAP_FMAC3 fims__ContainerFormatsType * SOAP_FMAC4 soap_get_fims__ContainerFormatsType(struct soap *soap, fims__ContainerFormatsType *p, const char *tag, const char *type)
{
	if ((p = soap_in_fims__ContainerFormatsType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 fims__ContainerFormatsType * SOAP_FMAC2 soap_instantiate_fims__ContainerFormatsType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_fims__ContainerFormatsType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_fims__ContainerFormatsType, n, EDLProvider_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(fims__ContainerFormatsType);
		if (size)
			*size = sizeof(fims__ContainerFormatsType);
		((fims__ContainerFormatsType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(fims__ContainerFormatsType, n);
		if (size)
			*size = n * sizeof(fims__ContainerFormatsType);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((fims__ContainerFormatsType*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (fims__ContainerFormatsType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_fims__ContainerFormatsType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying fims__ContainerFormatsType %p -> %p\n", q, p));
	*(fims__ContainerFormatsType*)p = *(fims__ContainerFormatsType*)q;
}

void fims__AudioFormatsType::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTofims__AudioFormatType(soap, &this->fims__AudioFormatsType::audioFormat);
	soap_default_std__vectorTemplateOf_XML(soap, &this->fims__AudioFormatsType::__any);
	this->fims__AudioFormatsType::__anyAttribute = NULL;
	/* transient soap skipped */
}

void fims__AudioFormatsType::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfPointerTofims__AudioFormatType(soap, &this->fims__AudioFormatsType::audioFormat);
	soap_serialize_std__vectorTemplateOf_XML(soap, &this->fims__AudioFormatsType::__any);
	/* transient soap skipped */
#endif
}

int fims__AudioFormatsType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_fims__AudioFormatsType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_fims__AudioFormatsType(struct soap *soap, const char *tag, int id, const fims__AudioFormatsType *a, const char *type)
{
	if (((fims__AudioFormatsType*)a)->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", ((fims__AudioFormatsType*)a)->__anyAttribute, 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_fims__AudioFormatsType), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTofims__AudioFormatType(soap, "fims:audioFormat", -1, &(a->fims__AudioFormatsType::audioFormat), ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOf_XML(soap, "-any", -1, &(a->fims__AudioFormatsType::__any), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *fims__AudioFormatsType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_fims__AudioFormatsType(soap, tag, this, type);
}

SOAP_FMAC3 fims__AudioFormatsType * SOAP_FMAC4 soap_in_fims__AudioFormatsType(struct soap *soap, const char *tag, fims__AudioFormatsType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (fims__AudioFormatsType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_fims__AudioFormatsType, sizeof(fims__AudioFormatsType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_fims__AudioFormatsType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (fims__AudioFormatsType *)a->soap_in(soap, tag, type);
		}
	}
	if (soap_s2string(soap, soap_attr_value(soap, "-anyAttribute", 0), &((fims__AudioFormatsType*)a)->__anyAttribute, 0, -1))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTofims__AudioFormatType(soap, "fims:audioFormat", &(a->fims__AudioFormatsType::audioFormat), "fims:AudioFormatType"))
					continue;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOf_XML(soap, "-any", &(a->fims__AudioFormatsType::__any), ""))
					continue;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (fims__AudioFormatsType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_fims__AudioFormatsType, 0, sizeof(fims__AudioFormatsType), 0, soap_copy_fims__AudioFormatsType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (a->fims__AudioFormatsType::audioFormat.size() < 1))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int fims__AudioFormatsType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_fims__AudioFormatsType);
	if (this->soap_out(soap, tag?tag:"fims:AudioFormatsType", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *fims__AudioFormatsType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_fims__AudioFormatsType(soap, this, tag, type);
}

SOAP_FMAC3 fims__AudioFormatsType * SOAP_FMAC4 soap_get_fims__AudioFormatsType(struct soap *soap, fims__AudioFormatsType *p, const char *tag, const char *type)
{
	if ((p = soap_in_fims__AudioFormatsType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 fims__AudioFormatsType * SOAP_FMAC2 soap_instantiate_fims__AudioFormatsType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_fims__AudioFormatsType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_fims__AudioFormatsType, n, EDLProvider_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(fims__AudioFormatsType);
		if (size)
			*size = sizeof(fims__AudioFormatsType);
		((fims__AudioFormatsType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(fims__AudioFormatsType, n);
		if (size)
			*size = n * sizeof(fims__AudioFormatsType);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((fims__AudioFormatsType*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (fims__AudioFormatsType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_fims__AudioFormatsType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying fims__AudioFormatsType %p -> %p\n", q, p));
	*(fims__AudioFormatsType*)p = *(fims__AudioFormatsType*)q;
}

void fims__VideoFormatsType::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTofims__VideoFormatType(soap, &this->fims__VideoFormatsType::videoFormat);
	soap_default_std__vectorTemplateOf_XML(soap, &this->fims__VideoFormatsType::__any);
	this->fims__VideoFormatsType::__anyAttribute = NULL;
	/* transient soap skipped */
}

void fims__VideoFormatsType::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfPointerTofims__VideoFormatType(soap, &this->fims__VideoFormatsType::videoFormat);
	soap_serialize_std__vectorTemplateOf_XML(soap, &this->fims__VideoFormatsType::__any);
	/* transient soap skipped */
#endif
}

int fims__VideoFormatsType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_fims__VideoFormatsType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_fims__VideoFormatsType(struct soap *soap, const char *tag, int id, const fims__VideoFormatsType *a, const char *type)
{
	if (((fims__VideoFormatsType*)a)->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", ((fims__VideoFormatsType*)a)->__anyAttribute, 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_fims__VideoFormatsType), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTofims__VideoFormatType(soap, "fims:videoFormat", -1, &(a->fims__VideoFormatsType::videoFormat), ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOf_XML(soap, "-any", -1, &(a->fims__VideoFormatsType::__any), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *fims__VideoFormatsType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_fims__VideoFormatsType(soap, tag, this, type);
}

SOAP_FMAC3 fims__VideoFormatsType * SOAP_FMAC4 soap_in_fims__VideoFormatsType(struct soap *soap, const char *tag, fims__VideoFormatsType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (fims__VideoFormatsType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_fims__VideoFormatsType, sizeof(fims__VideoFormatsType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_fims__VideoFormatsType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (fims__VideoFormatsType *)a->soap_in(soap, tag, type);
		}
	}
	if (soap_s2string(soap, soap_attr_value(soap, "-anyAttribute", 0), &((fims__VideoFormatsType*)a)->__anyAttribute, 0, -1))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTofims__VideoFormatType(soap, "fims:videoFormat", &(a->fims__VideoFormatsType::videoFormat), "fims:VideoFormatType"))
					continue;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOf_XML(soap, "-any", &(a->fims__VideoFormatsType::__any), ""))
					continue;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (fims__VideoFormatsType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_fims__VideoFormatsType, 0, sizeof(fims__VideoFormatsType), 0, soap_copy_fims__VideoFormatsType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (a->fims__VideoFormatsType::videoFormat.size() < 1))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int fims__VideoFormatsType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_fims__VideoFormatsType);
	if (this->soap_out(soap, tag?tag:"fims:VideoFormatsType", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *fims__VideoFormatsType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_fims__VideoFormatsType(soap, this, tag, type);
}

SOAP_FMAC3 fims__VideoFormatsType * SOAP_FMAC4 soap_get_fims__VideoFormatsType(struct soap *soap, fims__VideoFormatsType *p, const char *tag, const char *type)
{
	if ((p = soap_in_fims__VideoFormatsType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 fims__VideoFormatsType * SOAP_FMAC2 soap_instantiate_fims__VideoFormatsType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_fims__VideoFormatsType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_fims__VideoFormatsType, n, EDLProvider_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(fims__VideoFormatsType);
		if (size)
			*size = sizeof(fims__VideoFormatsType);
		((fims__VideoFormatsType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(fims__VideoFormatsType, n);
		if (size)
			*size = n * sizeof(fims__VideoFormatsType);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((fims__VideoFormatsType*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (fims__VideoFormatsType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_fims__VideoFormatsType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying fims__VideoFormatsType %p -> %p\n", q, p));
	*(fims__VideoFormatsType*)p = *(fims__VideoFormatsType*)q;
}

void fims__JobsType::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTofims__JobType(soap, &this->fims__JobsType::job);
	soap_default_std__vectorTemplateOf_XML(soap, &this->fims__JobsType::__any);
	this->fims__JobsType::__anyAttribute = NULL;
	/* transient soap skipped */
}

void fims__JobsType::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfPointerTofims__JobType(soap, &this->fims__JobsType::job);
	soap_serialize_std__vectorTemplateOf_XML(soap, &this->fims__JobsType::__any);
	/* transient soap skipped */
#endif
}

int fims__JobsType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_fims__JobsType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_fims__JobsType(struct soap *soap, const char *tag, int id, const fims__JobsType *a, const char *type)
{
	if (((fims__JobsType*)a)->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", ((fims__JobsType*)a)->__anyAttribute, 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_fims__JobsType), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTofims__JobType(soap, "fims:job", -1, &(a->fims__JobsType::job), ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOf_XML(soap, "-any", -1, &(a->fims__JobsType::__any), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *fims__JobsType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_fims__JobsType(soap, tag, this, type);
}

SOAP_FMAC3 fims__JobsType * SOAP_FMAC4 soap_in_fims__JobsType(struct soap *soap, const char *tag, fims__JobsType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (fims__JobsType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_fims__JobsType, sizeof(fims__JobsType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_fims__JobsType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (fims__JobsType *)a->soap_in(soap, tag, type);
		}
	}
	if (soap_s2string(soap, soap_attr_value(soap, "-anyAttribute", 0), &((fims__JobsType*)a)->__anyAttribute, 0, -1))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTofims__JobType(soap, "fims:job", &(a->fims__JobsType::job), "fims:JobType"))
					continue;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOf_XML(soap, "-any", &(a->fims__JobsType::__any), ""))
					continue;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (fims__JobsType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_fims__JobsType, 0, sizeof(fims__JobsType), 0, soap_copy_fims__JobsType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (a->fims__JobsType::job.size() < 1))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int fims__JobsType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_fims__JobsType);
	if (this->soap_out(soap, tag?tag:"fims:JobsType", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *fims__JobsType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_fims__JobsType(soap, this, tag, type);
}

SOAP_FMAC3 fims__JobsType * SOAP_FMAC4 soap_get_fims__JobsType(struct soap *soap, fims__JobsType *p, const char *tag, const char *type)
{
	if ((p = soap_in_fims__JobsType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 fims__JobsType * SOAP_FMAC2 soap_instantiate_fims__JobsType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_fims__JobsType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_fims__JobsType, n, EDLProvider_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(fims__JobsType);
		if (size)
			*size = sizeof(fims__JobsType);
		((fims__JobsType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(fims__JobsType, n);
		if (size)
			*size = n * sizeof(fims__JobsType);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((fims__JobsType*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (fims__JobsType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_fims__JobsType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying fims__JobsType %p -> %p\n", q, p));
	*(fims__JobsType*)p = *(fims__JobsType*)q;
}

void fims__QueuesType::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTofims__QueueType(soap, &this->fims__QueuesType::queue);
	soap_default_std__vectorTemplateOf_XML(soap, &this->fims__QueuesType::__any);
	this->fims__QueuesType::__anyAttribute = NULL;
	/* transient soap skipped */
}

void fims__QueuesType::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfPointerTofims__QueueType(soap, &this->fims__QueuesType::queue);
	soap_serialize_std__vectorTemplateOf_XML(soap, &this->fims__QueuesType::__any);
	/* transient soap skipped */
#endif
}

int fims__QueuesType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_fims__QueuesType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_fims__QueuesType(struct soap *soap, const char *tag, int id, const fims__QueuesType *a, const char *type)
{
	if (((fims__QueuesType*)a)->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", ((fims__QueuesType*)a)->__anyAttribute, 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_fims__QueuesType), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTofims__QueueType(soap, "fims:queue", -1, &(a->fims__QueuesType::queue), ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOf_XML(soap, "-any", -1, &(a->fims__QueuesType::__any), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *fims__QueuesType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_fims__QueuesType(soap, tag, this, type);
}

SOAP_FMAC3 fims__QueuesType * SOAP_FMAC4 soap_in_fims__QueuesType(struct soap *soap, const char *tag, fims__QueuesType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (fims__QueuesType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_fims__QueuesType, sizeof(fims__QueuesType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_fims__QueuesType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (fims__QueuesType *)a->soap_in(soap, tag, type);
		}
	}
	if (soap_s2string(soap, soap_attr_value(soap, "-anyAttribute", 0), &((fims__QueuesType*)a)->__anyAttribute, 0, -1))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTofims__QueueType(soap, "fims:queue", &(a->fims__QueuesType::queue), "fims:QueueType"))
					continue;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOf_XML(soap, "-any", &(a->fims__QueuesType::__any), ""))
					continue;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (fims__QueuesType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_fims__QueuesType, 0, sizeof(fims__QueuesType), 0, soap_copy_fims__QueuesType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (a->fims__QueuesType::queue.size() < 1))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int fims__QueuesType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_fims__QueuesType);
	if (this->soap_out(soap, tag?tag:"fims:QueuesType", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *fims__QueuesType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_fims__QueuesType(soap, this, tag, type);
}

SOAP_FMAC3 fims__QueuesType * SOAP_FMAC4 soap_get_fims__QueuesType(struct soap *soap, fims__QueuesType *p, const char *tag, const char *type)
{
	if ((p = soap_in_fims__QueuesType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 fims__QueuesType * SOAP_FMAC2 soap_instantiate_fims__QueuesType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_fims__QueuesType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_fims__QueuesType, n, EDLProvider_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(fims__QueuesType);
		if (size)
			*size = sizeof(fims__QueuesType);
		((fims__QueuesType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(fims__QueuesType, n);
		if (size)
			*size = n * sizeof(fims__QueuesType);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((fims__QueuesType*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (fims__QueuesType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_fims__QueuesType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying fims__QueuesType %p -> %p\n", q, p));
	*(fims__QueuesType*)p = *(fims__QueuesType*)q;
}

void fims__ServicesType::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTofims__ServiceType(soap, &this->fims__ServicesType::service);
	soap_default_std__vectorTemplateOf_XML(soap, &this->fims__ServicesType::__any);
	this->fims__ServicesType::__anyAttribute = NULL;
	/* transient soap skipped */
}

void fims__ServicesType::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfPointerTofims__ServiceType(soap, &this->fims__ServicesType::service);
	soap_serialize_std__vectorTemplateOf_XML(soap, &this->fims__ServicesType::__any);
	/* transient soap skipped */
#endif
}

int fims__ServicesType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_fims__ServicesType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_fims__ServicesType(struct soap *soap, const char *tag, int id, const fims__ServicesType *a, const char *type)
{
	if (((fims__ServicesType*)a)->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", ((fims__ServicesType*)a)->__anyAttribute, 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_fims__ServicesType), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTofims__ServiceType(soap, "fims:service", -1, &(a->fims__ServicesType::service), ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOf_XML(soap, "-any", -1, &(a->fims__ServicesType::__any), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *fims__ServicesType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_fims__ServicesType(soap, tag, this, type);
}

SOAP_FMAC3 fims__ServicesType * SOAP_FMAC4 soap_in_fims__ServicesType(struct soap *soap, const char *tag, fims__ServicesType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (fims__ServicesType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_fims__ServicesType, sizeof(fims__ServicesType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_fims__ServicesType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (fims__ServicesType *)a->soap_in(soap, tag, type);
		}
	}
	if (soap_s2string(soap, soap_attr_value(soap, "-anyAttribute", 0), &((fims__ServicesType*)a)->__anyAttribute, 0, -1))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTofims__ServiceType(soap, "fims:service", &(a->fims__ServicesType::service), "fims:ServiceType"))
					continue;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOf_XML(soap, "-any", &(a->fims__ServicesType::__any), ""))
					continue;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (fims__ServicesType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_fims__ServicesType, 0, sizeof(fims__ServicesType), 0, soap_copy_fims__ServicesType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (a->fims__ServicesType::service.size() < 1))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int fims__ServicesType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_fims__ServicesType);
	if (this->soap_out(soap, tag?tag:"fims:ServicesType", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *fims__ServicesType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_fims__ServicesType(soap, this, tag, type);
}

SOAP_FMAC3 fims__ServicesType * SOAP_FMAC4 soap_get_fims__ServicesType(struct soap *soap, fims__ServicesType *p, const char *tag, const char *type)
{
	if ((p = soap_in_fims__ServicesType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 fims__ServicesType * SOAP_FMAC2 soap_instantiate_fims__ServicesType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_fims__ServicesType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_fims__ServicesType, n, EDLProvider_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(fims__ServicesType);
		if (size)
			*size = sizeof(fims__ServicesType);
		((fims__ServicesType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(fims__ServicesType, n);
		if (size)
			*size = n * sizeof(fims__ServicesType);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((fims__ServicesType*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (fims__ServicesType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_fims__ServicesType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying fims__ServicesType %p -> %p\n", q, p));
	*(fims__ServicesType*)p = *(fims__ServicesType*)q;
}

void fims__ProfilesType::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTofims__ProfileType(soap, &this->fims__ProfilesType::profile);
	soap_default_std__vectorTemplateOf_XML(soap, &this->fims__ProfilesType::__any);
	this->fims__ProfilesType::__anyAttribute = NULL;
	/* transient soap skipped */
}

void fims__ProfilesType::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfPointerTofims__ProfileType(soap, &this->fims__ProfilesType::profile);
	soap_serialize_std__vectorTemplateOf_XML(soap, &this->fims__ProfilesType::__any);
	/* transient soap skipped */
#endif
}

int fims__ProfilesType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_fims__ProfilesType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_fims__ProfilesType(struct soap *soap, const char *tag, int id, const fims__ProfilesType *a, const char *type)
{
	if (((fims__ProfilesType*)a)->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", ((fims__ProfilesType*)a)->__anyAttribute, 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_fims__ProfilesType), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTofims__ProfileType(soap, "fims:profile", -1, &(a->fims__ProfilesType::profile), ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOf_XML(soap, "-any", -1, &(a->fims__ProfilesType::__any), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *fims__ProfilesType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_fims__ProfilesType(soap, tag, this, type);
}

SOAP_FMAC3 fims__ProfilesType * SOAP_FMAC4 soap_in_fims__ProfilesType(struct soap *soap, const char *tag, fims__ProfilesType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (fims__ProfilesType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_fims__ProfilesType, sizeof(fims__ProfilesType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_fims__ProfilesType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (fims__ProfilesType *)a->soap_in(soap, tag, type);
		}
	}
	if (soap_s2string(soap, soap_attr_value(soap, "-anyAttribute", 0), &((fims__ProfilesType*)a)->__anyAttribute, 0, -1))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTofims__ProfileType(soap, "fims:profile", &(a->fims__ProfilesType::profile), "fims:ProfileType"))
					continue;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOf_XML(soap, "-any", &(a->fims__ProfilesType::__any), ""))
					continue;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (fims__ProfilesType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_fims__ProfilesType, 0, sizeof(fims__ProfilesType), 0, soap_copy_fims__ProfilesType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (a->fims__ProfilesType::profile.size() < 1))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int fims__ProfilesType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_fims__ProfilesType);
	if (this->soap_out(soap, tag?tag:"fims:ProfilesType", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *fims__ProfilesType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_fims__ProfilesType(soap, this, tag, type);
}

SOAP_FMAC3 fims__ProfilesType * SOAP_FMAC4 soap_get_fims__ProfilesType(struct soap *soap, fims__ProfilesType *p, const char *tag, const char *type)
{
	if ((p = soap_in_fims__ProfilesType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 fims__ProfilesType * SOAP_FMAC2 soap_instantiate_fims__ProfilesType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_fims__ProfilesType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_fims__ProfilesType, n, EDLProvider_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(fims__ProfilesType);
		if (size)
			*size = sizeof(fims__ProfilesType);
		((fims__ProfilesType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(fims__ProfilesType, n);
		if (size)
			*size = n * sizeof(fims__ProfilesType);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((fims__ProfilesType*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (fims__ProfilesType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_fims__ProfilesType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying fims__ProfilesType %p -> %p\n", q, p));
	*(fims__ProfilesType*)p = *(fims__ProfilesType*)q;
}

void fims__ResourcesType::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTofims__ResourceType(soap, &this->fims__ResourcesType::resource);
	soap_default_std__vectorTemplateOf_XML(soap, &this->fims__ResourcesType::__any);
	this->fims__ResourcesType::__anyAttribute = NULL;
	/* transient soap skipped */
}

void fims__ResourcesType::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfPointerTofims__ResourceType(soap, &this->fims__ResourcesType::resource);
	soap_serialize_std__vectorTemplateOf_XML(soap, &this->fims__ResourcesType::__any);
	/* transient soap skipped */
#endif
}

int fims__ResourcesType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_fims__ResourcesType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_fims__ResourcesType(struct soap *soap, const char *tag, int id, const fims__ResourcesType *a, const char *type)
{
	if (((fims__ResourcesType*)a)->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", ((fims__ResourcesType*)a)->__anyAttribute, 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_fims__ResourcesType), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTofims__ResourceType(soap, "fims:resource", -1, &(a->fims__ResourcesType::resource), ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOf_XML(soap, "-any", -1, &(a->fims__ResourcesType::__any), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *fims__ResourcesType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_fims__ResourcesType(soap, tag, this, type);
}

SOAP_FMAC3 fims__ResourcesType * SOAP_FMAC4 soap_in_fims__ResourcesType(struct soap *soap, const char *tag, fims__ResourcesType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (fims__ResourcesType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_fims__ResourcesType, sizeof(fims__ResourcesType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_fims__ResourcesType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (fims__ResourcesType *)a->soap_in(soap, tag, type);
		}
	}
	if (soap_s2string(soap, soap_attr_value(soap, "-anyAttribute", 0), &((fims__ResourcesType*)a)->__anyAttribute, 0, -1))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTofims__ResourceType(soap, "fims:resource", &(a->fims__ResourcesType::resource), "fims:ResourceType"))
					continue;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOf_XML(soap, "-any", &(a->fims__ResourcesType::__any), ""))
					continue;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (fims__ResourcesType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_fims__ResourcesType, 0, sizeof(fims__ResourcesType), 0, soap_copy_fims__ResourcesType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (a->fims__ResourcesType::resource.size() < 1))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int fims__ResourcesType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_fims__ResourcesType);
	if (this->soap_out(soap, tag?tag:"fims:ResourcesType", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *fims__ResourcesType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_fims__ResourcesType(soap, this, tag, type);
}

SOAP_FMAC3 fims__ResourcesType * SOAP_FMAC4 soap_get_fims__ResourcesType(struct soap *soap, fims__ResourcesType *p, const char *tag, const char *type)
{
	if ((p = soap_in_fims__ResourcesType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 fims__ResourcesType * SOAP_FMAC2 soap_instantiate_fims__ResourcesType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_fims__ResourcesType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_fims__ResourcesType, n, EDLProvider_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(fims__ResourcesType);
		if (size)
			*size = sizeof(fims__ResourcesType);
		((fims__ResourcesType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(fims__ResourcesType, n);
		if (size)
			*size = n * sizeof(fims__ResourcesType);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((fims__ResourcesType*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (fims__ResourcesType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_fims__ResourcesType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying fims__ResourcesType %p -> %p\n", q, p));
	*(fims__ResourcesType*)p = *(fims__ResourcesType*)q;
}

void fims__InnerFaultType::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__wstring(soap, &this->fims__InnerFaultType::code);
	this->fims__InnerFaultType::description = NULL;
	this->fims__InnerFaultType::detail = NULL;
	/* transient soap skipped */
}

void fims__InnerFaultType::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &this->fims__InnerFaultType::code, SOAP_TYPE_std__wstring);
	soap_serialize_std__wstring(soap, &this->fims__InnerFaultType::code);
	soap_serialize_PointerTostd__wstring(soap, &this->fims__InnerFaultType::description);
	soap_serialize_PointerTostd__wstring(soap, &this->fims__InnerFaultType::detail);
	/* transient soap skipped */
#endif
}

int fims__InnerFaultType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_fims__InnerFaultType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_fims__InnerFaultType(struct soap *soap, const char *tag, int id, const fims__InnerFaultType *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_fims__InnerFaultType), type))
		return soap->error;
	if (soap_out_std__wstring(soap, "fims:code", -1, &(a->fims__InnerFaultType::code), ""))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "fims:description", -1, &(a->fims__InnerFaultType::description), ""))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "fims:detail", -1, &(a->fims__InnerFaultType::detail), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *fims__InnerFaultType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_fims__InnerFaultType(soap, tag, this, type);
}

SOAP_FMAC3 fims__InnerFaultType * SOAP_FMAC4 soap_in_fims__InnerFaultType(struct soap *soap, const char *tag, fims__InnerFaultType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (fims__InnerFaultType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_fims__InnerFaultType, sizeof(fims__InnerFaultType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_fims__InnerFaultType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (fims__InnerFaultType *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_code1 = 1;
	size_t soap_flag_description1 = 1;
	size_t soap_flag_detail1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_code1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__wstring(soap, "fims:code", &(a->fims__InnerFaultType::code), "xsd:string"))
				{	soap_flag_code1--;
					continue;
				}
			if (soap_flag_description1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "fims:description", &(a->fims__InnerFaultType::description), "xsd:string"))
				{	soap_flag_description1--;
					continue;
				}
			if (soap_flag_detail1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "fims:detail", &(a->fims__InnerFaultType::detail), "xsd:string"))
				{	soap_flag_detail1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (fims__InnerFaultType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_fims__InnerFaultType, 0, sizeof(fims__InnerFaultType), 0, soap_copy_fims__InnerFaultType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_code1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int fims__InnerFaultType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_fims__InnerFaultType);
	if (this->soap_out(soap, tag?tag:"fims:InnerFaultType", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *fims__InnerFaultType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_fims__InnerFaultType(soap, this, tag, type);
}

SOAP_FMAC3 fims__InnerFaultType * SOAP_FMAC4 soap_get_fims__InnerFaultType(struct soap *soap, fims__InnerFaultType *p, const char *tag, const char *type)
{
	if ((p = soap_in_fims__InnerFaultType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 fims__InnerFaultType * SOAP_FMAC2 soap_instantiate_fims__InnerFaultType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_fims__InnerFaultType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_fims__InnerFaultType, n, EDLProvider_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(fims__InnerFaultType);
		if (size)
			*size = sizeof(fims__InnerFaultType);
		((fims__InnerFaultType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(fims__InnerFaultType, n);
		if (size)
			*size = n * sizeof(fims__InnerFaultType);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((fims__InnerFaultType*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (fims__InnerFaultType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_fims__InnerFaultType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying fims__InnerFaultType %p -> %p\n", q, p));
	*(fims__InnerFaultType*)p = *(fims__InnerFaultType*)q;
}

void fims__FaultType::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_fims__ErrorCodeType(soap, &this->fims__FaultType::code);
	this->fims__FaultType::description = NULL;
	this->fims__FaultType::detail = NULL;
	soap_default_std__vectorTemplateOfPointerTofims__InnerFaultType(soap, &this->fims__FaultType::innerFault);
	/* transient soap skipped */
}

void fims__FaultType::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__wstring(soap, &this->fims__FaultType::description);
	soap_serialize_PointerTostd__wstring(soap, &this->fims__FaultType::detail);
	soap_serialize_std__vectorTemplateOfPointerTofims__InnerFaultType(soap, &this->fims__FaultType::innerFault);
	/* transient soap skipped */
#endif
}

int fims__FaultType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_fims__FaultType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_fims__FaultType(struct soap *soap, const char *tag, int id, const fims__FaultType *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_fims__FaultType), type))
		return soap->error;
	if (soap_out_fims__ErrorCodeType(soap, "fims:code", -1, &(a->fims__FaultType::code), ""))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "fims:description", -1, &(a->fims__FaultType::description), ""))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "fims:detail", -1, &(a->fims__FaultType::detail), ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTofims__InnerFaultType(soap, "fims:innerFault", -1, &(a->fims__FaultType::innerFault), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *fims__FaultType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_fims__FaultType(soap, tag, this, type);
}

SOAP_FMAC3 fims__FaultType * SOAP_FMAC4 soap_in_fims__FaultType(struct soap *soap, const char *tag, fims__FaultType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (fims__FaultType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_fims__FaultType, sizeof(fims__FaultType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_fims__FaultType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (fims__FaultType *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_code1 = 1;
	size_t soap_flag_description1 = 1;
	size_t soap_flag_detail1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_code1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_fims__ErrorCodeType(soap, "fims:code", &(a->fims__FaultType::code), "fims:ErrorCodeType"))
				{	soap_flag_code1--;
					continue;
				}
			if (soap_flag_description1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "fims:description", &(a->fims__FaultType::description), "xsd:string"))
				{	soap_flag_description1--;
					continue;
				}
			if (soap_flag_detail1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "fims:detail", &(a->fims__FaultType::detail), "xsd:string"))
				{	soap_flag_detail1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTofims__InnerFaultType(soap, "fims:innerFault", &(a->fims__FaultType::innerFault), "fims:InnerFaultType"))
					continue;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (fims__FaultType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_fims__FaultType, 0, sizeof(fims__FaultType), 0, soap_copy_fims__FaultType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_code1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int fims__FaultType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_fims__FaultType);
	if (this->soap_out(soap, tag?tag:"fims:FaultType", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *fims__FaultType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_fims__FaultType(soap, this, tag, type);
}

SOAP_FMAC3 fims__FaultType * SOAP_FMAC4 soap_get_fims__FaultType(struct soap *soap, fims__FaultType *p, const char *tag, const char *type)
{
	if ((p = soap_in_fims__FaultType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 fims__FaultType * SOAP_FMAC2 soap_instantiate_fims__FaultType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_fims__FaultType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_fims__FaultType, n, EDLProvider_fdelete);
	if (!cp)
		return NULL;
	if (type && !soap_match_tag(soap, type, "edlprovider:EdlProviderFaultType"))
	{	cp->type = SOAP_TYPE_edlprovider__EdlProviderFaultType;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(edlprovider__EdlProviderFaultType);
			if (size)
				*size = sizeof(edlprovider__EdlProviderFaultType);
			((edlprovider__EdlProviderFaultType*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW_ARRAY(edlprovider__EdlProviderFaultType, n);
			if (size)
				*size = n * sizeof(edlprovider__EdlProviderFaultType);
			if (cp->ptr)
				for (int i = 0; i < n; i++)
					((edlprovider__EdlProviderFaultType*)cp->ptr)[i].soap = soap;
		}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		if (!cp->ptr)
			soap->error = SOAP_EOM;
		return (edlprovider__EdlProviderFaultType*)cp->ptr;
	}
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(fims__FaultType);
		if (size)
			*size = sizeof(fims__FaultType);
		((fims__FaultType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(fims__FaultType, n);
		if (size)
			*size = n * sizeof(fims__FaultType);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((fims__FaultType*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (fims__FaultType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_fims__FaultType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying fims__FaultType %p -> %p\n", q, p));
	*(fims__FaultType*)p = *(fims__FaultType*)q;
}

void fims__ListFilterType::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->fims__ListFilterType::fromDate = NULL;
	this->fims__ListFilterType::toDate = NULL;
	soap_default_bool(soap, &this->fims__ListFilterType::includeQueued);
	soap_default_bool(soap, &this->fims__ListFilterType::includeActive);
	soap_default_bool(soap, &this->fims__ListFilterType::includeFinished);
	soap_default_bool(soap, &this->fims__ListFilterType::includeFailed);
	this->fims__ListFilterType::maxNumberResults = NULL;
	/* transient soap skipped */
}

void fims__ListFilterType::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTotime(soap, &this->fims__ListFilterType::fromDate);
	soap_serialize_PointerTotime(soap, &this->fims__ListFilterType::toDate);
	soap_embedded(soap, &this->fims__ListFilterType::includeQueued, SOAP_TYPE_bool);
	soap_embedded(soap, &this->fims__ListFilterType::includeActive, SOAP_TYPE_bool);
	soap_embedded(soap, &this->fims__ListFilterType::includeFinished, SOAP_TYPE_bool);
	soap_embedded(soap, &this->fims__ListFilterType::includeFailed, SOAP_TYPE_bool);
	soap_serialize_PointerToxsd__nonNegativeInteger(soap, &this->fims__ListFilterType::maxNumberResults);
	/* transient soap skipped */
#endif
}

int fims__ListFilterType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_fims__ListFilterType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_fims__ListFilterType(struct soap *soap, const char *tag, int id, const fims__ListFilterType *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_fims__ListFilterType), type))
		return soap->error;
	if (soap_out_PointerTotime(soap, "fims:fromDate", -1, &(a->fims__ListFilterType::fromDate), ""))
		return soap->error;
	if (soap_out_PointerTotime(soap, "fims:toDate", -1, &(a->fims__ListFilterType::toDate), ""))
		return soap->error;
	if (soap_out_bool(soap, "fims:includeQueued", -1, &(a->fims__ListFilterType::includeQueued), ""))
		return soap->error;
	if (soap_out_bool(soap, "fims:includeActive", -1, &(a->fims__ListFilterType::includeActive), ""))
		return soap->error;
	if (soap_out_bool(soap, "fims:includeFinished", -1, &(a->fims__ListFilterType::includeFinished), ""))
		return soap->error;
	if (soap_out_bool(soap, "fims:includeFailed", -1, &(a->fims__ListFilterType::includeFailed), ""))
		return soap->error;
	if (soap_out_PointerToxsd__nonNegativeInteger(soap, "fims:maxNumberResults", -1, &(a->fims__ListFilterType::maxNumberResults), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *fims__ListFilterType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_fims__ListFilterType(soap, tag, this, type);
}

SOAP_FMAC3 fims__ListFilterType * SOAP_FMAC4 soap_in_fims__ListFilterType(struct soap *soap, const char *tag, fims__ListFilterType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (fims__ListFilterType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_fims__ListFilterType, sizeof(fims__ListFilterType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_fims__ListFilterType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (fims__ListFilterType *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_fromDate1 = 1;
	size_t soap_flag_toDate1 = 1;
	size_t soap_flag_includeQueued1 = 1;
	size_t soap_flag_includeActive1 = 1;
	size_t soap_flag_includeFinished1 = 1;
	size_t soap_flag_includeFailed1 = 1;
	size_t soap_flag_maxNumberResults1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_fromDate1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTotime(soap, "fims:fromDate", &(a->fims__ListFilterType::fromDate), "xsd:dateTime"))
				{	soap_flag_fromDate1--;
					continue;
				}
			if (soap_flag_toDate1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTotime(soap, "fims:toDate", &(a->fims__ListFilterType::toDate), "xsd:dateTime"))
				{	soap_flag_toDate1--;
					continue;
				}
			if (soap_flag_includeQueued1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "fims:includeQueued", &(a->fims__ListFilterType::includeQueued), "xsd:boolean"))
				{	soap_flag_includeQueued1--;
					continue;
				}
			if (soap_flag_includeActive1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "fims:includeActive", &(a->fims__ListFilterType::includeActive), "xsd:boolean"))
				{	soap_flag_includeActive1--;
					continue;
				}
			if (soap_flag_includeFinished1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "fims:includeFinished", &(a->fims__ListFilterType::includeFinished), "xsd:boolean"))
				{	soap_flag_includeFinished1--;
					continue;
				}
			if (soap_flag_includeFailed1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "fims:includeFailed", &(a->fims__ListFilterType::includeFailed), "xsd:boolean"))
				{	soap_flag_includeFailed1--;
					continue;
				}
			if (soap_flag_maxNumberResults1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerToxsd__nonNegativeInteger(soap, "fims:maxNumberResults", &(a->fims__ListFilterType::maxNumberResults), "xsd:nonNegativeInteger"))
				{	soap_flag_maxNumberResults1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (fims__ListFilterType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_fims__ListFilterType, 0, sizeof(fims__ListFilterType), 0, soap_copy_fims__ListFilterType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_includeQueued1 > 0 || soap_flag_includeActive1 > 0 || soap_flag_includeFinished1 > 0 || soap_flag_includeFailed1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int fims__ListFilterType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_fims__ListFilterType);
	if (this->soap_out(soap, tag?tag:"fims:ListFilterType", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *fims__ListFilterType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_fims__ListFilterType(soap, this, tag, type);
}

SOAP_FMAC3 fims__ListFilterType * SOAP_FMAC4 soap_get_fims__ListFilterType(struct soap *soap, fims__ListFilterType *p, const char *tag, const char *type)
{
	if ((p = soap_in_fims__ListFilterType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 fims__ListFilterType * SOAP_FMAC2 soap_instantiate_fims__ListFilterType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_fims__ListFilterType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_fims__ListFilterType, n, EDLProvider_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(fims__ListFilterType);
		if (size)
			*size = sizeof(fims__ListFilterType);
		((fims__ListFilterType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(fims__ListFilterType, n);
		if (size)
			*size = n * sizeof(fims__ListFilterType);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((fims__ListFilterType*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (fims__ListFilterType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_fims__ListFilterType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying fims__ListFilterType %p -> %p\n", q, p));
	*(fims__ListFilterType*)p = *(fims__ListFilterType*)q;
}

void fims__QueryServiceDescriptionResponseType::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->fims__QueryServiceDescriptionResponseType::service = NULL;
	soap_default_fims__CurrentVersion(soap, &this->fims__QueryServiceDescriptionResponseType::version);
	/* transient soap skipped */
}

void fims__QueryServiceDescriptionResponseType::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTofims__ServiceType(soap, &this->fims__QueryServiceDescriptionResponseType::service);
	/* transient soap skipped */
#endif
}

int fims__QueryServiceDescriptionResponseType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_fims__QueryServiceDescriptionResponseType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_fims__QueryServiceDescriptionResponseType(struct soap *soap, const char *tag, int id, const fims__QueryServiceDescriptionResponseType *a, const char *type)
{
	soap_set_attr(soap, "version", soap_fims__CurrentVersion2s(soap, ((fims__QueryServiceDescriptionResponseType*)a)->version), 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_fims__QueryServiceDescriptionResponseType), type))
		return soap->error;
	if (a->fims__QueryServiceDescriptionResponseType::service)
	{	if (soap_out_PointerTofims__ServiceType(soap, "fims:service", -1, &a->fims__QueryServiceDescriptionResponseType::service, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "fims:service"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *fims__QueryServiceDescriptionResponseType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_fims__QueryServiceDescriptionResponseType(soap, tag, this, type);
}

SOAP_FMAC3 fims__QueryServiceDescriptionResponseType * SOAP_FMAC4 soap_in_fims__QueryServiceDescriptionResponseType(struct soap *soap, const char *tag, fims__QueryServiceDescriptionResponseType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (fims__QueryServiceDescriptionResponseType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_fims__QueryServiceDescriptionResponseType, sizeof(fims__QueryServiceDescriptionResponseType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_fims__QueryServiceDescriptionResponseType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (fims__QueryServiceDescriptionResponseType *)a->soap_in(soap, tag, type);
		}
	}
	if (soap_s2fims__CurrentVersion(soap, soap_attr_value(soap, "version", 1), &((fims__QueryServiceDescriptionResponseType*)a)->version))
		return NULL;
	size_t soap_flag_service1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_service1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTofims__ServiceType(soap, "fims:service", &(a->fims__QueryServiceDescriptionResponseType::service), "fims:ServiceType"))
				{	soap_flag_service1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (fims__QueryServiceDescriptionResponseType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_fims__QueryServiceDescriptionResponseType, 0, sizeof(fims__QueryServiceDescriptionResponseType), 0, soap_copy_fims__QueryServiceDescriptionResponseType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_service1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int fims__QueryServiceDescriptionResponseType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_fims__QueryServiceDescriptionResponseType);
	if (this->soap_out(soap, tag?tag:"fims:QueryServiceDescriptionResponseType", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *fims__QueryServiceDescriptionResponseType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_fims__QueryServiceDescriptionResponseType(soap, this, tag, type);
}

SOAP_FMAC3 fims__QueryServiceDescriptionResponseType * SOAP_FMAC4 soap_get_fims__QueryServiceDescriptionResponseType(struct soap *soap, fims__QueryServiceDescriptionResponseType *p, const char *tag, const char *type)
{
	if ((p = soap_in_fims__QueryServiceDescriptionResponseType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 fims__QueryServiceDescriptionResponseType * SOAP_FMAC2 soap_instantiate_fims__QueryServiceDescriptionResponseType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_fims__QueryServiceDescriptionResponseType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_fims__QueryServiceDescriptionResponseType, n, EDLProvider_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(fims__QueryServiceDescriptionResponseType);
		if (size)
			*size = sizeof(fims__QueryServiceDescriptionResponseType);
		((fims__QueryServiceDescriptionResponseType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(fims__QueryServiceDescriptionResponseType, n);
		if (size)
			*size = n * sizeof(fims__QueryServiceDescriptionResponseType);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((fims__QueryServiceDescriptionResponseType*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (fims__QueryServiceDescriptionResponseType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_fims__QueryServiceDescriptionResponseType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying fims__QueryServiceDescriptionResponseType %p -> %p\n", q, p));
	*(fims__QueryServiceDescriptionResponseType*)p = *(fims__QueryServiceDescriptionResponseType*)q;
}

void fims__QueryServiceDescriptionRequestType::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->fims__QueryServiceDescriptionRequestType::responseType = (enum _fims__QueryServiceDescriptionRequestType_responseType)1;
	soap_default_fims__CurrentVersion(soap, &this->fims__QueryServiceDescriptionRequestType::version);
	/* transient soap skipped */
}

void fims__QueryServiceDescriptionRequestType::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
#endif
}

int fims__QueryServiceDescriptionRequestType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_fims__QueryServiceDescriptionRequestType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_fims__QueryServiceDescriptionRequestType(struct soap *soap, const char *tag, int id, const fims__QueryServiceDescriptionRequestType *a, const char *type)
{
	soap_set_attr(soap, "responseType", soap__fims__QueryServiceDescriptionRequestType_responseType2s(soap, ((fims__QueryServiceDescriptionRequestType*)a)->responseType), 1);
	soap_set_attr(soap, "version", soap_fims__CurrentVersion2s(soap, ((fims__QueryServiceDescriptionRequestType*)a)->version), 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_fims__QueryServiceDescriptionRequestType), type))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *fims__QueryServiceDescriptionRequestType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_fims__QueryServiceDescriptionRequestType(soap, tag, this, type);
}

SOAP_FMAC3 fims__QueryServiceDescriptionRequestType * SOAP_FMAC4 soap_in_fims__QueryServiceDescriptionRequestType(struct soap *soap, const char *tag, fims__QueryServiceDescriptionRequestType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (fims__QueryServiceDescriptionRequestType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_fims__QueryServiceDescriptionRequestType, sizeof(fims__QueryServiceDescriptionRequestType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_fims__QueryServiceDescriptionRequestType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (fims__QueryServiceDescriptionRequestType *)a->soap_in(soap, tag, type);
		}
	}
	if (soap_s2_fims__QueryServiceDescriptionRequestType_responseType(soap, soap_attr_value(soap, "responseType", 0), &((fims__QueryServiceDescriptionRequestType*)a)->responseType))
		return NULL;
	if (soap_s2fims__CurrentVersion(soap, soap_attr_value(soap, "version", 1), &((fims__QueryServiceDescriptionRequestType*)a)->version))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (fims__QueryServiceDescriptionRequestType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_fims__QueryServiceDescriptionRequestType, 0, sizeof(fims__QueryServiceDescriptionRequestType), 0, soap_copy_fims__QueryServiceDescriptionRequestType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int fims__QueryServiceDescriptionRequestType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_fims__QueryServiceDescriptionRequestType);
	if (this->soap_out(soap, tag?tag:"fims:QueryServiceDescriptionRequestType", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *fims__QueryServiceDescriptionRequestType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_fims__QueryServiceDescriptionRequestType(soap, this, tag, type);
}

SOAP_FMAC3 fims__QueryServiceDescriptionRequestType * SOAP_FMAC4 soap_get_fims__QueryServiceDescriptionRequestType(struct soap *soap, fims__QueryServiceDescriptionRequestType *p, const char *tag, const char *type)
{
	if ((p = soap_in_fims__QueryServiceDescriptionRequestType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 fims__QueryServiceDescriptionRequestType * SOAP_FMAC2 soap_instantiate_fims__QueryServiceDescriptionRequestType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_fims__QueryServiceDescriptionRequestType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_fims__QueryServiceDescriptionRequestType, n, EDLProvider_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(fims__QueryServiceDescriptionRequestType);
		if (size)
			*size = sizeof(fims__QueryServiceDescriptionRequestType);
		((fims__QueryServiceDescriptionRequestType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(fims__QueryServiceDescriptionRequestType, n);
		if (size)
			*size = n * sizeof(fims__QueryServiceDescriptionRequestType);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((fims__QueryServiceDescriptionRequestType*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (fims__QueryServiceDescriptionRequestType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_fims__QueryServiceDescriptionRequestType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying fims__QueryServiceDescriptionRequestType %p -> %p\n", q, p));
	*(fims__QueryServiceDescriptionRequestType*)p = *(fims__QueryServiceDescriptionRequestType*)q;
}

void fims__QueryJobResponseType::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->fims__QueryJobResponseType::jobs = NULL;
	this->fims__QueryJobResponseType::notReportedResultsNumber = NULL;
	this->fims__QueryJobResponseType::ExtensionGroup = NULL;
	this->fims__QueryJobResponseType::ExtensionAttributes = NULL;
	soap_default_fims__CurrentVersion(soap, &this->fims__QueryJobResponseType::version);
	/* transient soap skipped */
}

void fims__QueryJobResponseType::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTofims__JobsType(soap, &this->fims__QueryJobResponseType::jobs);
	soap_serialize_PointerToxsd__nonNegativeInteger(soap, &this->fims__QueryJobResponseType::notReportedResultsNumber);
	soap_serialize_PointerTofims__ExtensionGroup(soap, &this->fims__QueryJobResponseType::ExtensionGroup);
	soap_serialize_PointerTofims__ExtensionAttributes(soap, &this->fims__QueryJobResponseType::ExtensionAttributes);
	/* transient soap skipped */
#endif
}

int fims__QueryJobResponseType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_fims__QueryJobResponseType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_fims__QueryJobResponseType(struct soap *soap, const char *tag, int id, const fims__QueryJobResponseType *a, const char *type)
{
	soap_set_attr(soap, "version", soap_fims__CurrentVersion2s(soap, ((fims__QueryJobResponseType*)a)->version), 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_fims__QueryJobResponseType), type))
		return soap->error;
	if (soap_out_PointerTofims__JobsType(soap, "fims:jobs", -1, &(a->fims__QueryJobResponseType::jobs), ""))
		return soap->error;
	if (soap_out_PointerToxsd__nonNegativeInteger(soap, "fims:notReportedResultsNumber", -1, &(a->fims__QueryJobResponseType::notReportedResultsNumber), ""))
		return soap->error;
	if (soap_out_PointerTofims__ExtensionGroup(soap, "fims:ExtensionGroup", -1, &(a->fims__QueryJobResponseType::ExtensionGroup), ""))
		return soap->error;
	if (soap_out_PointerTofims__ExtensionAttributes(soap, "fims:ExtensionAttributes", -1, &(a->fims__QueryJobResponseType::ExtensionAttributes), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *fims__QueryJobResponseType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_fims__QueryJobResponseType(soap, tag, this, type);
}

SOAP_FMAC3 fims__QueryJobResponseType * SOAP_FMAC4 soap_in_fims__QueryJobResponseType(struct soap *soap, const char *tag, fims__QueryJobResponseType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (fims__QueryJobResponseType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_fims__QueryJobResponseType, sizeof(fims__QueryJobResponseType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_fims__QueryJobResponseType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (fims__QueryJobResponseType *)a->soap_in(soap, tag, type);
		}
	}
	if (soap_s2fims__CurrentVersion(soap, soap_attr_value(soap, "version", 1), &((fims__QueryJobResponseType*)a)->version))
		return NULL;
	size_t soap_flag_jobs1 = 1;
	size_t soap_flag_notReportedResultsNumber1 = 1;
	size_t soap_flag_ExtensionGroup1 = 1;
	size_t soap_flag_ExtensionAttributes1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_jobs1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTofims__JobsType(soap, "fims:jobs", &(a->fims__QueryJobResponseType::jobs), "fims:JobsType"))
				{	soap_flag_jobs1--;
					continue;
				}
			if (soap_flag_notReportedResultsNumber1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerToxsd__nonNegativeInteger(soap, "fims:notReportedResultsNumber", &(a->fims__QueryJobResponseType::notReportedResultsNumber), "xsd:nonNegativeInteger"))
				{	soap_flag_notReportedResultsNumber1--;
					continue;
				}
			if (soap_flag_ExtensionGroup1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTofims__ExtensionGroup(soap, "fims:ExtensionGroup", &(a->fims__QueryJobResponseType::ExtensionGroup), "fims:ExtensionGroup"))
				{	soap_flag_ExtensionGroup1--;
					continue;
				}
			if (soap_flag_ExtensionAttributes1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTofims__ExtensionAttributes(soap, "fims:ExtensionAttributes", &(a->fims__QueryJobResponseType::ExtensionAttributes), "fims:ExtensionAttributes"))
				{	soap_flag_ExtensionAttributes1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (fims__QueryJobResponseType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_fims__QueryJobResponseType, 0, sizeof(fims__QueryJobResponseType), 0, soap_copy_fims__QueryJobResponseType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int fims__QueryJobResponseType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_fims__QueryJobResponseType);
	if (this->soap_out(soap, tag?tag:"fims:QueryJobResponseType", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *fims__QueryJobResponseType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_fims__QueryJobResponseType(soap, this, tag, type);
}

SOAP_FMAC3 fims__QueryJobResponseType * SOAP_FMAC4 soap_get_fims__QueryJobResponseType(struct soap *soap, fims__QueryJobResponseType *p, const char *tag, const char *type)
{
	if ((p = soap_in_fims__QueryJobResponseType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 fims__QueryJobResponseType * SOAP_FMAC2 soap_instantiate_fims__QueryJobResponseType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_fims__QueryJobResponseType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_fims__QueryJobResponseType, n, EDLProvider_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(fims__QueryJobResponseType);
		if (size)
			*size = sizeof(fims__QueryJobResponseType);
		((fims__QueryJobResponseType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(fims__QueryJobResponseType, n);
		if (size)
			*size = n * sizeof(fims__QueryJobResponseType);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((fims__QueryJobResponseType*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (fims__QueryJobResponseType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_fims__QueryJobResponseType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying fims__QueryJobResponseType %p -> %p\n", q, p));
	*(fims__QueryJobResponseType*)p = *(fims__QueryJobResponseType*)q;
}

void fims__QueryJobRequestByFilterType::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->fims__QueryJobRequestType::soap_default(soap);
	this->fims__QueryJobRequestByFilterType::listFilter = NULL;
}

void fims__QueryJobRequestByFilterType::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTofims__ListFilterType(soap, &this->fims__QueryJobRequestByFilterType::listFilter);
	this->fims__QueryJobRequestType::soap_serialize(soap);
#endif
}

int fims__QueryJobRequestByFilterType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_fims__QueryJobRequestByFilterType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_fims__QueryJobRequestByFilterType(struct soap *soap, const char *tag, int id, const fims__QueryJobRequestByFilterType *a, const char *type)
{
	soap_set_attr(soap, "version", soap_fims__CurrentVersion2s(soap, ((fims__QueryJobRequestType*)a)->version), 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_fims__QueryJobRequestByFilterType), "fims:QueryJobRequestByFilterType"))
		return soap->error;
	if (soap_out_fims__JobInfoSelectionType(soap, "fims:jobInfoSelection", -1, &(a->fims__QueryJobRequestType::jobInfoSelection), ""))
		return soap->error;
	if (soap_out_PointerTofims__ExtensionGroup(soap, "fims:ExtensionGroup", -1, &(a->fims__QueryJobRequestType::ExtensionGroup), ""))
		return soap->error;
	if (soap_out_PointerTofims__ExtensionAttributes(soap, "fims:ExtensionAttributes", -1, &(a->fims__QueryJobRequestType::ExtensionAttributes), ""))
		return soap->error;
	/* transient soap skipped */
	if (a->fims__QueryJobRequestByFilterType::listFilter)
	{	if (soap_out_PointerTofims__ListFilterType(soap, "fims:listFilter", -1, &a->fims__QueryJobRequestByFilterType::listFilter, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "fims:listFilter"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *fims__QueryJobRequestByFilterType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_fims__QueryJobRequestByFilterType(soap, tag, this, type);
}

SOAP_FMAC3 fims__QueryJobRequestByFilterType * SOAP_FMAC4 soap_in_fims__QueryJobRequestByFilterType(struct soap *soap, const char *tag, fims__QueryJobRequestByFilterType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (fims__QueryJobRequestByFilterType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_fims__QueryJobRequestByFilterType, sizeof(fims__QueryJobRequestByFilterType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_fims__QueryJobRequestByFilterType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (fims__QueryJobRequestByFilterType *)a->soap_in(soap, tag, type);
		}
	}
	if (soap_s2fims__CurrentVersion(soap, soap_attr_value(soap, "version", 1), &((fims__QueryJobRequestType*)a)->version))
		return NULL;
	size_t soap_flag_jobInfoSelection2 = 1;
	size_t soap_flag_ExtensionGroup2 = 1;
	size_t soap_flag_ExtensionAttributes2 = 1;
	size_t soap_flag_listFilter1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_jobInfoSelection2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_fims__JobInfoSelectionType(soap, "fims:jobInfoSelection", &(a->fims__QueryJobRequestType::jobInfoSelection), "fims:JobInfoSelectionType"))
				{	soap_flag_jobInfoSelection2--;
					continue;
				}
			if (soap_flag_ExtensionGroup2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTofims__ExtensionGroup(soap, "fims:ExtensionGroup", &(a->fims__QueryJobRequestType::ExtensionGroup), "fims:ExtensionGroup"))
				{	soap_flag_ExtensionGroup2--;
					continue;
				}
			if (soap_flag_ExtensionAttributes2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTofims__ExtensionAttributes(soap, "fims:ExtensionAttributes", &(a->fims__QueryJobRequestType::ExtensionAttributes), "fims:ExtensionAttributes"))
				{	soap_flag_ExtensionAttributes2--;
					continue;
				}
			/* transient soap skipped */
			if (soap_flag_listFilter1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTofims__ListFilterType(soap, "fims:listFilter", &(a->fims__QueryJobRequestByFilterType::listFilter), "fims:ListFilterType"))
				{	soap_flag_listFilter1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (fims__QueryJobRequestByFilterType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_fims__QueryJobRequestByFilterType, 0, sizeof(fims__QueryJobRequestByFilterType), 0, soap_copy_fims__QueryJobRequestByFilterType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_jobInfoSelection2 > 0 || soap_flag_listFilter1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int fims__QueryJobRequestByFilterType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_fims__QueryJobRequestByFilterType);
	if (this->soap_out(soap, tag?tag:"fims:QueryJobRequestByFilterType", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *fims__QueryJobRequestByFilterType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_fims__QueryJobRequestByFilterType(soap, this, tag, type);
}

SOAP_FMAC3 fims__QueryJobRequestByFilterType * SOAP_FMAC4 soap_get_fims__QueryJobRequestByFilterType(struct soap *soap, fims__QueryJobRequestByFilterType *p, const char *tag, const char *type)
{
	if ((p = soap_in_fims__QueryJobRequestByFilterType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 fims__QueryJobRequestByFilterType * SOAP_FMAC2 soap_instantiate_fims__QueryJobRequestByFilterType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_fims__QueryJobRequestByFilterType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_fims__QueryJobRequestByFilterType, n, EDLProvider_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(fims__QueryJobRequestByFilterType);
		if (size)
			*size = sizeof(fims__QueryJobRequestByFilterType);
		((fims__QueryJobRequestByFilterType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(fims__QueryJobRequestByFilterType, n);
		if (size)
			*size = n * sizeof(fims__QueryJobRequestByFilterType);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((fims__QueryJobRequestByFilterType*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (fims__QueryJobRequestByFilterType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_fims__QueryJobRequestByFilterType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying fims__QueryJobRequestByFilterType %p -> %p\n", q, p));
	*(fims__QueryJobRequestByFilterType*)p = *(fims__QueryJobRequestByFilterType*)q;
}

void fims__QueryJobRequestByIDType::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->fims__QueryJobRequestType::soap_default(soap);
	soap_default_std__vectorTemplateOffims__UID(soap, &this->fims__QueryJobRequestByIDType::jobID);
}

void fims__QueryJobRequestByIDType::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOffims__UID(soap, &this->fims__QueryJobRequestByIDType::jobID);
	this->fims__QueryJobRequestType::soap_serialize(soap);
#endif
}

int fims__QueryJobRequestByIDType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_fims__QueryJobRequestByIDType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_fims__QueryJobRequestByIDType(struct soap *soap, const char *tag, int id, const fims__QueryJobRequestByIDType *a, const char *type)
{
	soap_set_attr(soap, "version", soap_fims__CurrentVersion2s(soap, ((fims__QueryJobRequestType*)a)->version), 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_fims__QueryJobRequestByIDType), "fims:QueryJobRequestByIDType"))
		return soap->error;
	if (soap_out_fims__JobInfoSelectionType(soap, "fims:jobInfoSelection", -1, &(a->fims__QueryJobRequestType::jobInfoSelection), ""))
		return soap->error;
	if (soap_out_PointerTofims__ExtensionGroup(soap, "fims:ExtensionGroup", -1, &(a->fims__QueryJobRequestType::ExtensionGroup), ""))
		return soap->error;
	if (soap_out_PointerTofims__ExtensionAttributes(soap, "fims:ExtensionAttributes", -1, &(a->fims__QueryJobRequestType::ExtensionAttributes), ""))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_std__vectorTemplateOffims__UID(soap, "fims:jobID", -1, &(a->fims__QueryJobRequestByIDType::jobID), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *fims__QueryJobRequestByIDType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_fims__QueryJobRequestByIDType(soap, tag, this, type);
}

SOAP_FMAC3 fims__QueryJobRequestByIDType * SOAP_FMAC4 soap_in_fims__QueryJobRequestByIDType(struct soap *soap, const char *tag, fims__QueryJobRequestByIDType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (fims__QueryJobRequestByIDType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_fims__QueryJobRequestByIDType, sizeof(fims__QueryJobRequestByIDType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_fims__QueryJobRequestByIDType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (fims__QueryJobRequestByIDType *)a->soap_in(soap, tag, type);
		}
	}
	if (soap_s2fims__CurrentVersion(soap, soap_attr_value(soap, "version", 1), &((fims__QueryJobRequestType*)a)->version))
		return NULL;
	size_t soap_flag_jobInfoSelection2 = 1;
	size_t soap_flag_ExtensionGroup2 = 1;
	size_t soap_flag_ExtensionAttributes2 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_jobInfoSelection2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_fims__JobInfoSelectionType(soap, "fims:jobInfoSelection", &(a->fims__QueryJobRequestType::jobInfoSelection), "fims:JobInfoSelectionType"))
				{	soap_flag_jobInfoSelection2--;
					continue;
				}
			if (soap_flag_ExtensionGroup2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTofims__ExtensionGroup(soap, "fims:ExtensionGroup", &(a->fims__QueryJobRequestType::ExtensionGroup), "fims:ExtensionGroup"))
				{	soap_flag_ExtensionGroup2--;
					continue;
				}
			if (soap_flag_ExtensionAttributes2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTofims__ExtensionAttributes(soap, "fims:ExtensionAttributes", &(a->fims__QueryJobRequestType::ExtensionAttributes), "fims:ExtensionAttributes"))
				{	soap_flag_ExtensionAttributes2--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOffims__UID(soap, "fims:jobID", &(a->fims__QueryJobRequestByIDType::jobID), "fims:UID"))
					continue;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (fims__QueryJobRequestByIDType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_fims__QueryJobRequestByIDType, 0, sizeof(fims__QueryJobRequestByIDType), 0, soap_copy_fims__QueryJobRequestByIDType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_jobInfoSelection2 > 0 || a->fims__QueryJobRequestByIDType::jobID.size() < 1))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int fims__QueryJobRequestByIDType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_fims__QueryJobRequestByIDType);
	if (this->soap_out(soap, tag?tag:"fims:QueryJobRequestByIDType", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *fims__QueryJobRequestByIDType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_fims__QueryJobRequestByIDType(soap, this, tag, type);
}

SOAP_FMAC3 fims__QueryJobRequestByIDType * SOAP_FMAC4 soap_get_fims__QueryJobRequestByIDType(struct soap *soap, fims__QueryJobRequestByIDType *p, const char *tag, const char *type)
{
	if ((p = soap_in_fims__QueryJobRequestByIDType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 fims__QueryJobRequestByIDType * SOAP_FMAC2 soap_instantiate_fims__QueryJobRequestByIDType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_fims__QueryJobRequestByIDType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_fims__QueryJobRequestByIDType, n, EDLProvider_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(fims__QueryJobRequestByIDType);
		if (size)
			*size = sizeof(fims__QueryJobRequestByIDType);
		((fims__QueryJobRequestByIDType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(fims__QueryJobRequestByIDType, n);
		if (size)
			*size = n * sizeof(fims__QueryJobRequestByIDType);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((fims__QueryJobRequestByIDType*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (fims__QueryJobRequestByIDType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_fims__QueryJobRequestByIDType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying fims__QueryJobRequestByIDType %p -> %p\n", q, p));
	*(fims__QueryJobRequestByIDType*)p = *(fims__QueryJobRequestByIDType*)q;
}

void fims__QueryJobRequestType::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_fims__JobInfoSelectionType(soap, &this->fims__QueryJobRequestType::jobInfoSelection);
	this->fims__QueryJobRequestType::ExtensionGroup = NULL;
	this->fims__QueryJobRequestType::ExtensionAttributes = NULL;
	soap_default_fims__CurrentVersion(soap, &this->fims__QueryJobRequestType::version);
	/* transient soap skipped */
}

void fims__QueryJobRequestType::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTofims__ExtensionGroup(soap, &this->fims__QueryJobRequestType::ExtensionGroup);
	soap_serialize_PointerTofims__ExtensionAttributes(soap, &this->fims__QueryJobRequestType::ExtensionAttributes);
	/* transient soap skipped */
#endif
}

int fims__QueryJobRequestType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_fims__QueryJobRequestType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_fims__QueryJobRequestType(struct soap *soap, const char *tag, int id, const fims__QueryJobRequestType *a, const char *type)
{
	soap_set_attr(soap, "version", soap_fims__CurrentVersion2s(soap, ((fims__QueryJobRequestType*)a)->version), 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_fims__QueryJobRequestType), type))
		return soap->error;
	if (soap_out_fims__JobInfoSelectionType(soap, "fims:jobInfoSelection", -1, &(a->fims__QueryJobRequestType::jobInfoSelection), ""))
		return soap->error;
	if (soap_out_PointerTofims__ExtensionGroup(soap, "fims:ExtensionGroup", -1, &(a->fims__QueryJobRequestType::ExtensionGroup), ""))
		return soap->error;
	if (soap_out_PointerTofims__ExtensionAttributes(soap, "fims:ExtensionAttributes", -1, &(a->fims__QueryJobRequestType::ExtensionAttributes), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *fims__QueryJobRequestType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_fims__QueryJobRequestType(soap, tag, this, type);
}

SOAP_FMAC3 fims__QueryJobRequestType * SOAP_FMAC4 soap_in_fims__QueryJobRequestType(struct soap *soap, const char *tag, fims__QueryJobRequestType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (fims__QueryJobRequestType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_fims__QueryJobRequestType, sizeof(fims__QueryJobRequestType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_fims__QueryJobRequestType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (fims__QueryJobRequestType *)a->soap_in(soap, tag, type);
		}
	}
	if (soap_s2fims__CurrentVersion(soap, soap_attr_value(soap, "version", 1), &((fims__QueryJobRequestType*)a)->version))
		return NULL;
	size_t soap_flag_jobInfoSelection1 = 1;
	size_t soap_flag_ExtensionGroup1 = 1;
	size_t soap_flag_ExtensionAttributes1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_jobInfoSelection1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_fims__JobInfoSelectionType(soap, "fims:jobInfoSelection", &(a->fims__QueryJobRequestType::jobInfoSelection), "fims:JobInfoSelectionType"))
				{	soap_flag_jobInfoSelection1--;
					continue;
				}
			if (soap_flag_ExtensionGroup1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTofims__ExtensionGroup(soap, "fims:ExtensionGroup", &(a->fims__QueryJobRequestType::ExtensionGroup), "fims:ExtensionGroup"))
				{	soap_flag_ExtensionGroup1--;
					continue;
				}
			if (soap_flag_ExtensionAttributes1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTofims__ExtensionAttributes(soap, "fims:ExtensionAttributes", &(a->fims__QueryJobRequestType::ExtensionAttributes), "fims:ExtensionAttributes"))
				{	soap_flag_ExtensionAttributes1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (fims__QueryJobRequestType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_fims__QueryJobRequestType, 0, sizeof(fims__QueryJobRequestType), 0, soap_copy_fims__QueryJobRequestType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_jobInfoSelection1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int fims__QueryJobRequestType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_fims__QueryJobRequestType);
	if (this->soap_out(soap, tag?tag:"fims:QueryJobRequestType", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *fims__QueryJobRequestType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_fims__QueryJobRequestType(soap, this, tag, type);
}

SOAP_FMAC3 fims__QueryJobRequestType * SOAP_FMAC4 soap_get_fims__QueryJobRequestType(struct soap *soap, fims__QueryJobRequestType *p, const char *tag, const char *type)
{
	if ((p = soap_in_fims__QueryJobRequestType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 fims__QueryJobRequestType * SOAP_FMAC2 soap_instantiate_fims__QueryJobRequestType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_fims__QueryJobRequestType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_fims__QueryJobRequestType, n, EDLProvider_fdelete);
	if (!cp)
		return NULL;
	if (type && !soap_match_tag(soap, type, "fims:QueryJobRequestByIDType"))
	{	cp->type = SOAP_TYPE_fims__QueryJobRequestByIDType;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(fims__QueryJobRequestByIDType);
			if (size)
				*size = sizeof(fims__QueryJobRequestByIDType);
			((fims__QueryJobRequestByIDType*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW_ARRAY(fims__QueryJobRequestByIDType, n);
			if (size)
				*size = n * sizeof(fims__QueryJobRequestByIDType);
			if (cp->ptr)
				for (int i = 0; i < n; i++)
					((fims__QueryJobRequestByIDType*)cp->ptr)[i].soap = soap;
		}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		if (!cp->ptr)
			soap->error = SOAP_EOM;
		return (fims__QueryJobRequestByIDType*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "fims:QueryJobRequestByFilterType"))
	{	cp->type = SOAP_TYPE_fims__QueryJobRequestByFilterType;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(fims__QueryJobRequestByFilterType);
			if (size)
				*size = sizeof(fims__QueryJobRequestByFilterType);
			((fims__QueryJobRequestByFilterType*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW_ARRAY(fims__QueryJobRequestByFilterType, n);
			if (size)
				*size = n * sizeof(fims__QueryJobRequestByFilterType);
			if (cp->ptr)
				for (int i = 0; i < n; i++)
					((fims__QueryJobRequestByFilterType*)cp->ptr)[i].soap = soap;
		}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		if (!cp->ptr)
			soap->error = SOAP_EOM;
		return (fims__QueryJobRequestByFilterType*)cp->ptr;
	}
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(fims__QueryJobRequestType);
		if (size)
			*size = sizeof(fims__QueryJobRequestType);
		((fims__QueryJobRequestType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(fims__QueryJobRequestType, n);
		if (size)
			*size = n * sizeof(fims__QueryJobRequestType);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((fims__QueryJobRequestType*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (fims__QueryJobRequestType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_fims__QueryJobRequestType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying fims__QueryJobRequestType %p -> %p\n", q, p));
	*(fims__QueryJobRequestType*)p = *(fims__QueryJobRequestType*)q;
}

void fims__ManageQueueResponseType::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->fims__ManageQueueResponseType::queue = NULL;
	this->fims__ManageQueueResponseType::ExtensionGroup = NULL;
	this->fims__ManageQueueResponseType::ExtensionAttributes = NULL;
	soap_default_fims__CurrentVersion(soap, &this->fims__ManageQueueResponseType::version);
	/* transient soap skipped */
}

void fims__ManageQueueResponseType::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTofims__QueueType(soap, &this->fims__ManageQueueResponseType::queue);
	soap_serialize_PointerTofims__ExtensionGroup(soap, &this->fims__ManageQueueResponseType::ExtensionGroup);
	soap_serialize_PointerTofims__ExtensionAttributes(soap, &this->fims__ManageQueueResponseType::ExtensionAttributes);
	/* transient soap skipped */
#endif
}

int fims__ManageQueueResponseType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_fims__ManageQueueResponseType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_fims__ManageQueueResponseType(struct soap *soap, const char *tag, int id, const fims__ManageQueueResponseType *a, const char *type)
{
	soap_set_attr(soap, "version", soap_fims__CurrentVersion2s(soap, ((fims__ManageQueueResponseType*)a)->version), 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_fims__ManageQueueResponseType), type))
		return soap->error;
	if (a->fims__ManageQueueResponseType::queue)
	{	if (soap_out_PointerTofims__QueueType(soap, "fims:queue", -1, &a->fims__ManageQueueResponseType::queue, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "fims:queue"))
		return soap->error;
	if (soap_out_PointerTofims__ExtensionGroup(soap, "fims:ExtensionGroup", -1, &(a->fims__ManageQueueResponseType::ExtensionGroup), ""))
		return soap->error;
	if (soap_out_PointerTofims__ExtensionAttributes(soap, "fims:ExtensionAttributes", -1, &(a->fims__ManageQueueResponseType::ExtensionAttributes), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *fims__ManageQueueResponseType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_fims__ManageQueueResponseType(soap, tag, this, type);
}

SOAP_FMAC3 fims__ManageQueueResponseType * SOAP_FMAC4 soap_in_fims__ManageQueueResponseType(struct soap *soap, const char *tag, fims__ManageQueueResponseType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (fims__ManageQueueResponseType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_fims__ManageQueueResponseType, sizeof(fims__ManageQueueResponseType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_fims__ManageQueueResponseType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (fims__ManageQueueResponseType *)a->soap_in(soap, tag, type);
		}
	}
	if (soap_s2fims__CurrentVersion(soap, soap_attr_value(soap, "version", 1), &((fims__ManageQueueResponseType*)a)->version))
		return NULL;
	size_t soap_flag_queue1 = 1;
	size_t soap_flag_ExtensionGroup1 = 1;
	size_t soap_flag_ExtensionAttributes1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_queue1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTofims__QueueType(soap, "fims:queue", &(a->fims__ManageQueueResponseType::queue), "fims:QueueType"))
				{	soap_flag_queue1--;
					continue;
				}
			if (soap_flag_ExtensionGroup1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTofims__ExtensionGroup(soap, "fims:ExtensionGroup", &(a->fims__ManageQueueResponseType::ExtensionGroup), "fims:ExtensionGroup"))
				{	soap_flag_ExtensionGroup1--;
					continue;
				}
			if (soap_flag_ExtensionAttributes1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTofims__ExtensionAttributes(soap, "fims:ExtensionAttributes", &(a->fims__ManageQueueResponseType::ExtensionAttributes), "fims:ExtensionAttributes"))
				{	soap_flag_ExtensionAttributes1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (fims__ManageQueueResponseType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_fims__ManageQueueResponseType, 0, sizeof(fims__ManageQueueResponseType), 0, soap_copy_fims__ManageQueueResponseType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_queue1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int fims__ManageQueueResponseType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_fims__ManageQueueResponseType);
	if (this->soap_out(soap, tag?tag:"fims:ManageQueueResponseType", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *fims__ManageQueueResponseType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_fims__ManageQueueResponseType(soap, this, tag, type);
}

SOAP_FMAC3 fims__ManageQueueResponseType * SOAP_FMAC4 soap_get_fims__ManageQueueResponseType(struct soap *soap, fims__ManageQueueResponseType *p, const char *tag, const char *type)
{
	if ((p = soap_in_fims__ManageQueueResponseType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 fims__ManageQueueResponseType * SOAP_FMAC2 soap_instantiate_fims__ManageQueueResponseType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_fims__ManageQueueResponseType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_fims__ManageQueueResponseType, n, EDLProvider_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(fims__ManageQueueResponseType);
		if (size)
			*size = sizeof(fims__ManageQueueResponseType);
		((fims__ManageQueueResponseType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(fims__ManageQueueResponseType, n);
		if (size)
			*size = n * sizeof(fims__ManageQueueResponseType);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((fims__ManageQueueResponseType*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (fims__ManageQueueResponseType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_fims__ManageQueueResponseType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying fims__ManageQueueResponseType %p -> %p\n", q, p));
	*(fims__ManageQueueResponseType*)p = *(fims__ManageQueueResponseType*)q;
}

void fims__ManageQueueRequestType::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->fims__ManageQueueRequestType::queueID = NULL;
	soap_default_fims__QueueCommandType(soap, &this->fims__ManageQueueRequestType::queueCommand);
	this->fims__ManageQueueRequestType::ExtensionGroup = NULL;
	this->fims__ManageQueueRequestType::ExtensionAttributes = NULL;
	soap_default_fims__CurrentVersion(soap, &this->fims__ManageQueueRequestType::version);
	/* transient soap skipped */
}

void fims__ManageQueueRequestType::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTofims__UID(soap, &this->fims__ManageQueueRequestType::queueID);
	soap_serialize_PointerTofims__ExtensionGroup(soap, &this->fims__ManageQueueRequestType::ExtensionGroup);
	soap_serialize_PointerTofims__ExtensionAttributes(soap, &this->fims__ManageQueueRequestType::ExtensionAttributes);
	/* transient soap skipped */
#endif
}

int fims__ManageQueueRequestType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_fims__ManageQueueRequestType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_fims__ManageQueueRequestType(struct soap *soap, const char *tag, int id, const fims__ManageQueueRequestType *a, const char *type)
{
	soap_set_attr(soap, "version", soap_fims__CurrentVersion2s(soap, ((fims__ManageQueueRequestType*)a)->version), 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_fims__ManageQueueRequestType), type))
		return soap->error;
	if (soap_out_PointerTofims__UID(soap, "fims:queueID", -1, &(a->fims__ManageQueueRequestType::queueID), ""))
		return soap->error;
	if (soap_out_fims__QueueCommandType(soap, "fims:queueCommand", -1, &(a->fims__ManageQueueRequestType::queueCommand), ""))
		return soap->error;
	if (soap_out_PointerTofims__ExtensionGroup(soap, "fims:ExtensionGroup", -1, &(a->fims__ManageQueueRequestType::ExtensionGroup), ""))
		return soap->error;
	if (soap_out_PointerTofims__ExtensionAttributes(soap, "fims:ExtensionAttributes", -1, &(a->fims__ManageQueueRequestType::ExtensionAttributes), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *fims__ManageQueueRequestType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_fims__ManageQueueRequestType(soap, tag, this, type);
}

SOAP_FMAC3 fims__ManageQueueRequestType * SOAP_FMAC4 soap_in_fims__ManageQueueRequestType(struct soap *soap, const char *tag, fims__ManageQueueRequestType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (fims__ManageQueueRequestType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_fims__ManageQueueRequestType, sizeof(fims__ManageQueueRequestType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_fims__ManageQueueRequestType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (fims__ManageQueueRequestType *)a->soap_in(soap, tag, type);
		}
	}
	if (soap_s2fims__CurrentVersion(soap, soap_attr_value(soap, "version", 1), &((fims__ManageQueueRequestType*)a)->version))
		return NULL;
	size_t soap_flag_queueID1 = 1;
	size_t soap_flag_queueCommand1 = 1;
	size_t soap_flag_ExtensionGroup1 = 1;
	size_t soap_flag_ExtensionAttributes1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_queueID1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTofims__UID(soap, "fims:queueID", &(a->fims__ManageQueueRequestType::queueID), "fims:UID"))
				{	soap_flag_queueID1--;
					continue;
				}
			if (soap_flag_queueCommand1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_fims__QueueCommandType(soap, "fims:queueCommand", &(a->fims__ManageQueueRequestType::queueCommand), "fims:QueueCommandType"))
				{	soap_flag_queueCommand1--;
					continue;
				}
			if (soap_flag_ExtensionGroup1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTofims__ExtensionGroup(soap, "fims:ExtensionGroup", &(a->fims__ManageQueueRequestType::ExtensionGroup), "fims:ExtensionGroup"))
				{	soap_flag_ExtensionGroup1--;
					continue;
				}
			if (soap_flag_ExtensionAttributes1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTofims__ExtensionAttributes(soap, "fims:ExtensionAttributes", &(a->fims__ManageQueueRequestType::ExtensionAttributes), "fims:ExtensionAttributes"))
				{	soap_flag_ExtensionAttributes1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (fims__ManageQueueRequestType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_fims__ManageQueueRequestType, 0, sizeof(fims__ManageQueueRequestType), 0, soap_copy_fims__ManageQueueRequestType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_queueCommand1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int fims__ManageQueueRequestType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_fims__ManageQueueRequestType);
	if (this->soap_out(soap, tag?tag:"fims:ManageQueueRequestType", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *fims__ManageQueueRequestType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_fims__ManageQueueRequestType(soap, this, tag, type);
}

SOAP_FMAC3 fims__ManageQueueRequestType * SOAP_FMAC4 soap_get_fims__ManageQueueRequestType(struct soap *soap, fims__ManageQueueRequestType *p, const char *tag, const char *type)
{
	if ((p = soap_in_fims__ManageQueueRequestType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 fims__ManageQueueRequestType * SOAP_FMAC2 soap_instantiate_fims__ManageQueueRequestType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_fims__ManageQueueRequestType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_fims__ManageQueueRequestType, n, EDLProvider_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(fims__ManageQueueRequestType);
		if (size)
			*size = sizeof(fims__ManageQueueRequestType);
		((fims__ManageQueueRequestType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(fims__ManageQueueRequestType, n);
		if (size)
			*size = n * sizeof(fims__ManageQueueRequestType);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((fims__ManageQueueRequestType*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (fims__ManageQueueRequestType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_fims__ManageQueueRequestType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying fims__ManageQueueRequestType %p -> %p\n", q, p));
	*(fims__ManageQueueRequestType*)p = *(fims__ManageQueueRequestType*)q;
}

void fims__ManageJobResponseType::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->fims__ManageJobResponseType::job = NULL;
	this->fims__ManageJobResponseType::ExtensionGroup = NULL;
	this->fims__ManageJobResponseType::ExtensionAttributes = NULL;
	soap_default_fims__CurrentVersion(soap, &this->fims__ManageJobResponseType::version);
	/* transient soap skipped */
}

void fims__ManageJobResponseType::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTofims__JobType(soap, &this->fims__ManageJobResponseType::job);
	soap_serialize_PointerTofims__ExtensionGroup(soap, &this->fims__ManageJobResponseType::ExtensionGroup);
	soap_serialize_PointerTofims__ExtensionAttributes(soap, &this->fims__ManageJobResponseType::ExtensionAttributes);
	/* transient soap skipped */
#endif
}

int fims__ManageJobResponseType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_fims__ManageJobResponseType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_fims__ManageJobResponseType(struct soap *soap, const char *tag, int id, const fims__ManageJobResponseType *a, const char *type)
{
	soap_set_attr(soap, "version", soap_fims__CurrentVersion2s(soap, ((fims__ManageJobResponseType*)a)->version), 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_fims__ManageJobResponseType), type))
		return soap->error;
	if (a->fims__ManageJobResponseType::job)
	{	if (soap_out_PointerTofims__JobType(soap, "fims:job", -1, &a->fims__ManageJobResponseType::job, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "fims:job"))
		return soap->error;
	if (soap_out_PointerTofims__ExtensionGroup(soap, "fims:ExtensionGroup", -1, &(a->fims__ManageJobResponseType::ExtensionGroup), ""))
		return soap->error;
	if (soap_out_PointerTofims__ExtensionAttributes(soap, "fims:ExtensionAttributes", -1, &(a->fims__ManageJobResponseType::ExtensionAttributes), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *fims__ManageJobResponseType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_fims__ManageJobResponseType(soap, tag, this, type);
}

SOAP_FMAC3 fims__ManageJobResponseType * SOAP_FMAC4 soap_in_fims__ManageJobResponseType(struct soap *soap, const char *tag, fims__ManageJobResponseType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (fims__ManageJobResponseType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_fims__ManageJobResponseType, sizeof(fims__ManageJobResponseType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_fims__ManageJobResponseType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (fims__ManageJobResponseType *)a->soap_in(soap, tag, type);
		}
	}
	if (soap_s2fims__CurrentVersion(soap, soap_attr_value(soap, "version", 1), &((fims__ManageJobResponseType*)a)->version))
		return NULL;
	size_t soap_flag_job1 = 1;
	size_t soap_flag_ExtensionGroup1 = 1;
	size_t soap_flag_ExtensionAttributes1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_job1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTofims__JobType(soap, "fims:job", &(a->fims__ManageJobResponseType::job), "fims:JobType"))
				{	soap_flag_job1--;
					continue;
				}
			if (soap_flag_ExtensionGroup1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTofims__ExtensionGroup(soap, "fims:ExtensionGroup", &(a->fims__ManageJobResponseType::ExtensionGroup), "fims:ExtensionGroup"))
				{	soap_flag_ExtensionGroup1--;
					continue;
				}
			if (soap_flag_ExtensionAttributes1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTofims__ExtensionAttributes(soap, "fims:ExtensionAttributes", &(a->fims__ManageJobResponseType::ExtensionAttributes), "fims:ExtensionAttributes"))
				{	soap_flag_ExtensionAttributes1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (fims__ManageJobResponseType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_fims__ManageJobResponseType, 0, sizeof(fims__ManageJobResponseType), 0, soap_copy_fims__ManageJobResponseType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_job1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int fims__ManageJobResponseType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_fims__ManageJobResponseType);
	if (this->soap_out(soap, tag?tag:"fims:ManageJobResponseType", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *fims__ManageJobResponseType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_fims__ManageJobResponseType(soap, this, tag, type);
}

SOAP_FMAC3 fims__ManageJobResponseType * SOAP_FMAC4 soap_get_fims__ManageJobResponseType(struct soap *soap, fims__ManageJobResponseType *p, const char *tag, const char *type)
{
	if ((p = soap_in_fims__ManageJobResponseType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 fims__ManageJobResponseType * SOAP_FMAC2 soap_instantiate_fims__ManageJobResponseType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_fims__ManageJobResponseType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_fims__ManageJobResponseType, n, EDLProvider_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(fims__ManageJobResponseType);
		if (size)
			*size = sizeof(fims__ManageJobResponseType);
		((fims__ManageJobResponseType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(fims__ManageJobResponseType, n);
		if (size)
			*size = n * sizeof(fims__ManageJobResponseType);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((fims__ManageJobResponseType*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (fims__ManageJobResponseType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_fims__ManageJobResponseType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying fims__ManageJobResponseType %p -> %p\n", q, p));
	*(fims__ManageJobResponseType*)p = *(fims__ManageJobResponseType*)q;
}

void fims__ManageJobRequestType::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_fims__UID(soap, &this->fims__ManageJobRequestType::jobID);
	soap_default_fims__JobCommandType(soap, &this->fims__ManageJobRequestType::jobCommand);
	this->fims__ManageJobRequestType::priority = NULL;
	this->fims__ManageJobRequestType::ExtensionGroup = NULL;
	this->fims__ManageJobRequestType::ExtensionAttributes = NULL;
	soap_default_fims__CurrentVersion(soap, &this->fims__ManageJobRequestType::version);
	/* transient soap skipped */
}

void fims__ManageJobRequestType::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &this->fims__ManageJobRequestType::jobID, SOAP_TYPE_fims__UID);
	soap_serialize_fims__UID(soap, &this->fims__ManageJobRequestType::jobID);
	soap_serialize_PointerTofims__PriorityType(soap, &this->fims__ManageJobRequestType::priority);
	soap_serialize_PointerTofims__ExtensionGroup(soap, &this->fims__ManageJobRequestType::ExtensionGroup);
	soap_serialize_PointerTofims__ExtensionAttributes(soap, &this->fims__ManageJobRequestType::ExtensionAttributes);
	/* transient soap skipped */
#endif
}

int fims__ManageJobRequestType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_fims__ManageJobRequestType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_fims__ManageJobRequestType(struct soap *soap, const char *tag, int id, const fims__ManageJobRequestType *a, const char *type)
{
	soap_set_attr(soap, "version", soap_fims__CurrentVersion2s(soap, ((fims__ManageJobRequestType*)a)->version), 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_fims__ManageJobRequestType), type))
		return soap->error;
	if (soap_out_fims__UID(soap, "fims:jobID", -1, &(a->fims__ManageJobRequestType::jobID), ""))
		return soap->error;
	if (soap_out_fims__JobCommandType(soap, "fims:jobCommand", -1, &(a->fims__ManageJobRequestType::jobCommand), ""))
		return soap->error;
	if (soap_out_PointerTofims__PriorityType(soap, "fims:priority", -1, &(a->fims__ManageJobRequestType::priority), ""))
		return soap->error;
	if (soap_out_PointerTofims__ExtensionGroup(soap, "fims:ExtensionGroup", -1, &(a->fims__ManageJobRequestType::ExtensionGroup), ""))
		return soap->error;
	if (soap_out_PointerTofims__ExtensionAttributes(soap, "fims:ExtensionAttributes", -1, &(a->fims__ManageJobRequestType::ExtensionAttributes), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *fims__ManageJobRequestType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_fims__ManageJobRequestType(soap, tag, this, type);
}

SOAP_FMAC3 fims__ManageJobRequestType * SOAP_FMAC4 soap_in_fims__ManageJobRequestType(struct soap *soap, const char *tag, fims__ManageJobRequestType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (fims__ManageJobRequestType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_fims__ManageJobRequestType, sizeof(fims__ManageJobRequestType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_fims__ManageJobRequestType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (fims__ManageJobRequestType *)a->soap_in(soap, tag, type);
		}
	}
	if (soap_s2fims__CurrentVersion(soap, soap_attr_value(soap, "version", 1), &((fims__ManageJobRequestType*)a)->version))
		return NULL;
	size_t soap_flag_jobID1 = 1;
	size_t soap_flag_jobCommand1 = 1;
	size_t soap_flag_priority1 = 1;
	size_t soap_flag_ExtensionGroup1 = 1;
	size_t soap_flag_ExtensionAttributes1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_jobID1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_fims__UID(soap, "fims:jobID", &(a->fims__ManageJobRequestType::jobID), "fims:UID"))
				{	soap_flag_jobID1--;
					continue;
				}
			if (soap_flag_jobCommand1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_fims__JobCommandType(soap, "fims:jobCommand", &(a->fims__ManageJobRequestType::jobCommand), "fims:JobCommandType"))
				{	soap_flag_jobCommand1--;
					continue;
				}
			if (soap_flag_priority1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTofims__PriorityType(soap, "fims:priority", &(a->fims__ManageJobRequestType::priority), "fims:PriorityType"))
				{	soap_flag_priority1--;
					continue;
				}
			if (soap_flag_ExtensionGroup1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTofims__ExtensionGroup(soap, "fims:ExtensionGroup", &(a->fims__ManageJobRequestType::ExtensionGroup), "fims:ExtensionGroup"))
				{	soap_flag_ExtensionGroup1--;
					continue;
				}
			if (soap_flag_ExtensionAttributes1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTofims__ExtensionAttributes(soap, "fims:ExtensionAttributes", &(a->fims__ManageJobRequestType::ExtensionAttributes), "fims:ExtensionAttributes"))
				{	soap_flag_ExtensionAttributes1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (fims__ManageJobRequestType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_fims__ManageJobRequestType, 0, sizeof(fims__ManageJobRequestType), 0, soap_copy_fims__ManageJobRequestType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_jobID1 > 0 || soap_flag_jobCommand1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int fims__ManageJobRequestType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_fims__ManageJobRequestType);
	if (this->soap_out(soap, tag?tag:"fims:ManageJobRequestType", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *fims__ManageJobRequestType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_fims__ManageJobRequestType(soap, this, tag, type);
}

SOAP_FMAC3 fims__ManageJobRequestType * SOAP_FMAC4 soap_get_fims__ManageJobRequestType(struct soap *soap, fims__ManageJobRequestType *p, const char *tag, const char *type)
{
	if ((p = soap_in_fims__ManageJobRequestType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 fims__ManageJobRequestType * SOAP_FMAC2 soap_instantiate_fims__ManageJobRequestType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_fims__ManageJobRequestType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_fims__ManageJobRequestType, n, EDLProvider_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(fims__ManageJobRequestType);
		if (size)
			*size = sizeof(fims__ManageJobRequestType);
		((fims__ManageJobRequestType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(fims__ManageJobRequestType, n);
		if (size)
			*size = n * sizeof(fims__ManageJobRequestType);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((fims__ManageJobRequestType*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (fims__ManageJobRequestType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_fims__ManageJobRequestType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying fims__ManageJobRequestType %p -> %p\n", q, p));
	*(fims__ManageJobRequestType*)p = *(fims__ManageJobRequestType*)q;
}

void fims__StartJobByLatestType::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->fims__StartJobType::soap_default(soap);
}

void fims__StartJobByLatestType::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	this->fims__StartJobType::soap_serialize(soap);
#endif
}

int fims__StartJobByLatestType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_fims__StartJobByLatestType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_fims__StartJobByLatestType(struct soap *soap, const char *tag, int id, const fims__StartJobByLatestType *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_fims__StartJobByLatestType), "fims:StartJobByLatestType"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *fims__StartJobByLatestType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_fims__StartJobByLatestType(soap, tag, this, type);
}

SOAP_FMAC3 fims__StartJobByLatestType * SOAP_FMAC4 soap_in_fims__StartJobByLatestType(struct soap *soap, const char *tag, fims__StartJobByLatestType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (fims__StartJobByLatestType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_fims__StartJobByLatestType, sizeof(fims__StartJobByLatestType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_fims__StartJobByLatestType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (fims__StartJobByLatestType *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (fims__StartJobByLatestType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_fims__StartJobByLatestType, 0, sizeof(fims__StartJobByLatestType), 0, soap_copy_fims__StartJobByLatestType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int fims__StartJobByLatestType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_fims__StartJobByLatestType);
	if (this->soap_out(soap, tag?tag:"fims:StartJobByLatestType", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *fims__StartJobByLatestType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_fims__StartJobByLatestType(soap, this, tag, type);
}

SOAP_FMAC3 fims__StartJobByLatestType * SOAP_FMAC4 soap_get_fims__StartJobByLatestType(struct soap *soap, fims__StartJobByLatestType *p, const char *tag, const char *type)
{
	if ((p = soap_in_fims__StartJobByLatestType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 fims__StartJobByLatestType * SOAP_FMAC2 soap_instantiate_fims__StartJobByLatestType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_fims__StartJobByLatestType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_fims__StartJobByLatestType, n, EDLProvider_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(fims__StartJobByLatestType);
		if (size)
			*size = sizeof(fims__StartJobByLatestType);
		((fims__StartJobByLatestType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(fims__StartJobByLatestType, n);
		if (size)
			*size = n * sizeof(fims__StartJobByLatestType);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((fims__StartJobByLatestType*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (fims__StartJobByLatestType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_fims__StartJobByLatestType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying fims__StartJobByLatestType %p -> %p\n", q, p));
	*(fims__StartJobByLatestType*)p = *(fims__StartJobByLatestType*)q;
}

void fims__StartJobByTimeType::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->fims__StartJobType::soap_default(soap);
	soap_default_time(soap, &this->fims__StartJobByTimeType::time);
}

void fims__StartJobByTimeType::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &this->fims__StartJobByTimeType::time, SOAP_TYPE_time);
	this->fims__StartJobType::soap_serialize(soap);
#endif
}

int fims__StartJobByTimeType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_fims__StartJobByTimeType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_fims__StartJobByTimeType(struct soap *soap, const char *tag, int id, const fims__StartJobByTimeType *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_fims__StartJobByTimeType), "fims:StartJobByTimeType"))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_time(soap, "fims:time", -1, &(a->fims__StartJobByTimeType::time), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *fims__StartJobByTimeType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_fims__StartJobByTimeType(soap, tag, this, type);
}

SOAP_FMAC3 fims__StartJobByTimeType * SOAP_FMAC4 soap_in_fims__StartJobByTimeType(struct soap *soap, const char *tag, fims__StartJobByTimeType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (fims__StartJobByTimeType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_fims__StartJobByTimeType, sizeof(fims__StartJobByTimeType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_fims__StartJobByTimeType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (fims__StartJobByTimeType *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_time1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap_flag_time1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_time(soap, "fims:time", &(a->fims__StartJobByTimeType::time), "xsd:dateTime"))
				{	soap_flag_time1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (fims__StartJobByTimeType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_fims__StartJobByTimeType, 0, sizeof(fims__StartJobByTimeType), 0, soap_copy_fims__StartJobByTimeType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_time1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int fims__StartJobByTimeType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_fims__StartJobByTimeType);
	if (this->soap_out(soap, tag?tag:"fims:StartJobByTimeType", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *fims__StartJobByTimeType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_fims__StartJobByTimeType(soap, this, tag, type);
}

SOAP_FMAC3 fims__StartJobByTimeType * SOAP_FMAC4 soap_get_fims__StartJobByTimeType(struct soap *soap, fims__StartJobByTimeType *p, const char *tag, const char *type)
{
	if ((p = soap_in_fims__StartJobByTimeType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 fims__StartJobByTimeType * SOAP_FMAC2 soap_instantiate_fims__StartJobByTimeType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_fims__StartJobByTimeType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_fims__StartJobByTimeType, n, EDLProvider_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(fims__StartJobByTimeType);
		if (size)
			*size = sizeof(fims__StartJobByTimeType);
		((fims__StartJobByTimeType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(fims__StartJobByTimeType, n);
		if (size)
			*size = n * sizeof(fims__StartJobByTimeType);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((fims__StartJobByTimeType*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (fims__StartJobByTimeType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_fims__StartJobByTimeType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying fims__StartJobByTimeType %p -> %p\n", q, p));
	*(fims__StartJobByTimeType*)p = *(fims__StartJobByTimeType*)q;
}

void fims__StartJobByNoWaitType::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->fims__StartJobType::soap_default(soap);
}

void fims__StartJobByNoWaitType::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	this->fims__StartJobType::soap_serialize(soap);
#endif
}

int fims__StartJobByNoWaitType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_fims__StartJobByNoWaitType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_fims__StartJobByNoWaitType(struct soap *soap, const char *tag, int id, const fims__StartJobByNoWaitType *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_fims__StartJobByNoWaitType), "fims:StartJobByNoWaitType"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *fims__StartJobByNoWaitType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_fims__StartJobByNoWaitType(soap, tag, this, type);
}

SOAP_FMAC3 fims__StartJobByNoWaitType * SOAP_FMAC4 soap_in_fims__StartJobByNoWaitType(struct soap *soap, const char *tag, fims__StartJobByNoWaitType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (fims__StartJobByNoWaitType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_fims__StartJobByNoWaitType, sizeof(fims__StartJobByNoWaitType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_fims__StartJobByNoWaitType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (fims__StartJobByNoWaitType *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (fims__StartJobByNoWaitType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_fims__StartJobByNoWaitType, 0, sizeof(fims__StartJobByNoWaitType), 0, soap_copy_fims__StartJobByNoWaitType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int fims__StartJobByNoWaitType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_fims__StartJobByNoWaitType);
	if (this->soap_out(soap, tag?tag:"fims:StartJobByNoWaitType", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *fims__StartJobByNoWaitType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_fims__StartJobByNoWaitType(soap, this, tag, type);
}

SOAP_FMAC3 fims__StartJobByNoWaitType * SOAP_FMAC4 soap_get_fims__StartJobByNoWaitType(struct soap *soap, fims__StartJobByNoWaitType *p, const char *tag, const char *type)
{
	if ((p = soap_in_fims__StartJobByNoWaitType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 fims__StartJobByNoWaitType * SOAP_FMAC2 soap_instantiate_fims__StartJobByNoWaitType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_fims__StartJobByNoWaitType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_fims__StartJobByNoWaitType, n, EDLProvider_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(fims__StartJobByNoWaitType);
		if (size)
			*size = sizeof(fims__StartJobByNoWaitType);
		((fims__StartJobByNoWaitType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(fims__StartJobByNoWaitType, n);
		if (size)
			*size = n * sizeof(fims__StartJobByNoWaitType);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((fims__StartJobByNoWaitType*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (fims__StartJobByNoWaitType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_fims__StartJobByNoWaitType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying fims__StartJobByNoWaitType %p -> %p\n", q, p));
	*(fims__StartJobByNoWaitType*)p = *(fims__StartJobByNoWaitType*)q;
}

void fims__StartJobType::soap_default(struct soap *soap)
{
	this->soap = soap;
	/* transient soap skipped */
}

void fims__StartJobType::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
#endif
}

int fims__StartJobType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_fims__StartJobType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_fims__StartJobType(struct soap *soap, const char *tag, int id, const fims__StartJobType *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_fims__StartJobType), type))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *fims__StartJobType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_fims__StartJobType(soap, tag, this, type);
}

SOAP_FMAC3 fims__StartJobType * SOAP_FMAC4 soap_in_fims__StartJobType(struct soap *soap, const char *tag, fims__StartJobType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (fims__StartJobType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_fims__StartJobType, sizeof(fims__StartJobType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_fims__StartJobType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (fims__StartJobType *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (fims__StartJobType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_fims__StartJobType, 0, sizeof(fims__StartJobType), 0, soap_copy_fims__StartJobType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int fims__StartJobType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_fims__StartJobType);
	if (this->soap_out(soap, tag?tag:"fims:StartJobType", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *fims__StartJobType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_fims__StartJobType(soap, this, tag, type);
}

SOAP_FMAC3 fims__StartJobType * SOAP_FMAC4 soap_get_fims__StartJobType(struct soap *soap, fims__StartJobType *p, const char *tag, const char *type)
{
	if ((p = soap_in_fims__StartJobType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 fims__StartJobType * SOAP_FMAC2 soap_instantiate_fims__StartJobType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_fims__StartJobType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_fims__StartJobType, n, EDLProvider_fdelete);
	if (!cp)
		return NULL;
	if (type && !soap_match_tag(soap, type, "fims:StartJobByNoWaitType"))
	{	cp->type = SOAP_TYPE_fims__StartJobByNoWaitType;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(fims__StartJobByNoWaitType);
			if (size)
				*size = sizeof(fims__StartJobByNoWaitType);
			((fims__StartJobByNoWaitType*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW_ARRAY(fims__StartJobByNoWaitType, n);
			if (size)
				*size = n * sizeof(fims__StartJobByNoWaitType);
			if (cp->ptr)
				for (int i = 0; i < n; i++)
					((fims__StartJobByNoWaitType*)cp->ptr)[i].soap = soap;
		}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		if (!cp->ptr)
			soap->error = SOAP_EOM;
		return (fims__StartJobByNoWaitType*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "fims:StartJobByTimeType"))
	{	cp->type = SOAP_TYPE_fims__StartJobByTimeType;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(fims__StartJobByTimeType);
			if (size)
				*size = sizeof(fims__StartJobByTimeType);
			((fims__StartJobByTimeType*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW_ARRAY(fims__StartJobByTimeType, n);
			if (size)
				*size = n * sizeof(fims__StartJobByTimeType);
			if (cp->ptr)
				for (int i = 0; i < n; i++)
					((fims__StartJobByTimeType*)cp->ptr)[i].soap = soap;
		}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		if (!cp->ptr)
			soap->error = SOAP_EOM;
		return (fims__StartJobByTimeType*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "fims:StartJobByLatestType"))
	{	cp->type = SOAP_TYPE_fims__StartJobByLatestType;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(fims__StartJobByLatestType);
			if (size)
				*size = sizeof(fims__StartJobByLatestType);
			((fims__StartJobByLatestType*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW_ARRAY(fims__StartJobByLatestType, n);
			if (size)
				*size = n * sizeof(fims__StartJobByLatestType);
			if (cp->ptr)
				for (int i = 0; i < n; i++)
					((fims__StartJobByLatestType*)cp->ptr)[i].soap = soap;
		}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		if (!cp->ptr)
			soap->error = SOAP_EOM;
		return (fims__StartJobByLatestType*)cp->ptr;
	}
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(fims__StartJobType);
		if (size)
			*size = sizeof(fims__StartJobType);
		((fims__StartJobType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(fims__StartJobType, n);
		if (size)
			*size = n * sizeof(fims__StartJobType);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((fims__StartJobType*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (fims__StartJobType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_fims__StartJobType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying fims__StartJobType %p -> %p\n", q, p));
	*(fims__StartJobType*)p = *(fims__StartJobType*)q;
}

void fims__StopProcessByOpenEndType::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->fims__StopProcessType::soap_default(soap);
	this->fims__StopProcessByOpenEndType::actualStopTime = NULL;
	this->fims__StopProcessByOpenEndType::actualStopMark = NULL;
}

void fims__StopProcessByOpenEndType::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTotime(soap, &this->fims__StopProcessByOpenEndType::actualStopTime);
	soap_serialize_PointerTofimstime__TimeType(soap, &this->fims__StopProcessByOpenEndType::actualStopMark);
	this->fims__StopProcessType::soap_serialize(soap);
#endif
}

int fims__StopProcessByOpenEndType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_fims__StopProcessByOpenEndType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_fims__StopProcessByOpenEndType(struct soap *soap, const char *tag, int id, const fims__StopProcessByOpenEndType *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_fims__StopProcessByOpenEndType), "fims:StopProcessByOpenEndType"))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_PointerTotime(soap, "fims:actualStopTime", -1, &(a->fims__StopProcessByOpenEndType::actualStopTime), ""))
		return soap->error;
	if (soap_out_PointerTofimstime__TimeType(soap, "fims:actualStopMark", -1, &(a->fims__StopProcessByOpenEndType::actualStopMark), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *fims__StopProcessByOpenEndType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_fims__StopProcessByOpenEndType(soap, tag, this, type);
}

SOAP_FMAC3 fims__StopProcessByOpenEndType * SOAP_FMAC4 soap_in_fims__StopProcessByOpenEndType(struct soap *soap, const char *tag, fims__StopProcessByOpenEndType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (fims__StopProcessByOpenEndType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_fims__StopProcessByOpenEndType, sizeof(fims__StopProcessByOpenEndType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_fims__StopProcessByOpenEndType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (fims__StopProcessByOpenEndType *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_actualStopTime1 = 1;
	size_t soap_flag_actualStopMark1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap_flag_actualStopTime1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTotime(soap, "fims:actualStopTime", &(a->fims__StopProcessByOpenEndType::actualStopTime), "xsd:dateTime"))
				{	soap_flag_actualStopTime1--;
					continue;
				}
			if (soap_flag_actualStopMark1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTofimstime__TimeType(soap, "fims:actualStopMark", &(a->fims__StopProcessByOpenEndType::actualStopMark), "fimstime:TimeType"))
				{	soap_flag_actualStopMark1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (fims__StopProcessByOpenEndType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_fims__StopProcessByOpenEndType, 0, sizeof(fims__StopProcessByOpenEndType), 0, soap_copy_fims__StopProcessByOpenEndType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int fims__StopProcessByOpenEndType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_fims__StopProcessByOpenEndType);
	if (this->soap_out(soap, tag?tag:"fims:StopProcessByOpenEndType", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *fims__StopProcessByOpenEndType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_fims__StopProcessByOpenEndType(soap, this, tag, type);
}

SOAP_FMAC3 fims__StopProcessByOpenEndType * SOAP_FMAC4 soap_get_fims__StopProcessByOpenEndType(struct soap *soap, fims__StopProcessByOpenEndType *p, const char *tag, const char *type)
{
	if ((p = soap_in_fims__StopProcessByOpenEndType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 fims__StopProcessByOpenEndType * SOAP_FMAC2 soap_instantiate_fims__StopProcessByOpenEndType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_fims__StopProcessByOpenEndType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_fims__StopProcessByOpenEndType, n, EDLProvider_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(fims__StopProcessByOpenEndType);
		if (size)
			*size = sizeof(fims__StopProcessByOpenEndType);
		((fims__StopProcessByOpenEndType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(fims__StopProcessByOpenEndType, n);
		if (size)
			*size = n * sizeof(fims__StopProcessByOpenEndType);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((fims__StopProcessByOpenEndType*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (fims__StopProcessByOpenEndType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_fims__StopProcessByOpenEndType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying fims__StopProcessByOpenEndType %p -> %p\n", q, p));
	*(fims__StopProcessByOpenEndType*)p = *(fims__StopProcessByOpenEndType*)q;
}

void fims__StopProcessByServiceDefinedTimeType::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->fims__StopProcessType::soap_default(soap);
	this->fims__StopProcessByServiceDefinedTimeType::actualStopTime = NULL;
	this->fims__StopProcessByServiceDefinedTimeType::actualStopMark = NULL;
}

void fims__StopProcessByServiceDefinedTimeType::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTotime(soap, &this->fims__StopProcessByServiceDefinedTimeType::actualStopTime);
	soap_serialize_PointerTofimstime__TimeType(soap, &this->fims__StopProcessByServiceDefinedTimeType::actualStopMark);
	this->fims__StopProcessType::soap_serialize(soap);
#endif
}

int fims__StopProcessByServiceDefinedTimeType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_fims__StopProcessByServiceDefinedTimeType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_fims__StopProcessByServiceDefinedTimeType(struct soap *soap, const char *tag, int id, const fims__StopProcessByServiceDefinedTimeType *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_fims__StopProcessByServiceDefinedTimeType), "fims:StopProcessByServiceDefinedTimeType"))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_PointerTotime(soap, "fims:actualStopTime", -1, &(a->fims__StopProcessByServiceDefinedTimeType::actualStopTime), ""))
		return soap->error;
	if (soap_out_PointerTofimstime__TimeType(soap, "fims:actualStopMark", -1, &(a->fims__StopProcessByServiceDefinedTimeType::actualStopMark), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *fims__StopProcessByServiceDefinedTimeType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_fims__StopProcessByServiceDefinedTimeType(soap, tag, this, type);
}

SOAP_FMAC3 fims__StopProcessByServiceDefinedTimeType * SOAP_FMAC4 soap_in_fims__StopProcessByServiceDefinedTimeType(struct soap *soap, const char *tag, fims__StopProcessByServiceDefinedTimeType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (fims__StopProcessByServiceDefinedTimeType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_fims__StopProcessByServiceDefinedTimeType, sizeof(fims__StopProcessByServiceDefinedTimeType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_fims__StopProcessByServiceDefinedTimeType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (fims__StopProcessByServiceDefinedTimeType *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_actualStopTime1 = 1;
	size_t soap_flag_actualStopMark1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap_flag_actualStopTime1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTotime(soap, "fims:actualStopTime", &(a->fims__StopProcessByServiceDefinedTimeType::actualStopTime), "xsd:dateTime"))
				{	soap_flag_actualStopTime1--;
					continue;
				}
			if (soap_flag_actualStopMark1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTofimstime__TimeType(soap, "fims:actualStopMark", &(a->fims__StopProcessByServiceDefinedTimeType::actualStopMark), "fimstime:TimeType"))
				{	soap_flag_actualStopMark1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (fims__StopProcessByServiceDefinedTimeType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_fims__StopProcessByServiceDefinedTimeType, 0, sizeof(fims__StopProcessByServiceDefinedTimeType), 0, soap_copy_fims__StopProcessByServiceDefinedTimeType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int fims__StopProcessByServiceDefinedTimeType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_fims__StopProcessByServiceDefinedTimeType);
	if (this->soap_out(soap, tag?tag:"fims:StopProcessByServiceDefinedTimeType", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *fims__StopProcessByServiceDefinedTimeType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_fims__StopProcessByServiceDefinedTimeType(soap, this, tag, type);
}

SOAP_FMAC3 fims__StopProcessByServiceDefinedTimeType * SOAP_FMAC4 soap_get_fims__StopProcessByServiceDefinedTimeType(struct soap *soap, fims__StopProcessByServiceDefinedTimeType *p, const char *tag, const char *type)
{
	if ((p = soap_in_fims__StopProcessByServiceDefinedTimeType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 fims__StopProcessByServiceDefinedTimeType * SOAP_FMAC2 soap_instantiate_fims__StopProcessByServiceDefinedTimeType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_fims__StopProcessByServiceDefinedTimeType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_fims__StopProcessByServiceDefinedTimeType, n, EDLProvider_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(fims__StopProcessByServiceDefinedTimeType);
		if (size)
			*size = sizeof(fims__StopProcessByServiceDefinedTimeType);
		((fims__StopProcessByServiceDefinedTimeType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(fims__StopProcessByServiceDefinedTimeType, n);
		if (size)
			*size = n * sizeof(fims__StopProcessByServiceDefinedTimeType);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((fims__StopProcessByServiceDefinedTimeType*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (fims__StopProcessByServiceDefinedTimeType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_fims__StopProcessByServiceDefinedTimeType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying fims__StopProcessByServiceDefinedTimeType %p -> %p\n", q, p));
	*(fims__StopProcessByServiceDefinedTimeType*)p = *(fims__StopProcessByServiceDefinedTimeType*)q;
}

void fims__StopProcessByTimeMarkType::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->fims__StopProcessType::soap_default(soap);
	this->fims__StopProcessByTimeMarkType::timeMark = NULL;
}

void fims__StopProcessByTimeMarkType::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTofimstime__TimeType(soap, &this->fims__StopProcessByTimeMarkType::timeMark);
	this->fims__StopProcessType::soap_serialize(soap);
#endif
}

int fims__StopProcessByTimeMarkType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_fims__StopProcessByTimeMarkType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_fims__StopProcessByTimeMarkType(struct soap *soap, const char *tag, int id, const fims__StopProcessByTimeMarkType *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_fims__StopProcessByTimeMarkType), "fims:StopProcessByTimeMarkType"))
		return soap->error;
	/* transient soap skipped */
	if (a->fims__StopProcessByTimeMarkType::timeMark)
	{	if (soap_out_PointerTofimstime__TimeType(soap, "fims:timeMark", -1, &a->fims__StopProcessByTimeMarkType::timeMark, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "fims:timeMark"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *fims__StopProcessByTimeMarkType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_fims__StopProcessByTimeMarkType(soap, tag, this, type);
}

SOAP_FMAC3 fims__StopProcessByTimeMarkType * SOAP_FMAC4 soap_in_fims__StopProcessByTimeMarkType(struct soap *soap, const char *tag, fims__StopProcessByTimeMarkType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (fims__StopProcessByTimeMarkType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_fims__StopProcessByTimeMarkType, sizeof(fims__StopProcessByTimeMarkType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_fims__StopProcessByTimeMarkType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (fims__StopProcessByTimeMarkType *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_timeMark1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap_flag_timeMark1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTofimstime__TimeType(soap, "fims:timeMark", &(a->fims__StopProcessByTimeMarkType::timeMark), "fimstime:TimeType"))
				{	soap_flag_timeMark1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (fims__StopProcessByTimeMarkType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_fims__StopProcessByTimeMarkType, 0, sizeof(fims__StopProcessByTimeMarkType), 0, soap_copy_fims__StopProcessByTimeMarkType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_timeMark1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int fims__StopProcessByTimeMarkType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_fims__StopProcessByTimeMarkType);
	if (this->soap_out(soap, tag?tag:"fims:StopProcessByTimeMarkType", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *fims__StopProcessByTimeMarkType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_fims__StopProcessByTimeMarkType(soap, this, tag, type);
}

SOAP_FMAC3 fims__StopProcessByTimeMarkType * SOAP_FMAC4 soap_get_fims__StopProcessByTimeMarkType(struct soap *soap, fims__StopProcessByTimeMarkType *p, const char *tag, const char *type)
{
	if ((p = soap_in_fims__StopProcessByTimeMarkType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 fims__StopProcessByTimeMarkType * SOAP_FMAC2 soap_instantiate_fims__StopProcessByTimeMarkType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_fims__StopProcessByTimeMarkType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_fims__StopProcessByTimeMarkType, n, EDLProvider_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(fims__StopProcessByTimeMarkType);
		if (size)
			*size = sizeof(fims__StopProcessByTimeMarkType);
		((fims__StopProcessByTimeMarkType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(fims__StopProcessByTimeMarkType, n);
		if (size)
			*size = n * sizeof(fims__StopProcessByTimeMarkType);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((fims__StopProcessByTimeMarkType*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (fims__StopProcessByTimeMarkType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_fims__StopProcessByTimeMarkType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying fims__StopProcessByTimeMarkType %p -> %p\n", q, p));
	*(fims__StopProcessByTimeMarkType*)p = *(fims__StopProcessByTimeMarkType*)q;
}

void fims__StopProcessByDurationType::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->fims__StopProcessType::soap_default(soap);
	this->fims__StopProcessByDurationType::duration = NULL;
}

void fims__StopProcessByDurationType::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTofimstime__DurationType(soap, &this->fims__StopProcessByDurationType::duration);
	this->fims__StopProcessType::soap_serialize(soap);
#endif
}

int fims__StopProcessByDurationType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_fims__StopProcessByDurationType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_fims__StopProcessByDurationType(struct soap *soap, const char *tag, int id, const fims__StopProcessByDurationType *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_fims__StopProcessByDurationType), "fims:StopProcessByDurationType"))
		return soap->error;
	/* transient soap skipped */
	if (a->fims__StopProcessByDurationType::duration)
	{	if (soap_out_PointerTofimstime__DurationType(soap, "fims:duration", -1, &a->fims__StopProcessByDurationType::duration, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "fims:duration"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *fims__StopProcessByDurationType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_fims__StopProcessByDurationType(soap, tag, this, type);
}

SOAP_FMAC3 fims__StopProcessByDurationType * SOAP_FMAC4 soap_in_fims__StopProcessByDurationType(struct soap *soap, const char *tag, fims__StopProcessByDurationType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (fims__StopProcessByDurationType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_fims__StopProcessByDurationType, sizeof(fims__StopProcessByDurationType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_fims__StopProcessByDurationType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (fims__StopProcessByDurationType *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_duration1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap_flag_duration1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTofimstime__DurationType(soap, "fims:duration", &(a->fims__StopProcessByDurationType::duration), "fimstime:DurationType"))
				{	soap_flag_duration1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (fims__StopProcessByDurationType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_fims__StopProcessByDurationType, 0, sizeof(fims__StopProcessByDurationType), 0, soap_copy_fims__StopProcessByDurationType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_duration1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int fims__StopProcessByDurationType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_fims__StopProcessByDurationType);
	if (this->soap_out(soap, tag?tag:"fims:StopProcessByDurationType", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *fims__StopProcessByDurationType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_fims__StopProcessByDurationType(soap, this, tag, type);
}

SOAP_FMAC3 fims__StopProcessByDurationType * SOAP_FMAC4 soap_get_fims__StopProcessByDurationType(struct soap *soap, fims__StopProcessByDurationType *p, const char *tag, const char *type)
{
	if ((p = soap_in_fims__StopProcessByDurationType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 fims__StopProcessByDurationType * SOAP_FMAC2 soap_instantiate_fims__StopProcessByDurationType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_fims__StopProcessByDurationType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_fims__StopProcessByDurationType, n, EDLProvider_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(fims__StopProcessByDurationType);
		if (size)
			*size = sizeof(fims__StopProcessByDurationType);
		((fims__StopProcessByDurationType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(fims__StopProcessByDurationType, n);
		if (size)
			*size = n * sizeof(fims__StopProcessByDurationType);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((fims__StopProcessByDurationType*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (fims__StopProcessByDurationType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_fims__StopProcessByDurationType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying fims__StopProcessByDurationType %p -> %p\n", q, p));
	*(fims__StopProcessByDurationType*)p = *(fims__StopProcessByDurationType*)q;
}

void fims__StopProcessByTimeType::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->fims__StopProcessType::soap_default(soap);
	soap_default_time(soap, &this->fims__StopProcessByTimeType::time);
}

void fims__StopProcessByTimeType::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &this->fims__StopProcessByTimeType::time, SOAP_TYPE_time);
	this->fims__StopProcessType::soap_serialize(soap);
#endif
}

int fims__StopProcessByTimeType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_fims__StopProcessByTimeType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_fims__StopProcessByTimeType(struct soap *soap, const char *tag, int id, const fims__StopProcessByTimeType *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_fims__StopProcessByTimeType), "fims:StopProcessByTimeType"))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_time(soap, "fims:time", -1, &(a->fims__StopProcessByTimeType::time), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *fims__StopProcessByTimeType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_fims__StopProcessByTimeType(soap, tag, this, type);
}

SOAP_FMAC3 fims__StopProcessByTimeType * SOAP_FMAC4 soap_in_fims__StopProcessByTimeType(struct soap *soap, const char *tag, fims__StopProcessByTimeType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (fims__StopProcessByTimeType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_fims__StopProcessByTimeType, sizeof(fims__StopProcessByTimeType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_fims__StopProcessByTimeType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (fims__StopProcessByTimeType *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_time1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap_flag_time1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_time(soap, "fims:time", &(a->fims__StopProcessByTimeType::time), "xsd:dateTime"))
				{	soap_flag_time1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (fims__StopProcessByTimeType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_fims__StopProcessByTimeType, 0, sizeof(fims__StopProcessByTimeType), 0, soap_copy_fims__StopProcessByTimeType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_time1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int fims__StopProcessByTimeType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_fims__StopProcessByTimeType);
	if (this->soap_out(soap, tag?tag:"fims:StopProcessByTimeType", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *fims__StopProcessByTimeType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_fims__StopProcessByTimeType(soap, this, tag, type);
}

SOAP_FMAC3 fims__StopProcessByTimeType * SOAP_FMAC4 soap_get_fims__StopProcessByTimeType(struct soap *soap, fims__StopProcessByTimeType *p, const char *tag, const char *type)
{
	if ((p = soap_in_fims__StopProcessByTimeType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 fims__StopProcessByTimeType * SOAP_FMAC2 soap_instantiate_fims__StopProcessByTimeType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_fims__StopProcessByTimeType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_fims__StopProcessByTimeType, n, EDLProvider_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(fims__StopProcessByTimeType);
		if (size)
			*size = sizeof(fims__StopProcessByTimeType);
		((fims__StopProcessByTimeType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(fims__StopProcessByTimeType, n);
		if (size)
			*size = n * sizeof(fims__StopProcessByTimeType);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((fims__StopProcessByTimeType*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (fims__StopProcessByTimeType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_fims__StopProcessByTimeType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying fims__StopProcessByTimeType %p -> %p\n", q, p));
	*(fims__StopProcessByTimeType*)p = *(fims__StopProcessByTimeType*)q;
}

void fims__StopProcessType::soap_default(struct soap *soap)
{
	this->soap = soap;
	/* transient soap skipped */
}

void fims__StopProcessType::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
#endif
}

int fims__StopProcessType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_fims__StopProcessType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_fims__StopProcessType(struct soap *soap, const char *tag, int id, const fims__StopProcessType *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_fims__StopProcessType), type))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *fims__StopProcessType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_fims__StopProcessType(soap, tag, this, type);
}

SOAP_FMAC3 fims__StopProcessType * SOAP_FMAC4 soap_in_fims__StopProcessType(struct soap *soap, const char *tag, fims__StopProcessType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (fims__StopProcessType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_fims__StopProcessType, sizeof(fims__StopProcessType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_fims__StopProcessType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (fims__StopProcessType *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (fims__StopProcessType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_fims__StopProcessType, 0, sizeof(fims__StopProcessType), 0, soap_copy_fims__StopProcessType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int fims__StopProcessType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_fims__StopProcessType);
	if (this->soap_out(soap, tag?tag:"fims:StopProcessType", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *fims__StopProcessType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_fims__StopProcessType(soap, this, tag, type);
}

SOAP_FMAC3 fims__StopProcessType * SOAP_FMAC4 soap_get_fims__StopProcessType(struct soap *soap, fims__StopProcessType *p, const char *tag, const char *type)
{
	if ((p = soap_in_fims__StopProcessType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 fims__StopProcessType * SOAP_FMAC2 soap_instantiate_fims__StopProcessType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_fims__StopProcessType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_fims__StopProcessType, n, EDLProvider_fdelete);
	if (!cp)
		return NULL;
	if (type && !soap_match_tag(soap, type, "fims:StopProcessByTimeType"))
	{	cp->type = SOAP_TYPE_fims__StopProcessByTimeType;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(fims__StopProcessByTimeType);
			if (size)
				*size = sizeof(fims__StopProcessByTimeType);
			((fims__StopProcessByTimeType*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW_ARRAY(fims__StopProcessByTimeType, n);
			if (size)
				*size = n * sizeof(fims__StopProcessByTimeType);
			if (cp->ptr)
				for (int i = 0; i < n; i++)
					((fims__StopProcessByTimeType*)cp->ptr)[i].soap = soap;
		}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		if (!cp->ptr)
			soap->error = SOAP_EOM;
		return (fims__StopProcessByTimeType*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "fims:StopProcessByDurationType"))
	{	cp->type = SOAP_TYPE_fims__StopProcessByDurationType;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(fims__StopProcessByDurationType);
			if (size)
				*size = sizeof(fims__StopProcessByDurationType);
			((fims__StopProcessByDurationType*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW_ARRAY(fims__StopProcessByDurationType, n);
			if (size)
				*size = n * sizeof(fims__StopProcessByDurationType);
			if (cp->ptr)
				for (int i = 0; i < n; i++)
					((fims__StopProcessByDurationType*)cp->ptr)[i].soap = soap;
		}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		if (!cp->ptr)
			soap->error = SOAP_EOM;
		return (fims__StopProcessByDurationType*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "fims:StopProcessByTimeMarkType"))
	{	cp->type = SOAP_TYPE_fims__StopProcessByTimeMarkType;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(fims__StopProcessByTimeMarkType);
			if (size)
				*size = sizeof(fims__StopProcessByTimeMarkType);
			((fims__StopProcessByTimeMarkType*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW_ARRAY(fims__StopProcessByTimeMarkType, n);
			if (size)
				*size = n * sizeof(fims__StopProcessByTimeMarkType);
			if (cp->ptr)
				for (int i = 0; i < n; i++)
					((fims__StopProcessByTimeMarkType*)cp->ptr)[i].soap = soap;
		}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		if (!cp->ptr)
			soap->error = SOAP_EOM;
		return (fims__StopProcessByTimeMarkType*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "fims:StopProcessByServiceDefinedTimeType"))
	{	cp->type = SOAP_TYPE_fims__StopProcessByServiceDefinedTimeType;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(fims__StopProcessByServiceDefinedTimeType);
			if (size)
				*size = sizeof(fims__StopProcessByServiceDefinedTimeType);
			((fims__StopProcessByServiceDefinedTimeType*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW_ARRAY(fims__StopProcessByServiceDefinedTimeType, n);
			if (size)
				*size = n * sizeof(fims__StopProcessByServiceDefinedTimeType);
			if (cp->ptr)
				for (int i = 0; i < n; i++)
					((fims__StopProcessByServiceDefinedTimeType*)cp->ptr)[i].soap = soap;
		}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		if (!cp->ptr)
			soap->error = SOAP_EOM;
		return (fims__StopProcessByServiceDefinedTimeType*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "fims:StopProcessByOpenEndType"))
	{	cp->type = SOAP_TYPE_fims__StopProcessByOpenEndType;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(fims__StopProcessByOpenEndType);
			if (size)
				*size = sizeof(fims__StopProcessByOpenEndType);
			((fims__StopProcessByOpenEndType*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW_ARRAY(fims__StopProcessByOpenEndType, n);
			if (size)
				*size = n * sizeof(fims__StopProcessByOpenEndType);
			if (cp->ptr)
				for (int i = 0; i < n; i++)
					((fims__StopProcessByOpenEndType*)cp->ptr)[i].soap = soap;
		}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		if (!cp->ptr)
			soap->error = SOAP_EOM;
		return (fims__StopProcessByOpenEndType*)cp->ptr;
	}
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(fims__StopProcessType);
		if (size)
			*size = sizeof(fims__StopProcessType);
		((fims__StopProcessType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(fims__StopProcessType, n);
		if (size)
			*size = n * sizeof(fims__StopProcessType);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((fims__StopProcessType*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (fims__StopProcessType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_fims__StopProcessType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying fims__StopProcessType %p -> %p\n", q, p));
	*(fims__StopProcessType*)p = *(fims__StopProcessType*)q;
}

void fims__StartProcessByServiceDefinedTimeType::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->fims__StartProcessType::soap_default(soap);
	this->fims__StartProcessByServiceDefinedTimeType::actualStartTime = NULL;
	this->fims__StartProcessByServiceDefinedTimeType::actualStartMark = NULL;
}

void fims__StartProcessByServiceDefinedTimeType::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTotime(soap, &this->fims__StartProcessByServiceDefinedTimeType::actualStartTime);
	soap_serialize_PointerTofimstime__TimeType(soap, &this->fims__StartProcessByServiceDefinedTimeType::actualStartMark);
	this->fims__StartProcessType::soap_serialize(soap);
#endif
}

int fims__StartProcessByServiceDefinedTimeType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_fims__StartProcessByServiceDefinedTimeType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_fims__StartProcessByServiceDefinedTimeType(struct soap *soap, const char *tag, int id, const fims__StartProcessByServiceDefinedTimeType *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_fims__StartProcessByServiceDefinedTimeType), "fims:StartProcessByServiceDefinedTimeType"))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_PointerTotime(soap, "fims:actualStartTime", -1, &(a->fims__StartProcessByServiceDefinedTimeType::actualStartTime), ""))
		return soap->error;
	if (soap_out_PointerTofimstime__TimeType(soap, "fims:actualStartMark", -1, &(a->fims__StartProcessByServiceDefinedTimeType::actualStartMark), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *fims__StartProcessByServiceDefinedTimeType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_fims__StartProcessByServiceDefinedTimeType(soap, tag, this, type);
}

SOAP_FMAC3 fims__StartProcessByServiceDefinedTimeType * SOAP_FMAC4 soap_in_fims__StartProcessByServiceDefinedTimeType(struct soap *soap, const char *tag, fims__StartProcessByServiceDefinedTimeType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (fims__StartProcessByServiceDefinedTimeType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_fims__StartProcessByServiceDefinedTimeType, sizeof(fims__StartProcessByServiceDefinedTimeType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_fims__StartProcessByServiceDefinedTimeType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (fims__StartProcessByServiceDefinedTimeType *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_actualStartTime1 = 1;
	size_t soap_flag_actualStartMark1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap_flag_actualStartTime1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTotime(soap, "fims:actualStartTime", &(a->fims__StartProcessByServiceDefinedTimeType::actualStartTime), "xsd:dateTime"))
				{	soap_flag_actualStartTime1--;
					continue;
				}
			if (soap_flag_actualStartMark1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTofimstime__TimeType(soap, "fims:actualStartMark", &(a->fims__StartProcessByServiceDefinedTimeType::actualStartMark), "fimstime:TimeType"))
				{	soap_flag_actualStartMark1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (fims__StartProcessByServiceDefinedTimeType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_fims__StartProcessByServiceDefinedTimeType, 0, sizeof(fims__StartProcessByServiceDefinedTimeType), 0, soap_copy_fims__StartProcessByServiceDefinedTimeType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int fims__StartProcessByServiceDefinedTimeType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_fims__StartProcessByServiceDefinedTimeType);
	if (this->soap_out(soap, tag?tag:"fims:StartProcessByServiceDefinedTimeType", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *fims__StartProcessByServiceDefinedTimeType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_fims__StartProcessByServiceDefinedTimeType(soap, this, tag, type);
}

SOAP_FMAC3 fims__StartProcessByServiceDefinedTimeType * SOAP_FMAC4 soap_get_fims__StartProcessByServiceDefinedTimeType(struct soap *soap, fims__StartProcessByServiceDefinedTimeType *p, const char *tag, const char *type)
{
	if ((p = soap_in_fims__StartProcessByServiceDefinedTimeType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 fims__StartProcessByServiceDefinedTimeType * SOAP_FMAC2 soap_instantiate_fims__StartProcessByServiceDefinedTimeType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_fims__StartProcessByServiceDefinedTimeType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_fims__StartProcessByServiceDefinedTimeType, n, EDLProvider_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(fims__StartProcessByServiceDefinedTimeType);
		if (size)
			*size = sizeof(fims__StartProcessByServiceDefinedTimeType);
		((fims__StartProcessByServiceDefinedTimeType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(fims__StartProcessByServiceDefinedTimeType, n);
		if (size)
			*size = n * sizeof(fims__StartProcessByServiceDefinedTimeType);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((fims__StartProcessByServiceDefinedTimeType*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (fims__StartProcessByServiceDefinedTimeType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_fims__StartProcessByServiceDefinedTimeType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying fims__StartProcessByServiceDefinedTimeType %p -> %p\n", q, p));
	*(fims__StartProcessByServiceDefinedTimeType*)p = *(fims__StartProcessByServiceDefinedTimeType*)q;
}

void fims__StartProcessByTimeMarkType::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->fims__StartProcessType::soap_default(soap);
	this->fims__StartProcessByTimeMarkType::timeMark = NULL;
}

void fims__StartProcessByTimeMarkType::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTofimstime__TimeType(soap, &this->fims__StartProcessByTimeMarkType::timeMark);
	this->fims__StartProcessType::soap_serialize(soap);
#endif
}

int fims__StartProcessByTimeMarkType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_fims__StartProcessByTimeMarkType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_fims__StartProcessByTimeMarkType(struct soap *soap, const char *tag, int id, const fims__StartProcessByTimeMarkType *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_fims__StartProcessByTimeMarkType), "fims:StartProcessByTimeMarkType"))
		return soap->error;
	/* transient soap skipped */
	if (a->fims__StartProcessByTimeMarkType::timeMark)
	{	if (soap_out_PointerTofimstime__TimeType(soap, "fims:timeMark", -1, &a->fims__StartProcessByTimeMarkType::timeMark, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "fims:timeMark"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *fims__StartProcessByTimeMarkType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_fims__StartProcessByTimeMarkType(soap, tag, this, type);
}

SOAP_FMAC3 fims__StartProcessByTimeMarkType * SOAP_FMAC4 soap_in_fims__StartProcessByTimeMarkType(struct soap *soap, const char *tag, fims__StartProcessByTimeMarkType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (fims__StartProcessByTimeMarkType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_fims__StartProcessByTimeMarkType, sizeof(fims__StartProcessByTimeMarkType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_fims__StartProcessByTimeMarkType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (fims__StartProcessByTimeMarkType *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_timeMark1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap_flag_timeMark1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTofimstime__TimeType(soap, "fims:timeMark", &(a->fims__StartProcessByTimeMarkType::timeMark), "fimstime:TimeType"))
				{	soap_flag_timeMark1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (fims__StartProcessByTimeMarkType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_fims__StartProcessByTimeMarkType, 0, sizeof(fims__StartProcessByTimeMarkType), 0, soap_copy_fims__StartProcessByTimeMarkType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_timeMark1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int fims__StartProcessByTimeMarkType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_fims__StartProcessByTimeMarkType);
	if (this->soap_out(soap, tag?tag:"fims:StartProcessByTimeMarkType", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *fims__StartProcessByTimeMarkType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_fims__StartProcessByTimeMarkType(soap, this, tag, type);
}

SOAP_FMAC3 fims__StartProcessByTimeMarkType * SOAP_FMAC4 soap_get_fims__StartProcessByTimeMarkType(struct soap *soap, fims__StartProcessByTimeMarkType *p, const char *tag, const char *type)
{
	if ((p = soap_in_fims__StartProcessByTimeMarkType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 fims__StartProcessByTimeMarkType * SOAP_FMAC2 soap_instantiate_fims__StartProcessByTimeMarkType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_fims__StartProcessByTimeMarkType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_fims__StartProcessByTimeMarkType, n, EDLProvider_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(fims__StartProcessByTimeMarkType);
		if (size)
			*size = sizeof(fims__StartProcessByTimeMarkType);
		((fims__StartProcessByTimeMarkType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(fims__StartProcessByTimeMarkType, n);
		if (size)
			*size = n * sizeof(fims__StartProcessByTimeMarkType);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((fims__StartProcessByTimeMarkType*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (fims__StartProcessByTimeMarkType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_fims__StartProcessByTimeMarkType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying fims__StartProcessByTimeMarkType %p -> %p\n", q, p));
	*(fims__StartProcessByTimeMarkType*)p = *(fims__StartProcessByTimeMarkType*)q;
}

void fims__StartProcessByTimeType::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->fims__StartProcessType::soap_default(soap);
	soap_default_time(soap, &this->fims__StartProcessByTimeType::time);
}

void fims__StartProcessByTimeType::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &this->fims__StartProcessByTimeType::time, SOAP_TYPE_time);
	this->fims__StartProcessType::soap_serialize(soap);
#endif
}

int fims__StartProcessByTimeType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_fims__StartProcessByTimeType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_fims__StartProcessByTimeType(struct soap *soap, const char *tag, int id, const fims__StartProcessByTimeType *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_fims__StartProcessByTimeType), "fims:StartProcessByTimeType"))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_time(soap, "fims:time", -1, &(a->fims__StartProcessByTimeType::time), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *fims__StartProcessByTimeType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_fims__StartProcessByTimeType(soap, tag, this, type);
}

SOAP_FMAC3 fims__StartProcessByTimeType * SOAP_FMAC4 soap_in_fims__StartProcessByTimeType(struct soap *soap, const char *tag, fims__StartProcessByTimeType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (fims__StartProcessByTimeType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_fims__StartProcessByTimeType, sizeof(fims__StartProcessByTimeType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_fims__StartProcessByTimeType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (fims__StartProcessByTimeType *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_time1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap_flag_time1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_time(soap, "fims:time", &(a->fims__StartProcessByTimeType::time), "xsd:dateTime"))
				{	soap_flag_time1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (fims__StartProcessByTimeType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_fims__StartProcessByTimeType, 0, sizeof(fims__StartProcessByTimeType), 0, soap_copy_fims__StartProcessByTimeType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_time1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int fims__StartProcessByTimeType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_fims__StartProcessByTimeType);
	if (this->soap_out(soap, tag?tag:"fims:StartProcessByTimeType", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *fims__StartProcessByTimeType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_fims__StartProcessByTimeType(soap, this, tag, type);
}

SOAP_FMAC3 fims__StartProcessByTimeType * SOAP_FMAC4 soap_get_fims__StartProcessByTimeType(struct soap *soap, fims__StartProcessByTimeType *p, const char *tag, const char *type)
{
	if ((p = soap_in_fims__StartProcessByTimeType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 fims__StartProcessByTimeType * SOAP_FMAC2 soap_instantiate_fims__StartProcessByTimeType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_fims__StartProcessByTimeType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_fims__StartProcessByTimeType, n, EDLProvider_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(fims__StartProcessByTimeType);
		if (size)
			*size = sizeof(fims__StartProcessByTimeType);
		((fims__StartProcessByTimeType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(fims__StartProcessByTimeType, n);
		if (size)
			*size = n * sizeof(fims__StartProcessByTimeType);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((fims__StartProcessByTimeType*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (fims__StartProcessByTimeType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_fims__StartProcessByTimeType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying fims__StartProcessByTimeType %p -> %p\n", q, p));
	*(fims__StartProcessByTimeType*)p = *(fims__StartProcessByTimeType*)q;
}

void fims__StartProcessByNoWaitType::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->fims__StartProcessType::soap_default(soap);
	this->fims__StartProcessByNoWaitType::actualStartTime = NULL;
	this->fims__StartProcessByNoWaitType::actualStartMark = NULL;
}

void fims__StartProcessByNoWaitType::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTotime(soap, &this->fims__StartProcessByNoWaitType::actualStartTime);
	soap_serialize_PointerTofimstime__TimeType(soap, &this->fims__StartProcessByNoWaitType::actualStartMark);
	this->fims__StartProcessType::soap_serialize(soap);
#endif
}

int fims__StartProcessByNoWaitType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_fims__StartProcessByNoWaitType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_fims__StartProcessByNoWaitType(struct soap *soap, const char *tag, int id, const fims__StartProcessByNoWaitType *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_fims__StartProcessByNoWaitType), "fims:StartProcessByNoWaitType"))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_PointerTotime(soap, "fims:actualStartTime", -1, &(a->fims__StartProcessByNoWaitType::actualStartTime), ""))
		return soap->error;
	if (soap_out_PointerTofimstime__TimeType(soap, "fims:actualStartMark", -1, &(a->fims__StartProcessByNoWaitType::actualStartMark), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *fims__StartProcessByNoWaitType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_fims__StartProcessByNoWaitType(soap, tag, this, type);
}

SOAP_FMAC3 fims__StartProcessByNoWaitType * SOAP_FMAC4 soap_in_fims__StartProcessByNoWaitType(struct soap *soap, const char *tag, fims__StartProcessByNoWaitType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (fims__StartProcessByNoWaitType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_fims__StartProcessByNoWaitType, sizeof(fims__StartProcessByNoWaitType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_fims__StartProcessByNoWaitType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (fims__StartProcessByNoWaitType *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_actualStartTime1 = 1;
	size_t soap_flag_actualStartMark1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap_flag_actualStartTime1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTotime(soap, "fims:actualStartTime", &(a->fims__StartProcessByNoWaitType::actualStartTime), "xsd:dateTime"))
				{	soap_flag_actualStartTime1--;
					continue;
				}
			if (soap_flag_actualStartMark1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTofimstime__TimeType(soap, "fims:actualStartMark", &(a->fims__StartProcessByNoWaitType::actualStartMark), "fimstime:TimeType"))
				{	soap_flag_actualStartMark1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (fims__StartProcessByNoWaitType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_fims__StartProcessByNoWaitType, 0, sizeof(fims__StartProcessByNoWaitType), 0, soap_copy_fims__StartProcessByNoWaitType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int fims__StartProcessByNoWaitType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_fims__StartProcessByNoWaitType);
	if (this->soap_out(soap, tag?tag:"fims:StartProcessByNoWaitType", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *fims__StartProcessByNoWaitType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_fims__StartProcessByNoWaitType(soap, this, tag, type);
}

SOAP_FMAC3 fims__StartProcessByNoWaitType * SOAP_FMAC4 soap_get_fims__StartProcessByNoWaitType(struct soap *soap, fims__StartProcessByNoWaitType *p, const char *tag, const char *type)
{
	if ((p = soap_in_fims__StartProcessByNoWaitType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 fims__StartProcessByNoWaitType * SOAP_FMAC2 soap_instantiate_fims__StartProcessByNoWaitType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_fims__StartProcessByNoWaitType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_fims__StartProcessByNoWaitType, n, EDLProvider_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(fims__StartProcessByNoWaitType);
		if (size)
			*size = sizeof(fims__StartProcessByNoWaitType);
		((fims__StartProcessByNoWaitType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(fims__StartProcessByNoWaitType, n);
		if (size)
			*size = n * sizeof(fims__StartProcessByNoWaitType);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((fims__StartProcessByNoWaitType*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (fims__StartProcessByNoWaitType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_fims__StartProcessByNoWaitType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying fims__StartProcessByNoWaitType %p -> %p\n", q, p));
	*(fims__StartProcessByNoWaitType*)p = *(fims__StartProcessByNoWaitType*)q;
}

void fims__StartProcessType::soap_default(struct soap *soap)
{
	this->soap = soap;
	/* transient soap skipped */
}

void fims__StartProcessType::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
#endif
}

int fims__StartProcessType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_fims__StartProcessType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_fims__StartProcessType(struct soap *soap, const char *tag, int id, const fims__StartProcessType *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_fims__StartProcessType), type))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *fims__StartProcessType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_fims__StartProcessType(soap, tag, this, type);
}

SOAP_FMAC3 fims__StartProcessType * SOAP_FMAC4 soap_in_fims__StartProcessType(struct soap *soap, const char *tag, fims__StartProcessType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (fims__StartProcessType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_fims__StartProcessType, sizeof(fims__StartProcessType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_fims__StartProcessType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (fims__StartProcessType *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (fims__StartProcessType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_fims__StartProcessType, 0, sizeof(fims__StartProcessType), 0, soap_copy_fims__StartProcessType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int fims__StartProcessType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_fims__StartProcessType);
	if (this->soap_out(soap, tag?tag:"fims:StartProcessType", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *fims__StartProcessType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_fims__StartProcessType(soap, this, tag, type);
}

SOAP_FMAC3 fims__StartProcessType * SOAP_FMAC4 soap_get_fims__StartProcessType(struct soap *soap, fims__StartProcessType *p, const char *tag, const char *type)
{
	if ((p = soap_in_fims__StartProcessType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 fims__StartProcessType * SOAP_FMAC2 soap_instantiate_fims__StartProcessType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_fims__StartProcessType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_fims__StartProcessType, n, EDLProvider_fdelete);
	if (!cp)
		return NULL;
	if (type && !soap_match_tag(soap, type, "fims:StartProcessByNoWaitType"))
	{	cp->type = SOAP_TYPE_fims__StartProcessByNoWaitType;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(fims__StartProcessByNoWaitType);
			if (size)
				*size = sizeof(fims__StartProcessByNoWaitType);
			((fims__StartProcessByNoWaitType*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW_ARRAY(fims__StartProcessByNoWaitType, n);
			if (size)
				*size = n * sizeof(fims__StartProcessByNoWaitType);
			if (cp->ptr)
				for (int i = 0; i < n; i++)
					((fims__StartProcessByNoWaitType*)cp->ptr)[i].soap = soap;
		}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		if (!cp->ptr)
			soap->error = SOAP_EOM;
		return (fims__StartProcessByNoWaitType*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "fims:StartProcessByTimeType"))
	{	cp->type = SOAP_TYPE_fims__StartProcessByTimeType;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(fims__StartProcessByTimeType);
			if (size)
				*size = sizeof(fims__StartProcessByTimeType);
			((fims__StartProcessByTimeType*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW_ARRAY(fims__StartProcessByTimeType, n);
			if (size)
				*size = n * sizeof(fims__StartProcessByTimeType);
			if (cp->ptr)
				for (int i = 0; i < n; i++)
					((fims__StartProcessByTimeType*)cp->ptr)[i].soap = soap;
		}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		if (!cp->ptr)
			soap->error = SOAP_EOM;
		return (fims__StartProcessByTimeType*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "fims:StartProcessByTimeMarkType"))
	{	cp->type = SOAP_TYPE_fims__StartProcessByTimeMarkType;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(fims__StartProcessByTimeMarkType);
			if (size)
				*size = sizeof(fims__StartProcessByTimeMarkType);
			((fims__StartProcessByTimeMarkType*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW_ARRAY(fims__StartProcessByTimeMarkType, n);
			if (size)
				*size = n * sizeof(fims__StartProcessByTimeMarkType);
			if (cp->ptr)
				for (int i = 0; i < n; i++)
					((fims__StartProcessByTimeMarkType*)cp->ptr)[i].soap = soap;
		}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		if (!cp->ptr)
			soap->error = SOAP_EOM;
		return (fims__StartProcessByTimeMarkType*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "fims:StartProcessByServiceDefinedTimeType"))
	{	cp->type = SOAP_TYPE_fims__StartProcessByServiceDefinedTimeType;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(fims__StartProcessByServiceDefinedTimeType);
			if (size)
				*size = sizeof(fims__StartProcessByServiceDefinedTimeType);
			((fims__StartProcessByServiceDefinedTimeType*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW_ARRAY(fims__StartProcessByServiceDefinedTimeType, n);
			if (size)
				*size = n * sizeof(fims__StartProcessByServiceDefinedTimeType);
			if (cp->ptr)
				for (int i = 0; i < n; i++)
					((fims__StartProcessByServiceDefinedTimeType*)cp->ptr)[i].soap = soap;
		}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		if (!cp->ptr)
			soap->error = SOAP_EOM;
		return (fims__StartProcessByServiceDefinedTimeType*)cp->ptr;
	}
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(fims__StartProcessType);
		if (size)
			*size = sizeof(fims__StartProcessType);
		((fims__StartProcessType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(fims__StartProcessType, n);
		if (size)
			*size = n * sizeof(fims__StartProcessType);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((fims__StartProcessType*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (fims__StartProcessType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_fims__StartProcessType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying fims__StartProcessType %p -> %p\n", q, p));
	*(fims__StartProcessType*)p = *(fims__StartProcessType*)q;
}

void fims__HashFunctionType::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_fims__HashFunctionTypes(soap, &this->fims__HashFunctionType::__item);
	this->fims__HashFunctionType::typeLabel = NULL;
	this->fims__HashFunctionType::typeDefinition = NULL;
	this->fims__HashFunctionType::typeLink = NULL;
	this->fims__HashFunctionType::__anyAttribute = NULL;
	/* transient soap skipped */
}

void fims__HashFunctionType::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
#endif
}

int fims__HashFunctionType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_fims__HashFunctionType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_fims__HashFunctionType(struct soap *soap, const char *tag, int id, const fims__HashFunctionType *a, const char *type)
{
	if (((fims__HashFunctionType*)a)->typeLabel)
		soap_set_attr(soap, "typeLabel", soap_wchar2s(soap, ((fims__HashFunctionType*)a)->typeLabel->c_str()), 2);
	if (((fims__HashFunctionType*)a)->typeDefinition)
		soap_set_attr(soap, "typeDefinition", soap_wchar2s(soap, ((fims__HashFunctionType*)a)->typeDefinition->c_str()), 2);
	if (((fims__HashFunctionType*)a)->typeLink)
		soap_set_attr(soap, "typeLink", soap_wchar2s(soap, ((fims__HashFunctionType*)a)->typeLink->c_str()), 2);
	if (((fims__HashFunctionType*)a)->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", ((fims__HashFunctionType*)a)->__anyAttribute, 1);
	return soap_out_fims__HashFunctionTypes(soap, tag, id, &a->fims__HashFunctionType::__item, "");
}

void *fims__HashFunctionType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_fims__HashFunctionType(soap, tag, this, type);
}

SOAP_FMAC3 fims__HashFunctionType * SOAP_FMAC4 soap_in_fims__HashFunctionType(struct soap *soap, const char *tag, fims__HashFunctionType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (fims__HashFunctionType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_fims__HashFunctionType, sizeof(fims__HashFunctionType), soap->type, soap->arrayType)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_fims__HashFunctionType)
			return (fims__HashFunctionType *)a->soap_in(soap, tag, type);
	}
	{	const char *t = soap_attr_value(soap, "typeLabel", 0);
		if (t)
		{
			if (!(((fims__HashFunctionType*)a)->typeLabel = (std::wstring *)soap_malloc(soap, sizeof(std::wstring))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			wchar_t *s = NULL;
			if (soap_s2wchar(soap, t, &s, 0, -1))
				return NULL;
			if (s)
			{	((fims__HashFunctionType*)a)->typeLabel = soap_new_std__wstring(soap, -1);
				((fims__HashFunctionType*)a)->typeLabel->assign(s);
			}
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "typeDefinition", 0);
		if (t)
		{
			if (!(((fims__HashFunctionType*)a)->typeDefinition = (std::wstring *)soap_malloc(soap, sizeof(std::wstring))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			wchar_t *s = NULL;
			if (soap_s2wchar(soap, t, &s, 0, -1))
				return NULL;
			if (s)
			{	((fims__HashFunctionType*)a)->typeDefinition = soap_new_std__wstring(soap, -1);
				((fims__HashFunctionType*)a)->typeDefinition->assign(s);
			}
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "typeLink", 0);
		if (t)
		{
			if (!(((fims__HashFunctionType*)a)->typeLink = (std::wstring *)soap_malloc(soap, sizeof(std::wstring))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			wchar_t *s = NULL;
			if (soap_s2wchar(soap, t, &s, 0, -1))
				return NULL;
			if (s)
			{	((fims__HashFunctionType*)a)->typeLink = soap_new_std__wstring(soap, -1);
				((fims__HashFunctionType*)a)->typeLink->assign(s);
			}
		}
		else if (soap->error)
			return NULL;
	}
	if (soap_s2string(soap, soap_attr_value(soap, "-anyAttribute", 0), &((fims__HashFunctionType*)a)->__anyAttribute, 0, -1))
		return NULL;
	if (!soap_in_fims__HashFunctionTypes(soap, tag, &(a->fims__HashFunctionType::__item), "fims:HashFunctionType"))
		return NULL;
	return a;
}

int fims__HashFunctionType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_fims__HashFunctionType);
	if (this->soap_out(soap, tag?tag:"fims:HashFunctionType", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *fims__HashFunctionType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_fims__HashFunctionType(soap, this, tag, type);
}

SOAP_FMAC3 fims__HashFunctionType * SOAP_FMAC4 soap_get_fims__HashFunctionType(struct soap *soap, fims__HashFunctionType *p, const char *tag, const char *type)
{
	if ((p = soap_in_fims__HashFunctionType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 fims__HashFunctionType * SOAP_FMAC2 soap_instantiate_fims__HashFunctionType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_fims__HashFunctionType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_fims__HashFunctionType, n, EDLProvider_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(fims__HashFunctionType);
		if (size)
			*size = sizeof(fims__HashFunctionType);
		((fims__HashFunctionType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(fims__HashFunctionType, n);
		if (size)
			*size = n * sizeof(fims__HashFunctionType);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((fims__HashFunctionType*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (fims__HashFunctionType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_fims__HashFunctionType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying fims__HashFunctionType %p -> %p\n", q, p));
	*(fims__HashFunctionType*)p = *(fims__HashFunctionType*)q;
}

void fims__StorageType::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_fims__StorageTypes(soap, &this->fims__StorageType::__item);
	this->fims__StorageType::typeLabel = NULL;
	this->fims__StorageType::typeDefinition = NULL;
	this->fims__StorageType::typeLink = NULL;
	this->fims__StorageType::__anyAttribute = NULL;
	/* transient soap skipped */
}

void fims__StorageType::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
#endif
}

int fims__StorageType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_fims__StorageType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_fims__StorageType(struct soap *soap, const char *tag, int id, const fims__StorageType *a, const char *type)
{
	if (((fims__StorageType*)a)->typeLabel)
		soap_set_attr(soap, "typeLabel", soap_wchar2s(soap, ((fims__StorageType*)a)->typeLabel->c_str()), 2);
	if (((fims__StorageType*)a)->typeDefinition)
		soap_set_attr(soap, "typeDefinition", soap_wchar2s(soap, ((fims__StorageType*)a)->typeDefinition->c_str()), 2);
	if (((fims__StorageType*)a)->typeLink)
		soap_set_attr(soap, "typeLink", soap_wchar2s(soap, ((fims__StorageType*)a)->typeLink->c_str()), 2);
	if (((fims__StorageType*)a)->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", ((fims__StorageType*)a)->__anyAttribute, 1);
	return soap_out_fims__StorageTypes(soap, tag, id, &a->fims__StorageType::__item, "");
}

void *fims__StorageType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_fims__StorageType(soap, tag, this, type);
}

SOAP_FMAC3 fims__StorageType * SOAP_FMAC4 soap_in_fims__StorageType(struct soap *soap, const char *tag, fims__StorageType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (fims__StorageType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_fims__StorageType, sizeof(fims__StorageType), soap->type, soap->arrayType)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_fims__StorageType)
			return (fims__StorageType *)a->soap_in(soap, tag, type);
	}
	{	const char *t = soap_attr_value(soap, "typeLabel", 0);
		if (t)
		{
			if (!(((fims__StorageType*)a)->typeLabel = (std::wstring *)soap_malloc(soap, sizeof(std::wstring))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			wchar_t *s = NULL;
			if (soap_s2wchar(soap, t, &s, 0, -1))
				return NULL;
			if (s)
			{	((fims__StorageType*)a)->typeLabel = soap_new_std__wstring(soap, -1);
				((fims__StorageType*)a)->typeLabel->assign(s);
			}
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "typeDefinition", 0);
		if (t)
		{
			if (!(((fims__StorageType*)a)->typeDefinition = (std::wstring *)soap_malloc(soap, sizeof(std::wstring))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			wchar_t *s = NULL;
			if (soap_s2wchar(soap, t, &s, 0, -1))
				return NULL;
			if (s)
			{	((fims__StorageType*)a)->typeDefinition = soap_new_std__wstring(soap, -1);
				((fims__StorageType*)a)->typeDefinition->assign(s);
			}
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "typeLink", 0);
		if (t)
		{
			if (!(((fims__StorageType*)a)->typeLink = (std::wstring *)soap_malloc(soap, sizeof(std::wstring))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			wchar_t *s = NULL;
			if (soap_s2wchar(soap, t, &s, 0, -1))
				return NULL;
			if (s)
			{	((fims__StorageType*)a)->typeLink = soap_new_std__wstring(soap, -1);
				((fims__StorageType*)a)->typeLink->assign(s);
			}
		}
		else if (soap->error)
			return NULL;
	}
	if (soap_s2string(soap, soap_attr_value(soap, "-anyAttribute", 0), &((fims__StorageType*)a)->__anyAttribute, 0, -1))
		return NULL;
	if (!soap_in_fims__StorageTypes(soap, tag, &(a->fims__StorageType::__item), "fims:StorageType"))
		return NULL;
	return a;
}

int fims__StorageType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_fims__StorageType);
	if (this->soap_out(soap, tag?tag:"fims:StorageType", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *fims__StorageType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_fims__StorageType(soap, this, tag, type);
}

SOAP_FMAC3 fims__StorageType * SOAP_FMAC4 soap_get_fims__StorageType(struct soap *soap, fims__StorageType *p, const char *tag, const char *type)
{
	if ((p = soap_in_fims__StorageType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 fims__StorageType * SOAP_FMAC2 soap_instantiate_fims__StorageType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_fims__StorageType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_fims__StorageType, n, EDLProvider_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(fims__StorageType);
		if (size)
			*size = sizeof(fims__StorageType);
		((fims__StorageType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(fims__StorageType, n);
		if (size)
			*size = n * sizeof(fims__StorageType);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((fims__StorageType*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (fims__StorageType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_fims__StorageType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying fims__StorageType %p -> %p\n", q, p));
	*(fims__StorageType*)p = *(fims__StorageType*)q;
}

void fims__ProcessedInfoByFramesType::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->fims__ProcessedInfoType::soap_default(soap);
	soap_default_xsd__nonNegativeInteger(soap, &this->fims__ProcessedInfoByFramesType::processedFramesCount);
}

void fims__ProcessedInfoByFramesType::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &this->fims__ProcessedInfoByFramesType::processedFramesCount, SOAP_TYPE_xsd__nonNegativeInteger);
	soap_serialize_xsd__nonNegativeInteger(soap, &this->fims__ProcessedInfoByFramesType::processedFramesCount);
	this->fims__ProcessedInfoType::soap_serialize(soap);
#endif
}

int fims__ProcessedInfoByFramesType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_fims__ProcessedInfoByFramesType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_fims__ProcessedInfoByFramesType(struct soap *soap, const char *tag, int id, const fims__ProcessedInfoByFramesType *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_fims__ProcessedInfoByFramesType), "fims:ProcessedInfoByFramesType"))
		return soap->error;
	if (soap_out_xsd__nonNegativeInteger(soap, "fims:percentageProcessedCompleted", -1, &(a->fims__ProcessedInfoType::percentageProcessedCompleted), ""))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_xsd__nonNegativeInteger(soap, "fims:processedFramesCount", -1, &(a->fims__ProcessedInfoByFramesType::processedFramesCount), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *fims__ProcessedInfoByFramesType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_fims__ProcessedInfoByFramesType(soap, tag, this, type);
}

SOAP_FMAC3 fims__ProcessedInfoByFramesType * SOAP_FMAC4 soap_in_fims__ProcessedInfoByFramesType(struct soap *soap, const char *tag, fims__ProcessedInfoByFramesType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (fims__ProcessedInfoByFramesType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_fims__ProcessedInfoByFramesType, sizeof(fims__ProcessedInfoByFramesType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_fims__ProcessedInfoByFramesType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (fims__ProcessedInfoByFramesType *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_percentageProcessedCompleted2 = 1;
	size_t soap_flag_processedFramesCount1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_percentageProcessedCompleted2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__nonNegativeInteger(soap, "fims:percentageProcessedCompleted", &(a->fims__ProcessedInfoType::percentageProcessedCompleted), "xsd:nonNegativeInteger"))
				{	soap_flag_percentageProcessedCompleted2--;
					continue;
				}
			/* transient soap skipped */
			if (soap_flag_processedFramesCount1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__nonNegativeInteger(soap, "fims:processedFramesCount", &(a->fims__ProcessedInfoByFramesType::processedFramesCount), "xsd:nonNegativeInteger"))
				{	soap_flag_processedFramesCount1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (fims__ProcessedInfoByFramesType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_fims__ProcessedInfoByFramesType, 0, sizeof(fims__ProcessedInfoByFramesType), 0, soap_copy_fims__ProcessedInfoByFramesType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_percentageProcessedCompleted2 > 0 || soap_flag_processedFramesCount1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int fims__ProcessedInfoByFramesType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_fims__ProcessedInfoByFramesType);
	if (this->soap_out(soap, tag?tag:"fims:ProcessedInfoByFramesType", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *fims__ProcessedInfoByFramesType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_fims__ProcessedInfoByFramesType(soap, this, tag, type);
}

SOAP_FMAC3 fims__ProcessedInfoByFramesType * SOAP_FMAC4 soap_get_fims__ProcessedInfoByFramesType(struct soap *soap, fims__ProcessedInfoByFramesType *p, const char *tag, const char *type)
{
	if ((p = soap_in_fims__ProcessedInfoByFramesType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 fims__ProcessedInfoByFramesType * SOAP_FMAC2 soap_instantiate_fims__ProcessedInfoByFramesType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_fims__ProcessedInfoByFramesType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_fims__ProcessedInfoByFramesType, n, EDLProvider_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(fims__ProcessedInfoByFramesType);
		if (size)
			*size = sizeof(fims__ProcessedInfoByFramesType);
		((fims__ProcessedInfoByFramesType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(fims__ProcessedInfoByFramesType, n);
		if (size)
			*size = n * sizeof(fims__ProcessedInfoByFramesType);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((fims__ProcessedInfoByFramesType*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (fims__ProcessedInfoByFramesType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_fims__ProcessedInfoByFramesType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying fims__ProcessedInfoByFramesType %p -> %p\n", q, p));
	*(fims__ProcessedInfoByFramesType*)p = *(fims__ProcessedInfoByFramesType*)q;
}

void fims__ProcessedInfoByBytesType::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->fims__ProcessedInfoType::soap_default(soap);
	soap_default_unsignedLONG64(soap, &this->fims__ProcessedInfoByBytesType::processedBytesCount);
}

void fims__ProcessedInfoByBytesType::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &this->fims__ProcessedInfoByBytesType::processedBytesCount, SOAP_TYPE_unsignedLONG64);
	this->fims__ProcessedInfoType::soap_serialize(soap);
#endif
}

int fims__ProcessedInfoByBytesType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_fims__ProcessedInfoByBytesType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_fims__ProcessedInfoByBytesType(struct soap *soap, const char *tag, int id, const fims__ProcessedInfoByBytesType *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_fims__ProcessedInfoByBytesType), "fims:ProcessedInfoByBytesType"))
		return soap->error;
	if (soap_out_xsd__nonNegativeInteger(soap, "fims:percentageProcessedCompleted", -1, &(a->fims__ProcessedInfoType::percentageProcessedCompleted), ""))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_unsignedLONG64(soap, "fims:processedBytesCount", -1, &(a->fims__ProcessedInfoByBytesType::processedBytesCount), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *fims__ProcessedInfoByBytesType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_fims__ProcessedInfoByBytesType(soap, tag, this, type);
}

SOAP_FMAC3 fims__ProcessedInfoByBytesType * SOAP_FMAC4 soap_in_fims__ProcessedInfoByBytesType(struct soap *soap, const char *tag, fims__ProcessedInfoByBytesType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (fims__ProcessedInfoByBytesType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_fims__ProcessedInfoByBytesType, sizeof(fims__ProcessedInfoByBytesType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_fims__ProcessedInfoByBytesType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (fims__ProcessedInfoByBytesType *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_percentageProcessedCompleted2 = 1;
	size_t soap_flag_processedBytesCount1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_percentageProcessedCompleted2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__nonNegativeInteger(soap, "fims:percentageProcessedCompleted", &(a->fims__ProcessedInfoType::percentageProcessedCompleted), "xsd:nonNegativeInteger"))
				{	soap_flag_percentageProcessedCompleted2--;
					continue;
				}
			/* transient soap skipped */
			if (soap_flag_processedBytesCount1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_unsignedLONG64(soap, "fims:processedBytesCount", &(a->fims__ProcessedInfoByBytesType::processedBytesCount), "xsd:unsignedLong"))
				{	soap_flag_processedBytesCount1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (fims__ProcessedInfoByBytesType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_fims__ProcessedInfoByBytesType, 0, sizeof(fims__ProcessedInfoByBytesType), 0, soap_copy_fims__ProcessedInfoByBytesType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_percentageProcessedCompleted2 > 0 || soap_flag_processedBytesCount1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int fims__ProcessedInfoByBytesType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_fims__ProcessedInfoByBytesType);
	if (this->soap_out(soap, tag?tag:"fims:ProcessedInfoByBytesType", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *fims__ProcessedInfoByBytesType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_fims__ProcessedInfoByBytesType(soap, this, tag, type);
}

SOAP_FMAC3 fims__ProcessedInfoByBytesType * SOAP_FMAC4 soap_get_fims__ProcessedInfoByBytesType(struct soap *soap, fims__ProcessedInfoByBytesType *p, const char *tag, const char *type)
{
	if ((p = soap_in_fims__ProcessedInfoByBytesType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 fims__ProcessedInfoByBytesType * SOAP_FMAC2 soap_instantiate_fims__ProcessedInfoByBytesType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_fims__ProcessedInfoByBytesType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_fims__ProcessedInfoByBytesType, n, EDLProvider_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(fims__ProcessedInfoByBytesType);
		if (size)
			*size = sizeof(fims__ProcessedInfoByBytesType);
		((fims__ProcessedInfoByBytesType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(fims__ProcessedInfoByBytesType, n);
		if (size)
			*size = n * sizeof(fims__ProcessedInfoByBytesType);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((fims__ProcessedInfoByBytesType*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (fims__ProcessedInfoByBytesType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_fims__ProcessedInfoByBytesType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying fims__ProcessedInfoByBytesType %p -> %p\n", q, p));
	*(fims__ProcessedInfoByBytesType*)p = *(fims__ProcessedInfoByBytesType*)q;
}

void fims__ProcessedInfoType::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_xsd__nonNegativeInteger(soap, &this->fims__ProcessedInfoType::percentageProcessedCompleted);
	/* transient soap skipped */
}

void fims__ProcessedInfoType::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &this->fims__ProcessedInfoType::percentageProcessedCompleted, SOAP_TYPE_xsd__nonNegativeInteger);
	soap_serialize_xsd__nonNegativeInteger(soap, &this->fims__ProcessedInfoType::percentageProcessedCompleted);
	/* transient soap skipped */
#endif
}

int fims__ProcessedInfoType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_fims__ProcessedInfoType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_fims__ProcessedInfoType(struct soap *soap, const char *tag, int id, const fims__ProcessedInfoType *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_fims__ProcessedInfoType), type))
		return soap->error;
	if (soap_out_xsd__nonNegativeInteger(soap, "fims:percentageProcessedCompleted", -1, &(a->fims__ProcessedInfoType::percentageProcessedCompleted), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *fims__ProcessedInfoType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_fims__ProcessedInfoType(soap, tag, this, type);
}

SOAP_FMAC3 fims__ProcessedInfoType * SOAP_FMAC4 soap_in_fims__ProcessedInfoType(struct soap *soap, const char *tag, fims__ProcessedInfoType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (fims__ProcessedInfoType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_fims__ProcessedInfoType, sizeof(fims__ProcessedInfoType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_fims__ProcessedInfoType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (fims__ProcessedInfoType *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_percentageProcessedCompleted1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_percentageProcessedCompleted1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__nonNegativeInteger(soap, "fims:percentageProcessedCompleted", &(a->fims__ProcessedInfoType::percentageProcessedCompleted), "xsd:nonNegativeInteger"))
				{	soap_flag_percentageProcessedCompleted1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (fims__ProcessedInfoType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_fims__ProcessedInfoType, 0, sizeof(fims__ProcessedInfoType), 0, soap_copy_fims__ProcessedInfoType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_percentageProcessedCompleted1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int fims__ProcessedInfoType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_fims__ProcessedInfoType);
	if (this->soap_out(soap, tag?tag:"fims:ProcessedInfoType", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *fims__ProcessedInfoType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_fims__ProcessedInfoType(soap, this, tag, type);
}

SOAP_FMAC3 fims__ProcessedInfoType * SOAP_FMAC4 soap_get_fims__ProcessedInfoType(struct soap *soap, fims__ProcessedInfoType *p, const char *tag, const char *type)
{
	if ((p = soap_in_fims__ProcessedInfoType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 fims__ProcessedInfoType * SOAP_FMAC2 soap_instantiate_fims__ProcessedInfoType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_fims__ProcessedInfoType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_fims__ProcessedInfoType, n, EDLProvider_fdelete);
	if (!cp)
		return NULL;
	if (type && !soap_match_tag(soap, type, "fims:ProcessedInfoByBytesType"))
	{	cp->type = SOAP_TYPE_fims__ProcessedInfoByBytesType;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(fims__ProcessedInfoByBytesType);
			if (size)
				*size = sizeof(fims__ProcessedInfoByBytesType);
			((fims__ProcessedInfoByBytesType*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW_ARRAY(fims__ProcessedInfoByBytesType, n);
			if (size)
				*size = n * sizeof(fims__ProcessedInfoByBytesType);
			if (cp->ptr)
				for (int i = 0; i < n; i++)
					((fims__ProcessedInfoByBytesType*)cp->ptr)[i].soap = soap;
		}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		if (!cp->ptr)
			soap->error = SOAP_EOM;
		return (fims__ProcessedInfoByBytesType*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "fims:ProcessedInfoByFramesType"))
	{	cp->type = SOAP_TYPE_fims__ProcessedInfoByFramesType;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(fims__ProcessedInfoByFramesType);
			if (size)
				*size = sizeof(fims__ProcessedInfoByFramesType);
			((fims__ProcessedInfoByFramesType*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW_ARRAY(fims__ProcessedInfoByFramesType, n);
			if (size)
				*size = n * sizeof(fims__ProcessedInfoByFramesType);
			if (cp->ptr)
				for (int i = 0; i < n; i++)
					((fims__ProcessedInfoByFramesType*)cp->ptr)[i].soap = soap;
		}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		if (!cp->ptr)
			soap->error = SOAP_EOM;
		return (fims__ProcessedInfoByFramesType*)cp->ptr;
	}
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(fims__ProcessedInfoType);
		if (size)
			*size = sizeof(fims__ProcessedInfoType);
		((fims__ProcessedInfoType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(fims__ProcessedInfoType, n);
		if (size)
			*size = n * sizeof(fims__ProcessedInfoType);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((fims__ProcessedInfoType*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (fims__ProcessedInfoType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_fims__ProcessedInfoType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying fims__ProcessedInfoType %p -> %p\n", q, p));
	*(fims__ProcessedInfoType*)p = *(fims__ProcessedInfoType*)q;
}

void fims__HashType::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->fims__HashType::hashFunction = NULL;
	this->fims__HashType::value.xsd__hexBinary::soap_default(soap);
	/* transient soap skipped */
}

void fims__HashType::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTofims__HashFunctionType(soap, &this->fims__HashType::hashFunction);
	this->fims__HashType::value.soap_serialize(soap);
	/* transient soap skipped */
#endif
}

int fims__HashType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_fims__HashType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_fims__HashType(struct soap *soap, const char *tag, int id, const fims__HashType *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_fims__HashType), type))
		return soap->error;
	if (a->fims__HashType::hashFunction)
	{	if (soap_out_PointerTofims__HashFunctionType(soap, "fims:hashFunction", -1, &a->fims__HashType::hashFunction, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "fims:hashFunction"))
		return soap->error;
	if ((a->fims__HashType::value).soap_out(soap, "fims:value", -1, ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *fims__HashType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_fims__HashType(soap, tag, this, type);
}

SOAP_FMAC3 fims__HashType * SOAP_FMAC4 soap_in_fims__HashType(struct soap *soap, const char *tag, fims__HashType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (fims__HashType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_fims__HashType, sizeof(fims__HashType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_fims__HashType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (fims__HashType *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_hashFunction1 = 1;
	size_t soap_flag_value1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_hashFunction1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTofims__HashFunctionType(soap, "fims:hashFunction", &(a->fims__HashType::hashFunction), "fims:HashFunctionType"))
				{	soap_flag_hashFunction1--;
					continue;
				}
			if (soap_flag_value1 && soap->error == SOAP_TAG_MISMATCH)
				if ((a->fims__HashType::value).soap_in(soap, "fims:value", "xsd:hexBinary"))
				{	soap_flag_value1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (fims__HashType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_fims__HashType, 0, sizeof(fims__HashType), 0, soap_copy_fims__HashType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_hashFunction1 > 0 || soap_flag_value1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int fims__HashType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_fims__HashType);
	if (this->soap_out(soap, tag?tag:"fims:HashType", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *fims__HashType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_fims__HashType(soap, this, tag, type);
}

SOAP_FMAC3 fims__HashType * SOAP_FMAC4 soap_get_fims__HashType(struct soap *soap, fims__HashType *p, const char *tag, const char *type)
{
	if ((p = soap_in_fims__HashType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 fims__HashType * SOAP_FMAC2 soap_instantiate_fims__HashType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_fims__HashType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_fims__HashType, n, EDLProvider_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(fims__HashType);
		if (size)
			*size = sizeof(fims__HashType);
		((fims__HashType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(fims__HashType, n);
		if (size)
			*size = n * sizeof(fims__HashType);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((fims__HashType*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (fims__HashType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_fims__HashType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying fims__HashType %p -> %p\n", q, p));
	*(fims__HashType*)p = *(fims__HashType*)q;
}

void fims__RationalType::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_LONG64(soap, &this->fims__RationalType::__item);
	soap_default_xsd__positiveInteger(soap, &this->fims__RationalType::numerator);
	soap_default_xsd__positiveInteger(soap, &this->fims__RationalType::denominator);
	/* transient soap skipped */
}

void fims__RationalType::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
#endif
}

int fims__RationalType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_fims__RationalType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_fims__RationalType(struct soap *soap, const char *tag, int id, const fims__RationalType *a, const char *type)
{
	soap_set_attr(soap, "numerator", soap_wchar2s(soap, ((fims__RationalType*)a)->numerator.c_str()), 2);
	soap_set_attr(soap, "denominator", soap_wchar2s(soap, ((fims__RationalType*)a)->denominator.c_str()), 2);
	return soap_out_LONG64(soap, tag, id, &a->fims__RationalType::__item, "");
}

void *fims__RationalType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_fims__RationalType(soap, tag, this, type);
}

SOAP_FMAC3 fims__RationalType * SOAP_FMAC4 soap_in_fims__RationalType(struct soap *soap, const char *tag, fims__RationalType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (fims__RationalType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_fims__RationalType, sizeof(fims__RationalType), soap->type, soap->arrayType)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_fims__RationalType)
			return (fims__RationalType *)a->soap_in(soap, tag, type);
	}
	{	const char *t = soap_attr_value(soap, "numerator", 1);
		if (t)
		{	wchar_t *s;
			if (soap_s2wchar(soap, t, &s, 0, -1))
				return NULL;
			((fims__RationalType*)a)->numerator.assign(s);
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "denominator", 1);
		if (t)
		{	wchar_t *s;
			if (soap_s2wchar(soap, t, &s, 0, -1))
				return NULL;
			((fims__RationalType*)a)->denominator.assign(s);
		}
		else if (soap->error)
			return NULL;
	}
	if (!soap_in_LONG64(soap, tag, &(a->fims__RationalType::__item), "fims:RationalType"))
		return NULL;
	return a;
}

int fims__RationalType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_fims__RationalType);
	if (this->soap_out(soap, tag?tag:"fims:RationalType", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *fims__RationalType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_fims__RationalType(soap, this, tag, type);
}

SOAP_FMAC3 fims__RationalType * SOAP_FMAC4 soap_get_fims__RationalType(struct soap *soap, fims__RationalType *p, const char *tag, const char *type)
{
	if ((p = soap_in_fims__RationalType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 fims__RationalType * SOAP_FMAC2 soap_instantiate_fims__RationalType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_fims__RationalType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_fims__RationalType, n, EDLProvider_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(fims__RationalType);
		if (size)
			*size = sizeof(fims__RationalType);
		((fims__RationalType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(fims__RationalType, n);
		if (size)
			*size = n * sizeof(fims__RationalType);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((fims__RationalType*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (fims__RationalType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_fims__RationalType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying fims__RationalType %p -> %p\n", q, p));
	*(fims__RationalType*)p = *(fims__RationalType*)q;
}

void fims__LengthType::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_xsd__nonNegativeInteger(soap, &this->fims__LengthType::__item);
	this->fims__LengthType::unit = NULL;
	/* transient soap skipped */
}

void fims__LengthType::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &this->fims__LengthType::__item, SOAP_TYPE_xsd__nonNegativeInteger);
	soap_serialize_xsd__nonNegativeInteger(soap, &this->fims__LengthType::__item);
	/* transient soap skipped */
#endif
}

int fims__LengthType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_fims__LengthType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_fims__LengthType(struct soap *soap, const char *tag, int id, const fims__LengthType *a, const char *type)
{
	if (((fims__LengthType*)a)->unit)
		soap_set_attr(soap, "unit", soap_wchar2s(soap, ((fims__LengthType*)a)->unit->c_str()), 2);
	return soap_out_xsd__nonNegativeInteger(soap, tag, id, &a->fims__LengthType::__item, "");
}

void *fims__LengthType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_fims__LengthType(soap, tag, this, type);
}

SOAP_FMAC3 fims__LengthType * SOAP_FMAC4 soap_in_fims__LengthType(struct soap *soap, const char *tag, fims__LengthType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (fims__LengthType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_fims__LengthType, sizeof(fims__LengthType), soap->type, soap->arrayType)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_fims__LengthType)
			return (fims__LengthType *)a->soap_in(soap, tag, type);
	}
	{	const char *t = soap_attr_value(soap, "unit", 0);
		if (t)
		{
			if (!(((fims__LengthType*)a)->unit = (std::wstring *)soap_malloc(soap, sizeof(std::wstring))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			wchar_t *s = NULL;
			if (soap_s2wchar(soap, t, &s, 0, -1))
				return NULL;
			if (s)
			{	((fims__LengthType*)a)->unit = soap_new_std__wstring(soap, -1);
				((fims__LengthType*)a)->unit->assign(s);
			}
		}
		else if (soap->error)
			return NULL;
	}
	if (!soap_in_xsd__nonNegativeInteger(soap, tag, &(a->fims__LengthType::__item), "fims:LengthType"))
		return NULL;
	return a;
}

int fims__LengthType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_fims__LengthType);
	if (this->soap_out(soap, tag?tag:"fims:LengthType", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *fims__LengthType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_fims__LengthType(soap, this, tag, type);
}

SOAP_FMAC3 fims__LengthType * SOAP_FMAC4 soap_get_fims__LengthType(struct soap *soap, fims__LengthType *p, const char *tag, const char *type)
{
	if ((p = soap_in_fims__LengthType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 fims__LengthType * SOAP_FMAC2 soap_instantiate_fims__LengthType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_fims__LengthType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_fims__LengthType, n, EDLProvider_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(fims__LengthType);
		if (size)
			*size = sizeof(fims__LengthType);
		((fims__LengthType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(fims__LengthType, n);
		if (size)
			*size = n * sizeof(fims__LengthType);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((fims__LengthType*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (fims__LengthType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_fims__LengthType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying fims__LengthType %p -> %p\n", q, p));
	*(fims__LengthType*)p = *(fims__LengthType*)q;
}

void fims__TechnicalAttributeType::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__wstring(soap, &this->fims__TechnicalAttributeType::__item);
	this->fims__TechnicalAttributeType::typeLabel = NULL;
	this->fims__TechnicalAttributeType::typeDefinition = NULL;
	this->fims__TechnicalAttributeType::typeLink = NULL;
	this->fims__TechnicalAttributeType::formatLabel = NULL;
	this->fims__TechnicalAttributeType::formatDefinition = NULL;
	this->fims__TechnicalAttributeType::formatLink = NULL;
	/* transient soap skipped */
}

void fims__TechnicalAttributeType::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &this->fims__TechnicalAttributeType::__item, SOAP_TYPE_std__wstring);
	soap_serialize_std__wstring(soap, &this->fims__TechnicalAttributeType::__item);
	/* transient soap skipped */
#endif
}

int fims__TechnicalAttributeType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_fims__TechnicalAttributeType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_fims__TechnicalAttributeType(struct soap *soap, const char *tag, int id, const fims__TechnicalAttributeType *a, const char *type)
{
	if (((fims__TechnicalAttributeType*)a)->typeLabel)
		soap_set_attr(soap, "typeLabel", soap_wchar2s(soap, ((fims__TechnicalAttributeType*)a)->typeLabel->c_str()), 2);
	if (((fims__TechnicalAttributeType*)a)->typeDefinition)
		soap_set_attr(soap, "typeDefinition", soap_wchar2s(soap, ((fims__TechnicalAttributeType*)a)->typeDefinition->c_str()), 2);
	if (((fims__TechnicalAttributeType*)a)->typeLink)
		soap_set_attr(soap, "typeLink", soap_wchar2s(soap, ((fims__TechnicalAttributeType*)a)->typeLink->c_str()), 2);
	if (((fims__TechnicalAttributeType*)a)->formatLabel)
		soap_set_attr(soap, "formatLabel", soap_wchar2s(soap, ((fims__TechnicalAttributeType*)a)->formatLabel->c_str()), 2);
	if (((fims__TechnicalAttributeType*)a)->formatDefinition)
		soap_set_attr(soap, "formatDefinition", soap_wchar2s(soap, ((fims__TechnicalAttributeType*)a)->formatDefinition->c_str()), 2);
	if (((fims__TechnicalAttributeType*)a)->formatLink)
		soap_set_attr(soap, "formatLink", soap_wchar2s(soap, ((fims__TechnicalAttributeType*)a)->formatLink->c_str()), 2);
	return soap_out_std__wstring(soap, tag, id, &a->fims__TechnicalAttributeType::__item, "");
}

void *fims__TechnicalAttributeType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_fims__TechnicalAttributeType(soap, tag, this, type);
}

SOAP_FMAC3 fims__TechnicalAttributeType * SOAP_FMAC4 soap_in_fims__TechnicalAttributeType(struct soap *soap, const char *tag, fims__TechnicalAttributeType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (fims__TechnicalAttributeType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_fims__TechnicalAttributeType, sizeof(fims__TechnicalAttributeType), soap->type, soap->arrayType)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_fims__TechnicalAttributeType)
			return (fims__TechnicalAttributeType *)a->soap_in(soap, tag, type);
	}
	{	const char *t = soap_attr_value(soap, "typeLabel", 0);
		if (t)
		{
			if (!(((fims__TechnicalAttributeType*)a)->typeLabel = (std::wstring *)soap_malloc(soap, sizeof(std::wstring))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			wchar_t *s = NULL;
			if (soap_s2wchar(soap, t, &s, 0, -1))
				return NULL;
			if (s)
			{	((fims__TechnicalAttributeType*)a)->typeLabel = soap_new_std__wstring(soap, -1);
				((fims__TechnicalAttributeType*)a)->typeLabel->assign(s);
			}
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "typeDefinition", 0);
		if (t)
		{
			if (!(((fims__TechnicalAttributeType*)a)->typeDefinition = (std::wstring *)soap_malloc(soap, sizeof(std::wstring))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			wchar_t *s = NULL;
			if (soap_s2wchar(soap, t, &s, 0, -1))
				return NULL;
			if (s)
			{	((fims__TechnicalAttributeType*)a)->typeDefinition = soap_new_std__wstring(soap, -1);
				((fims__TechnicalAttributeType*)a)->typeDefinition->assign(s);
			}
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "typeLink", 0);
		if (t)
		{
			if (!(((fims__TechnicalAttributeType*)a)->typeLink = (std::wstring *)soap_malloc(soap, sizeof(std::wstring))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			wchar_t *s = NULL;
			if (soap_s2wchar(soap, t, &s, 0, -1))
				return NULL;
			if (s)
			{	((fims__TechnicalAttributeType*)a)->typeLink = soap_new_std__wstring(soap, -1);
				((fims__TechnicalAttributeType*)a)->typeLink->assign(s);
			}
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "formatLabel", 0);
		if (t)
		{
			if (!(((fims__TechnicalAttributeType*)a)->formatLabel = (std::wstring *)soap_malloc(soap, sizeof(std::wstring))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			wchar_t *s = NULL;
			if (soap_s2wchar(soap, t, &s, 0, -1))
				return NULL;
			if (s)
			{	((fims__TechnicalAttributeType*)a)->formatLabel = soap_new_std__wstring(soap, -1);
				((fims__TechnicalAttributeType*)a)->formatLabel->assign(s);
			}
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "formatDefinition", 0);
		if (t)
		{
			if (!(((fims__TechnicalAttributeType*)a)->formatDefinition = (std::wstring *)soap_malloc(soap, sizeof(std::wstring))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			wchar_t *s = NULL;
			if (soap_s2wchar(soap, t, &s, 0, -1))
				return NULL;
			if (s)
			{	((fims__TechnicalAttributeType*)a)->formatDefinition = soap_new_std__wstring(soap, -1);
				((fims__TechnicalAttributeType*)a)->formatDefinition->assign(s);
			}
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "formatLink", 0);
		if (t)
		{
			if (!(((fims__TechnicalAttributeType*)a)->formatLink = (std::wstring *)soap_malloc(soap, sizeof(std::wstring))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			wchar_t *s = NULL;
			if (soap_s2wchar(soap, t, &s, 0, -1))
				return NULL;
			if (s)
			{	((fims__TechnicalAttributeType*)a)->formatLink = soap_new_std__wstring(soap, -1);
				((fims__TechnicalAttributeType*)a)->formatLink->assign(s);
			}
		}
		else if (soap->error)
			return NULL;
	}
	if (!soap_in_std__wstring(soap, tag, &(a->fims__TechnicalAttributeType::__item), "fims:TechnicalAttributeType"))
		return NULL;
	return a;
}

int fims__TechnicalAttributeType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_fims__TechnicalAttributeType);
	if (this->soap_out(soap, tag?tag:"fims:TechnicalAttributeType", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *fims__TechnicalAttributeType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_fims__TechnicalAttributeType(soap, this, tag, type);
}

SOAP_FMAC3 fims__TechnicalAttributeType * SOAP_FMAC4 soap_get_fims__TechnicalAttributeType(struct soap *soap, fims__TechnicalAttributeType *p, const char *tag, const char *type)
{
	if ((p = soap_in_fims__TechnicalAttributeType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 fims__TechnicalAttributeType * SOAP_FMAC2 soap_instantiate_fims__TechnicalAttributeType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_fims__TechnicalAttributeType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_fims__TechnicalAttributeType, n, EDLProvider_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(fims__TechnicalAttributeType);
		if (size)
			*size = sizeof(fims__TechnicalAttributeType);
		((fims__TechnicalAttributeType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(fims__TechnicalAttributeType, n);
		if (size)
			*size = n * sizeof(fims__TechnicalAttributeType);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((fims__TechnicalAttributeType*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (fims__TechnicalAttributeType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_fims__TechnicalAttributeType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying fims__TechnicalAttributeType %p -> %p\n", q, p));
	*(fims__TechnicalAttributeType*)p = *(fims__TechnicalAttributeType*)q;
}

void fims__TransformAtomType::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->fims__TransformAtomType::videoFormat = NULL;
	this->fims__TransformAtomType::audioFormat = NULL;
	this->fims__TransformAtomType::containerFormat = NULL;
	this->fims__TransformAtomType::ExtensionGroup = NULL;
	this->fims__TransformAtomType::ExtensionAttributes = NULL;
	/* transient soap skipped */
}

void fims__TransformAtomType::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTofims__VideoFormatType(soap, &this->fims__TransformAtomType::videoFormat);
	soap_serialize_PointerTofims__AudioFormatType(soap, &this->fims__TransformAtomType::audioFormat);
	soap_serialize_PointerTofims__ContainerFormatType(soap, &this->fims__TransformAtomType::containerFormat);
	soap_serialize_PointerTofims__ExtensionGroup(soap, &this->fims__TransformAtomType::ExtensionGroup);
	soap_serialize_PointerTofims__ExtensionAttributes(soap, &this->fims__TransformAtomType::ExtensionAttributes);
	/* transient soap skipped */
#endif
}

int fims__TransformAtomType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_fims__TransformAtomType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_fims__TransformAtomType(struct soap *soap, const char *tag, int id, const fims__TransformAtomType *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_fims__TransformAtomType), type))
		return soap->error;
	if (soap_out_PointerTofims__VideoFormatType(soap, "fims:videoFormat", -1, &(a->fims__TransformAtomType::videoFormat), ""))
		return soap->error;
	if (soap_out_PointerTofims__AudioFormatType(soap, "fims:audioFormat", -1, &(a->fims__TransformAtomType::audioFormat), ""))
		return soap->error;
	if (soap_out_PointerTofims__ContainerFormatType(soap, "fims:containerFormat", -1, &(a->fims__TransformAtomType::containerFormat), ""))
		return soap->error;
	if (soap_out_PointerTofims__ExtensionGroup(soap, "fims:ExtensionGroup", -1, &(a->fims__TransformAtomType::ExtensionGroup), ""))
		return soap->error;
	if (soap_out_PointerTofims__ExtensionAttributes(soap, "fims:ExtensionAttributes", -1, &(a->fims__TransformAtomType::ExtensionAttributes), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *fims__TransformAtomType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_fims__TransformAtomType(soap, tag, this, type);
}

SOAP_FMAC3 fims__TransformAtomType * SOAP_FMAC4 soap_in_fims__TransformAtomType(struct soap *soap, const char *tag, fims__TransformAtomType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (fims__TransformAtomType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_fims__TransformAtomType, sizeof(fims__TransformAtomType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_fims__TransformAtomType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (fims__TransformAtomType *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_videoFormat1 = 1;
	size_t soap_flag_audioFormat1 = 1;
	size_t soap_flag_containerFormat1 = 1;
	size_t soap_flag_ExtensionGroup1 = 1;
	size_t soap_flag_ExtensionAttributes1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_videoFormat1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTofims__VideoFormatType(soap, "fims:videoFormat", &(a->fims__TransformAtomType::videoFormat), "fims:VideoFormatType"))
				{	soap_flag_videoFormat1--;
					continue;
				}
			if (soap_flag_audioFormat1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTofims__AudioFormatType(soap, "fims:audioFormat", &(a->fims__TransformAtomType::audioFormat), "fims:AudioFormatType"))
				{	soap_flag_audioFormat1--;
					continue;
				}
			if (soap_flag_containerFormat1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTofims__ContainerFormatType(soap, "fims:containerFormat", &(a->fims__TransformAtomType::containerFormat), "fims:ContainerFormatType"))
				{	soap_flag_containerFormat1--;
					continue;
				}
			if (soap_flag_ExtensionGroup1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTofims__ExtensionGroup(soap, "fims:ExtensionGroup", &(a->fims__TransformAtomType::ExtensionGroup), "fims:ExtensionGroup"))
				{	soap_flag_ExtensionGroup1--;
					continue;
				}
			if (soap_flag_ExtensionAttributes1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTofims__ExtensionAttributes(soap, "fims:ExtensionAttributes", &(a->fims__TransformAtomType::ExtensionAttributes), "fims:ExtensionAttributes"))
				{	soap_flag_ExtensionAttributes1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (fims__TransformAtomType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_fims__TransformAtomType, 0, sizeof(fims__TransformAtomType), 0, soap_copy_fims__TransformAtomType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int fims__TransformAtomType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_fims__TransformAtomType);
	if (this->soap_out(soap, tag?tag:"fims:TransformAtomType", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *fims__TransformAtomType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_fims__TransformAtomType(soap, this, tag, type);
}

SOAP_FMAC3 fims__TransformAtomType * SOAP_FMAC4 soap_get_fims__TransformAtomType(struct soap *soap, fims__TransformAtomType *p, const char *tag, const char *type)
{
	if ((p = soap_in_fims__TransformAtomType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 fims__TransformAtomType * SOAP_FMAC2 soap_instantiate_fims__TransformAtomType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_fims__TransformAtomType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_fims__TransformAtomType, n, EDLProvider_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(fims__TransformAtomType);
		if (size)
			*size = sizeof(fims__TransformAtomType);
		((fims__TransformAtomType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(fims__TransformAtomType, n);
		if (size)
			*size = n * sizeof(fims__TransformAtomType);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((fims__TransformAtomType*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (fims__TransformAtomType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_fims__TransformAtomType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying fims__TransformAtomType %p -> %p\n", q, p));
	*(fims__TransformAtomType*)p = *(fims__TransformAtomType*)q;
}

void fims__TransferAtomType::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_xsd__anyURI(soap, &this->fims__TransferAtomType::destination);
	this->fims__TransferAtomType::ExtensionGroup = NULL;
	this->fims__TransferAtomType::ExtensionAttributes = NULL;
	/* transient soap skipped */
}

void fims__TransferAtomType::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &this->fims__TransferAtomType::destination, SOAP_TYPE_xsd__anyURI);
	soap_serialize_xsd__anyURI(soap, &this->fims__TransferAtomType::destination);
	soap_serialize_PointerTofims__ExtensionGroup(soap, &this->fims__TransferAtomType::ExtensionGroup);
	soap_serialize_PointerTofims__ExtensionAttributes(soap, &this->fims__TransferAtomType::ExtensionAttributes);
	/* transient soap skipped */
#endif
}

int fims__TransferAtomType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_fims__TransferAtomType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_fims__TransferAtomType(struct soap *soap, const char *tag, int id, const fims__TransferAtomType *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_fims__TransferAtomType), type))
		return soap->error;
	if (soap_out_xsd__anyURI(soap, "fims:destination", -1, &(a->fims__TransferAtomType::destination), ""))
		return soap->error;
	if (soap_out_PointerTofims__ExtensionGroup(soap, "fims:ExtensionGroup", -1, &(a->fims__TransferAtomType::ExtensionGroup), ""))
		return soap->error;
	if (soap_out_PointerTofims__ExtensionAttributes(soap, "fims:ExtensionAttributes", -1, &(a->fims__TransferAtomType::ExtensionAttributes), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *fims__TransferAtomType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_fims__TransferAtomType(soap, tag, this, type);
}

SOAP_FMAC3 fims__TransferAtomType * SOAP_FMAC4 soap_in_fims__TransferAtomType(struct soap *soap, const char *tag, fims__TransferAtomType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (fims__TransferAtomType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_fims__TransferAtomType, sizeof(fims__TransferAtomType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_fims__TransferAtomType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (fims__TransferAtomType *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_destination1 = 1;
	size_t soap_flag_ExtensionGroup1 = 1;
	size_t soap_flag_ExtensionAttributes1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_destination1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__anyURI(soap, "fims:destination", &(a->fims__TransferAtomType::destination), "xsd:anyURI"))
				{	soap_flag_destination1--;
					continue;
				}
			if (soap_flag_ExtensionGroup1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTofims__ExtensionGroup(soap, "fims:ExtensionGroup", &(a->fims__TransferAtomType::ExtensionGroup), "fims:ExtensionGroup"))
				{	soap_flag_ExtensionGroup1--;
					continue;
				}
			if (soap_flag_ExtensionAttributes1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTofims__ExtensionAttributes(soap, "fims:ExtensionAttributes", &(a->fims__TransferAtomType::ExtensionAttributes), "fims:ExtensionAttributes"))
				{	soap_flag_ExtensionAttributes1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (fims__TransferAtomType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_fims__TransferAtomType, 0, sizeof(fims__TransferAtomType), 0, soap_copy_fims__TransferAtomType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_destination1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int fims__TransferAtomType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_fims__TransferAtomType);
	if (this->soap_out(soap, tag?tag:"fims:TransferAtomType", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *fims__TransferAtomType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_fims__TransferAtomType(soap, this, tag, type);
}

SOAP_FMAC3 fims__TransferAtomType * SOAP_FMAC4 soap_get_fims__TransferAtomType(struct soap *soap, fims__TransferAtomType *p, const char *tag, const char *type)
{
	if ((p = soap_in_fims__TransferAtomType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 fims__TransferAtomType * SOAP_FMAC2 soap_instantiate_fims__TransferAtomType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_fims__TransferAtomType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_fims__TransferAtomType, n, EDLProvider_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(fims__TransferAtomType);
		if (size)
			*size = sizeof(fims__TransferAtomType);
		((fims__TransferAtomType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(fims__TransferAtomType, n);
		if (size)
			*size = n * sizeof(fims__TransferAtomType);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((fims__TransferAtomType*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (fims__TransferAtomType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_fims__TransferAtomType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying fims__TransferAtomType %p -> %p\n", q, p));
	*(fims__TransferAtomType*)p = *(fims__TransferAtomType*)q;
}

void fims__EssencePlaceholderLocatorType::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->fims__BMEssenceLocatorType::soap_default(soap);
}

void fims__EssencePlaceholderLocatorType::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	this->fims__BMEssenceLocatorType::soap_serialize(soap);
#endif
}

int fims__EssencePlaceholderLocatorType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_fims__EssencePlaceholderLocatorType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_fims__EssencePlaceholderLocatorType(struct soap *soap, const char *tag, int id, const fims__EssencePlaceholderLocatorType *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_fims__EssencePlaceholderLocatorType), "fims:EssencePlaceholderLocatorType"))
		return soap->error;
	if (soap_out_fims__ResourceIDType(soap, "fims:resourceID", -1, &(a->fims__ResourceReferenceType::resourceID), ""))
		return soap->error;
	if (soap_out_PointerTofims__RevisionIDType(soap, "fims:revisionID", -1, &(a->fims__ResourceReferenceType::revisionID), ""))
		return soap->error;
	if (soap_out_PointerToxsd__anyURI(soap, "fims:location", -1, &(a->fims__ResourceReferenceType::location), ""))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_PointerTotime(soap, "fims:resourceCreationDate", -1, &(a->fims__ResourceType::resourceCreationDate), ""))
		return soap->error;
	if (soap_out_PointerTotime(soap, "fims:resourceModifiedDate", -1, &(a->fims__ResourceType::resourceModifiedDate), ""))
		return soap->error;
	if (soap_out_PointerTobool(soap, "fims:serviceGeneratedElement", -1, &(a->fims__ResourceType::serviceGeneratedElement), ""))
		return soap->error;
	if (soap_out_PointerTobool(soap, "fims:isFullyPopulated", -1, &(a->fims__ResourceType::isFullyPopulated), ""))
		return soap->error;
	if (soap_out_PointerTofims__AsyncEndpointType(soap, "fims:notifyAt", -1, &(a->fims__ResourceType::notifyAt), ""))
		return soap->error;
	if (soap_out_PointerTofims__ExtensionGroup(soap, "fims:ExtensionGroup", -1, &(a->fims__ResourceType::ExtensionGroup), ""))
		return soap->error;
	if (soap_out_PointerTofims__ExtensionAttributes(soap, "fims:ExtensionAttributes", -1, &(a->fims__ResourceType::ExtensionAttributes), ""))
		return soap->error;
	if (soap_out_PointerTofims__StorageType(soap, "fims:storageType", -1, &(a->fims__BMEssenceLocatorType::storageType), ""))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "fims:locatorInfo", -1, &(a->fims__BMEssenceLocatorType::locatorInfo), ""))
		return soap->error;
	if (soap_out_PointerTo_fims__BMEssenceLocatorType_containerMimeType(soap, "fims:containerMimeType", -1, &(a->fims__BMEssenceLocatorType::containerMimeType), ""))
		return soap->error;
	if (soap_out_PointerTofims__BMEssenceLocatorStatusType(soap, "fims:status", -1, &(a->fims__BMEssenceLocatorType::status), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *fims__EssencePlaceholderLocatorType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_fims__EssencePlaceholderLocatorType(soap, tag, this, type);
}

SOAP_FMAC3 fims__EssencePlaceholderLocatorType * SOAP_FMAC4 soap_in_fims__EssencePlaceholderLocatorType(struct soap *soap, const char *tag, fims__EssencePlaceholderLocatorType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (fims__EssencePlaceholderLocatorType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_fims__EssencePlaceholderLocatorType, sizeof(fims__EssencePlaceholderLocatorType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_fims__EssencePlaceholderLocatorType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (fims__EssencePlaceholderLocatorType *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_resourceID4 = 1;
	size_t soap_flag_revisionID4 = 1;
	size_t soap_flag_location4 = 1;
	size_t soap_flag_resourceCreationDate3 = 1;
	size_t soap_flag_resourceModifiedDate3 = 1;
	size_t soap_flag_serviceGeneratedElement3 = 1;
	size_t soap_flag_isFullyPopulated3 = 1;
	size_t soap_flag_notifyAt3 = 1;
	size_t soap_flag_ExtensionGroup3 = 1;
	size_t soap_flag_ExtensionAttributes3 = 1;
	size_t soap_flag_storageType2 = 1;
	size_t soap_flag_locatorInfo2 = 1;
	size_t soap_flag_containerMimeType2 = 1;
	size_t soap_flag_status2 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_resourceID4 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_fims__ResourceIDType(soap, "fims:resourceID", &(a->fims__ResourceReferenceType::resourceID), "fims:ResourceIDType"))
				{	soap_flag_resourceID4--;
					continue;
				}
			if (soap_flag_revisionID4 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTofims__RevisionIDType(soap, "fims:revisionID", &(a->fims__ResourceReferenceType::revisionID), "fims:RevisionIDType"))
				{	soap_flag_revisionID4--;
					continue;
				}
			if (soap_flag_location4 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerToxsd__anyURI(soap, "fims:location", &(a->fims__ResourceReferenceType::location), "xsd:anyURI"))
				{	soap_flag_location4--;
					continue;
				}
			/* transient soap skipped */
			if (soap_flag_resourceCreationDate3 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTotime(soap, "fims:resourceCreationDate", &(a->fims__ResourceType::resourceCreationDate), "xsd:dateTime"))
				{	soap_flag_resourceCreationDate3--;
					continue;
				}
			if (soap_flag_resourceModifiedDate3 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTotime(soap, "fims:resourceModifiedDate", &(a->fims__ResourceType::resourceModifiedDate), "xsd:dateTime"))
				{	soap_flag_resourceModifiedDate3--;
					continue;
				}
			if (soap_flag_serviceGeneratedElement3 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTobool(soap, "fims:serviceGeneratedElement", &(a->fims__ResourceType::serviceGeneratedElement), "xsd:boolean"))
				{	soap_flag_serviceGeneratedElement3--;
					continue;
				}
			if (soap_flag_isFullyPopulated3 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTobool(soap, "fims:isFullyPopulated", &(a->fims__ResourceType::isFullyPopulated), "xsd:boolean"))
				{	soap_flag_isFullyPopulated3--;
					continue;
				}
			if (soap_flag_notifyAt3 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTofims__AsyncEndpointType(soap, "fims:notifyAt", &(a->fims__ResourceType::notifyAt), "fims:AsyncEndpointType"))
				{	soap_flag_notifyAt3--;
					continue;
				}
			if (soap_flag_ExtensionGroup3 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTofims__ExtensionGroup(soap, "fims:ExtensionGroup", &(a->fims__ResourceType::ExtensionGroup), "fims:ExtensionGroup"))
				{	soap_flag_ExtensionGroup3--;
					continue;
				}
			if (soap_flag_ExtensionAttributes3 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTofims__ExtensionAttributes(soap, "fims:ExtensionAttributes", &(a->fims__ResourceType::ExtensionAttributes), "fims:ExtensionAttributes"))
				{	soap_flag_ExtensionAttributes3--;
					continue;
				}
			if (soap_flag_storageType2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTofims__StorageType(soap, "fims:storageType", &(a->fims__BMEssenceLocatorType::storageType), "fims:StorageType"))
				{	soap_flag_storageType2--;
					continue;
				}
			if (soap_flag_locatorInfo2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "fims:locatorInfo", &(a->fims__BMEssenceLocatorType::locatorInfo), "xsd:string"))
				{	soap_flag_locatorInfo2--;
					continue;
				}
			if (soap_flag_containerMimeType2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_fims__BMEssenceLocatorType_containerMimeType(soap, "fims:containerMimeType", &(a->fims__BMEssenceLocatorType::containerMimeType), ""))
				{	soap_flag_containerMimeType2--;
					continue;
				}
			if (soap_flag_status2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTofims__BMEssenceLocatorStatusType(soap, "fims:status", &(a->fims__BMEssenceLocatorType::status), "fims:BMEssenceLocatorStatusType"))
				{	soap_flag_status2--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (fims__EssencePlaceholderLocatorType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_fims__EssencePlaceholderLocatorType, 0, sizeof(fims__EssencePlaceholderLocatorType), 0, soap_copy_fims__EssencePlaceholderLocatorType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_resourceID4 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int fims__EssencePlaceholderLocatorType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_fims__EssencePlaceholderLocatorType);
	if (this->soap_out(soap, tag?tag:"fims:EssencePlaceholderLocatorType", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *fims__EssencePlaceholderLocatorType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_fims__EssencePlaceholderLocatorType(soap, this, tag, type);
}

SOAP_FMAC3 fims__EssencePlaceholderLocatorType * SOAP_FMAC4 soap_get_fims__EssencePlaceholderLocatorType(struct soap *soap, fims__EssencePlaceholderLocatorType *p, const char *tag, const char *type)
{
	if ((p = soap_in_fims__EssencePlaceholderLocatorType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 fims__EssencePlaceholderLocatorType * SOAP_FMAC2 soap_instantiate_fims__EssencePlaceholderLocatorType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_fims__EssencePlaceholderLocatorType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_fims__EssencePlaceholderLocatorType, n, EDLProvider_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(fims__EssencePlaceholderLocatorType);
		if (size)
			*size = sizeof(fims__EssencePlaceholderLocatorType);
		((fims__EssencePlaceholderLocatorType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(fims__EssencePlaceholderLocatorType, n);
		if (size)
			*size = n * sizeof(fims__EssencePlaceholderLocatorType);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((fims__EssencePlaceholderLocatorType*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (fims__EssencePlaceholderLocatorType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_fims__EssencePlaceholderLocatorType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying fims__EssencePlaceholderLocatorType %p -> %p\n", q, p));
	*(fims__EssencePlaceholderLocatorType*)p = *(fims__EssencePlaceholderLocatorType*)q;
}

void fims__FolderLocatorType::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->fims__BMEssenceLocatorType::soap_default(soap);
	this->fims__FolderLocatorType::folder = NULL;
}

void fims__FolderLocatorType::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerToxsd__anyURI(soap, &this->fims__FolderLocatorType::folder);
	this->fims__BMEssenceLocatorType::soap_serialize(soap);
#endif
}

int fims__FolderLocatorType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_fims__FolderLocatorType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_fims__FolderLocatorType(struct soap *soap, const char *tag, int id, const fims__FolderLocatorType *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_fims__FolderLocatorType), "fims:FolderLocatorType"))
		return soap->error;
	if (soap_out_fims__ResourceIDType(soap, "fims:resourceID", -1, &(a->fims__ResourceReferenceType::resourceID), ""))
		return soap->error;
	if (soap_out_PointerTofims__RevisionIDType(soap, "fims:revisionID", -1, &(a->fims__ResourceReferenceType::revisionID), ""))
		return soap->error;
	if (soap_out_PointerToxsd__anyURI(soap, "fims:location", -1, &(a->fims__ResourceReferenceType::location), ""))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_PointerTotime(soap, "fims:resourceCreationDate", -1, &(a->fims__ResourceType::resourceCreationDate), ""))
		return soap->error;
	if (soap_out_PointerTotime(soap, "fims:resourceModifiedDate", -1, &(a->fims__ResourceType::resourceModifiedDate), ""))
		return soap->error;
	if (soap_out_PointerTobool(soap, "fims:serviceGeneratedElement", -1, &(a->fims__ResourceType::serviceGeneratedElement), ""))
		return soap->error;
	if (soap_out_PointerTobool(soap, "fims:isFullyPopulated", -1, &(a->fims__ResourceType::isFullyPopulated), ""))
		return soap->error;
	if (soap_out_PointerTofims__AsyncEndpointType(soap, "fims:notifyAt", -1, &(a->fims__ResourceType::notifyAt), ""))
		return soap->error;
	if (soap_out_PointerTofims__ExtensionGroup(soap, "fims:ExtensionGroup", -1, &(a->fims__ResourceType::ExtensionGroup), ""))
		return soap->error;
	if (soap_out_PointerTofims__ExtensionAttributes(soap, "fims:ExtensionAttributes", -1, &(a->fims__ResourceType::ExtensionAttributes), ""))
		return soap->error;
	if (soap_out_PointerTofims__StorageType(soap, "fims:storageType", -1, &(a->fims__BMEssenceLocatorType::storageType), ""))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "fims:locatorInfo", -1, &(a->fims__BMEssenceLocatorType::locatorInfo), ""))
		return soap->error;
	if (soap_out_PointerTo_fims__BMEssenceLocatorType_containerMimeType(soap, "fims:containerMimeType", -1, &(a->fims__BMEssenceLocatorType::containerMimeType), ""))
		return soap->error;
	if (soap_out_PointerTofims__BMEssenceLocatorStatusType(soap, "fims:status", -1, &(a->fims__BMEssenceLocatorType::status), ""))
		return soap->error;
	if (soap_out_PointerToxsd__anyURI(soap, "fims:folder", -1, &(a->fims__FolderLocatorType::folder), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *fims__FolderLocatorType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_fims__FolderLocatorType(soap, tag, this, type);
}

SOAP_FMAC3 fims__FolderLocatorType * SOAP_FMAC4 soap_in_fims__FolderLocatorType(struct soap *soap, const char *tag, fims__FolderLocatorType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (fims__FolderLocatorType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_fims__FolderLocatorType, sizeof(fims__FolderLocatorType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_fims__FolderLocatorType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (fims__FolderLocatorType *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_resourceID4 = 1;
	size_t soap_flag_revisionID4 = 1;
	size_t soap_flag_location4 = 1;
	size_t soap_flag_resourceCreationDate3 = 1;
	size_t soap_flag_resourceModifiedDate3 = 1;
	size_t soap_flag_serviceGeneratedElement3 = 1;
	size_t soap_flag_isFullyPopulated3 = 1;
	size_t soap_flag_notifyAt3 = 1;
	size_t soap_flag_ExtensionGroup3 = 1;
	size_t soap_flag_ExtensionAttributes3 = 1;
	size_t soap_flag_storageType2 = 1;
	size_t soap_flag_locatorInfo2 = 1;
	size_t soap_flag_containerMimeType2 = 1;
	size_t soap_flag_status2 = 1;
	size_t soap_flag_folder1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_resourceID4 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_fims__ResourceIDType(soap, "fims:resourceID", &(a->fims__ResourceReferenceType::resourceID), "fims:ResourceIDType"))
				{	soap_flag_resourceID4--;
					continue;
				}
			if (soap_flag_revisionID4 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTofims__RevisionIDType(soap, "fims:revisionID", &(a->fims__ResourceReferenceType::revisionID), "fims:RevisionIDType"))
				{	soap_flag_revisionID4--;
					continue;
				}
			if (soap_flag_location4 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerToxsd__anyURI(soap, "fims:location", &(a->fims__ResourceReferenceType::location), "xsd:anyURI"))
				{	soap_flag_location4--;
					continue;
				}
			/* transient soap skipped */
			if (soap_flag_resourceCreationDate3 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTotime(soap, "fims:resourceCreationDate", &(a->fims__ResourceType::resourceCreationDate), "xsd:dateTime"))
				{	soap_flag_resourceCreationDate3--;
					continue;
				}
			if (soap_flag_resourceModifiedDate3 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTotime(soap, "fims:resourceModifiedDate", &(a->fims__ResourceType::resourceModifiedDate), "xsd:dateTime"))
				{	soap_flag_resourceModifiedDate3--;
					continue;
				}
			if (soap_flag_serviceGeneratedElement3 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTobool(soap, "fims:serviceGeneratedElement", &(a->fims__ResourceType::serviceGeneratedElement), "xsd:boolean"))
				{	soap_flag_serviceGeneratedElement3--;
					continue;
				}
			if (soap_flag_isFullyPopulated3 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTobool(soap, "fims:isFullyPopulated", &(a->fims__ResourceType::isFullyPopulated), "xsd:boolean"))
				{	soap_flag_isFullyPopulated3--;
					continue;
				}
			if (soap_flag_notifyAt3 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTofims__AsyncEndpointType(soap, "fims:notifyAt", &(a->fims__ResourceType::notifyAt), "fims:AsyncEndpointType"))
				{	soap_flag_notifyAt3--;
					continue;
				}
			if (soap_flag_ExtensionGroup3 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTofims__ExtensionGroup(soap, "fims:ExtensionGroup", &(a->fims__ResourceType::ExtensionGroup), "fims:ExtensionGroup"))
				{	soap_flag_ExtensionGroup3--;
					continue;
				}
			if (soap_flag_ExtensionAttributes3 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTofims__ExtensionAttributes(soap, "fims:ExtensionAttributes", &(a->fims__ResourceType::ExtensionAttributes), "fims:ExtensionAttributes"))
				{	soap_flag_ExtensionAttributes3--;
					continue;
				}
			if (soap_flag_storageType2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTofims__StorageType(soap, "fims:storageType", &(a->fims__BMEssenceLocatorType::storageType), "fims:StorageType"))
				{	soap_flag_storageType2--;
					continue;
				}
			if (soap_flag_locatorInfo2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "fims:locatorInfo", &(a->fims__BMEssenceLocatorType::locatorInfo), "xsd:string"))
				{	soap_flag_locatorInfo2--;
					continue;
				}
			if (soap_flag_containerMimeType2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_fims__BMEssenceLocatorType_containerMimeType(soap, "fims:containerMimeType", &(a->fims__BMEssenceLocatorType::containerMimeType), ""))
				{	soap_flag_containerMimeType2--;
					continue;
				}
			if (soap_flag_status2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTofims__BMEssenceLocatorStatusType(soap, "fims:status", &(a->fims__BMEssenceLocatorType::status), "fims:BMEssenceLocatorStatusType"))
				{	soap_flag_status2--;
					continue;
				}
			if (soap_flag_folder1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerToxsd__anyURI(soap, "fims:folder", &(a->fims__FolderLocatorType::folder), "xsd:anyURI"))
				{	soap_flag_folder1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (fims__FolderLocatorType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_fims__FolderLocatorType, 0, sizeof(fims__FolderLocatorType), 0, soap_copy_fims__FolderLocatorType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_resourceID4 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int fims__FolderLocatorType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_fims__FolderLocatorType);
	if (this->soap_out(soap, tag?tag:"fims:FolderLocatorType", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *fims__FolderLocatorType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_fims__FolderLocatorType(soap, this, tag, type);
}

SOAP_FMAC3 fims__FolderLocatorType * SOAP_FMAC4 soap_get_fims__FolderLocatorType(struct soap *soap, fims__FolderLocatorType *p, const char *tag, const char *type)
{
	if ((p = soap_in_fims__FolderLocatorType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 fims__FolderLocatorType * SOAP_FMAC2 soap_instantiate_fims__FolderLocatorType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_fims__FolderLocatorType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_fims__FolderLocatorType, n, EDLProvider_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(fims__FolderLocatorType);
		if (size)
			*size = sizeof(fims__FolderLocatorType);
		((fims__FolderLocatorType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(fims__FolderLocatorType, n);
		if (size)
			*size = n * sizeof(fims__FolderLocatorType);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((fims__FolderLocatorType*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (fims__FolderLocatorType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_fims__FolderLocatorType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying fims__FolderLocatorType %p -> %p\n", q, p));
	*(fims__FolderLocatorType*)p = *(fims__FolderLocatorType*)q;
}

void fims__ListFileLocatorType::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->fims__BMEssenceLocatorType::soap_default(soap);
	soap_default_std__vectorTemplateOfxsd__anyURI(soap, &this->fims__ListFileLocatorType::file);
}

void fims__ListFileLocatorType::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfxsd__anyURI(soap, &this->fims__ListFileLocatorType::file);
	this->fims__BMEssenceLocatorType::soap_serialize(soap);
#endif
}

int fims__ListFileLocatorType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_fims__ListFileLocatorType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_fims__ListFileLocatorType(struct soap *soap, const char *tag, int id, const fims__ListFileLocatorType *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_fims__ListFileLocatorType), "fims:ListFileLocatorType"))
		return soap->error;
	if (soap_out_fims__ResourceIDType(soap, "fims:resourceID", -1, &(a->fims__ResourceReferenceType::resourceID), ""))
		return soap->error;
	if (soap_out_PointerTofims__RevisionIDType(soap, "fims:revisionID", -1, &(a->fims__ResourceReferenceType::revisionID), ""))
		return soap->error;
	if (soap_out_PointerToxsd__anyURI(soap, "fims:location", -1, &(a->fims__ResourceReferenceType::location), ""))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_PointerTotime(soap, "fims:resourceCreationDate", -1, &(a->fims__ResourceType::resourceCreationDate), ""))
		return soap->error;
	if (soap_out_PointerTotime(soap, "fims:resourceModifiedDate", -1, &(a->fims__ResourceType::resourceModifiedDate), ""))
		return soap->error;
	if (soap_out_PointerTobool(soap, "fims:serviceGeneratedElement", -1, &(a->fims__ResourceType::serviceGeneratedElement), ""))
		return soap->error;
	if (soap_out_PointerTobool(soap, "fims:isFullyPopulated", -1, &(a->fims__ResourceType::isFullyPopulated), ""))
		return soap->error;
	if (soap_out_PointerTofims__AsyncEndpointType(soap, "fims:notifyAt", -1, &(a->fims__ResourceType::notifyAt), ""))
		return soap->error;
	if (soap_out_PointerTofims__ExtensionGroup(soap, "fims:ExtensionGroup", -1, &(a->fims__ResourceType::ExtensionGroup), ""))
		return soap->error;
	if (soap_out_PointerTofims__ExtensionAttributes(soap, "fims:ExtensionAttributes", -1, &(a->fims__ResourceType::ExtensionAttributes), ""))
		return soap->error;
	if (soap_out_PointerTofims__StorageType(soap, "fims:storageType", -1, &(a->fims__BMEssenceLocatorType::storageType), ""))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "fims:locatorInfo", -1, &(a->fims__BMEssenceLocatorType::locatorInfo), ""))
		return soap->error;
	if (soap_out_PointerTo_fims__BMEssenceLocatorType_containerMimeType(soap, "fims:containerMimeType", -1, &(a->fims__BMEssenceLocatorType::containerMimeType), ""))
		return soap->error;
	if (soap_out_PointerTofims__BMEssenceLocatorStatusType(soap, "fims:status", -1, &(a->fims__BMEssenceLocatorType::status), ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfxsd__anyURI(soap, "fims:file", -1, &(a->fims__ListFileLocatorType::file), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *fims__ListFileLocatorType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_fims__ListFileLocatorType(soap, tag, this, type);
}

SOAP_FMAC3 fims__ListFileLocatorType * SOAP_FMAC4 soap_in_fims__ListFileLocatorType(struct soap *soap, const char *tag, fims__ListFileLocatorType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (fims__ListFileLocatorType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_fims__ListFileLocatorType, sizeof(fims__ListFileLocatorType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_fims__ListFileLocatorType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (fims__ListFileLocatorType *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_resourceID4 = 1;
	size_t soap_flag_revisionID4 = 1;
	size_t soap_flag_location4 = 1;
	size_t soap_flag_resourceCreationDate3 = 1;
	size_t soap_flag_resourceModifiedDate3 = 1;
	size_t soap_flag_serviceGeneratedElement3 = 1;
	size_t soap_flag_isFullyPopulated3 = 1;
	size_t soap_flag_notifyAt3 = 1;
	size_t soap_flag_ExtensionGroup3 = 1;
	size_t soap_flag_ExtensionAttributes3 = 1;
	size_t soap_flag_storageType2 = 1;
	size_t soap_flag_locatorInfo2 = 1;
	size_t soap_flag_containerMimeType2 = 1;
	size_t soap_flag_status2 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_resourceID4 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_fims__ResourceIDType(soap, "fims:resourceID", &(a->fims__ResourceReferenceType::resourceID), "fims:ResourceIDType"))
				{	soap_flag_resourceID4--;
					continue;
				}
			if (soap_flag_revisionID4 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTofims__RevisionIDType(soap, "fims:revisionID", &(a->fims__ResourceReferenceType::revisionID), "fims:RevisionIDType"))
				{	soap_flag_revisionID4--;
					continue;
				}
			if (soap_flag_location4 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerToxsd__anyURI(soap, "fims:location", &(a->fims__ResourceReferenceType::location), "xsd:anyURI"))
				{	soap_flag_location4--;
					continue;
				}
			/* transient soap skipped */
			if (soap_flag_resourceCreationDate3 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTotime(soap, "fims:resourceCreationDate", &(a->fims__ResourceType::resourceCreationDate), "xsd:dateTime"))
				{	soap_flag_resourceCreationDate3--;
					continue;
				}
			if (soap_flag_resourceModifiedDate3 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTotime(soap, "fims:resourceModifiedDate", &(a->fims__ResourceType::resourceModifiedDate), "xsd:dateTime"))
				{	soap_flag_resourceModifiedDate3--;
					continue;
				}
			if (soap_flag_serviceGeneratedElement3 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTobool(soap, "fims:serviceGeneratedElement", &(a->fims__ResourceType::serviceGeneratedElement), "xsd:boolean"))
				{	soap_flag_serviceGeneratedElement3--;
					continue;
				}
			if (soap_flag_isFullyPopulated3 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTobool(soap, "fims:isFullyPopulated", &(a->fims__ResourceType::isFullyPopulated), "xsd:boolean"))
				{	soap_flag_isFullyPopulated3--;
					continue;
				}
			if (soap_flag_notifyAt3 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTofims__AsyncEndpointType(soap, "fims:notifyAt", &(a->fims__ResourceType::notifyAt), "fims:AsyncEndpointType"))
				{	soap_flag_notifyAt3--;
					continue;
				}
			if (soap_flag_ExtensionGroup3 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTofims__ExtensionGroup(soap, "fims:ExtensionGroup", &(a->fims__ResourceType::ExtensionGroup), "fims:ExtensionGroup"))
				{	soap_flag_ExtensionGroup3--;
					continue;
				}
			if (soap_flag_ExtensionAttributes3 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTofims__ExtensionAttributes(soap, "fims:ExtensionAttributes", &(a->fims__ResourceType::ExtensionAttributes), "fims:ExtensionAttributes"))
				{	soap_flag_ExtensionAttributes3--;
					continue;
				}
			if (soap_flag_storageType2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTofims__StorageType(soap, "fims:storageType", &(a->fims__BMEssenceLocatorType::storageType), "fims:StorageType"))
				{	soap_flag_storageType2--;
					continue;
				}
			if (soap_flag_locatorInfo2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "fims:locatorInfo", &(a->fims__BMEssenceLocatorType::locatorInfo), "xsd:string"))
				{	soap_flag_locatorInfo2--;
					continue;
				}
			if (soap_flag_containerMimeType2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_fims__BMEssenceLocatorType_containerMimeType(soap, "fims:containerMimeType", &(a->fims__BMEssenceLocatorType::containerMimeType), ""))
				{	soap_flag_containerMimeType2--;
					continue;
				}
			if (soap_flag_status2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTofims__BMEssenceLocatorStatusType(soap, "fims:status", &(a->fims__BMEssenceLocatorType::status), "fims:BMEssenceLocatorStatusType"))
				{	soap_flag_status2--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfxsd__anyURI(soap, "fims:file", &(a->fims__ListFileLocatorType::file), "xsd:anyURI"))
					continue;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (fims__ListFileLocatorType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_fims__ListFileLocatorType, 0, sizeof(fims__ListFileLocatorType), 0, soap_copy_fims__ListFileLocatorType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_resourceID4 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int fims__ListFileLocatorType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_fims__ListFileLocatorType);
	if (this->soap_out(soap, tag?tag:"fims:ListFileLocatorType", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *fims__ListFileLocatorType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_fims__ListFileLocatorType(soap, this, tag, type);
}

SOAP_FMAC3 fims__ListFileLocatorType * SOAP_FMAC4 soap_get_fims__ListFileLocatorType(struct soap *soap, fims__ListFileLocatorType *p, const char *tag, const char *type)
{
	if ((p = soap_in_fims__ListFileLocatorType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 fims__ListFileLocatorType * SOAP_FMAC2 soap_instantiate_fims__ListFileLocatorType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_fims__ListFileLocatorType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_fims__ListFileLocatorType, n, EDLProvider_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(fims__ListFileLocatorType);
		if (size)
			*size = sizeof(fims__ListFileLocatorType);
		((fims__ListFileLocatorType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(fims__ListFileLocatorType, n);
		if (size)
			*size = n * sizeof(fims__ListFileLocatorType);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((fims__ListFileLocatorType*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (fims__ListFileLocatorType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_fims__ListFileLocatorType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying fims__ListFileLocatorType %p -> %p\n", q, p));
	*(fims__ListFileLocatorType*)p = *(fims__ListFileLocatorType*)q;
}

void fims__SimpleFileLocatorType::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->fims__BMEssenceLocatorType::soap_default(soap);
	this->fims__SimpleFileLocatorType::file = NULL;
}

void fims__SimpleFileLocatorType::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerToxsd__anyURI(soap, &this->fims__SimpleFileLocatorType::file);
	this->fims__BMEssenceLocatorType::soap_serialize(soap);
#endif
}

int fims__SimpleFileLocatorType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_fims__SimpleFileLocatorType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_fims__SimpleFileLocatorType(struct soap *soap, const char *tag, int id, const fims__SimpleFileLocatorType *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_fims__SimpleFileLocatorType), "fims:SimpleFileLocatorType"))
		return soap->error;
	if (soap_out_fims__ResourceIDType(soap, "fims:resourceID", -1, &(a->fims__ResourceReferenceType::resourceID), ""))
		return soap->error;
	if (soap_out_PointerTofims__RevisionIDType(soap, "fims:revisionID", -1, &(a->fims__ResourceReferenceType::revisionID), ""))
		return soap->error;
	if (soap_out_PointerToxsd__anyURI(soap, "fims:location", -1, &(a->fims__ResourceReferenceType::location), ""))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_PointerTotime(soap, "fims:resourceCreationDate", -1, &(a->fims__ResourceType::resourceCreationDate), ""))
		return soap->error;
	if (soap_out_PointerTotime(soap, "fims:resourceModifiedDate", -1, &(a->fims__ResourceType::resourceModifiedDate), ""))
		return soap->error;
	if (soap_out_PointerTobool(soap, "fims:serviceGeneratedElement", -1, &(a->fims__ResourceType::serviceGeneratedElement), ""))
		return soap->error;
	if (soap_out_PointerTobool(soap, "fims:isFullyPopulated", -1, &(a->fims__ResourceType::isFullyPopulated), ""))
		return soap->error;
	if (soap_out_PointerTofims__AsyncEndpointType(soap, "fims:notifyAt", -1, &(a->fims__ResourceType::notifyAt), ""))
		return soap->error;
	if (soap_out_PointerTofims__ExtensionGroup(soap, "fims:ExtensionGroup", -1, &(a->fims__ResourceType::ExtensionGroup), ""))
		return soap->error;
	if (soap_out_PointerTofims__ExtensionAttributes(soap, "fims:ExtensionAttributes", -1, &(a->fims__ResourceType::ExtensionAttributes), ""))
		return soap->error;
	if (soap_out_PointerTofims__StorageType(soap, "fims:storageType", -1, &(a->fims__BMEssenceLocatorType::storageType), ""))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "fims:locatorInfo", -1, &(a->fims__BMEssenceLocatorType::locatorInfo), ""))
		return soap->error;
	if (soap_out_PointerTo_fims__BMEssenceLocatorType_containerMimeType(soap, "fims:containerMimeType", -1, &(a->fims__BMEssenceLocatorType::containerMimeType), ""))
		return soap->error;
	if (soap_out_PointerTofims__BMEssenceLocatorStatusType(soap, "fims:status", -1, &(a->fims__BMEssenceLocatorType::status), ""))
		return soap->error;
	if (soap_out_PointerToxsd__anyURI(soap, "fims:file", -1, &(a->fims__SimpleFileLocatorType::file), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *fims__SimpleFileLocatorType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_fims__SimpleFileLocatorType(soap, tag, this, type);
}

SOAP_FMAC3 fims__SimpleFileLocatorType * SOAP_FMAC4 soap_in_fims__SimpleFileLocatorType(struct soap *soap, const char *tag, fims__SimpleFileLocatorType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (fims__SimpleFileLocatorType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_fims__SimpleFileLocatorType, sizeof(fims__SimpleFileLocatorType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_fims__SimpleFileLocatorType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (fims__SimpleFileLocatorType *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_resourceID4 = 1;
	size_t soap_flag_revisionID4 = 1;
	size_t soap_flag_location4 = 1;
	size_t soap_flag_resourceCreationDate3 = 1;
	size_t soap_flag_resourceModifiedDate3 = 1;
	size_t soap_flag_serviceGeneratedElement3 = 1;
	size_t soap_flag_isFullyPopulated3 = 1;
	size_t soap_flag_notifyAt3 = 1;
	size_t soap_flag_ExtensionGroup3 = 1;
	size_t soap_flag_ExtensionAttributes3 = 1;
	size_t soap_flag_storageType2 = 1;
	size_t soap_flag_locatorInfo2 = 1;
	size_t soap_flag_containerMimeType2 = 1;
	size_t soap_flag_status2 = 1;
	size_t soap_flag_file1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_resourceID4 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_fims__ResourceIDType(soap, "fims:resourceID", &(a->fims__ResourceReferenceType::resourceID), "fims:ResourceIDType"))
				{	soap_flag_resourceID4--;
					continue;
				}
			if (soap_flag_revisionID4 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTofims__RevisionIDType(soap, "fims:revisionID", &(a->fims__ResourceReferenceType::revisionID), "fims:RevisionIDType"))
				{	soap_flag_revisionID4--;
					continue;
				}
			if (soap_flag_location4 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerToxsd__anyURI(soap, "fims:location", &(a->fims__ResourceReferenceType::location), "xsd:anyURI"))
				{	soap_flag_location4--;
					continue;
				}
			/* transient soap skipped */
			if (soap_flag_resourceCreationDate3 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTotime(soap, "fims:resourceCreationDate", &(a->fims__ResourceType::resourceCreationDate), "xsd:dateTime"))
				{	soap_flag_resourceCreationDate3--;
					continue;
				}
			if (soap_flag_resourceModifiedDate3 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTotime(soap, "fims:resourceModifiedDate", &(a->fims__ResourceType::resourceModifiedDate), "xsd:dateTime"))
				{	soap_flag_resourceModifiedDate3--;
					continue;
				}
			if (soap_flag_serviceGeneratedElement3 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTobool(soap, "fims:serviceGeneratedElement", &(a->fims__ResourceType::serviceGeneratedElement), "xsd:boolean"))
				{	soap_flag_serviceGeneratedElement3--;
					continue;
				}
			if (soap_flag_isFullyPopulated3 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTobool(soap, "fims:isFullyPopulated", &(a->fims__ResourceType::isFullyPopulated), "xsd:boolean"))
				{	soap_flag_isFullyPopulated3--;
					continue;
				}
			if (soap_flag_notifyAt3 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTofims__AsyncEndpointType(soap, "fims:notifyAt", &(a->fims__ResourceType::notifyAt), "fims:AsyncEndpointType"))
				{	soap_flag_notifyAt3--;
					continue;
				}
			if (soap_flag_ExtensionGroup3 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTofims__ExtensionGroup(soap, "fims:ExtensionGroup", &(a->fims__ResourceType::ExtensionGroup), "fims:ExtensionGroup"))
				{	soap_flag_ExtensionGroup3--;
					continue;
				}
			if (soap_flag_ExtensionAttributes3 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTofims__ExtensionAttributes(soap, "fims:ExtensionAttributes", &(a->fims__ResourceType::ExtensionAttributes), "fims:ExtensionAttributes"))
				{	soap_flag_ExtensionAttributes3--;
					continue;
				}
			if (soap_flag_storageType2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTofims__StorageType(soap, "fims:storageType", &(a->fims__BMEssenceLocatorType::storageType), "fims:StorageType"))
				{	soap_flag_storageType2--;
					continue;
				}
			if (soap_flag_locatorInfo2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "fims:locatorInfo", &(a->fims__BMEssenceLocatorType::locatorInfo), "xsd:string"))
				{	soap_flag_locatorInfo2--;
					continue;
				}
			if (soap_flag_containerMimeType2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_fims__BMEssenceLocatorType_containerMimeType(soap, "fims:containerMimeType", &(a->fims__BMEssenceLocatorType::containerMimeType), ""))
				{	soap_flag_containerMimeType2--;
					continue;
				}
			if (soap_flag_status2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTofims__BMEssenceLocatorStatusType(soap, "fims:status", &(a->fims__BMEssenceLocatorType::status), "fims:BMEssenceLocatorStatusType"))
				{	soap_flag_status2--;
					continue;
				}
			if (soap_flag_file1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerToxsd__anyURI(soap, "fims:file", &(a->fims__SimpleFileLocatorType::file), "xsd:anyURI"))
				{	soap_flag_file1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (fims__SimpleFileLocatorType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_fims__SimpleFileLocatorType, 0, sizeof(fims__SimpleFileLocatorType), 0, soap_copy_fims__SimpleFileLocatorType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_resourceID4 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int fims__SimpleFileLocatorType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_fims__SimpleFileLocatorType);
	if (this->soap_out(soap, tag?tag:"fims:SimpleFileLocatorType", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *fims__SimpleFileLocatorType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_fims__SimpleFileLocatorType(soap, this, tag, type);
}

SOAP_FMAC3 fims__SimpleFileLocatorType * SOAP_FMAC4 soap_get_fims__SimpleFileLocatorType(struct soap *soap, fims__SimpleFileLocatorType *p, const char *tag, const char *type)
{
	if ((p = soap_in_fims__SimpleFileLocatorType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 fims__SimpleFileLocatorType * SOAP_FMAC2 soap_instantiate_fims__SimpleFileLocatorType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_fims__SimpleFileLocatorType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_fims__SimpleFileLocatorType, n, EDLProvider_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(fims__SimpleFileLocatorType);
		if (size)
			*size = sizeof(fims__SimpleFileLocatorType);
		((fims__SimpleFileLocatorType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(fims__SimpleFileLocatorType, n);
		if (size)
			*size = n * sizeof(fims__SimpleFileLocatorType);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((fims__SimpleFileLocatorType*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (fims__SimpleFileLocatorType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_fims__SimpleFileLocatorType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying fims__SimpleFileLocatorType %p -> %p\n", q, p));
	*(fims__SimpleFileLocatorType*)p = *(fims__SimpleFileLocatorType*)q;
}

void fims__BMEssenceLocatorType::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->fims__ResourceType::soap_default(soap);
	this->fims__BMEssenceLocatorType::storageType = NULL;
	this->fims__BMEssenceLocatorType::locatorInfo = NULL;
	this->fims__BMEssenceLocatorType::containerMimeType = NULL;
	this->fims__BMEssenceLocatorType::status = NULL;
}

void fims__BMEssenceLocatorType::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTofims__StorageType(soap, &this->fims__BMEssenceLocatorType::storageType);
	soap_serialize_PointerTostd__wstring(soap, &this->fims__BMEssenceLocatorType::locatorInfo);
	soap_serialize_PointerTo_fims__BMEssenceLocatorType_containerMimeType(soap, &this->fims__BMEssenceLocatorType::containerMimeType);
	soap_serialize_PointerTofims__BMEssenceLocatorStatusType(soap, &this->fims__BMEssenceLocatorType::status);
	this->fims__ResourceType::soap_serialize(soap);
#endif
}

int fims__BMEssenceLocatorType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_fims__BMEssenceLocatorType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_fims__BMEssenceLocatorType(struct soap *soap, const char *tag, int id, const fims__BMEssenceLocatorType *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_fims__BMEssenceLocatorType), "fims:BMEssenceLocatorType"))
		return soap->error;
	if (soap_out_fims__ResourceIDType(soap, "fims:resourceID", -1, &(a->fims__ResourceReferenceType::resourceID), ""))
		return soap->error;
	if (soap_out_PointerTofims__RevisionIDType(soap, "fims:revisionID", -1, &(a->fims__ResourceReferenceType::revisionID), ""))
		return soap->error;
	if (soap_out_PointerToxsd__anyURI(soap, "fims:location", -1, &(a->fims__ResourceReferenceType::location), ""))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_PointerTotime(soap, "fims:resourceCreationDate", -1, &(a->fims__ResourceType::resourceCreationDate), ""))
		return soap->error;
	if (soap_out_PointerTotime(soap, "fims:resourceModifiedDate", -1, &(a->fims__ResourceType::resourceModifiedDate), ""))
		return soap->error;
	if (soap_out_PointerTobool(soap, "fims:serviceGeneratedElement", -1, &(a->fims__ResourceType::serviceGeneratedElement), ""))
		return soap->error;
	if (soap_out_PointerTobool(soap, "fims:isFullyPopulated", -1, &(a->fims__ResourceType::isFullyPopulated), ""))
		return soap->error;
	if (soap_out_PointerTofims__AsyncEndpointType(soap, "fims:notifyAt", -1, &(a->fims__ResourceType::notifyAt), ""))
		return soap->error;
	if (soap_out_PointerTofims__ExtensionGroup(soap, "fims:ExtensionGroup", -1, &(a->fims__ResourceType::ExtensionGroup), ""))
		return soap->error;
	if (soap_out_PointerTofims__ExtensionAttributes(soap, "fims:ExtensionAttributes", -1, &(a->fims__ResourceType::ExtensionAttributes), ""))
		return soap->error;
	if (soap_out_PointerTofims__StorageType(soap, "fims:storageType", -1, &(a->fims__BMEssenceLocatorType::storageType), ""))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "fims:locatorInfo", -1, &(a->fims__BMEssenceLocatorType::locatorInfo), ""))
		return soap->error;
	if (soap_out_PointerTo_fims__BMEssenceLocatorType_containerMimeType(soap, "fims:containerMimeType", -1, &(a->fims__BMEssenceLocatorType::containerMimeType), ""))
		return soap->error;
	if (soap_out_PointerTofims__BMEssenceLocatorStatusType(soap, "fims:status", -1, &(a->fims__BMEssenceLocatorType::status), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *fims__BMEssenceLocatorType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_fims__BMEssenceLocatorType(soap, tag, this, type);
}

SOAP_FMAC3 fims__BMEssenceLocatorType * SOAP_FMAC4 soap_in_fims__BMEssenceLocatorType(struct soap *soap, const char *tag, fims__BMEssenceLocatorType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (fims__BMEssenceLocatorType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_fims__BMEssenceLocatorType, sizeof(fims__BMEssenceLocatorType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_fims__BMEssenceLocatorType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (fims__BMEssenceLocatorType *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_resourceID3 = 1;
	size_t soap_flag_revisionID3 = 1;
	size_t soap_flag_location3 = 1;
	size_t soap_flag_resourceCreationDate2 = 1;
	size_t soap_flag_resourceModifiedDate2 = 1;
	size_t soap_flag_serviceGeneratedElement2 = 1;
	size_t soap_flag_isFullyPopulated2 = 1;
	size_t soap_flag_notifyAt2 = 1;
	size_t soap_flag_ExtensionGroup2 = 1;
	size_t soap_flag_ExtensionAttributes2 = 1;
	size_t soap_flag_storageType1 = 1;
	size_t soap_flag_locatorInfo1 = 1;
	size_t soap_flag_containerMimeType1 = 1;
	size_t soap_flag_status1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_resourceID3 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_fims__ResourceIDType(soap, "fims:resourceID", &(a->fims__ResourceReferenceType::resourceID), "fims:ResourceIDType"))
				{	soap_flag_resourceID3--;
					continue;
				}
			if (soap_flag_revisionID3 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTofims__RevisionIDType(soap, "fims:revisionID", &(a->fims__ResourceReferenceType::revisionID), "fims:RevisionIDType"))
				{	soap_flag_revisionID3--;
					continue;
				}
			if (soap_flag_location3 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerToxsd__anyURI(soap, "fims:location", &(a->fims__ResourceReferenceType::location), "xsd:anyURI"))
				{	soap_flag_location3--;
					continue;
				}
			/* transient soap skipped */
			if (soap_flag_resourceCreationDate2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTotime(soap, "fims:resourceCreationDate", &(a->fims__ResourceType::resourceCreationDate), "xsd:dateTime"))
				{	soap_flag_resourceCreationDate2--;
					continue;
				}
			if (soap_flag_resourceModifiedDate2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTotime(soap, "fims:resourceModifiedDate", &(a->fims__ResourceType::resourceModifiedDate), "xsd:dateTime"))
				{	soap_flag_resourceModifiedDate2--;
					continue;
				}
			if (soap_flag_serviceGeneratedElement2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTobool(soap, "fims:serviceGeneratedElement", &(a->fims__ResourceType::serviceGeneratedElement), "xsd:boolean"))
				{	soap_flag_serviceGeneratedElement2--;
					continue;
				}
			if (soap_flag_isFullyPopulated2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTobool(soap, "fims:isFullyPopulated", &(a->fims__ResourceType::isFullyPopulated), "xsd:boolean"))
				{	soap_flag_isFullyPopulated2--;
					continue;
				}
			if (soap_flag_notifyAt2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTofims__AsyncEndpointType(soap, "fims:notifyAt", &(a->fims__ResourceType::notifyAt), "fims:AsyncEndpointType"))
				{	soap_flag_notifyAt2--;
					continue;
				}
			if (soap_flag_ExtensionGroup2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTofims__ExtensionGroup(soap, "fims:ExtensionGroup", &(a->fims__ResourceType::ExtensionGroup), "fims:ExtensionGroup"))
				{	soap_flag_ExtensionGroup2--;
					continue;
				}
			if (soap_flag_ExtensionAttributes2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTofims__ExtensionAttributes(soap, "fims:ExtensionAttributes", &(a->fims__ResourceType::ExtensionAttributes), "fims:ExtensionAttributes"))
				{	soap_flag_ExtensionAttributes2--;
					continue;
				}
			if (soap_flag_storageType1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTofims__StorageType(soap, "fims:storageType", &(a->fims__BMEssenceLocatorType::storageType), "fims:StorageType"))
				{	soap_flag_storageType1--;
					continue;
				}
			if (soap_flag_locatorInfo1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "fims:locatorInfo", &(a->fims__BMEssenceLocatorType::locatorInfo), "xsd:string"))
				{	soap_flag_locatorInfo1--;
					continue;
				}
			if (soap_flag_containerMimeType1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_fims__BMEssenceLocatorType_containerMimeType(soap, "fims:containerMimeType", &(a->fims__BMEssenceLocatorType::containerMimeType), ""))
				{	soap_flag_containerMimeType1--;
					continue;
				}
			if (soap_flag_status1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTofims__BMEssenceLocatorStatusType(soap, "fims:status", &(a->fims__BMEssenceLocatorType::status), "fims:BMEssenceLocatorStatusType"))
				{	soap_flag_status1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (fims__BMEssenceLocatorType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_fims__BMEssenceLocatorType, 0, sizeof(fims__BMEssenceLocatorType), 0, soap_copy_fims__BMEssenceLocatorType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_resourceID3 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int fims__BMEssenceLocatorType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_fims__BMEssenceLocatorType);
	if (this->soap_out(soap, tag?tag:"fims:BMEssenceLocatorType", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *fims__BMEssenceLocatorType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_fims__BMEssenceLocatorType(soap, this, tag, type);
}

SOAP_FMAC3 fims__BMEssenceLocatorType * SOAP_FMAC4 soap_get_fims__BMEssenceLocatorType(struct soap *soap, fims__BMEssenceLocatorType *p, const char *tag, const char *type)
{
	if ((p = soap_in_fims__BMEssenceLocatorType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 fims__BMEssenceLocatorType * SOAP_FMAC2 soap_instantiate_fims__BMEssenceLocatorType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_fims__BMEssenceLocatorType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_fims__BMEssenceLocatorType, n, EDLProvider_fdelete);
	if (!cp)
		return NULL;
	if (type && !soap_match_tag(soap, type, "fims:SimpleFileLocatorType"))
	{	cp->type = SOAP_TYPE_fims__SimpleFileLocatorType;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(fims__SimpleFileLocatorType);
			if (size)
				*size = sizeof(fims__SimpleFileLocatorType);
			((fims__SimpleFileLocatorType*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW_ARRAY(fims__SimpleFileLocatorType, n);
			if (size)
				*size = n * sizeof(fims__SimpleFileLocatorType);
			if (cp->ptr)
				for (int i = 0; i < n; i++)
					((fims__SimpleFileLocatorType*)cp->ptr)[i].soap = soap;
		}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		if (!cp->ptr)
			soap->error = SOAP_EOM;
		return (fims__SimpleFileLocatorType*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "fims:ListFileLocatorType"))
	{	cp->type = SOAP_TYPE_fims__ListFileLocatorType;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(fims__ListFileLocatorType);
			if (size)
				*size = sizeof(fims__ListFileLocatorType);
			((fims__ListFileLocatorType*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW_ARRAY(fims__ListFileLocatorType, n);
			if (size)
				*size = n * sizeof(fims__ListFileLocatorType);
			if (cp->ptr)
				for (int i = 0; i < n; i++)
					((fims__ListFileLocatorType*)cp->ptr)[i].soap = soap;
		}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		if (!cp->ptr)
			soap->error = SOAP_EOM;
		return (fims__ListFileLocatorType*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "fims:FolderLocatorType"))
	{	cp->type = SOAP_TYPE_fims__FolderLocatorType;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(fims__FolderLocatorType);
			if (size)
				*size = sizeof(fims__FolderLocatorType);
			((fims__FolderLocatorType*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW_ARRAY(fims__FolderLocatorType, n);
			if (size)
				*size = n * sizeof(fims__FolderLocatorType);
			if (cp->ptr)
				for (int i = 0; i < n; i++)
					((fims__FolderLocatorType*)cp->ptr)[i].soap = soap;
		}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		if (!cp->ptr)
			soap->error = SOAP_EOM;
		return (fims__FolderLocatorType*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "fims:EssencePlaceholderLocatorType"))
	{	cp->type = SOAP_TYPE_fims__EssencePlaceholderLocatorType;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(fims__EssencePlaceholderLocatorType);
			if (size)
				*size = sizeof(fims__EssencePlaceholderLocatorType);
			((fims__EssencePlaceholderLocatorType*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW_ARRAY(fims__EssencePlaceholderLocatorType, n);
			if (size)
				*size = n * sizeof(fims__EssencePlaceholderLocatorType);
			if (cp->ptr)
				for (int i = 0; i < n; i++)
					((fims__EssencePlaceholderLocatorType*)cp->ptr)[i].soap = soap;
		}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		if (!cp->ptr)
			soap->error = SOAP_EOM;
		return (fims__EssencePlaceholderLocatorType*)cp->ptr;
	}
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(fims__BMEssenceLocatorType);
		if (size)
			*size = sizeof(fims__BMEssenceLocatorType);
		((fims__BMEssenceLocatorType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(fims__BMEssenceLocatorType, n);
		if (size)
			*size = n * sizeof(fims__BMEssenceLocatorType);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((fims__BMEssenceLocatorType*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (fims__BMEssenceLocatorType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_fims__BMEssenceLocatorType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying fims__BMEssenceLocatorType %p -> %p\n", q, p));
	*(fims__BMEssenceLocatorType*)p = *(fims__BMEssenceLocatorType*)q;
}

void fims__BMContentFormatType::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->fims__ResourceType::soap_default(soap);
	this->fims__BMContentFormatType::bmEssenceLocators = NULL;
	this->fims__BMContentFormatType::formatCollection = NULL;
	this->fims__BMContentFormatType::duration = NULL;
	this->fims__BMContentFormatType::hash = NULL;
	this->fims__BMContentFormatType::packageSize = NULL;
	this->fims__BMContentFormatType::mimeType = NULL;
}

void fims__BMContentFormatType::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTofims__BMEssenceLocatorsType(soap, &this->fims__BMContentFormatType::bmEssenceLocators);
	soap_serialize_PointerTo_fims__formatCollection(soap, &this->fims__BMContentFormatType::formatCollection);
	soap_serialize_PointerTofimstime__DurationType(soap, &this->fims__BMContentFormatType::duration);
	soap_serialize_PointerTofims__HashType(soap, &this->fims__BMContentFormatType::hash);
	soap_serialize_PointerTounsignedLONG64(soap, &this->fims__BMContentFormatType::packageSize);
	soap_serialize_PointerTo_fims__BMContentFormatType_mimeType(soap, &this->fims__BMContentFormatType::mimeType);
	this->fims__ResourceType::soap_serialize(soap);
#endif
}

int fims__BMContentFormatType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_fims__BMContentFormatType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_fims__BMContentFormatType(struct soap *soap, const char *tag, int id, const fims__BMContentFormatType *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_fims__BMContentFormatType), "fims:BMContentFormatType"))
		return soap->error;
	if (soap_out_fims__ResourceIDType(soap, "fims:resourceID", -1, &(a->fims__ResourceReferenceType::resourceID), ""))
		return soap->error;
	if (soap_out_PointerTofims__RevisionIDType(soap, "fims:revisionID", -1, &(a->fims__ResourceReferenceType::revisionID), ""))
		return soap->error;
	if (soap_out_PointerToxsd__anyURI(soap, "fims:location", -1, &(a->fims__ResourceReferenceType::location), ""))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_PointerTotime(soap, "fims:resourceCreationDate", -1, &(a->fims__ResourceType::resourceCreationDate), ""))
		return soap->error;
	if (soap_out_PointerTotime(soap, "fims:resourceModifiedDate", -1, &(a->fims__ResourceType::resourceModifiedDate), ""))
		return soap->error;
	if (soap_out_PointerTobool(soap, "fims:serviceGeneratedElement", -1, &(a->fims__ResourceType::serviceGeneratedElement), ""))
		return soap->error;
	if (soap_out_PointerTobool(soap, "fims:isFullyPopulated", -1, &(a->fims__ResourceType::isFullyPopulated), ""))
		return soap->error;
	if (soap_out_PointerTofims__AsyncEndpointType(soap, "fims:notifyAt", -1, &(a->fims__ResourceType::notifyAt), ""))
		return soap->error;
	if (soap_out_PointerTofims__ExtensionGroup(soap, "fims:ExtensionGroup", -1, &(a->fims__ResourceType::ExtensionGroup), ""))
		return soap->error;
	if (soap_out_PointerTofims__ExtensionAttributes(soap, "fims:ExtensionAttributes", -1, &(a->fims__ResourceType::ExtensionAttributes), ""))
		return soap->error;
	if (soap_out_PointerTofims__BMEssenceLocatorsType(soap, "fims:bmEssenceLocators", -1, &(a->fims__BMContentFormatType::bmEssenceLocators), ""))
		return soap->error;
	if (soap_out_PointerTo_fims__formatCollection(soap, "fims:formatCollection", -1, &(a->fims__BMContentFormatType::formatCollection), ""))
		return soap->error;
	if (soap_out_PointerTofimstime__DurationType(soap, "fims:duration", -1, &(a->fims__BMContentFormatType::duration), ""))
		return soap->error;
	if (soap_out_PointerTofims__HashType(soap, "fims:hash", -1, &(a->fims__BMContentFormatType::hash), ""))
		return soap->error;
	if (soap_out_PointerTounsignedLONG64(soap, "fims:packageSize", -1, &(a->fims__BMContentFormatType::packageSize), ""))
		return soap->error;
	if (soap_out_PointerTo_fims__BMContentFormatType_mimeType(soap, "fims:mimeType", -1, &(a->fims__BMContentFormatType::mimeType), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *fims__BMContentFormatType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_fims__BMContentFormatType(soap, tag, this, type);
}

SOAP_FMAC3 fims__BMContentFormatType * SOAP_FMAC4 soap_in_fims__BMContentFormatType(struct soap *soap, const char *tag, fims__BMContentFormatType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (fims__BMContentFormatType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_fims__BMContentFormatType, sizeof(fims__BMContentFormatType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_fims__BMContentFormatType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (fims__BMContentFormatType *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_resourceID3 = 1;
	size_t soap_flag_revisionID3 = 1;
	size_t soap_flag_location3 = 1;
	size_t soap_flag_resourceCreationDate2 = 1;
	size_t soap_flag_resourceModifiedDate2 = 1;
	size_t soap_flag_serviceGeneratedElement2 = 1;
	size_t soap_flag_isFullyPopulated2 = 1;
	size_t soap_flag_notifyAt2 = 1;
	size_t soap_flag_ExtensionGroup2 = 1;
	size_t soap_flag_ExtensionAttributes2 = 1;
	size_t soap_flag_bmEssenceLocators1 = 1;
	size_t soap_flag_formatCollection1 = 1;
	size_t soap_flag_duration1 = 1;
	size_t soap_flag_hash1 = 1;
	size_t soap_flag_packageSize1 = 1;
	size_t soap_flag_mimeType1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_resourceID3 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_fims__ResourceIDType(soap, "fims:resourceID", &(a->fims__ResourceReferenceType::resourceID), "fims:ResourceIDType"))
				{	soap_flag_resourceID3--;
					continue;
				}
			if (soap_flag_revisionID3 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTofims__RevisionIDType(soap, "fims:revisionID", &(a->fims__ResourceReferenceType::revisionID), "fims:RevisionIDType"))
				{	soap_flag_revisionID3--;
					continue;
				}
			if (soap_flag_location3 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerToxsd__anyURI(soap, "fims:location", &(a->fims__ResourceReferenceType::location), "xsd:anyURI"))
				{	soap_flag_location3--;
					continue;
				}
			/* transient soap skipped */
			if (soap_flag_resourceCreationDate2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTotime(soap, "fims:resourceCreationDate", &(a->fims__ResourceType::resourceCreationDate), "xsd:dateTime"))
				{	soap_flag_resourceCreationDate2--;
					continue;
				}
			if (soap_flag_resourceModifiedDate2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTotime(soap, "fims:resourceModifiedDate", &(a->fims__ResourceType::resourceModifiedDate), "xsd:dateTime"))
				{	soap_flag_resourceModifiedDate2--;
					continue;
				}
			if (soap_flag_serviceGeneratedElement2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTobool(soap, "fims:serviceGeneratedElement", &(a->fims__ResourceType::serviceGeneratedElement), "xsd:boolean"))
				{	soap_flag_serviceGeneratedElement2--;
					continue;
				}
			if (soap_flag_isFullyPopulated2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTobool(soap, "fims:isFullyPopulated", &(a->fims__ResourceType::isFullyPopulated), "xsd:boolean"))
				{	soap_flag_isFullyPopulated2--;
					continue;
				}
			if (soap_flag_notifyAt2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTofims__AsyncEndpointType(soap, "fims:notifyAt", &(a->fims__ResourceType::notifyAt), "fims:AsyncEndpointType"))
				{	soap_flag_notifyAt2--;
					continue;
				}
			if (soap_flag_ExtensionGroup2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTofims__ExtensionGroup(soap, "fims:ExtensionGroup", &(a->fims__ResourceType::ExtensionGroup), "fims:ExtensionGroup"))
				{	soap_flag_ExtensionGroup2--;
					continue;
				}
			if (soap_flag_ExtensionAttributes2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTofims__ExtensionAttributes(soap, "fims:ExtensionAttributes", &(a->fims__ResourceType::ExtensionAttributes), "fims:ExtensionAttributes"))
				{	soap_flag_ExtensionAttributes2--;
					continue;
				}
			if (soap_flag_bmEssenceLocators1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTofims__BMEssenceLocatorsType(soap, "fims:bmEssenceLocators", &(a->fims__BMContentFormatType::bmEssenceLocators), "fims:BMEssenceLocatorsType"))
				{	soap_flag_bmEssenceLocators1--;
					continue;
				}
			if (soap_flag_formatCollection1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_fims__formatCollection(soap, "fims:formatCollection", &(a->fims__BMContentFormatType::formatCollection), ""))
				{	soap_flag_formatCollection1--;
					continue;
				}
			if (soap_flag_duration1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTofimstime__DurationType(soap, "fims:duration", &(a->fims__BMContentFormatType::duration), "fimstime:DurationType"))
				{	soap_flag_duration1--;
					continue;
				}
			if (soap_flag_hash1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTofims__HashType(soap, "fims:hash", &(a->fims__BMContentFormatType::hash), "fims:HashType"))
				{	soap_flag_hash1--;
					continue;
				}
			if (soap_flag_packageSize1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTounsignedLONG64(soap, "fims:packageSize", &(a->fims__BMContentFormatType::packageSize), "xsd:unsignedLong"))
				{	soap_flag_packageSize1--;
					continue;
				}
			if (soap_flag_mimeType1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_fims__BMContentFormatType_mimeType(soap, "fims:mimeType", &(a->fims__BMContentFormatType::mimeType), ""))
				{	soap_flag_mimeType1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (fims__BMContentFormatType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_fims__BMContentFormatType, 0, sizeof(fims__BMContentFormatType), 0, soap_copy_fims__BMContentFormatType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_resourceID3 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int fims__BMContentFormatType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_fims__BMContentFormatType);
	if (this->soap_out(soap, tag?tag:"fims:BMContentFormatType", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *fims__BMContentFormatType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_fims__BMContentFormatType(soap, this, tag, type);
}

SOAP_FMAC3 fims__BMContentFormatType * SOAP_FMAC4 soap_get_fims__BMContentFormatType(struct soap *soap, fims__BMContentFormatType *p, const char *tag, const char *type)
{
	if ((p = soap_in_fims__BMContentFormatType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 fims__BMContentFormatType * SOAP_FMAC2 soap_instantiate_fims__BMContentFormatType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_fims__BMContentFormatType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_fims__BMContentFormatType, n, EDLProvider_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(fims__BMContentFormatType);
		if (size)
			*size = sizeof(fims__BMContentFormatType);
		((fims__BMContentFormatType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(fims__BMContentFormatType, n);
		if (size)
			*size = n * sizeof(fims__BMContentFormatType);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((fims__BMContentFormatType*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (fims__BMContentFormatType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_fims__BMContentFormatType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying fims__BMContentFormatType %p -> %p\n", q, p));
	*(fims__BMContentFormatType*)p = *(fims__BMContentFormatType*)q;
}

void fims__DescriptionType::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->fims__ResourceType::soap_default(soap);
	this->fims__DescriptionType::fimsdescription__bmContentDescription = NULL;
}

void fims__DescriptionType::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTofimsdescription__bmContentDescriptionType(soap, &this->fims__DescriptionType::fimsdescription__bmContentDescription);
	this->fims__ResourceType::soap_serialize(soap);
#endif
}

int fims__DescriptionType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_fims__DescriptionType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_fims__DescriptionType(struct soap *soap, const char *tag, int id, const fims__DescriptionType *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_fims__DescriptionType), "fims:DescriptionType"))
		return soap->error;
	if (soap_out_fims__ResourceIDType(soap, "fims:resourceID", -1, &(a->fims__ResourceReferenceType::resourceID), ""))
		return soap->error;
	if (soap_out_PointerTofims__RevisionIDType(soap, "fims:revisionID", -1, &(a->fims__ResourceReferenceType::revisionID), ""))
		return soap->error;
	if (soap_out_PointerToxsd__anyURI(soap, "fims:location", -1, &(a->fims__ResourceReferenceType::location), ""))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_PointerTotime(soap, "fims:resourceCreationDate", -1, &(a->fims__ResourceType::resourceCreationDate), ""))
		return soap->error;
	if (soap_out_PointerTotime(soap, "fims:resourceModifiedDate", -1, &(a->fims__ResourceType::resourceModifiedDate), ""))
		return soap->error;
	if (soap_out_PointerTobool(soap, "fims:serviceGeneratedElement", -1, &(a->fims__ResourceType::serviceGeneratedElement), ""))
		return soap->error;
	if (soap_out_PointerTobool(soap, "fims:isFullyPopulated", -1, &(a->fims__ResourceType::isFullyPopulated), ""))
		return soap->error;
	if (soap_out_PointerTofims__AsyncEndpointType(soap, "fims:notifyAt", -1, &(a->fims__ResourceType::notifyAt), ""))
		return soap->error;
	if (soap_out_PointerTofims__ExtensionGroup(soap, "fims:ExtensionGroup", -1, &(a->fims__ResourceType::ExtensionGroup), ""))
		return soap->error;
	if (soap_out_PointerTofims__ExtensionAttributes(soap, "fims:ExtensionAttributes", -1, &(a->fims__ResourceType::ExtensionAttributes), ""))
		return soap->error;
	if (soap_out_PointerTofimsdescription__bmContentDescriptionType(soap, "fimsdescription:bmContentDescription", -1, &(a->fims__DescriptionType::fimsdescription__bmContentDescription), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *fims__DescriptionType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_fims__DescriptionType(soap, tag, this, type);
}

SOAP_FMAC3 fims__DescriptionType * SOAP_FMAC4 soap_in_fims__DescriptionType(struct soap *soap, const char *tag, fims__DescriptionType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (fims__DescriptionType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_fims__DescriptionType, sizeof(fims__DescriptionType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_fims__DescriptionType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (fims__DescriptionType *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_resourceID3 = 1;
	size_t soap_flag_revisionID3 = 1;
	size_t soap_flag_location3 = 1;
	size_t soap_flag_resourceCreationDate2 = 1;
	size_t soap_flag_resourceModifiedDate2 = 1;
	size_t soap_flag_serviceGeneratedElement2 = 1;
	size_t soap_flag_isFullyPopulated2 = 1;
	size_t soap_flag_notifyAt2 = 1;
	size_t soap_flag_ExtensionGroup2 = 1;
	size_t soap_flag_ExtensionAttributes2 = 1;
	size_t soap_flag_fimsdescription__bmContentDescription1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_resourceID3 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_fims__ResourceIDType(soap, "fims:resourceID", &(a->fims__ResourceReferenceType::resourceID), "fims:ResourceIDType"))
				{	soap_flag_resourceID3--;
					continue;
				}
			if (soap_flag_revisionID3 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTofims__RevisionIDType(soap, "fims:revisionID", &(a->fims__ResourceReferenceType::revisionID), "fims:RevisionIDType"))
				{	soap_flag_revisionID3--;
					continue;
				}
			if (soap_flag_location3 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerToxsd__anyURI(soap, "fims:location", &(a->fims__ResourceReferenceType::location), "xsd:anyURI"))
				{	soap_flag_location3--;
					continue;
				}
			/* transient soap skipped */
			if (soap_flag_resourceCreationDate2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTotime(soap, "fims:resourceCreationDate", &(a->fims__ResourceType::resourceCreationDate), "xsd:dateTime"))
				{	soap_flag_resourceCreationDate2--;
					continue;
				}
			if (soap_flag_resourceModifiedDate2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTotime(soap, "fims:resourceModifiedDate", &(a->fims__ResourceType::resourceModifiedDate), "xsd:dateTime"))
				{	soap_flag_resourceModifiedDate2--;
					continue;
				}
			if (soap_flag_serviceGeneratedElement2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTobool(soap, "fims:serviceGeneratedElement", &(a->fims__ResourceType::serviceGeneratedElement), "xsd:boolean"))
				{	soap_flag_serviceGeneratedElement2--;
					continue;
				}
			if (soap_flag_isFullyPopulated2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTobool(soap, "fims:isFullyPopulated", &(a->fims__ResourceType::isFullyPopulated), "xsd:boolean"))
				{	soap_flag_isFullyPopulated2--;
					continue;
				}
			if (soap_flag_notifyAt2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTofims__AsyncEndpointType(soap, "fims:notifyAt", &(a->fims__ResourceType::notifyAt), "fims:AsyncEndpointType"))
				{	soap_flag_notifyAt2--;
					continue;
				}
			if (soap_flag_ExtensionGroup2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTofims__ExtensionGroup(soap, "fims:ExtensionGroup", &(a->fims__ResourceType::ExtensionGroup), "fims:ExtensionGroup"))
				{	soap_flag_ExtensionGroup2--;
					continue;
				}
			if (soap_flag_ExtensionAttributes2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTofims__ExtensionAttributes(soap, "fims:ExtensionAttributes", &(a->fims__ResourceType::ExtensionAttributes), "fims:ExtensionAttributes"))
				{	soap_flag_ExtensionAttributes2--;
					continue;
				}
			if (soap_flag_fimsdescription__bmContentDescription1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTofimsdescription__bmContentDescriptionType(soap, "fimsdescription:bmContentDescription", &(a->fims__DescriptionType::fimsdescription__bmContentDescription), "fimsdescription:bmContentDescriptionType"))
				{	soap_flag_fimsdescription__bmContentDescription1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (fims__DescriptionType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_fims__DescriptionType, 0, sizeof(fims__DescriptionType), 0, soap_copy_fims__DescriptionType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_resourceID3 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int fims__DescriptionType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_fims__DescriptionType);
	if (this->soap_out(soap, tag?tag:"fims:DescriptionType", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *fims__DescriptionType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_fims__DescriptionType(soap, this, tag, type);
}

SOAP_FMAC3 fims__DescriptionType * SOAP_FMAC4 soap_get_fims__DescriptionType(struct soap *soap, fims__DescriptionType *p, const char *tag, const char *type)
{
	if ((p = soap_in_fims__DescriptionType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 fims__DescriptionType * SOAP_FMAC2 soap_instantiate_fims__DescriptionType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_fims__DescriptionType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_fims__DescriptionType, n, EDLProvider_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(fims__DescriptionType);
		if (size)
			*size = sizeof(fims__DescriptionType);
		((fims__DescriptionType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(fims__DescriptionType, n);
		if (size)
			*size = n * sizeof(fims__DescriptionType);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((fims__DescriptionType*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (fims__DescriptionType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_fims__DescriptionType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying fims__DescriptionType %p -> %p\n", q, p));
	*(fims__DescriptionType*)p = *(fims__DescriptionType*)q;
}

void fims__BMContentType::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->fims__ResourceType::soap_default(soap);
	this->fims__BMContentType::bmContentFormats = NULL;
	this->fims__BMContentType::descriptions = NULL;
	this->fims__BMContentType::status = NULL;
}

void fims__BMContentType::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTofims__BMContentFormatsType(soap, &this->fims__BMContentType::bmContentFormats);
	soap_serialize_PointerTofims__DescriptionsType(soap, &this->fims__BMContentType::descriptions);
	soap_serialize_PointerTofims__BMContentStatusType(soap, &this->fims__BMContentType::status);
	this->fims__ResourceType::soap_serialize(soap);
#endif
}

int fims__BMContentType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_fims__BMContentType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_fims__BMContentType(struct soap *soap, const char *tag, int id, const fims__BMContentType *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_fims__BMContentType), "fims:BMContentType"))
		return soap->error;
	if (soap_out_fims__ResourceIDType(soap, "fims:resourceID", -1, &(a->fims__ResourceReferenceType::resourceID), ""))
		return soap->error;
	if (soap_out_PointerTofims__RevisionIDType(soap, "fims:revisionID", -1, &(a->fims__ResourceReferenceType::revisionID), ""))
		return soap->error;
	if (soap_out_PointerToxsd__anyURI(soap, "fims:location", -1, &(a->fims__ResourceReferenceType::location), ""))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_PointerTotime(soap, "fims:resourceCreationDate", -1, &(a->fims__ResourceType::resourceCreationDate), ""))
		return soap->error;
	if (soap_out_PointerTotime(soap, "fims:resourceModifiedDate", -1, &(a->fims__ResourceType::resourceModifiedDate), ""))
		return soap->error;
	if (soap_out_PointerTobool(soap, "fims:serviceGeneratedElement", -1, &(a->fims__ResourceType::serviceGeneratedElement), ""))
		return soap->error;
	if (soap_out_PointerTobool(soap, "fims:isFullyPopulated", -1, &(a->fims__ResourceType::isFullyPopulated), ""))
		return soap->error;
	if (soap_out_PointerTofims__AsyncEndpointType(soap, "fims:notifyAt", -1, &(a->fims__ResourceType::notifyAt), ""))
		return soap->error;
	if (soap_out_PointerTofims__ExtensionGroup(soap, "fims:ExtensionGroup", -1, &(a->fims__ResourceType::ExtensionGroup), ""))
		return soap->error;
	if (soap_out_PointerTofims__ExtensionAttributes(soap, "fims:ExtensionAttributes", -1, &(a->fims__ResourceType::ExtensionAttributes), ""))
		return soap->error;
	if (soap_out_PointerTofims__BMContentFormatsType(soap, "fims:bmContentFormats", -1, &(a->fims__BMContentType::bmContentFormats), ""))
		return soap->error;
	if (soap_out_PointerTofims__DescriptionsType(soap, "fims:descriptions", -1, &(a->fims__BMContentType::descriptions), ""))
		return soap->error;
	if (soap_out_PointerTofims__BMContentStatusType(soap, "fims:status", -1, &(a->fims__BMContentType::status), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *fims__BMContentType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_fims__BMContentType(soap, tag, this, type);
}

SOAP_FMAC3 fims__BMContentType * SOAP_FMAC4 soap_in_fims__BMContentType(struct soap *soap, const char *tag, fims__BMContentType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (fims__BMContentType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_fims__BMContentType, sizeof(fims__BMContentType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_fims__BMContentType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (fims__BMContentType *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_resourceID3 = 1;
	size_t soap_flag_revisionID3 = 1;
	size_t soap_flag_location3 = 1;
	size_t soap_flag_resourceCreationDate2 = 1;
	size_t soap_flag_resourceModifiedDate2 = 1;
	size_t soap_flag_serviceGeneratedElement2 = 1;
	size_t soap_flag_isFullyPopulated2 = 1;
	size_t soap_flag_notifyAt2 = 1;
	size_t soap_flag_ExtensionGroup2 = 1;
	size_t soap_flag_ExtensionAttributes2 = 1;
	size_t soap_flag_bmContentFormats1 = 1;
	size_t soap_flag_descriptions1 = 1;
	size_t soap_flag_status1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_resourceID3 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_fims__ResourceIDType(soap, "fims:resourceID", &(a->fims__ResourceReferenceType::resourceID), "fims:ResourceIDType"))
				{	soap_flag_resourceID3--;
					continue;
				}
			if (soap_flag_revisionID3 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTofims__RevisionIDType(soap, "fims:revisionID", &(a->fims__ResourceReferenceType::revisionID), "fims:RevisionIDType"))
				{	soap_flag_revisionID3--;
					continue;
				}
			if (soap_flag_location3 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerToxsd__anyURI(soap, "fims:location", &(a->fims__ResourceReferenceType::location), "xsd:anyURI"))
				{	soap_flag_location3--;
					continue;
				}
			/* transient soap skipped */
			if (soap_flag_resourceCreationDate2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTotime(soap, "fims:resourceCreationDate", &(a->fims__ResourceType::resourceCreationDate), "xsd:dateTime"))
				{	soap_flag_resourceCreationDate2--;
					continue;
				}
			if (soap_flag_resourceModifiedDate2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTotime(soap, "fims:resourceModifiedDate", &(a->fims__ResourceType::resourceModifiedDate), "xsd:dateTime"))
				{	soap_flag_resourceModifiedDate2--;
					continue;
				}
			if (soap_flag_serviceGeneratedElement2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTobool(soap, "fims:serviceGeneratedElement", &(a->fims__ResourceType::serviceGeneratedElement), "xsd:boolean"))
				{	soap_flag_serviceGeneratedElement2--;
					continue;
				}
			if (soap_flag_isFullyPopulated2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTobool(soap, "fims:isFullyPopulated", &(a->fims__ResourceType::isFullyPopulated), "xsd:boolean"))
				{	soap_flag_isFullyPopulated2--;
					continue;
				}
			if (soap_flag_notifyAt2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTofims__AsyncEndpointType(soap, "fims:notifyAt", &(a->fims__ResourceType::notifyAt), "fims:AsyncEndpointType"))
				{	soap_flag_notifyAt2--;
					continue;
				}
			if (soap_flag_ExtensionGroup2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTofims__ExtensionGroup(soap, "fims:ExtensionGroup", &(a->fims__ResourceType::ExtensionGroup), "fims:ExtensionGroup"))
				{	soap_flag_ExtensionGroup2--;
					continue;
				}
			if (soap_flag_ExtensionAttributes2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTofims__ExtensionAttributes(soap, "fims:ExtensionAttributes", &(a->fims__ResourceType::ExtensionAttributes), "fims:ExtensionAttributes"))
				{	soap_flag_ExtensionAttributes2--;
					continue;
				}
			if (soap_flag_bmContentFormats1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTofims__BMContentFormatsType(soap, "fims:bmContentFormats", &(a->fims__BMContentType::bmContentFormats), "fims:BMContentFormatsType"))
				{	soap_flag_bmContentFormats1--;
					continue;
				}
			if (soap_flag_descriptions1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTofims__DescriptionsType(soap, "fims:descriptions", &(a->fims__BMContentType::descriptions), "fims:DescriptionsType"))
				{	soap_flag_descriptions1--;
					continue;
				}
			if (soap_flag_status1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTofims__BMContentStatusType(soap, "fims:status", &(a->fims__BMContentType::status), "fims:BMContentStatusType"))
				{	soap_flag_status1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (fims__BMContentType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_fims__BMContentType, 0, sizeof(fims__BMContentType), 0, soap_copy_fims__BMContentType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_resourceID3 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int fims__BMContentType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_fims__BMContentType);
	if (this->soap_out(soap, tag?tag:"fims:BMContentType", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *fims__BMContentType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_fims__BMContentType(soap, this, tag, type);
}

SOAP_FMAC3 fims__BMContentType * SOAP_FMAC4 soap_get_fims__BMContentType(struct soap *soap, fims__BMContentType *p, const char *tag, const char *type)
{
	if ((p = soap_in_fims__BMContentType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 fims__BMContentType * SOAP_FMAC2 soap_instantiate_fims__BMContentType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_fims__BMContentType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_fims__BMContentType, n, EDLProvider_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(fims__BMContentType);
		if (size)
			*size = sizeof(fims__BMContentType);
		((fims__BMContentType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(fims__BMContentType, n);
		if (size)
			*size = n * sizeof(fims__BMContentType);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((fims__BMContentType*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (fims__BMContentType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_fims__BMContentType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying fims__BMContentType %p -> %p\n", q, p));
	*(fims__BMContentType*)p = *(fims__BMContentType*)q;
}

void fims__BMObjectType::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->fims__ResourceType::soap_default(soap);
	this->fims__BMObjectType::bmContents = NULL;
}

void fims__BMObjectType::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTofims__BMContentsType(soap, &this->fims__BMObjectType::bmContents);
	this->fims__ResourceType::soap_serialize(soap);
#endif
}

int fims__BMObjectType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_fims__BMObjectType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_fims__BMObjectType(struct soap *soap, const char *tag, int id, const fims__BMObjectType *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_fims__BMObjectType), "fims:BMObjectType"))
		return soap->error;
	if (soap_out_fims__ResourceIDType(soap, "fims:resourceID", -1, &(a->fims__ResourceReferenceType::resourceID), ""))
		return soap->error;
	if (soap_out_PointerTofims__RevisionIDType(soap, "fims:revisionID", -1, &(a->fims__ResourceReferenceType::revisionID), ""))
		return soap->error;
	if (soap_out_PointerToxsd__anyURI(soap, "fims:location", -1, &(a->fims__ResourceReferenceType::location), ""))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_PointerTotime(soap, "fims:resourceCreationDate", -1, &(a->fims__ResourceType::resourceCreationDate), ""))
		return soap->error;
	if (soap_out_PointerTotime(soap, "fims:resourceModifiedDate", -1, &(a->fims__ResourceType::resourceModifiedDate), ""))
		return soap->error;
	if (soap_out_PointerTobool(soap, "fims:serviceGeneratedElement", -1, &(a->fims__ResourceType::serviceGeneratedElement), ""))
		return soap->error;
	if (soap_out_PointerTobool(soap, "fims:isFullyPopulated", -1, &(a->fims__ResourceType::isFullyPopulated), ""))
		return soap->error;
	if (soap_out_PointerTofims__AsyncEndpointType(soap, "fims:notifyAt", -1, &(a->fims__ResourceType::notifyAt), ""))
		return soap->error;
	if (soap_out_PointerTofims__ExtensionGroup(soap, "fims:ExtensionGroup", -1, &(a->fims__ResourceType::ExtensionGroup), ""))
		return soap->error;
	if (soap_out_PointerTofims__ExtensionAttributes(soap, "fims:ExtensionAttributes", -1, &(a->fims__ResourceType::ExtensionAttributes), ""))
		return soap->error;
	if (soap_out_PointerTofims__BMContentsType(soap, "fims:bmContents", -1, &(a->fims__BMObjectType::bmContents), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *fims__BMObjectType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_fims__BMObjectType(soap, tag, this, type);
}

SOAP_FMAC3 fims__BMObjectType * SOAP_FMAC4 soap_in_fims__BMObjectType(struct soap *soap, const char *tag, fims__BMObjectType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (fims__BMObjectType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_fims__BMObjectType, sizeof(fims__BMObjectType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_fims__BMObjectType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (fims__BMObjectType *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_resourceID3 = 1;
	size_t soap_flag_revisionID3 = 1;
	size_t soap_flag_location3 = 1;
	size_t soap_flag_resourceCreationDate2 = 1;
	size_t soap_flag_resourceModifiedDate2 = 1;
	size_t soap_flag_serviceGeneratedElement2 = 1;
	size_t soap_flag_isFullyPopulated2 = 1;
	size_t soap_flag_notifyAt2 = 1;
	size_t soap_flag_ExtensionGroup2 = 1;
	size_t soap_flag_ExtensionAttributes2 = 1;
	size_t soap_flag_bmContents1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_resourceID3 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_fims__ResourceIDType(soap, "fims:resourceID", &(a->fims__ResourceReferenceType::resourceID), "fims:ResourceIDType"))
				{	soap_flag_resourceID3--;
					continue;
				}
			if (soap_flag_revisionID3 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTofims__RevisionIDType(soap, "fims:revisionID", &(a->fims__ResourceReferenceType::revisionID), "fims:RevisionIDType"))
				{	soap_flag_revisionID3--;
					continue;
				}
			if (soap_flag_location3 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerToxsd__anyURI(soap, "fims:location", &(a->fims__ResourceReferenceType::location), "xsd:anyURI"))
				{	soap_flag_location3--;
					continue;
				}
			/* transient soap skipped */
			if (soap_flag_resourceCreationDate2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTotime(soap, "fims:resourceCreationDate", &(a->fims__ResourceType::resourceCreationDate), "xsd:dateTime"))
				{	soap_flag_resourceCreationDate2--;
					continue;
				}
			if (soap_flag_resourceModifiedDate2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTotime(soap, "fims:resourceModifiedDate", &(a->fims__ResourceType::resourceModifiedDate), "xsd:dateTime"))
				{	soap_flag_resourceModifiedDate2--;
					continue;
				}
			if (soap_flag_serviceGeneratedElement2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTobool(soap, "fims:serviceGeneratedElement", &(a->fims__ResourceType::serviceGeneratedElement), "xsd:boolean"))
				{	soap_flag_serviceGeneratedElement2--;
					continue;
				}
			if (soap_flag_isFullyPopulated2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTobool(soap, "fims:isFullyPopulated", &(a->fims__ResourceType::isFullyPopulated), "xsd:boolean"))
				{	soap_flag_isFullyPopulated2--;
					continue;
				}
			if (soap_flag_notifyAt2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTofims__AsyncEndpointType(soap, "fims:notifyAt", &(a->fims__ResourceType::notifyAt), "fims:AsyncEndpointType"))
				{	soap_flag_notifyAt2--;
					continue;
				}
			if (soap_flag_ExtensionGroup2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTofims__ExtensionGroup(soap, "fims:ExtensionGroup", &(a->fims__ResourceType::ExtensionGroup), "fims:ExtensionGroup"))
				{	soap_flag_ExtensionGroup2--;
					continue;
				}
			if (soap_flag_ExtensionAttributes2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTofims__ExtensionAttributes(soap, "fims:ExtensionAttributes", &(a->fims__ResourceType::ExtensionAttributes), "fims:ExtensionAttributes"))
				{	soap_flag_ExtensionAttributes2--;
					continue;
				}
			if (soap_flag_bmContents1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTofims__BMContentsType(soap, "fims:bmContents", &(a->fims__BMObjectType::bmContents), "fims:BMContentsType"))
				{	soap_flag_bmContents1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (fims__BMObjectType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_fims__BMObjectType, 0, sizeof(fims__BMObjectType), 0, soap_copy_fims__BMObjectType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_resourceID3 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int fims__BMObjectType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_fims__BMObjectType);
	if (this->soap_out(soap, tag?tag:"fims:BMObjectType", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *fims__BMObjectType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_fims__BMObjectType(soap, this, tag, type);
}

SOAP_FMAC3 fims__BMObjectType * SOAP_FMAC4 soap_get_fims__BMObjectType(struct soap *soap, fims__BMObjectType *p, const char *tag, const char *type)
{
	if ((p = soap_in_fims__BMObjectType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 fims__BMObjectType * SOAP_FMAC2 soap_instantiate_fims__BMObjectType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_fims__BMObjectType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_fims__BMObjectType, n, EDLProvider_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(fims__BMObjectType);
		if (size)
			*size = sizeof(fims__BMObjectType);
		((fims__BMObjectType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(fims__BMObjectType, n);
		if (size)
			*size = n * sizeof(fims__BMObjectType);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((fims__BMObjectType*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (fims__BMObjectType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_fims__BMObjectType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying fims__BMObjectType %p -> %p\n", q, p));
	*(fims__BMObjectType*)p = *(fims__BMObjectType*)q;
}

void fims__CodecType::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->fims__CodecType::name = NULL;
	this->fims__CodecType::vendor = NULL;
	this->fims__CodecType::version = NULL;
	this->fims__CodecType::family = NULL;
	this->fims__CodecType::typeLabel = NULL;
	this->fims__CodecType::typeDefinition = NULL;
	this->fims__CodecType::typeLink = NULL;
	/* transient soap skipped */
}

void fims__CodecType::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__wstring(soap, &this->fims__CodecType::name);
	soap_serialize_PointerTostd__wstring(soap, &this->fims__CodecType::vendor);
	soap_serialize_PointerTostd__wstring(soap, &this->fims__CodecType::version);
	soap_serialize_PointerTostd__wstring(soap, &this->fims__CodecType::family);
	/* transient soap skipped */
#endif
}

int fims__CodecType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_fims__CodecType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_fims__CodecType(struct soap *soap, const char *tag, int id, const fims__CodecType *a, const char *type)
{
	if (((fims__CodecType*)a)->typeLabel)
		soap_set_attr(soap, "typeLabel", soap_wchar2s(soap, ((fims__CodecType*)a)->typeLabel->c_str()), 2);
	if (((fims__CodecType*)a)->typeDefinition)
		soap_set_attr(soap, "typeDefinition", soap_wchar2s(soap, ((fims__CodecType*)a)->typeDefinition->c_str()), 2);
	if (((fims__CodecType*)a)->typeLink)
		soap_set_attr(soap, "typeLink", soap_wchar2s(soap, ((fims__CodecType*)a)->typeLink->c_str()), 2);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_fims__CodecType), type))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "fims:name", -1, &(a->fims__CodecType::name), ""))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "fims:vendor", -1, &(a->fims__CodecType::vendor), ""))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "fims:version", -1, &(a->fims__CodecType::version), ""))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "fims:family", -1, &(a->fims__CodecType::family), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *fims__CodecType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_fims__CodecType(soap, tag, this, type);
}

SOAP_FMAC3 fims__CodecType * SOAP_FMAC4 soap_in_fims__CodecType(struct soap *soap, const char *tag, fims__CodecType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (fims__CodecType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_fims__CodecType, sizeof(fims__CodecType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_fims__CodecType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (fims__CodecType *)a->soap_in(soap, tag, type);
		}
	}
	{	const char *t = soap_attr_value(soap, "typeLabel", 0);
		if (t)
		{
			if (!(((fims__CodecType*)a)->typeLabel = (std::wstring *)soap_malloc(soap, sizeof(std::wstring))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			wchar_t *s = NULL;
			if (soap_s2wchar(soap, t, &s, 0, -1))
				return NULL;
			if (s)
			{	((fims__CodecType*)a)->typeLabel = soap_new_std__wstring(soap, -1);
				((fims__CodecType*)a)->typeLabel->assign(s);
			}
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "typeDefinition", 0);
		if (t)
		{
			if (!(((fims__CodecType*)a)->typeDefinition = (std::wstring *)soap_malloc(soap, sizeof(std::wstring))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			wchar_t *s = NULL;
			if (soap_s2wchar(soap, t, &s, 0, -1))
				return NULL;
			if (s)
			{	((fims__CodecType*)a)->typeDefinition = soap_new_std__wstring(soap, -1);
				((fims__CodecType*)a)->typeDefinition->assign(s);
			}
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "typeLink", 0);
		if (t)
		{
			if (!(((fims__CodecType*)a)->typeLink = (std::wstring *)soap_malloc(soap, sizeof(std::wstring))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			wchar_t *s = NULL;
			if (soap_s2wchar(soap, t, &s, 0, -1))
				return NULL;
			if (s)
			{	((fims__CodecType*)a)->typeLink = soap_new_std__wstring(soap, -1);
				((fims__CodecType*)a)->typeLink->assign(s);
			}
		}
		else if (soap->error)
			return NULL;
	}
	size_t soap_flag_name1 = 1;
	size_t soap_flag_vendor1 = 1;
	size_t soap_flag_version1 = 1;
	size_t soap_flag_family1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_name1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "fims:name", &(a->fims__CodecType::name), "xsd:string"))
				{	soap_flag_name1--;
					continue;
				}
			if (soap_flag_vendor1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "fims:vendor", &(a->fims__CodecType::vendor), "xsd:string"))
				{	soap_flag_vendor1--;
					continue;
				}
			if (soap_flag_version1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "fims:version", &(a->fims__CodecType::version), "xsd:string"))
				{	soap_flag_version1--;
					continue;
				}
			if (soap_flag_family1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "fims:family", &(a->fims__CodecType::family), "xsd:string"))
				{	soap_flag_family1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (fims__CodecType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_fims__CodecType, 0, sizeof(fims__CodecType), 0, soap_copy_fims__CodecType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int fims__CodecType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_fims__CodecType);
	if (this->soap_out(soap, tag?tag:"fims:CodecType", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *fims__CodecType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_fims__CodecType(soap, this, tag, type);
}

SOAP_FMAC3 fims__CodecType * SOAP_FMAC4 soap_get_fims__CodecType(struct soap *soap, fims__CodecType *p, const char *tag, const char *type)
{
	if ((p = soap_in_fims__CodecType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 fims__CodecType * SOAP_FMAC2 soap_instantiate_fims__CodecType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_fims__CodecType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_fims__CodecType, n, EDLProvider_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(fims__CodecType);
		if (size)
			*size = sizeof(fims__CodecType);
		((fims__CodecType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(fims__CodecType, n);
		if (size)
			*size = n * sizeof(fims__CodecType);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((fims__CodecType*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (fims__CodecType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_fims__CodecType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying fims__CodecType %p -> %p\n", q, p));
	*(fims__CodecType*)p = *(fims__CodecType*)q;
}

void fims__BMTrackType::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->fims__BMTrackType::ExtensionGroup = NULL;
	this->fims__BMTrackType::ExtensionAttributes = NULL;
	this->fims__BMTrackType::trackID = NULL;
	this->fims__BMTrackType::trackName = NULL;
	this->fims__BMTrackType::language = NULL;
	this->fims__BMTrackType::typeLabel = NULL;
	this->fims__BMTrackType::typeDefinition = NULL;
	this->fims__BMTrackType::typeLink = NULL;
	/* transient soap skipped */
}

void fims__BMTrackType::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTofims__ExtensionGroup(soap, &this->fims__BMTrackType::ExtensionGroup);
	soap_serialize_PointerTofims__ExtensionAttributes(soap, &this->fims__BMTrackType::ExtensionAttributes);
	/* transient soap skipped */
#endif
}

int fims__BMTrackType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_fims__BMTrackType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_fims__BMTrackType(struct soap *soap, const char *tag, int id, const fims__BMTrackType *a, const char *type)
{
	if (((fims__BMTrackType*)a)->trackID)
		soap_set_attr(soap, "trackID", soap_wchar2s(soap, ((fims__BMTrackType*)a)->trackID->c_str()), 2);
	if (((fims__BMTrackType*)a)->trackName)
		soap_set_attr(soap, "trackName", soap_wchar2s(soap, ((fims__BMTrackType*)a)->trackName->c_str()), 2);
	if (((fims__BMTrackType*)a)->language)
		soap_set_attr(soap, "language", soap_wchar2s(soap, ((fims__BMTrackType*)a)->language->c_str()), 2);
	if (((fims__BMTrackType*)a)->typeLabel)
		soap_set_attr(soap, "typeLabel", soap_wchar2s(soap, ((fims__BMTrackType*)a)->typeLabel->c_str()), 2);
	if (((fims__BMTrackType*)a)->typeDefinition)
		soap_set_attr(soap, "typeDefinition", soap_wchar2s(soap, ((fims__BMTrackType*)a)->typeDefinition->c_str()), 2);
	if (((fims__BMTrackType*)a)->typeLink)
		soap_set_attr(soap, "typeLink", soap_wchar2s(soap, ((fims__BMTrackType*)a)->typeLink->c_str()), 2);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_fims__BMTrackType), type))
		return soap->error;
	if (soap_out_PointerTofims__ExtensionGroup(soap, "fims:ExtensionGroup", -1, &(a->fims__BMTrackType::ExtensionGroup), ""))
		return soap->error;
	if (soap_out_PointerTofims__ExtensionAttributes(soap, "fims:ExtensionAttributes", -1, &(a->fims__BMTrackType::ExtensionAttributes), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *fims__BMTrackType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_fims__BMTrackType(soap, tag, this, type);
}

SOAP_FMAC3 fims__BMTrackType * SOAP_FMAC4 soap_in_fims__BMTrackType(struct soap *soap, const char *tag, fims__BMTrackType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (fims__BMTrackType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_fims__BMTrackType, sizeof(fims__BMTrackType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_fims__BMTrackType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (fims__BMTrackType *)a->soap_in(soap, tag, type);
		}
	}
	{	const char *t = soap_attr_value(soap, "trackID", 0);
		if (t)
		{
			if (!(((fims__BMTrackType*)a)->trackID = (std::wstring *)soap_malloc(soap, sizeof(std::wstring))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			wchar_t *s = NULL;
			if (soap_s2wchar(soap, t, &s, 0, -1))
				return NULL;
			if (s)
			{	((fims__BMTrackType*)a)->trackID = soap_new_std__wstring(soap, -1);
				((fims__BMTrackType*)a)->trackID->assign(s);
			}
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "trackName", 0);
		if (t)
		{
			if (!(((fims__BMTrackType*)a)->trackName = (std::wstring *)soap_malloc(soap, sizeof(std::wstring))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			wchar_t *s = NULL;
			if (soap_s2wchar(soap, t, &s, 0, -1))
				return NULL;
			if (s)
			{	((fims__BMTrackType*)a)->trackName = soap_new_std__wstring(soap, -1);
				((fims__BMTrackType*)a)->trackName->assign(s);
			}
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "language", 0);
		if (t)
		{
			if (!(((fims__BMTrackType*)a)->language = (std::wstring *)soap_malloc(soap, sizeof(std::wstring))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			wchar_t *s = NULL;
			if (soap_s2wchar(soap, t, &s, 0, -1))
				return NULL;
			if (s)
			{	((fims__BMTrackType*)a)->language = soap_new_std__wstring(soap, -1);
				((fims__BMTrackType*)a)->language->assign(s);
			}
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "typeLabel", 0);
		if (t)
		{
			if (!(((fims__BMTrackType*)a)->typeLabel = (std::wstring *)soap_malloc(soap, sizeof(std::wstring))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			wchar_t *s = NULL;
			if (soap_s2wchar(soap, t, &s, 0, -1))
				return NULL;
			if (s)
			{	((fims__BMTrackType*)a)->typeLabel = soap_new_std__wstring(soap, -1);
				((fims__BMTrackType*)a)->typeLabel->assign(s);
			}
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "typeDefinition", 0);
		if (t)
		{
			if (!(((fims__BMTrackType*)a)->typeDefinition = (std::wstring *)soap_malloc(soap, sizeof(std::wstring))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			wchar_t *s = NULL;
			if (soap_s2wchar(soap, t, &s, 0, -1))
				return NULL;
			if (s)
			{	((fims__BMTrackType*)a)->typeDefinition = soap_new_std__wstring(soap, -1);
				((fims__BMTrackType*)a)->typeDefinition->assign(s);
			}
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "typeLink", 0);
		if (t)
		{
			if (!(((fims__BMTrackType*)a)->typeLink = (std::wstring *)soap_malloc(soap, sizeof(std::wstring))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			wchar_t *s = NULL;
			if (soap_s2wchar(soap, t, &s, 0, -1))
				return NULL;
			if (s)
			{	((fims__BMTrackType*)a)->typeLink = soap_new_std__wstring(soap, -1);
				((fims__BMTrackType*)a)->typeLink->assign(s);
			}
		}
		else if (soap->error)
			return NULL;
	}
	size_t soap_flag_ExtensionGroup1 = 1;
	size_t soap_flag_ExtensionAttributes1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ExtensionGroup1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTofims__ExtensionGroup(soap, "fims:ExtensionGroup", &(a->fims__BMTrackType::ExtensionGroup), "fims:ExtensionGroup"))
				{	soap_flag_ExtensionGroup1--;
					continue;
				}
			if (soap_flag_ExtensionAttributes1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTofims__ExtensionAttributes(soap, "fims:ExtensionAttributes", &(a->fims__BMTrackType::ExtensionAttributes), "fims:ExtensionAttributes"))
				{	soap_flag_ExtensionAttributes1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (fims__BMTrackType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_fims__BMTrackType, 0, sizeof(fims__BMTrackType), 0, soap_copy_fims__BMTrackType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int fims__BMTrackType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_fims__BMTrackType);
	if (this->soap_out(soap, tag?tag:"fims:BMTrackType", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *fims__BMTrackType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_fims__BMTrackType(soap, this, tag, type);
}

SOAP_FMAC3 fims__BMTrackType * SOAP_FMAC4 soap_get_fims__BMTrackType(struct soap *soap, fims__BMTrackType *p, const char *tag, const char *type)
{
	if ((p = soap_in_fims__BMTrackType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 fims__BMTrackType * SOAP_FMAC2 soap_instantiate_fims__BMTrackType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_fims__BMTrackType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_fims__BMTrackType, n, EDLProvider_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(fims__BMTrackType);
		if (size)
			*size = sizeof(fims__BMTrackType);
		((fims__BMTrackType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(fims__BMTrackType, n);
		if (size)
			*size = n * sizeof(fims__BMTrackType);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((fims__BMTrackType*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (fims__BMTrackType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_fims__BMTrackType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying fims__BMTrackType %p -> %p\n", q, p));
	*(fims__BMTrackType*)p = *(fims__BMTrackType*)q;
}

void fims__ContainerFormatType::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->fims__FormatType::soap_default(soap);
	this->fims__ContainerFormatType::containerFormat = NULL;
}

void fims__ContainerFormatType::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTo_fims__ContainerFormatType_containerFormat(soap, &this->fims__ContainerFormatType::containerFormat);
	this->fims__FormatType::soap_serialize(soap);
#endif
}

int fims__ContainerFormatType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_fims__ContainerFormatType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_fims__ContainerFormatType(struct soap *soap, const char *tag, int id, const fims__ContainerFormatType *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_fims__ContainerFormatType), "fims:ContainerFormatType"))
		return soap->error;
	if (soap_out_fims__ResourceIDType(soap, "fims:resourceID", -1, &(a->fims__ResourceReferenceType::resourceID), ""))
		return soap->error;
	if (soap_out_PointerTofims__RevisionIDType(soap, "fims:revisionID", -1, &(a->fims__ResourceReferenceType::revisionID), ""))
		return soap->error;
	if (soap_out_PointerToxsd__anyURI(soap, "fims:location", -1, &(a->fims__ResourceReferenceType::location), ""))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_PointerTotime(soap, "fims:resourceCreationDate", -1, &(a->fims__ResourceType::resourceCreationDate), ""))
		return soap->error;
	if (soap_out_PointerTotime(soap, "fims:resourceModifiedDate", -1, &(a->fims__ResourceType::resourceModifiedDate), ""))
		return soap->error;
	if (soap_out_PointerTobool(soap, "fims:serviceGeneratedElement", -1, &(a->fims__ResourceType::serviceGeneratedElement), ""))
		return soap->error;
	if (soap_out_PointerTobool(soap, "fims:isFullyPopulated", -1, &(a->fims__ResourceType::isFullyPopulated), ""))
		return soap->error;
	if (soap_out_PointerTofims__AsyncEndpointType(soap, "fims:notifyAt", -1, &(a->fims__ResourceType::notifyAt), ""))
		return soap->error;
	if (soap_out_PointerTofims__ExtensionGroup(soap, "fims:ExtensionGroup", -1, &(a->fims__ResourceType::ExtensionGroup), ""))
		return soap->error;
	if (soap_out_PointerTofims__ExtensionAttributes(soap, "fims:ExtensionAttributes", -1, &(a->fims__ResourceType::ExtensionAttributes), ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTofims__TechnicalAttributeType(soap, "fims:technicalAttribute", -1, &(a->fims__FormatType::technicalAttribute), ""))
		return soap->error;
	if (soap_out_PointerTo_fims__ContainerFormatType_containerFormat(soap, "fims:containerFormat", -1, &(a->fims__ContainerFormatType::containerFormat), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *fims__ContainerFormatType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_fims__ContainerFormatType(soap, tag, this, type);
}

SOAP_FMAC3 fims__ContainerFormatType * SOAP_FMAC4 soap_in_fims__ContainerFormatType(struct soap *soap, const char *tag, fims__ContainerFormatType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (fims__ContainerFormatType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_fims__ContainerFormatType, sizeof(fims__ContainerFormatType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_fims__ContainerFormatType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (fims__ContainerFormatType *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_resourceID4 = 1;
	size_t soap_flag_revisionID4 = 1;
	size_t soap_flag_location4 = 1;
	size_t soap_flag_resourceCreationDate3 = 1;
	size_t soap_flag_resourceModifiedDate3 = 1;
	size_t soap_flag_serviceGeneratedElement3 = 1;
	size_t soap_flag_isFullyPopulated3 = 1;
	size_t soap_flag_notifyAt3 = 1;
	size_t soap_flag_ExtensionGroup3 = 1;
	size_t soap_flag_ExtensionAttributes3 = 1;
	size_t soap_flag_containerFormat1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_resourceID4 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_fims__ResourceIDType(soap, "fims:resourceID", &(a->fims__ResourceReferenceType::resourceID), "fims:ResourceIDType"))
				{	soap_flag_resourceID4--;
					continue;
				}
			if (soap_flag_revisionID4 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTofims__RevisionIDType(soap, "fims:revisionID", &(a->fims__ResourceReferenceType::revisionID), "fims:RevisionIDType"))
				{	soap_flag_revisionID4--;
					continue;
				}
			if (soap_flag_location4 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerToxsd__anyURI(soap, "fims:location", &(a->fims__ResourceReferenceType::location), "xsd:anyURI"))
				{	soap_flag_location4--;
					continue;
				}
			/* transient soap skipped */
			if (soap_flag_resourceCreationDate3 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTotime(soap, "fims:resourceCreationDate", &(a->fims__ResourceType::resourceCreationDate), "xsd:dateTime"))
				{	soap_flag_resourceCreationDate3--;
					continue;
				}
			if (soap_flag_resourceModifiedDate3 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTotime(soap, "fims:resourceModifiedDate", &(a->fims__ResourceType::resourceModifiedDate), "xsd:dateTime"))
				{	soap_flag_resourceModifiedDate3--;
					continue;
				}
			if (soap_flag_serviceGeneratedElement3 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTobool(soap, "fims:serviceGeneratedElement", &(a->fims__ResourceType::serviceGeneratedElement), "xsd:boolean"))
				{	soap_flag_serviceGeneratedElement3--;
					continue;
				}
			if (soap_flag_isFullyPopulated3 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTobool(soap, "fims:isFullyPopulated", &(a->fims__ResourceType::isFullyPopulated), "xsd:boolean"))
				{	soap_flag_isFullyPopulated3--;
					continue;
				}
			if (soap_flag_notifyAt3 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTofims__AsyncEndpointType(soap, "fims:notifyAt", &(a->fims__ResourceType::notifyAt), "fims:AsyncEndpointType"))
				{	soap_flag_notifyAt3--;
					continue;
				}
			if (soap_flag_ExtensionGroup3 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTofims__ExtensionGroup(soap, "fims:ExtensionGroup", &(a->fims__ResourceType::ExtensionGroup), "fims:ExtensionGroup"))
				{	soap_flag_ExtensionGroup3--;
					continue;
				}
			if (soap_flag_ExtensionAttributes3 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTofims__ExtensionAttributes(soap, "fims:ExtensionAttributes", &(a->fims__ResourceType::ExtensionAttributes), "fims:ExtensionAttributes"))
				{	soap_flag_ExtensionAttributes3--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTofims__TechnicalAttributeType(soap, "fims:technicalAttribute", &(a->fims__FormatType::technicalAttribute), "fims:TechnicalAttributeType"))
					continue;
			if (soap_flag_containerFormat1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_fims__ContainerFormatType_containerFormat(soap, "fims:containerFormat", &(a->fims__ContainerFormatType::containerFormat), ""))
				{	soap_flag_containerFormat1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (fims__ContainerFormatType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_fims__ContainerFormatType, 0, sizeof(fims__ContainerFormatType), 0, soap_copy_fims__ContainerFormatType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_resourceID4 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int fims__ContainerFormatType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_fims__ContainerFormatType);
	if (this->soap_out(soap, tag?tag:"fims:ContainerFormatType", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *fims__ContainerFormatType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_fims__ContainerFormatType(soap, this, tag, type);
}

SOAP_FMAC3 fims__ContainerFormatType * SOAP_FMAC4 soap_get_fims__ContainerFormatType(struct soap *soap, fims__ContainerFormatType *p, const char *tag, const char *type)
{
	if ((p = soap_in_fims__ContainerFormatType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 fims__ContainerFormatType * SOAP_FMAC2 soap_instantiate_fims__ContainerFormatType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_fims__ContainerFormatType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_fims__ContainerFormatType, n, EDLProvider_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(fims__ContainerFormatType);
		if (size)
			*size = sizeof(fims__ContainerFormatType);
		((fims__ContainerFormatType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(fims__ContainerFormatType, n);
		if (size)
			*size = n * sizeof(fims__ContainerFormatType);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((fims__ContainerFormatType*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (fims__ContainerFormatType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_fims__ContainerFormatType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying fims__ContainerFormatType %p -> %p\n", q, p));
	*(fims__ContainerFormatType*)p = *(fims__ContainerFormatType*)q;
}

void fims__AncillaryDataFormatType::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->fims__AncillaryDataFormatType::DID = NULL;
	this->fims__AncillaryDataFormatType::SDID = NULL;
	this->fims__AncillaryDataFormatType::lineNumber = NULL;
	this->fims__AncillaryDataFormatType::wrappingType = NULL;
	this->fims__AncillaryDataFormatType::ExtensionGroup = NULL;
	this->fims__AncillaryDataFormatType::ExtensionAttributes = NULL;
	/* transient soap skipped */
}

void fims__AncillaryDataFormatType::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerToxsd__integer(soap, &this->fims__AncillaryDataFormatType::DID);
	soap_serialize_PointerToxsd__integer(soap, &this->fims__AncillaryDataFormatType::SDID);
	soap_serialize_PointerToxsd__integer(soap, &this->fims__AncillaryDataFormatType::lineNumber);
	soap_serialize_PointerToxsd__integer(soap, &this->fims__AncillaryDataFormatType::wrappingType);
	soap_serialize_PointerTofims__ExtensionGroup(soap, &this->fims__AncillaryDataFormatType::ExtensionGroup);
	soap_serialize_PointerTofims__ExtensionAttributes(soap, &this->fims__AncillaryDataFormatType::ExtensionAttributes);
	/* transient soap skipped */
#endif
}

int fims__AncillaryDataFormatType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_fims__AncillaryDataFormatType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_fims__AncillaryDataFormatType(struct soap *soap, const char *tag, int id, const fims__AncillaryDataFormatType *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_fims__AncillaryDataFormatType), type))
		return soap->error;
	if (soap_out_PointerToxsd__integer(soap, "fims:DID", -1, &(a->fims__AncillaryDataFormatType::DID), ""))
		return soap->error;
	if (soap_out_PointerToxsd__integer(soap, "fims:SDID", -1, &(a->fims__AncillaryDataFormatType::SDID), ""))
		return soap->error;
	if (soap_out_PointerToxsd__integer(soap, "fims:lineNumber", -1, &(a->fims__AncillaryDataFormatType::lineNumber), ""))
		return soap->error;
	if (soap_out_PointerToxsd__integer(soap, "fims:wrappingType", -1, &(a->fims__AncillaryDataFormatType::wrappingType), ""))
		return soap->error;
	if (soap_out_PointerTofims__ExtensionGroup(soap, "fims:ExtensionGroup", -1, &(a->fims__AncillaryDataFormatType::ExtensionGroup), ""))
		return soap->error;
	if (soap_out_PointerTofims__ExtensionAttributes(soap, "fims:ExtensionAttributes", -1, &(a->fims__AncillaryDataFormatType::ExtensionAttributes), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *fims__AncillaryDataFormatType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_fims__AncillaryDataFormatType(soap, tag, this, type);
}

SOAP_FMAC3 fims__AncillaryDataFormatType * SOAP_FMAC4 soap_in_fims__AncillaryDataFormatType(struct soap *soap, const char *tag, fims__AncillaryDataFormatType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (fims__AncillaryDataFormatType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_fims__AncillaryDataFormatType, sizeof(fims__AncillaryDataFormatType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_fims__AncillaryDataFormatType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (fims__AncillaryDataFormatType *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_DID1 = 1;
	size_t soap_flag_SDID1 = 1;
	size_t soap_flag_lineNumber1 = 1;
	size_t soap_flag_wrappingType1 = 1;
	size_t soap_flag_ExtensionGroup1 = 1;
	size_t soap_flag_ExtensionAttributes1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_DID1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerToxsd__integer(soap, "fims:DID", &(a->fims__AncillaryDataFormatType::DID), "xsd:integer"))
				{	soap_flag_DID1--;
					continue;
				}
			if (soap_flag_SDID1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerToxsd__integer(soap, "fims:SDID", &(a->fims__AncillaryDataFormatType::SDID), "xsd:integer"))
				{	soap_flag_SDID1--;
					continue;
				}
			if (soap_flag_lineNumber1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerToxsd__integer(soap, "fims:lineNumber", &(a->fims__AncillaryDataFormatType::lineNumber), "xsd:integer"))
				{	soap_flag_lineNumber1--;
					continue;
				}
			if (soap_flag_wrappingType1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerToxsd__integer(soap, "fims:wrappingType", &(a->fims__AncillaryDataFormatType::wrappingType), "xsd:integer"))
				{	soap_flag_wrappingType1--;
					continue;
				}
			if (soap_flag_ExtensionGroup1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTofims__ExtensionGroup(soap, "fims:ExtensionGroup", &(a->fims__AncillaryDataFormatType::ExtensionGroup), "fims:ExtensionGroup"))
				{	soap_flag_ExtensionGroup1--;
					continue;
				}
			if (soap_flag_ExtensionAttributes1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTofims__ExtensionAttributes(soap, "fims:ExtensionAttributes", &(a->fims__AncillaryDataFormatType::ExtensionAttributes), "fims:ExtensionAttributes"))
				{	soap_flag_ExtensionAttributes1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (fims__AncillaryDataFormatType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_fims__AncillaryDataFormatType, 0, sizeof(fims__AncillaryDataFormatType), 0, soap_copy_fims__AncillaryDataFormatType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int fims__AncillaryDataFormatType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_fims__AncillaryDataFormatType);
	if (this->soap_out(soap, tag?tag:"fims:AncillaryDataFormatType", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *fims__AncillaryDataFormatType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_fims__AncillaryDataFormatType(soap, this, tag, type);
}

SOAP_FMAC3 fims__AncillaryDataFormatType * SOAP_FMAC4 soap_get_fims__AncillaryDataFormatType(struct soap *soap, fims__AncillaryDataFormatType *p, const char *tag, const char *type)
{
	if ((p = soap_in_fims__AncillaryDataFormatType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 fims__AncillaryDataFormatType * SOAP_FMAC2 soap_instantiate_fims__AncillaryDataFormatType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_fims__AncillaryDataFormatType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_fims__AncillaryDataFormatType, n, EDLProvider_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(fims__AncillaryDataFormatType);
		if (size)
			*size = sizeof(fims__AncillaryDataFormatType);
		((fims__AncillaryDataFormatType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(fims__AncillaryDataFormatType, n);
		if (size)
			*size = n * sizeof(fims__AncillaryDataFormatType);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((fims__AncillaryDataFormatType*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (fims__AncillaryDataFormatType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_fims__AncillaryDataFormatType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying fims__AncillaryDataFormatType %p -> %p\n", q, p));
	*(fims__AncillaryDataFormatType*)p = *(fims__AncillaryDataFormatType*)q;
}

void fims__CaptioningFormatType::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__wstring(soap, &this->fims__CaptioningFormatType::__item);
	this->fims__CaptioningFormatType::captioningSourceUri = NULL;
	this->fims__CaptioningFormatType::language = NULL;
	this->fims__CaptioningFormatType::formatLabel = NULL;
	this->fims__CaptioningFormatType::formatDefinition = NULL;
	this->fims__CaptioningFormatType::formatLink = NULL;
	this->fims__CaptioningFormatType::__anyAttribute = NULL;
	/* transient soap skipped */
}

void fims__CaptioningFormatType::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &this->fims__CaptioningFormatType::__item, SOAP_TYPE_std__wstring);
	soap_serialize_std__wstring(soap, &this->fims__CaptioningFormatType::__item);
	/* transient soap skipped */
#endif
}

int fims__CaptioningFormatType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_fims__CaptioningFormatType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_fims__CaptioningFormatType(struct soap *soap, const char *tag, int id, const fims__CaptioningFormatType *a, const char *type)
{
	if (((fims__CaptioningFormatType*)a)->captioningSourceUri)
		soap_set_attr(soap, "captioningSourceUri", soap_wchar2s(soap, ((fims__CaptioningFormatType*)a)->captioningSourceUri->c_str()), 2);
	if (((fims__CaptioningFormatType*)a)->language)
		soap_set_attr(soap, "language", soap_wchar2s(soap, ((fims__CaptioningFormatType*)a)->language->c_str()), 2);
	if (((fims__CaptioningFormatType*)a)->formatLabel)
		soap_set_attr(soap, "formatLabel", soap_wchar2s(soap, ((fims__CaptioningFormatType*)a)->formatLabel->c_str()), 2);
	if (((fims__CaptioningFormatType*)a)->formatDefinition)
		soap_set_attr(soap, "formatDefinition", soap_wchar2s(soap, ((fims__CaptioningFormatType*)a)->formatDefinition->c_str()), 2);
	if (((fims__CaptioningFormatType*)a)->formatLink)
		soap_set_attr(soap, "formatLink", soap_wchar2s(soap, ((fims__CaptioningFormatType*)a)->formatLink->c_str()), 2);
	if (((fims__CaptioningFormatType*)a)->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", ((fims__CaptioningFormatType*)a)->__anyAttribute, 1);
	return soap_out_std__wstring(soap, tag, id, &a->fims__CaptioningFormatType::__item, "");
}

void *fims__CaptioningFormatType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_fims__CaptioningFormatType(soap, tag, this, type);
}

SOAP_FMAC3 fims__CaptioningFormatType * SOAP_FMAC4 soap_in_fims__CaptioningFormatType(struct soap *soap, const char *tag, fims__CaptioningFormatType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (fims__CaptioningFormatType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_fims__CaptioningFormatType, sizeof(fims__CaptioningFormatType), soap->type, soap->arrayType)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_fims__CaptioningFormatType)
			return (fims__CaptioningFormatType *)a->soap_in(soap, tag, type);
	}
	{	const char *t = soap_attr_value(soap, "captioningSourceUri", 0);
		if (t)
		{
			if (!(((fims__CaptioningFormatType*)a)->captioningSourceUri = (std::wstring *)soap_malloc(soap, sizeof(std::wstring))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			wchar_t *s = NULL;
			if (soap_s2wchar(soap, t, &s, 0, -1))
				return NULL;
			if (s)
			{	((fims__CaptioningFormatType*)a)->captioningSourceUri = soap_new_std__wstring(soap, -1);
				((fims__CaptioningFormatType*)a)->captioningSourceUri->assign(s);
			}
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "language", 0);
		if (t)
		{
			if (!(((fims__CaptioningFormatType*)a)->language = (std::wstring *)soap_malloc(soap, sizeof(std::wstring))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			wchar_t *s = NULL;
			if (soap_s2wchar(soap, t, &s, 0, -1))
				return NULL;
			if (s)
			{	((fims__CaptioningFormatType*)a)->language = soap_new_std__wstring(soap, -1);
				((fims__CaptioningFormatType*)a)->language->assign(s);
			}
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "formatLabel", 0);
		if (t)
		{
			if (!(((fims__CaptioningFormatType*)a)->formatLabel = (std::wstring *)soap_malloc(soap, sizeof(std::wstring))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			wchar_t *s = NULL;
			if (soap_s2wchar(soap, t, &s, 0, -1))
				return NULL;
			if (s)
			{	((fims__CaptioningFormatType*)a)->formatLabel = soap_new_std__wstring(soap, -1);
				((fims__CaptioningFormatType*)a)->formatLabel->assign(s);
			}
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "formatDefinition", 0);
		if (t)
		{
			if (!(((fims__CaptioningFormatType*)a)->formatDefinition = (std::wstring *)soap_malloc(soap, sizeof(std::wstring))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			wchar_t *s = NULL;
			if (soap_s2wchar(soap, t, &s, 0, -1))
				return NULL;
			if (s)
			{	((fims__CaptioningFormatType*)a)->formatDefinition = soap_new_std__wstring(soap, -1);
				((fims__CaptioningFormatType*)a)->formatDefinition->assign(s);
			}
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "formatLink", 0);
		if (t)
		{
			if (!(((fims__CaptioningFormatType*)a)->formatLink = (std::wstring *)soap_malloc(soap, sizeof(std::wstring))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			wchar_t *s = NULL;
			if (soap_s2wchar(soap, t, &s, 0, -1))
				return NULL;
			if (s)
			{	((fims__CaptioningFormatType*)a)->formatLink = soap_new_std__wstring(soap, -1);
				((fims__CaptioningFormatType*)a)->formatLink->assign(s);
			}
		}
		else if (soap->error)
			return NULL;
	}
	if (soap_s2string(soap, soap_attr_value(soap, "-anyAttribute", 0), &((fims__CaptioningFormatType*)a)->__anyAttribute, 0, -1))
		return NULL;
	if (!soap_in_std__wstring(soap, tag, &(a->fims__CaptioningFormatType::__item), "fims:CaptioningFormatType"))
		return NULL;
	return a;
}

int fims__CaptioningFormatType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_fims__CaptioningFormatType);
	if (this->soap_out(soap, tag?tag:"fims:CaptioningFormatType", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *fims__CaptioningFormatType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_fims__CaptioningFormatType(soap, this, tag, type);
}

SOAP_FMAC3 fims__CaptioningFormatType * SOAP_FMAC4 soap_get_fims__CaptioningFormatType(struct soap *soap, fims__CaptioningFormatType *p, const char *tag, const char *type)
{
	if ((p = soap_in_fims__CaptioningFormatType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 fims__CaptioningFormatType * SOAP_FMAC2 soap_instantiate_fims__CaptioningFormatType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_fims__CaptioningFormatType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_fims__CaptioningFormatType, n, EDLProvider_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(fims__CaptioningFormatType);
		if (size)
			*size = sizeof(fims__CaptioningFormatType);
		((fims__CaptioningFormatType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(fims__CaptioningFormatType, n);
		if (size)
			*size = n * sizeof(fims__CaptioningFormatType);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((fims__CaptioningFormatType*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (fims__CaptioningFormatType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_fims__CaptioningFormatType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying fims__CaptioningFormatType %p -> %p\n", q, p));
	*(fims__CaptioningFormatType*)p = *(fims__CaptioningFormatType*)q;
}

void fims__DataFormatType::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->fims__FormatType::soap_default(soap);
	soap_default_std__vectorTemplateOfPointerTofims__CaptioningFormatType(soap, &this->fims__DataFormatType::captioningFormat);
	soap_default_std__vectorTemplateOfPointerTofims__AncillaryDataFormatType(soap, &this->fims__DataFormatType::ancillaryDataFormat);
}

void fims__DataFormatType::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfPointerTofims__CaptioningFormatType(soap, &this->fims__DataFormatType::captioningFormat);
	soap_serialize_std__vectorTemplateOfPointerTofims__AncillaryDataFormatType(soap, &this->fims__DataFormatType::ancillaryDataFormat);
	this->fims__FormatType::soap_serialize(soap);
#endif
}

int fims__DataFormatType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_fims__DataFormatType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_fims__DataFormatType(struct soap *soap, const char *tag, int id, const fims__DataFormatType *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_fims__DataFormatType), "fims:DataFormatType"))
		return soap->error;
	if (soap_out_fims__ResourceIDType(soap, "fims:resourceID", -1, &(a->fims__ResourceReferenceType::resourceID), ""))
		return soap->error;
	if (soap_out_PointerTofims__RevisionIDType(soap, "fims:revisionID", -1, &(a->fims__ResourceReferenceType::revisionID), ""))
		return soap->error;
	if (soap_out_PointerToxsd__anyURI(soap, "fims:location", -1, &(a->fims__ResourceReferenceType::location), ""))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_PointerTotime(soap, "fims:resourceCreationDate", -1, &(a->fims__ResourceType::resourceCreationDate), ""))
		return soap->error;
	if (soap_out_PointerTotime(soap, "fims:resourceModifiedDate", -1, &(a->fims__ResourceType::resourceModifiedDate), ""))
		return soap->error;
	if (soap_out_PointerTobool(soap, "fims:serviceGeneratedElement", -1, &(a->fims__ResourceType::serviceGeneratedElement), ""))
		return soap->error;
	if (soap_out_PointerTobool(soap, "fims:isFullyPopulated", -1, &(a->fims__ResourceType::isFullyPopulated), ""))
		return soap->error;
	if (soap_out_PointerTofims__AsyncEndpointType(soap, "fims:notifyAt", -1, &(a->fims__ResourceType::notifyAt), ""))
		return soap->error;
	if (soap_out_PointerTofims__ExtensionGroup(soap, "fims:ExtensionGroup", -1, &(a->fims__ResourceType::ExtensionGroup), ""))
		return soap->error;
	if (soap_out_PointerTofims__ExtensionAttributes(soap, "fims:ExtensionAttributes", -1, &(a->fims__ResourceType::ExtensionAttributes), ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTofims__TechnicalAttributeType(soap, "fims:technicalAttribute", -1, &(a->fims__FormatType::technicalAttribute), ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTofims__CaptioningFormatType(soap, "fims:captioningFormat", -1, &(a->fims__DataFormatType::captioningFormat), ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTofims__AncillaryDataFormatType(soap, "fims:ancillaryDataFormat", -1, &(a->fims__DataFormatType::ancillaryDataFormat), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *fims__DataFormatType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_fims__DataFormatType(soap, tag, this, type);
}

SOAP_FMAC3 fims__DataFormatType * SOAP_FMAC4 soap_in_fims__DataFormatType(struct soap *soap, const char *tag, fims__DataFormatType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (fims__DataFormatType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_fims__DataFormatType, sizeof(fims__DataFormatType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_fims__DataFormatType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (fims__DataFormatType *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_resourceID4 = 1;
	size_t soap_flag_revisionID4 = 1;
	size_t soap_flag_location4 = 1;
	size_t soap_flag_resourceCreationDate3 = 1;
	size_t soap_flag_resourceModifiedDate3 = 1;
	size_t soap_flag_serviceGeneratedElement3 = 1;
	size_t soap_flag_isFullyPopulated3 = 1;
	size_t soap_flag_notifyAt3 = 1;
	size_t soap_flag_ExtensionGroup3 = 1;
	size_t soap_flag_ExtensionAttributes3 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_resourceID4 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_fims__ResourceIDType(soap, "fims:resourceID", &(a->fims__ResourceReferenceType::resourceID), "fims:ResourceIDType"))
				{	soap_flag_resourceID4--;
					continue;
				}
			if (soap_flag_revisionID4 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTofims__RevisionIDType(soap, "fims:revisionID", &(a->fims__ResourceReferenceType::revisionID), "fims:RevisionIDType"))
				{	soap_flag_revisionID4--;
					continue;
				}
			if (soap_flag_location4 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerToxsd__anyURI(soap, "fims:location", &(a->fims__ResourceReferenceType::location), "xsd:anyURI"))
				{	soap_flag_location4--;
					continue;
				}
			/* transient soap skipped */
			if (soap_flag_resourceCreationDate3 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTotime(soap, "fims:resourceCreationDate", &(a->fims__ResourceType::resourceCreationDate), "xsd:dateTime"))
				{	soap_flag_resourceCreationDate3--;
					continue;
				}
			if (soap_flag_resourceModifiedDate3 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTotime(soap, "fims:resourceModifiedDate", &(a->fims__ResourceType::resourceModifiedDate), "xsd:dateTime"))
				{	soap_flag_resourceModifiedDate3--;
					continue;
				}
			if (soap_flag_serviceGeneratedElement3 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTobool(soap, "fims:serviceGeneratedElement", &(a->fims__ResourceType::serviceGeneratedElement), "xsd:boolean"))
				{	soap_flag_serviceGeneratedElement3--;
					continue;
				}
			if (soap_flag_isFullyPopulated3 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTobool(soap, "fims:isFullyPopulated", &(a->fims__ResourceType::isFullyPopulated), "xsd:boolean"))
				{	soap_flag_isFullyPopulated3--;
					continue;
				}
			if (soap_flag_notifyAt3 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTofims__AsyncEndpointType(soap, "fims:notifyAt", &(a->fims__ResourceType::notifyAt), "fims:AsyncEndpointType"))
				{	soap_flag_notifyAt3--;
					continue;
				}
			if (soap_flag_ExtensionGroup3 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTofims__ExtensionGroup(soap, "fims:ExtensionGroup", &(a->fims__ResourceType::ExtensionGroup), "fims:ExtensionGroup"))
				{	soap_flag_ExtensionGroup3--;
					continue;
				}
			if (soap_flag_ExtensionAttributes3 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTofims__ExtensionAttributes(soap, "fims:ExtensionAttributes", &(a->fims__ResourceType::ExtensionAttributes), "fims:ExtensionAttributes"))
				{	soap_flag_ExtensionAttributes3--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTofims__TechnicalAttributeType(soap, "fims:technicalAttribute", &(a->fims__FormatType::technicalAttribute), "fims:TechnicalAttributeType"))
					continue;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTofims__CaptioningFormatType(soap, "fims:captioningFormat", &(a->fims__DataFormatType::captioningFormat), "fims:CaptioningFormatType"))
					continue;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTofims__AncillaryDataFormatType(soap, "fims:ancillaryDataFormat", &(a->fims__DataFormatType::ancillaryDataFormat), "fims:AncillaryDataFormatType"))
					continue;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (fims__DataFormatType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_fims__DataFormatType, 0, sizeof(fims__DataFormatType), 0, soap_copy_fims__DataFormatType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_resourceID4 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int fims__DataFormatType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_fims__DataFormatType);
	if (this->soap_out(soap, tag?tag:"fims:DataFormatType", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *fims__DataFormatType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_fims__DataFormatType(soap, this, tag, type);
}

SOAP_FMAC3 fims__DataFormatType * SOAP_FMAC4 soap_get_fims__DataFormatType(struct soap *soap, fims__DataFormatType *p, const char *tag, const char *type)
{
	if ((p = soap_in_fims__DataFormatType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 fims__DataFormatType * SOAP_FMAC2 soap_instantiate_fims__DataFormatType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_fims__DataFormatType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_fims__DataFormatType, n, EDLProvider_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(fims__DataFormatType);
		if (size)
			*size = sizeof(fims__DataFormatType);
		((fims__DataFormatType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(fims__DataFormatType, n);
		if (size)
			*size = n * sizeof(fims__DataFormatType);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((fims__DataFormatType*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (fims__DataFormatType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_fims__DataFormatType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying fims__DataFormatType %p -> %p\n", q, p));
	*(fims__DataFormatType*)p = *(fims__DataFormatType*)q;
}

void fims__AudioFormatType::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->fims__FormatType::soap_default(soap);
	this->fims__AudioFormatType::samplingRate = NULL;
	this->fims__AudioFormatType::audioEncoding = NULL;
	this->fims__AudioFormatType::trackConfiguration = NULL;
	soap_default_std__vectorTemplateOfPointerTofims__BMTrackType(soap, &this->fims__AudioFormatType::audioTrack);
	this->fims__AudioFormatType::channels = NULL;
	this->fims__AudioFormatType::bitRate = NULL;
	this->fims__AudioFormatType::bitRateMode = NULL;
	this->fims__AudioFormatType::sampleSize = NULL;
	this->fims__AudioFormatType::sampleType = NULL;
}

void fims__AudioFormatType::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerToxsd__decimal(soap, &this->fims__AudioFormatType::samplingRate);
	soap_serialize_PointerTofims__CodecType(soap, &this->fims__AudioFormatType::audioEncoding);
	soap_serialize_PointerTo_fims__AudioFormatType_trackConfiguration(soap, &this->fims__AudioFormatType::trackConfiguration);
	soap_serialize_std__vectorTemplateOfPointerTofims__BMTrackType(soap, &this->fims__AudioFormatType::audioTrack);
	soap_serialize_PointerToxsd__nonNegativeInteger(soap, &this->fims__AudioFormatType::channels);
	soap_serialize_PointerToxsd__nonNegativeInteger(soap, &this->fims__AudioFormatType::bitRate);
	soap_serialize_PointerTofims__BitRateModeType(soap, &this->fims__AudioFormatType::bitRateMode);
	soap_serialize_PointerToxsd__nonNegativeInteger(soap, &this->fims__AudioFormatType::sampleSize);
	soap_serialize_PointerTofims__AudioSampleType(soap, &this->fims__AudioFormatType::sampleType);
	this->fims__FormatType::soap_serialize(soap);
#endif
}

int fims__AudioFormatType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_fims__AudioFormatType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_fims__AudioFormatType(struct soap *soap, const char *tag, int id, const fims__AudioFormatType *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_fims__AudioFormatType), "fims:AudioFormatType"))
		return soap->error;
	if (soap_out_fims__ResourceIDType(soap, "fims:resourceID", -1, &(a->fims__ResourceReferenceType::resourceID), ""))
		return soap->error;
	if (soap_out_PointerTofims__RevisionIDType(soap, "fims:revisionID", -1, &(a->fims__ResourceReferenceType::revisionID), ""))
		return soap->error;
	if (soap_out_PointerToxsd__anyURI(soap, "fims:location", -1, &(a->fims__ResourceReferenceType::location), ""))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_PointerTotime(soap, "fims:resourceCreationDate", -1, &(a->fims__ResourceType::resourceCreationDate), ""))
		return soap->error;
	if (soap_out_PointerTotime(soap, "fims:resourceModifiedDate", -1, &(a->fims__ResourceType::resourceModifiedDate), ""))
		return soap->error;
	if (soap_out_PointerTobool(soap, "fims:serviceGeneratedElement", -1, &(a->fims__ResourceType::serviceGeneratedElement), ""))
		return soap->error;
	if (soap_out_PointerTobool(soap, "fims:isFullyPopulated", -1, &(a->fims__ResourceType::isFullyPopulated), ""))
		return soap->error;
	if (soap_out_PointerTofims__AsyncEndpointType(soap, "fims:notifyAt", -1, &(a->fims__ResourceType::notifyAt), ""))
		return soap->error;
	if (soap_out_PointerTofims__ExtensionGroup(soap, "fims:ExtensionGroup", -1, &(a->fims__ResourceType::ExtensionGroup), ""))
		return soap->error;
	if (soap_out_PointerTofims__ExtensionAttributes(soap, "fims:ExtensionAttributes", -1, &(a->fims__ResourceType::ExtensionAttributes), ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTofims__TechnicalAttributeType(soap, "fims:technicalAttribute", -1, &(a->fims__FormatType::technicalAttribute), ""))
		return soap->error;
	if (soap_out_PointerToxsd__decimal(soap, "fims:samplingRate", -1, &(a->fims__AudioFormatType::samplingRate), ""))
		return soap->error;
	if (soap_out_PointerTofims__CodecType(soap, "fims:audioEncoding", -1, &(a->fims__AudioFormatType::audioEncoding), ""))
		return soap->error;
	if (soap_out_PointerTo_fims__AudioFormatType_trackConfiguration(soap, "fims:trackConfiguration", -1, &(a->fims__AudioFormatType::trackConfiguration), ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTofims__BMTrackType(soap, "fims:audioTrack", -1, &(a->fims__AudioFormatType::audioTrack), ""))
		return soap->error;
	if (soap_out_PointerToxsd__nonNegativeInteger(soap, "fims:channels", -1, &(a->fims__AudioFormatType::channels), ""))
		return soap->error;
	if (soap_out_PointerToxsd__nonNegativeInteger(soap, "fims:bitRate", -1, &(a->fims__AudioFormatType::bitRate), ""))
		return soap->error;
	if (soap_out_PointerTofims__BitRateModeType(soap, "fims:bitRateMode", -1, &(a->fims__AudioFormatType::bitRateMode), ""))
		return soap->error;
	if (soap_out_PointerToxsd__nonNegativeInteger(soap, "fims:sampleSize", -1, &(a->fims__AudioFormatType::sampleSize), ""))
		return soap->error;
	if (soap_out_PointerTofims__AudioSampleType(soap, "fims:sampleType", -1, &(a->fims__AudioFormatType::sampleType), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *fims__AudioFormatType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_fims__AudioFormatType(soap, tag, this, type);
}

SOAP_FMAC3 fims__AudioFormatType * SOAP_FMAC4 soap_in_fims__AudioFormatType(struct soap *soap, const char *tag, fims__AudioFormatType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (fims__AudioFormatType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_fims__AudioFormatType, sizeof(fims__AudioFormatType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_fims__AudioFormatType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (fims__AudioFormatType *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_resourceID4 = 1;
	size_t soap_flag_revisionID4 = 1;
	size_t soap_flag_location4 = 1;
	size_t soap_flag_resourceCreationDate3 = 1;
	size_t soap_flag_resourceModifiedDate3 = 1;
	size_t soap_flag_serviceGeneratedElement3 = 1;
	size_t soap_flag_isFullyPopulated3 = 1;
	size_t soap_flag_notifyAt3 = 1;
	size_t soap_flag_ExtensionGroup3 = 1;
	size_t soap_flag_ExtensionAttributes3 = 1;
	size_t soap_flag_samplingRate1 = 1;
	size_t soap_flag_audioEncoding1 = 1;
	size_t soap_flag_trackConfiguration1 = 1;
	size_t soap_flag_channels1 = 1;
	size_t soap_flag_bitRate1 = 1;
	size_t soap_flag_bitRateMode1 = 1;
	size_t soap_flag_sampleSize1 = 1;
	size_t soap_flag_sampleType1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_resourceID4 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_fims__ResourceIDType(soap, "fims:resourceID", &(a->fims__ResourceReferenceType::resourceID), "fims:ResourceIDType"))
				{	soap_flag_resourceID4--;
					continue;
				}
			if (soap_flag_revisionID4 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTofims__RevisionIDType(soap, "fims:revisionID", &(a->fims__ResourceReferenceType::revisionID), "fims:RevisionIDType"))
				{	soap_flag_revisionID4--;
					continue;
				}
			if (soap_flag_location4 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerToxsd__anyURI(soap, "fims:location", &(a->fims__ResourceReferenceType::location), "xsd:anyURI"))
				{	soap_flag_location4--;
					continue;
				}
			/* transient soap skipped */
			if (soap_flag_resourceCreationDate3 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTotime(soap, "fims:resourceCreationDate", &(a->fims__ResourceType::resourceCreationDate), "xsd:dateTime"))
				{	soap_flag_resourceCreationDate3--;
					continue;
				}
			if (soap_flag_resourceModifiedDate3 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTotime(soap, "fims:resourceModifiedDate", &(a->fims__ResourceType::resourceModifiedDate), "xsd:dateTime"))
				{	soap_flag_resourceModifiedDate3--;
					continue;
				}
			if (soap_flag_serviceGeneratedElement3 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTobool(soap, "fims:serviceGeneratedElement", &(a->fims__ResourceType::serviceGeneratedElement), "xsd:boolean"))
				{	soap_flag_serviceGeneratedElement3--;
					continue;
				}
			if (soap_flag_isFullyPopulated3 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTobool(soap, "fims:isFullyPopulated", &(a->fims__ResourceType::isFullyPopulated), "xsd:boolean"))
				{	soap_flag_isFullyPopulated3--;
					continue;
				}
			if (soap_flag_notifyAt3 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTofims__AsyncEndpointType(soap, "fims:notifyAt", &(a->fims__ResourceType::notifyAt), "fims:AsyncEndpointType"))
				{	soap_flag_notifyAt3--;
					continue;
				}
			if (soap_flag_ExtensionGroup3 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTofims__ExtensionGroup(soap, "fims:ExtensionGroup", &(a->fims__ResourceType::ExtensionGroup), "fims:ExtensionGroup"))
				{	soap_flag_ExtensionGroup3--;
					continue;
				}
			if (soap_flag_ExtensionAttributes3 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTofims__ExtensionAttributes(soap, "fims:ExtensionAttributes", &(a->fims__ResourceType::ExtensionAttributes), "fims:ExtensionAttributes"))
				{	soap_flag_ExtensionAttributes3--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTofims__TechnicalAttributeType(soap, "fims:technicalAttribute", &(a->fims__FormatType::technicalAttribute), "fims:TechnicalAttributeType"))
					continue;
			if (soap_flag_samplingRate1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerToxsd__decimal(soap, "fims:samplingRate", &(a->fims__AudioFormatType::samplingRate), "xsd:decimal"))
				{	soap_flag_samplingRate1--;
					continue;
				}
			if (soap_flag_audioEncoding1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTofims__CodecType(soap, "fims:audioEncoding", &(a->fims__AudioFormatType::audioEncoding), "fims:CodecType"))
				{	soap_flag_audioEncoding1--;
					continue;
				}
			if (soap_flag_trackConfiguration1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_fims__AudioFormatType_trackConfiguration(soap, "fims:trackConfiguration", &(a->fims__AudioFormatType::trackConfiguration), ""))
				{	soap_flag_trackConfiguration1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTofims__BMTrackType(soap, "fims:audioTrack", &(a->fims__AudioFormatType::audioTrack), "fims:BMTrackType"))
					continue;
			if (soap_flag_channels1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerToxsd__nonNegativeInteger(soap, "fims:channels", &(a->fims__AudioFormatType::channels), "xsd:nonNegativeInteger"))
				{	soap_flag_channels1--;
					continue;
				}
			if (soap_flag_bitRate1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerToxsd__nonNegativeInteger(soap, "fims:bitRate", &(a->fims__AudioFormatType::bitRate), "xsd:nonNegativeInteger"))
				{	soap_flag_bitRate1--;
					continue;
				}
			if (soap_flag_bitRateMode1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTofims__BitRateModeType(soap, "fims:bitRateMode", &(a->fims__AudioFormatType::bitRateMode), "fims:BitRateModeType"))
				{	soap_flag_bitRateMode1--;
					continue;
				}
			if (soap_flag_sampleSize1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerToxsd__nonNegativeInteger(soap, "fims:sampleSize", &(a->fims__AudioFormatType::sampleSize), "xsd:nonNegativeInteger"))
				{	soap_flag_sampleSize1--;
					continue;
				}
			if (soap_flag_sampleType1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTofims__AudioSampleType(soap, "fims:sampleType", &(a->fims__AudioFormatType::sampleType), "fims:AudioSampleType"))
				{	soap_flag_sampleType1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (fims__AudioFormatType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_fims__AudioFormatType, 0, sizeof(fims__AudioFormatType), 0, soap_copy_fims__AudioFormatType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_resourceID4 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int fims__AudioFormatType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_fims__AudioFormatType);
	if (this->soap_out(soap, tag?tag:"fims:AudioFormatType", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *fims__AudioFormatType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_fims__AudioFormatType(soap, this, tag, type);
}

SOAP_FMAC3 fims__AudioFormatType * SOAP_FMAC4 soap_get_fims__AudioFormatType(struct soap *soap, fims__AudioFormatType *p, const char *tag, const char *type)
{
	if ((p = soap_in_fims__AudioFormatType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 fims__AudioFormatType * SOAP_FMAC2 soap_instantiate_fims__AudioFormatType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_fims__AudioFormatType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_fims__AudioFormatType, n, EDLProvider_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(fims__AudioFormatType);
		if (size)
			*size = sizeof(fims__AudioFormatType);
		((fims__AudioFormatType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(fims__AudioFormatType, n);
		if (size)
			*size = n * sizeof(fims__AudioFormatType);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((fims__AudioFormatType*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (fims__AudioFormatType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_fims__AudioFormatType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying fims__AudioFormatType %p -> %p\n", q, p));
	*(fims__AudioFormatType*)p = *(fims__AudioFormatType*)q;
}

void fims__VideoFormatType::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->fims__FormatType::soap_default(soap);
	this->fims__VideoFormatType::displayWidth = NULL;
	this->fims__VideoFormatType::displayHeight = NULL;
	this->fims__VideoFormatType::frameRate = NULL;
	this->fims__VideoFormatType::aspectRatio = NULL;
	this->fims__VideoFormatType::videoEncoding = NULL;
	soap_default_std__vectorTemplateOfPointerTofims__BMTrackType(soap, &this->fims__VideoFormatType::videoTrack);
	this->fims__VideoFormatType::bitRate = NULL;
	this->fims__VideoFormatType::bitRateMode = NULL;
	this->fims__VideoFormatType::lines = NULL;
	this->fims__VideoFormatType::scanningFormat = NULL;
	this->fims__VideoFormatType::scanningOrder = NULL;
	this->fims__VideoFormatType::noiseFilter = NULL;
}

void fims__VideoFormatType::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTofims__LengthType(soap, &this->fims__VideoFormatType::displayWidth);
	soap_serialize_PointerTofims__LengthType(soap, &this->fims__VideoFormatType::displayHeight);
	soap_serialize_PointerTofims__RationalType(soap, &this->fims__VideoFormatType::frameRate);
	soap_serialize_PointerTofims__RationalType(soap, &this->fims__VideoFormatType::aspectRatio);
	soap_serialize_PointerTofims__CodecType(soap, &this->fims__VideoFormatType::videoEncoding);
	soap_serialize_std__vectorTemplateOfPointerTofims__BMTrackType(soap, &this->fims__VideoFormatType::videoTrack);
	soap_serialize_PointerToxsd__nonNegativeInteger(soap, &this->fims__VideoFormatType::bitRate);
	soap_serialize_PointerTofims__BitRateModeType(soap, &this->fims__VideoFormatType::bitRateMode);
	soap_serialize_PointerToxsd__nonNegativeInteger(soap, &this->fims__VideoFormatType::lines);
	soap_serialize_PointerTofims__ScanningFormatType(soap, &this->fims__VideoFormatType::scanningFormat);
	soap_serialize_PointerTofims__ScanningOrderType(soap, &this->fims__VideoFormatType::scanningOrder);
	soap_serialize_PointerTobool(soap, &this->fims__VideoFormatType::noiseFilter);
	this->fims__FormatType::soap_serialize(soap);
#endif
}

int fims__VideoFormatType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_fims__VideoFormatType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_fims__VideoFormatType(struct soap *soap, const char *tag, int id, const fims__VideoFormatType *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_fims__VideoFormatType), "fims:VideoFormatType"))
		return soap->error;
	if (soap_out_fims__ResourceIDType(soap, "fims:resourceID", -1, &(a->fims__ResourceReferenceType::resourceID), ""))
		return soap->error;
	if (soap_out_PointerTofims__RevisionIDType(soap, "fims:revisionID", -1, &(a->fims__ResourceReferenceType::revisionID), ""))
		return soap->error;
	if (soap_out_PointerToxsd__anyURI(soap, "fims:location", -1, &(a->fims__ResourceReferenceType::location), ""))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_PointerTotime(soap, "fims:resourceCreationDate", -1, &(a->fims__ResourceType::resourceCreationDate), ""))
		return soap->error;
	if (soap_out_PointerTotime(soap, "fims:resourceModifiedDate", -1, &(a->fims__ResourceType::resourceModifiedDate), ""))
		return soap->error;
	if (soap_out_PointerTobool(soap, "fims:serviceGeneratedElement", -1, &(a->fims__ResourceType::serviceGeneratedElement), ""))
		return soap->error;
	if (soap_out_PointerTobool(soap, "fims:isFullyPopulated", -1, &(a->fims__ResourceType::isFullyPopulated), ""))
		return soap->error;
	if (soap_out_PointerTofims__AsyncEndpointType(soap, "fims:notifyAt", -1, &(a->fims__ResourceType::notifyAt), ""))
		return soap->error;
	if (soap_out_PointerTofims__ExtensionGroup(soap, "fims:ExtensionGroup", -1, &(a->fims__ResourceType::ExtensionGroup), ""))
		return soap->error;
	if (soap_out_PointerTofims__ExtensionAttributes(soap, "fims:ExtensionAttributes", -1, &(a->fims__ResourceType::ExtensionAttributes), ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTofims__TechnicalAttributeType(soap, "fims:technicalAttribute", -1, &(a->fims__FormatType::technicalAttribute), ""))
		return soap->error;
	if (soap_out_PointerTofims__LengthType(soap, "fims:displayWidth", -1, &(a->fims__VideoFormatType::displayWidth), ""))
		return soap->error;
	if (soap_out_PointerTofims__LengthType(soap, "fims:displayHeight", -1, &(a->fims__VideoFormatType::displayHeight), ""))
		return soap->error;
	if (soap_out_PointerTofims__RationalType(soap, "fims:frameRate", -1, &(a->fims__VideoFormatType::frameRate), ""))
		return soap->error;
	if (soap_out_PointerTofims__RationalType(soap, "fims:aspectRatio", -1, &(a->fims__VideoFormatType::aspectRatio), ""))
		return soap->error;
	if (soap_out_PointerTofims__CodecType(soap, "fims:videoEncoding", -1, &(a->fims__VideoFormatType::videoEncoding), ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTofims__BMTrackType(soap, "fims:videoTrack", -1, &(a->fims__VideoFormatType::videoTrack), ""))
		return soap->error;
	if (soap_out_PointerToxsd__nonNegativeInteger(soap, "fims:bitRate", -1, &(a->fims__VideoFormatType::bitRate), ""))
		return soap->error;
	if (soap_out_PointerTofims__BitRateModeType(soap, "fims:bitRateMode", -1, &(a->fims__VideoFormatType::bitRateMode), ""))
		return soap->error;
	if (soap_out_PointerToxsd__nonNegativeInteger(soap, "fims:lines", -1, &(a->fims__VideoFormatType::lines), ""))
		return soap->error;
	if (soap_out_PointerTofims__ScanningFormatType(soap, "fims:scanningFormat", -1, &(a->fims__VideoFormatType::scanningFormat), ""))
		return soap->error;
	if (soap_out_PointerTofims__ScanningOrderType(soap, "fims:scanningOrder", -1, &(a->fims__VideoFormatType::scanningOrder), ""))
		return soap->error;
	if (soap_out_PointerTobool(soap, "fims:noiseFilter", -1, &(a->fims__VideoFormatType::noiseFilter), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *fims__VideoFormatType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_fims__VideoFormatType(soap, tag, this, type);
}

SOAP_FMAC3 fims__VideoFormatType * SOAP_FMAC4 soap_in_fims__VideoFormatType(struct soap *soap, const char *tag, fims__VideoFormatType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (fims__VideoFormatType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_fims__VideoFormatType, sizeof(fims__VideoFormatType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_fims__VideoFormatType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (fims__VideoFormatType *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_resourceID4 = 1;
	size_t soap_flag_revisionID4 = 1;
	size_t soap_flag_location4 = 1;
	size_t soap_flag_resourceCreationDate3 = 1;
	size_t soap_flag_resourceModifiedDate3 = 1;
	size_t soap_flag_serviceGeneratedElement3 = 1;
	size_t soap_flag_isFullyPopulated3 = 1;
	size_t soap_flag_notifyAt3 = 1;
	size_t soap_flag_ExtensionGroup3 = 1;
	size_t soap_flag_ExtensionAttributes3 = 1;
	size_t soap_flag_displayWidth1 = 1;
	size_t soap_flag_displayHeight1 = 1;
	size_t soap_flag_frameRate1 = 1;
	size_t soap_flag_aspectRatio1 = 1;
	size_t soap_flag_videoEncoding1 = 1;
	size_t soap_flag_bitRate1 = 1;
	size_t soap_flag_bitRateMode1 = 1;
	size_t soap_flag_lines1 = 1;
	size_t soap_flag_scanningFormat1 = 1;
	size_t soap_flag_scanningOrder1 = 1;
	size_t soap_flag_noiseFilter1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_resourceID4 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_fims__ResourceIDType(soap, "fims:resourceID", &(a->fims__ResourceReferenceType::resourceID), "fims:ResourceIDType"))
				{	soap_flag_resourceID4--;
					continue;
				}
			if (soap_flag_revisionID4 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTofims__RevisionIDType(soap, "fims:revisionID", &(a->fims__ResourceReferenceType::revisionID), "fims:RevisionIDType"))
				{	soap_flag_revisionID4--;
					continue;
				}
			if (soap_flag_location4 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerToxsd__anyURI(soap, "fims:location", &(a->fims__ResourceReferenceType::location), "xsd:anyURI"))
				{	soap_flag_location4--;
					continue;
				}
			/* transient soap skipped */
			if (soap_flag_resourceCreationDate3 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTotime(soap, "fims:resourceCreationDate", &(a->fims__ResourceType::resourceCreationDate), "xsd:dateTime"))
				{	soap_flag_resourceCreationDate3--;
					continue;
				}
			if (soap_flag_resourceModifiedDate3 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTotime(soap, "fims:resourceModifiedDate", &(a->fims__ResourceType::resourceModifiedDate), "xsd:dateTime"))
				{	soap_flag_resourceModifiedDate3--;
					continue;
				}
			if (soap_flag_serviceGeneratedElement3 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTobool(soap, "fims:serviceGeneratedElement", &(a->fims__ResourceType::serviceGeneratedElement), "xsd:boolean"))
				{	soap_flag_serviceGeneratedElement3--;
					continue;
				}
			if (soap_flag_isFullyPopulated3 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTobool(soap, "fims:isFullyPopulated", &(a->fims__ResourceType::isFullyPopulated), "xsd:boolean"))
				{	soap_flag_isFullyPopulated3--;
					continue;
				}
			if (soap_flag_notifyAt3 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTofims__AsyncEndpointType(soap, "fims:notifyAt", &(a->fims__ResourceType::notifyAt), "fims:AsyncEndpointType"))
				{	soap_flag_notifyAt3--;
					continue;
				}
			if (soap_flag_ExtensionGroup3 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTofims__ExtensionGroup(soap, "fims:ExtensionGroup", &(a->fims__ResourceType::ExtensionGroup), "fims:ExtensionGroup"))
				{	soap_flag_ExtensionGroup3--;
					continue;
				}
			if (soap_flag_ExtensionAttributes3 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTofims__ExtensionAttributes(soap, "fims:ExtensionAttributes", &(a->fims__ResourceType::ExtensionAttributes), "fims:ExtensionAttributes"))
				{	soap_flag_ExtensionAttributes3--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTofims__TechnicalAttributeType(soap, "fims:technicalAttribute", &(a->fims__FormatType::technicalAttribute), "fims:TechnicalAttributeType"))
					continue;
			if (soap_flag_displayWidth1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTofims__LengthType(soap, "fims:displayWidth", &(a->fims__VideoFormatType::displayWidth), "fims:LengthType"))
				{	soap_flag_displayWidth1--;
					continue;
				}
			if (soap_flag_displayHeight1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTofims__LengthType(soap, "fims:displayHeight", &(a->fims__VideoFormatType::displayHeight), "fims:LengthType"))
				{	soap_flag_displayHeight1--;
					continue;
				}
			if (soap_flag_frameRate1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTofims__RationalType(soap, "fims:frameRate", &(a->fims__VideoFormatType::frameRate), "fims:RationalType"))
				{	soap_flag_frameRate1--;
					continue;
				}
			if (soap_flag_aspectRatio1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTofims__RationalType(soap, "fims:aspectRatio", &(a->fims__VideoFormatType::aspectRatio), "fims:RationalType"))
				{	soap_flag_aspectRatio1--;
					continue;
				}
			if (soap_flag_videoEncoding1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTofims__CodecType(soap, "fims:videoEncoding", &(a->fims__VideoFormatType::videoEncoding), "fims:CodecType"))
				{	soap_flag_videoEncoding1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTofims__BMTrackType(soap, "fims:videoTrack", &(a->fims__VideoFormatType::videoTrack), "fims:BMTrackType"))
					continue;
			if (soap_flag_bitRate1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerToxsd__nonNegativeInteger(soap, "fims:bitRate", &(a->fims__VideoFormatType::bitRate), "xsd:nonNegativeInteger"))
				{	soap_flag_bitRate1--;
					continue;
				}
			if (soap_flag_bitRateMode1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTofims__BitRateModeType(soap, "fims:bitRateMode", &(a->fims__VideoFormatType::bitRateMode), "fims:BitRateModeType"))
				{	soap_flag_bitRateMode1--;
					continue;
				}
			if (soap_flag_lines1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerToxsd__nonNegativeInteger(soap, "fims:lines", &(a->fims__VideoFormatType::lines), "xsd:nonNegativeInteger"))
				{	soap_flag_lines1--;
					continue;
				}
			if (soap_flag_scanningFormat1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTofims__ScanningFormatType(soap, "fims:scanningFormat", &(a->fims__VideoFormatType::scanningFormat), "fims:ScanningFormatType"))
				{	soap_flag_scanningFormat1--;
					continue;
				}
			if (soap_flag_scanningOrder1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTofims__ScanningOrderType(soap, "fims:scanningOrder", &(a->fims__VideoFormatType::scanningOrder), "fims:ScanningOrderType"))
				{	soap_flag_scanningOrder1--;
					continue;
				}
			if (soap_flag_noiseFilter1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTobool(soap, "fims:noiseFilter", &(a->fims__VideoFormatType::noiseFilter), "xsd:boolean"))
				{	soap_flag_noiseFilter1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (fims__VideoFormatType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_fims__VideoFormatType, 0, sizeof(fims__VideoFormatType), 0, soap_copy_fims__VideoFormatType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_resourceID4 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int fims__VideoFormatType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_fims__VideoFormatType);
	if (this->soap_out(soap, tag?tag:"fims:VideoFormatType", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *fims__VideoFormatType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_fims__VideoFormatType(soap, this, tag, type);
}

SOAP_FMAC3 fims__VideoFormatType * SOAP_FMAC4 soap_get_fims__VideoFormatType(struct soap *soap, fims__VideoFormatType *p, const char *tag, const char *type)
{
	if ((p = soap_in_fims__VideoFormatType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 fims__VideoFormatType * SOAP_FMAC2 soap_instantiate_fims__VideoFormatType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_fims__VideoFormatType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_fims__VideoFormatType, n, EDLProvider_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(fims__VideoFormatType);
		if (size)
			*size = sizeof(fims__VideoFormatType);
		((fims__VideoFormatType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(fims__VideoFormatType, n);
		if (size)
			*size = n * sizeof(fims__VideoFormatType);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((fims__VideoFormatType*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (fims__VideoFormatType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_fims__VideoFormatType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying fims__VideoFormatType %p -> %p\n", q, p));
	*(fims__VideoFormatType*)p = *(fims__VideoFormatType*)q;
}

void fims__FormatType::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->fims__ResourceType::soap_default(soap);
	soap_default_std__vectorTemplateOfPointerTofims__TechnicalAttributeType(soap, &this->fims__FormatType::technicalAttribute);
}

void fims__FormatType::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfPointerTofims__TechnicalAttributeType(soap, &this->fims__FormatType::technicalAttribute);
	this->fims__ResourceType::soap_serialize(soap);
#endif
}

int fims__FormatType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_fims__FormatType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_fims__FormatType(struct soap *soap, const char *tag, int id, const fims__FormatType *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_fims__FormatType), "fims:FormatType"))
		return soap->error;
	if (soap_out_fims__ResourceIDType(soap, "fims:resourceID", -1, &(a->fims__ResourceReferenceType::resourceID), ""))
		return soap->error;
	if (soap_out_PointerTofims__RevisionIDType(soap, "fims:revisionID", -1, &(a->fims__ResourceReferenceType::revisionID), ""))
		return soap->error;
	if (soap_out_PointerToxsd__anyURI(soap, "fims:location", -1, &(a->fims__ResourceReferenceType::location), ""))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_PointerTotime(soap, "fims:resourceCreationDate", -1, &(a->fims__ResourceType::resourceCreationDate), ""))
		return soap->error;
	if (soap_out_PointerTotime(soap, "fims:resourceModifiedDate", -1, &(a->fims__ResourceType::resourceModifiedDate), ""))
		return soap->error;
	if (soap_out_PointerTobool(soap, "fims:serviceGeneratedElement", -1, &(a->fims__ResourceType::serviceGeneratedElement), ""))
		return soap->error;
	if (soap_out_PointerTobool(soap, "fims:isFullyPopulated", -1, &(a->fims__ResourceType::isFullyPopulated), ""))
		return soap->error;
	if (soap_out_PointerTofims__AsyncEndpointType(soap, "fims:notifyAt", -1, &(a->fims__ResourceType::notifyAt), ""))
		return soap->error;
	if (soap_out_PointerTofims__ExtensionGroup(soap, "fims:ExtensionGroup", -1, &(a->fims__ResourceType::ExtensionGroup), ""))
		return soap->error;
	if (soap_out_PointerTofims__ExtensionAttributes(soap, "fims:ExtensionAttributes", -1, &(a->fims__ResourceType::ExtensionAttributes), ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTofims__TechnicalAttributeType(soap, "fims:technicalAttribute", -1, &(a->fims__FormatType::technicalAttribute), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *fims__FormatType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_fims__FormatType(soap, tag, this, type);
}

SOAP_FMAC3 fims__FormatType * SOAP_FMAC4 soap_in_fims__FormatType(struct soap *soap, const char *tag, fims__FormatType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (fims__FormatType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_fims__FormatType, sizeof(fims__FormatType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_fims__FormatType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (fims__FormatType *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_resourceID3 = 1;
	size_t soap_flag_revisionID3 = 1;
	size_t soap_flag_location3 = 1;
	size_t soap_flag_resourceCreationDate2 = 1;
	size_t soap_flag_resourceModifiedDate2 = 1;
	size_t soap_flag_serviceGeneratedElement2 = 1;
	size_t soap_flag_isFullyPopulated2 = 1;
	size_t soap_flag_notifyAt2 = 1;
	size_t soap_flag_ExtensionGroup2 = 1;
	size_t soap_flag_ExtensionAttributes2 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_resourceID3 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_fims__ResourceIDType(soap, "fims:resourceID", &(a->fims__ResourceReferenceType::resourceID), "fims:ResourceIDType"))
				{	soap_flag_resourceID3--;
					continue;
				}
			if (soap_flag_revisionID3 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTofims__RevisionIDType(soap, "fims:revisionID", &(a->fims__ResourceReferenceType::revisionID), "fims:RevisionIDType"))
				{	soap_flag_revisionID3--;
					continue;
				}
			if (soap_flag_location3 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerToxsd__anyURI(soap, "fims:location", &(a->fims__ResourceReferenceType::location), "xsd:anyURI"))
				{	soap_flag_location3--;
					continue;
				}
			/* transient soap skipped */
			if (soap_flag_resourceCreationDate2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTotime(soap, "fims:resourceCreationDate", &(a->fims__ResourceType::resourceCreationDate), "xsd:dateTime"))
				{	soap_flag_resourceCreationDate2--;
					continue;
				}
			if (soap_flag_resourceModifiedDate2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTotime(soap, "fims:resourceModifiedDate", &(a->fims__ResourceType::resourceModifiedDate), "xsd:dateTime"))
				{	soap_flag_resourceModifiedDate2--;
					continue;
				}
			if (soap_flag_serviceGeneratedElement2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTobool(soap, "fims:serviceGeneratedElement", &(a->fims__ResourceType::serviceGeneratedElement), "xsd:boolean"))
				{	soap_flag_serviceGeneratedElement2--;
					continue;
				}
			if (soap_flag_isFullyPopulated2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTobool(soap, "fims:isFullyPopulated", &(a->fims__ResourceType::isFullyPopulated), "xsd:boolean"))
				{	soap_flag_isFullyPopulated2--;
					continue;
				}
			if (soap_flag_notifyAt2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTofims__AsyncEndpointType(soap, "fims:notifyAt", &(a->fims__ResourceType::notifyAt), "fims:AsyncEndpointType"))
				{	soap_flag_notifyAt2--;
					continue;
				}
			if (soap_flag_ExtensionGroup2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTofims__ExtensionGroup(soap, "fims:ExtensionGroup", &(a->fims__ResourceType::ExtensionGroup), "fims:ExtensionGroup"))
				{	soap_flag_ExtensionGroup2--;
					continue;
				}
			if (soap_flag_ExtensionAttributes2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTofims__ExtensionAttributes(soap, "fims:ExtensionAttributes", &(a->fims__ResourceType::ExtensionAttributes), "fims:ExtensionAttributes"))
				{	soap_flag_ExtensionAttributes2--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTofims__TechnicalAttributeType(soap, "fims:technicalAttribute", &(a->fims__FormatType::technicalAttribute), "fims:TechnicalAttributeType"))
					continue;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (fims__FormatType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_fims__FormatType, 0, sizeof(fims__FormatType), 0, soap_copy_fims__FormatType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_resourceID3 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int fims__FormatType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_fims__FormatType);
	if (this->soap_out(soap, tag?tag:"fims:FormatType", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *fims__FormatType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_fims__FormatType(soap, this, tag, type);
}

SOAP_FMAC3 fims__FormatType * SOAP_FMAC4 soap_get_fims__FormatType(struct soap *soap, fims__FormatType *p, const char *tag, const char *type)
{
	if ((p = soap_in_fims__FormatType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 fims__FormatType * SOAP_FMAC2 soap_instantiate_fims__FormatType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_fims__FormatType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_fims__FormatType, n, EDLProvider_fdelete);
	if (!cp)
		return NULL;
	if (type && !soap_match_tag(soap, type, "fims:VideoFormatType"))
	{	cp->type = SOAP_TYPE_fims__VideoFormatType;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(fims__VideoFormatType);
			if (size)
				*size = sizeof(fims__VideoFormatType);
			((fims__VideoFormatType*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW_ARRAY(fims__VideoFormatType, n);
			if (size)
				*size = n * sizeof(fims__VideoFormatType);
			if (cp->ptr)
				for (int i = 0; i < n; i++)
					((fims__VideoFormatType*)cp->ptr)[i].soap = soap;
		}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		if (!cp->ptr)
			soap->error = SOAP_EOM;
		return (fims__VideoFormatType*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "fims:AudioFormatType"))
	{	cp->type = SOAP_TYPE_fims__AudioFormatType;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(fims__AudioFormatType);
			if (size)
				*size = sizeof(fims__AudioFormatType);
			((fims__AudioFormatType*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW_ARRAY(fims__AudioFormatType, n);
			if (size)
				*size = n * sizeof(fims__AudioFormatType);
			if (cp->ptr)
				for (int i = 0; i < n; i++)
					((fims__AudioFormatType*)cp->ptr)[i].soap = soap;
		}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		if (!cp->ptr)
			soap->error = SOAP_EOM;
		return (fims__AudioFormatType*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "fims:DataFormatType"))
	{	cp->type = SOAP_TYPE_fims__DataFormatType;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(fims__DataFormatType);
			if (size)
				*size = sizeof(fims__DataFormatType);
			((fims__DataFormatType*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW_ARRAY(fims__DataFormatType, n);
			if (size)
				*size = n * sizeof(fims__DataFormatType);
			if (cp->ptr)
				for (int i = 0; i < n; i++)
					((fims__DataFormatType*)cp->ptr)[i].soap = soap;
		}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		if (!cp->ptr)
			soap->error = SOAP_EOM;
		return (fims__DataFormatType*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "fims:ContainerFormatType"))
	{	cp->type = SOAP_TYPE_fims__ContainerFormatType;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(fims__ContainerFormatType);
			if (size)
				*size = sizeof(fims__ContainerFormatType);
			((fims__ContainerFormatType*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW_ARRAY(fims__ContainerFormatType, n);
			if (size)
				*size = n * sizeof(fims__ContainerFormatType);
			if (cp->ptr)
				for (int i = 0; i < n; i++)
					((fims__ContainerFormatType*)cp->ptr)[i].soap = soap;
		}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		if (!cp->ptr)
			soap->error = SOAP_EOM;
		return (fims__ContainerFormatType*)cp->ptr;
	}
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(fims__FormatType);
		if (size)
			*size = sizeof(fims__FormatType);
		((fims__FormatType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(fims__FormatType, n);
		if (size)
			*size = n * sizeof(fims__FormatType);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((fims__FormatType*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (fims__FormatType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_fims__FormatType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying fims__FormatType %p -> %p\n", q, p));
	*(fims__FormatType*)p = *(fims__FormatType*)q;
}

void fims__JobType::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->fims__ResourceType::soap_default(soap);
	this->fims__JobType::status = NULL;
	this->fims__JobType::statusDescription = NULL;
	this->fims__JobType::serviceProviderJobID = NULL;
	this->fims__JobType::queueReference = NULL;
	this->fims__JobType::tasks = NULL;
	this->fims__JobType::operationName = NULL;
	this->fims__JobType::bmObjects = NULL;
	this->fims__JobType::priority = NULL;
	this->fims__JobType::startJob = NULL;
	this->fims__JobType::finishBefore = NULL;
	this->fims__JobType::estimatedCompletionDuration = NULL;
	this->fims__JobType::currentQueuePosition = NULL;
	this->fims__JobType::jobStartedTime = NULL;
	this->fims__JobType::jobElapsedTime = NULL;
	this->fims__JobType::jobCompletedTime = NULL;
	this->fims__JobType::processed = NULL;
}

void fims__JobType::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTofims__JobStatusType(soap, &this->fims__JobType::status);
	soap_serialize_PointerTostd__wstring(soap, &this->fims__JobType::statusDescription);
	soap_serialize_PointerTostd__wstring(soap, &this->fims__JobType::serviceProviderJobID);
	soap_serialize_PointerTofims__QueueType(soap, &this->fims__JobType::queueReference);
	soap_serialize_PointerTofims__JobsType(soap, &this->fims__JobType::tasks);
	soap_serialize_PointerTostd__wstring(soap, &this->fims__JobType::operationName);
	soap_serialize_PointerTofims__BMObjectsType(soap, &this->fims__JobType::bmObjects);
	soap_serialize_PointerTofims__PriorityType(soap, &this->fims__JobType::priority);
	soap_serialize_PointerTofims__StartJobType(soap, &this->fims__JobType::startJob);
	soap_serialize_PointerTotime(soap, &this->fims__JobType::finishBefore);
	soap_serialize_PointerToxsd__duration(soap, &this->fims__JobType::estimatedCompletionDuration);
	soap_serialize_PointerToxsd__nonNegativeInteger(soap, &this->fims__JobType::currentQueuePosition);
	soap_serialize_PointerTotime(soap, &this->fims__JobType::jobStartedTime);
	soap_serialize_PointerToxsd__duration(soap, &this->fims__JobType::jobElapsedTime);
	soap_serialize_PointerTotime(soap, &this->fims__JobType::jobCompletedTime);
	soap_serialize_PointerTofims__ProcessedInfoType(soap, &this->fims__JobType::processed);
	this->fims__ResourceType::soap_serialize(soap);
#endif
}

int fims__JobType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_fims__JobType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_fims__JobType(struct soap *soap, const char *tag, int id, const fims__JobType *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_fims__JobType), "fims:JobType"))
		return soap->error;
	if (soap_out_fims__ResourceIDType(soap, "fims:resourceID", -1, &(a->fims__ResourceReferenceType::resourceID), ""))
		return soap->error;
	if (soap_out_PointerTofims__RevisionIDType(soap, "fims:revisionID", -1, &(a->fims__ResourceReferenceType::revisionID), ""))
		return soap->error;
	if (soap_out_PointerToxsd__anyURI(soap, "fims:location", -1, &(a->fims__ResourceReferenceType::location), ""))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_PointerTotime(soap, "fims:resourceCreationDate", -1, &(a->fims__ResourceType::resourceCreationDate), ""))
		return soap->error;
	if (soap_out_PointerTotime(soap, "fims:resourceModifiedDate", -1, &(a->fims__ResourceType::resourceModifiedDate), ""))
		return soap->error;
	if (soap_out_PointerTobool(soap, "fims:serviceGeneratedElement", -1, &(a->fims__ResourceType::serviceGeneratedElement), ""))
		return soap->error;
	if (soap_out_PointerTobool(soap, "fims:isFullyPopulated", -1, &(a->fims__ResourceType::isFullyPopulated), ""))
		return soap->error;
	if (soap_out_PointerTofims__AsyncEndpointType(soap, "fims:notifyAt", -1, &(a->fims__ResourceType::notifyAt), ""))
		return soap->error;
	if (soap_out_PointerTofims__ExtensionGroup(soap, "fims:ExtensionGroup", -1, &(a->fims__ResourceType::ExtensionGroup), ""))
		return soap->error;
	if (soap_out_PointerTofims__ExtensionAttributes(soap, "fims:ExtensionAttributes", -1, &(a->fims__ResourceType::ExtensionAttributes), ""))
		return soap->error;
	if (soap_out_PointerTofims__JobStatusType(soap, "fims:status", -1, &(a->fims__JobType::status), ""))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "fims:statusDescription", -1, &(a->fims__JobType::statusDescription), ""))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "fims:serviceProviderJobID", -1, &(a->fims__JobType::serviceProviderJobID), ""))
		return soap->error;
	if (soap_out_PointerTofims__QueueType(soap, "fims:queueReference", -1, &(a->fims__JobType::queueReference), ""))
		return soap->error;
	if (soap_out_PointerTofims__JobsType(soap, "fims:tasks", -1, &(a->fims__JobType::tasks), ""))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "fims:operationName", -1, &(a->fims__JobType::operationName), ""))
		return soap->error;
	if (soap_out_PointerTofims__BMObjectsType(soap, "fims:bmObjects", -1, &(a->fims__JobType::bmObjects), ""))
		return soap->error;
	if (soap_out_PointerTofims__PriorityType(soap, "fims:priority", -1, &(a->fims__JobType::priority), ""))
		return soap->error;
	if (soap_out_PointerTofims__StartJobType(soap, "fims:startJob", -1, &(a->fims__JobType::startJob), ""))
		return soap->error;
	if (soap_out_PointerTotime(soap, "fims:finishBefore", -1, &(a->fims__JobType::finishBefore), ""))
		return soap->error;
	if (soap_out_PointerToxsd__duration(soap, "fims:estimatedCompletionDuration", -1, &(a->fims__JobType::estimatedCompletionDuration), ""))
		return soap->error;
	if (soap_out_PointerToxsd__nonNegativeInteger(soap, "fims:currentQueuePosition", -1, &(a->fims__JobType::currentQueuePosition), ""))
		return soap->error;
	if (soap_out_PointerTotime(soap, "fims:jobStartedTime", -1, &(a->fims__JobType::jobStartedTime), ""))
		return soap->error;
	if (soap_out_PointerToxsd__duration(soap, "fims:jobElapsedTime", -1, &(a->fims__JobType::jobElapsedTime), ""))
		return soap->error;
	if (soap_out_PointerTotime(soap, "fims:jobCompletedTime", -1, &(a->fims__JobType::jobCompletedTime), ""))
		return soap->error;
	if (soap_out_PointerTofims__ProcessedInfoType(soap, "fims:processed", -1, &(a->fims__JobType::processed), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *fims__JobType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_fims__JobType(soap, tag, this, type);
}

SOAP_FMAC3 fims__JobType * SOAP_FMAC4 soap_in_fims__JobType(struct soap *soap, const char *tag, fims__JobType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (fims__JobType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_fims__JobType, sizeof(fims__JobType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_fims__JobType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (fims__JobType *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_resourceID3 = 1;
	size_t soap_flag_revisionID3 = 1;
	size_t soap_flag_location3 = 1;
	size_t soap_flag_resourceCreationDate2 = 1;
	size_t soap_flag_resourceModifiedDate2 = 1;
	size_t soap_flag_serviceGeneratedElement2 = 1;
	size_t soap_flag_isFullyPopulated2 = 1;
	size_t soap_flag_notifyAt2 = 1;
	size_t soap_flag_ExtensionGroup2 = 1;
	size_t soap_flag_ExtensionAttributes2 = 1;
	size_t soap_flag_status1 = 1;
	size_t soap_flag_statusDescription1 = 1;
	size_t soap_flag_serviceProviderJobID1 = 1;
	size_t soap_flag_queueReference1 = 1;
	size_t soap_flag_tasks1 = 1;
	size_t soap_flag_operationName1 = 1;
	size_t soap_flag_bmObjects1 = 1;
	size_t soap_flag_priority1 = 1;
	size_t soap_flag_startJob1 = 1;
	size_t soap_flag_finishBefore1 = 1;
	size_t soap_flag_estimatedCompletionDuration1 = 1;
	size_t soap_flag_currentQueuePosition1 = 1;
	size_t soap_flag_jobStartedTime1 = 1;
	size_t soap_flag_jobElapsedTime1 = 1;
	size_t soap_flag_jobCompletedTime1 = 1;
	size_t soap_flag_processed1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_resourceID3 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_fims__ResourceIDType(soap, "fims:resourceID", &(a->fims__ResourceReferenceType::resourceID), "fims:ResourceIDType"))
				{	soap_flag_resourceID3--;
					continue;
				}
			if (soap_flag_revisionID3 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTofims__RevisionIDType(soap, "fims:revisionID", &(a->fims__ResourceReferenceType::revisionID), "fims:RevisionIDType"))
				{	soap_flag_revisionID3--;
					continue;
				}
			if (soap_flag_location3 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerToxsd__anyURI(soap, "fims:location", &(a->fims__ResourceReferenceType::location), "xsd:anyURI"))
				{	soap_flag_location3--;
					continue;
				}
			/* transient soap skipped */
			if (soap_flag_resourceCreationDate2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTotime(soap, "fims:resourceCreationDate", &(a->fims__ResourceType::resourceCreationDate), "xsd:dateTime"))
				{	soap_flag_resourceCreationDate2--;
					continue;
				}
			if (soap_flag_resourceModifiedDate2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTotime(soap, "fims:resourceModifiedDate", &(a->fims__ResourceType::resourceModifiedDate), "xsd:dateTime"))
				{	soap_flag_resourceModifiedDate2--;
					continue;
				}
			if (soap_flag_serviceGeneratedElement2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTobool(soap, "fims:serviceGeneratedElement", &(a->fims__ResourceType::serviceGeneratedElement), "xsd:boolean"))
				{	soap_flag_serviceGeneratedElement2--;
					continue;
				}
			if (soap_flag_isFullyPopulated2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTobool(soap, "fims:isFullyPopulated", &(a->fims__ResourceType::isFullyPopulated), "xsd:boolean"))
				{	soap_flag_isFullyPopulated2--;
					continue;
				}
			if (soap_flag_notifyAt2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTofims__AsyncEndpointType(soap, "fims:notifyAt", &(a->fims__ResourceType::notifyAt), "fims:AsyncEndpointType"))
				{	soap_flag_notifyAt2--;
					continue;
				}
			if (soap_flag_ExtensionGroup2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTofims__ExtensionGroup(soap, "fims:ExtensionGroup", &(a->fims__ResourceType::ExtensionGroup), "fims:ExtensionGroup"))
				{	soap_flag_ExtensionGroup2--;
					continue;
				}
			if (soap_flag_ExtensionAttributes2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTofims__ExtensionAttributes(soap, "fims:ExtensionAttributes", &(a->fims__ResourceType::ExtensionAttributes), "fims:ExtensionAttributes"))
				{	soap_flag_ExtensionAttributes2--;
					continue;
				}
			if (soap_flag_status1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTofims__JobStatusType(soap, "fims:status", &(a->fims__JobType::status), "fims:JobStatusType"))
				{	soap_flag_status1--;
					continue;
				}
			if (soap_flag_statusDescription1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "fims:statusDescription", &(a->fims__JobType::statusDescription), "xsd:string"))
				{	soap_flag_statusDescription1--;
					continue;
				}
			if (soap_flag_serviceProviderJobID1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "fims:serviceProviderJobID", &(a->fims__JobType::serviceProviderJobID), "xsd:string"))
				{	soap_flag_serviceProviderJobID1--;
					continue;
				}
			if (soap_flag_queueReference1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTofims__QueueType(soap, "fims:queueReference", &(a->fims__JobType::queueReference), "fims:QueueType"))
				{	soap_flag_queueReference1--;
					continue;
				}
			if (soap_flag_tasks1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTofims__JobsType(soap, "fims:tasks", &(a->fims__JobType::tasks), "fims:JobsType"))
				{	soap_flag_tasks1--;
					continue;
				}
			if (soap_flag_operationName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "fims:operationName", &(a->fims__JobType::operationName), "xsd:string"))
				{	soap_flag_operationName1--;
					continue;
				}
			if (soap_flag_bmObjects1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTofims__BMObjectsType(soap, "fims:bmObjects", &(a->fims__JobType::bmObjects), "fims:BMObjectsType"))
				{	soap_flag_bmObjects1--;
					continue;
				}
			if (soap_flag_priority1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTofims__PriorityType(soap, "fims:priority", &(a->fims__JobType::priority), "fims:PriorityType"))
				{	soap_flag_priority1--;
					continue;
				}
			if (soap_flag_startJob1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTofims__StartJobType(soap, "fims:startJob", &(a->fims__JobType::startJob), "fims:StartJobType"))
				{	soap_flag_startJob1--;
					continue;
				}
			if (soap_flag_finishBefore1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTotime(soap, "fims:finishBefore", &(a->fims__JobType::finishBefore), "xsd:dateTime"))
				{	soap_flag_finishBefore1--;
					continue;
				}
			if (soap_flag_estimatedCompletionDuration1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToxsd__duration(soap, "fims:estimatedCompletionDuration", &(a->fims__JobType::estimatedCompletionDuration), "xsd:duration"))
				{	soap_flag_estimatedCompletionDuration1--;
					continue;
				}
			if (soap_flag_currentQueuePosition1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerToxsd__nonNegativeInteger(soap, "fims:currentQueuePosition", &(a->fims__JobType::currentQueuePosition), "xsd:nonNegativeInteger"))
				{	soap_flag_currentQueuePosition1--;
					continue;
				}
			if (soap_flag_jobStartedTime1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTotime(soap, "fims:jobStartedTime", &(a->fims__JobType::jobStartedTime), "xsd:dateTime"))
				{	soap_flag_jobStartedTime1--;
					continue;
				}
			if (soap_flag_jobElapsedTime1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToxsd__duration(soap, "fims:jobElapsedTime", &(a->fims__JobType::jobElapsedTime), "xsd:duration"))
				{	soap_flag_jobElapsedTime1--;
					continue;
				}
			if (soap_flag_jobCompletedTime1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTotime(soap, "fims:jobCompletedTime", &(a->fims__JobType::jobCompletedTime), "xsd:dateTime"))
				{	soap_flag_jobCompletedTime1--;
					continue;
				}
			if (soap_flag_processed1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTofims__ProcessedInfoType(soap, "fims:processed", &(a->fims__JobType::processed), "fims:ProcessedInfoType"))
				{	soap_flag_processed1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (fims__JobType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_fims__JobType, 0, sizeof(fims__JobType), 0, soap_copy_fims__JobType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_resourceID3 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int fims__JobType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_fims__JobType);
	if (this->soap_out(soap, tag?tag:"fims:JobType", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *fims__JobType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_fims__JobType(soap, this, tag, type);
}

SOAP_FMAC3 fims__JobType * SOAP_FMAC4 soap_get_fims__JobType(struct soap *soap, fims__JobType *p, const char *tag, const char *type)
{
	if ((p = soap_in_fims__JobType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 fims__JobType * SOAP_FMAC2 soap_instantiate_fims__JobType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_fims__JobType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_fims__JobType, n, EDLProvider_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(fims__JobType);
		if (size)
			*size = sizeof(fims__JobType);
		((fims__JobType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(fims__JobType, n);
		if (size)
			*size = n * sizeof(fims__JobType);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((fims__JobType*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (fims__JobType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_fims__JobType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying fims__JobType %p -> %p\n", q, p));
	*(fims__JobType*)p = *(fims__JobType*)q;
}

void fims__QueueType::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->fims__ResourceType::soap_default(soap);
	this->fims__QueueType::status = NULL;
	this->fims__QueueType::statusDescription = NULL;
	this->fims__QueueType::length = NULL;
	this->fims__QueueType::availability = NULL;
	this->fims__QueueType::estimatedTotalCompletionDuration = NULL;
	this->fims__QueueType::jobs = NULL;
}

void fims__QueueType::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTofims__QueueStatusType(soap, &this->fims__QueueType::status);
	soap_serialize_PointerTostd__wstring(soap, &this->fims__QueueType::statusDescription);
	soap_serialize_PointerToxsd__nonNegativeInteger(soap, &this->fims__QueueType::length);
	soap_serialize_PointerTobool(soap, &this->fims__QueueType::availability);
	soap_serialize_PointerToxsd__duration(soap, &this->fims__QueueType::estimatedTotalCompletionDuration);
	soap_serialize_PointerTofims__JobsType(soap, &this->fims__QueueType::jobs);
	this->fims__ResourceType::soap_serialize(soap);
#endif
}

int fims__QueueType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_fims__QueueType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_fims__QueueType(struct soap *soap, const char *tag, int id, const fims__QueueType *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_fims__QueueType), "fims:QueueType"))
		return soap->error;
	if (soap_out_fims__ResourceIDType(soap, "fims:resourceID", -1, &(a->fims__ResourceReferenceType::resourceID), ""))
		return soap->error;
	if (soap_out_PointerTofims__RevisionIDType(soap, "fims:revisionID", -1, &(a->fims__ResourceReferenceType::revisionID), ""))
		return soap->error;
	if (soap_out_PointerToxsd__anyURI(soap, "fims:location", -1, &(a->fims__ResourceReferenceType::location), ""))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_PointerTotime(soap, "fims:resourceCreationDate", -1, &(a->fims__ResourceType::resourceCreationDate), ""))
		return soap->error;
	if (soap_out_PointerTotime(soap, "fims:resourceModifiedDate", -1, &(a->fims__ResourceType::resourceModifiedDate), ""))
		return soap->error;
	if (soap_out_PointerTobool(soap, "fims:serviceGeneratedElement", -1, &(a->fims__ResourceType::serviceGeneratedElement), ""))
		return soap->error;
	if (soap_out_PointerTobool(soap, "fims:isFullyPopulated", -1, &(a->fims__ResourceType::isFullyPopulated), ""))
		return soap->error;
	if (soap_out_PointerTofims__AsyncEndpointType(soap, "fims:notifyAt", -1, &(a->fims__ResourceType::notifyAt), ""))
		return soap->error;
	if (soap_out_PointerTofims__ExtensionGroup(soap, "fims:ExtensionGroup", -1, &(a->fims__ResourceType::ExtensionGroup), ""))
		return soap->error;
	if (soap_out_PointerTofims__ExtensionAttributes(soap, "fims:ExtensionAttributes", -1, &(a->fims__ResourceType::ExtensionAttributes), ""))
		return soap->error;
	if (soap_out_PointerTofims__QueueStatusType(soap, "fims:status", -1, &(a->fims__QueueType::status), ""))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "fims:statusDescription", -1, &(a->fims__QueueType::statusDescription), ""))
		return soap->error;
	if (soap_out_PointerToxsd__nonNegativeInteger(soap, "fims:length", -1, &(a->fims__QueueType::length), ""))
		return soap->error;
	if (soap_out_PointerTobool(soap, "fims:availability", -1, &(a->fims__QueueType::availability), ""))
		return soap->error;
	if (soap_out_PointerToxsd__duration(soap, "fims:estimatedTotalCompletionDuration", -1, &(a->fims__QueueType::estimatedTotalCompletionDuration), ""))
		return soap->error;
	if (soap_out_PointerTofims__JobsType(soap, "fims:jobs", -1, &(a->fims__QueueType::jobs), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *fims__QueueType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_fims__QueueType(soap, tag, this, type);
}

SOAP_FMAC3 fims__QueueType * SOAP_FMAC4 soap_in_fims__QueueType(struct soap *soap, const char *tag, fims__QueueType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (fims__QueueType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_fims__QueueType, sizeof(fims__QueueType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_fims__QueueType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (fims__QueueType *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_resourceID3 = 1;
	size_t soap_flag_revisionID3 = 1;
	size_t soap_flag_location3 = 1;
	size_t soap_flag_resourceCreationDate2 = 1;
	size_t soap_flag_resourceModifiedDate2 = 1;
	size_t soap_flag_serviceGeneratedElement2 = 1;
	size_t soap_flag_isFullyPopulated2 = 1;
	size_t soap_flag_notifyAt2 = 1;
	size_t soap_flag_ExtensionGroup2 = 1;
	size_t soap_flag_ExtensionAttributes2 = 1;
	size_t soap_flag_status1 = 1;
	size_t soap_flag_statusDescription1 = 1;
	size_t soap_flag_length1 = 1;
	size_t soap_flag_availability1 = 1;
	size_t soap_flag_estimatedTotalCompletionDuration1 = 1;
	size_t soap_flag_jobs1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_resourceID3 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_fims__ResourceIDType(soap, "fims:resourceID", &(a->fims__ResourceReferenceType::resourceID), "fims:ResourceIDType"))
				{	soap_flag_resourceID3--;
					continue;
				}
			if (soap_flag_revisionID3 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTofims__RevisionIDType(soap, "fims:revisionID", &(a->fims__ResourceReferenceType::revisionID), "fims:RevisionIDType"))
				{	soap_flag_revisionID3--;
					continue;
				}
			if (soap_flag_location3 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerToxsd__anyURI(soap, "fims:location", &(a->fims__ResourceReferenceType::location), "xsd:anyURI"))
				{	soap_flag_location3--;
					continue;
				}
			/* transient soap skipped */
			if (soap_flag_resourceCreationDate2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTotime(soap, "fims:resourceCreationDate", &(a->fims__ResourceType::resourceCreationDate), "xsd:dateTime"))
				{	soap_flag_resourceCreationDate2--;
					continue;
				}
			if (soap_flag_resourceModifiedDate2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTotime(soap, "fims:resourceModifiedDate", &(a->fims__ResourceType::resourceModifiedDate), "xsd:dateTime"))
				{	soap_flag_resourceModifiedDate2--;
					continue;
				}
			if (soap_flag_serviceGeneratedElement2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTobool(soap, "fims:serviceGeneratedElement", &(a->fims__ResourceType::serviceGeneratedElement), "xsd:boolean"))
				{	soap_flag_serviceGeneratedElement2--;
					continue;
				}
			if (soap_flag_isFullyPopulated2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTobool(soap, "fims:isFullyPopulated", &(a->fims__ResourceType::isFullyPopulated), "xsd:boolean"))
				{	soap_flag_isFullyPopulated2--;
					continue;
				}
			if (soap_flag_notifyAt2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTofims__AsyncEndpointType(soap, "fims:notifyAt", &(a->fims__ResourceType::notifyAt), "fims:AsyncEndpointType"))
				{	soap_flag_notifyAt2--;
					continue;
				}
			if (soap_flag_ExtensionGroup2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTofims__ExtensionGroup(soap, "fims:ExtensionGroup", &(a->fims__ResourceType::ExtensionGroup), "fims:ExtensionGroup"))
				{	soap_flag_ExtensionGroup2--;
					continue;
				}
			if (soap_flag_ExtensionAttributes2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTofims__ExtensionAttributes(soap, "fims:ExtensionAttributes", &(a->fims__ResourceType::ExtensionAttributes), "fims:ExtensionAttributes"))
				{	soap_flag_ExtensionAttributes2--;
					continue;
				}
			if (soap_flag_status1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTofims__QueueStatusType(soap, "fims:status", &(a->fims__QueueType::status), "fims:QueueStatusType"))
				{	soap_flag_status1--;
					continue;
				}
			if (soap_flag_statusDescription1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "fims:statusDescription", &(a->fims__QueueType::statusDescription), "xsd:string"))
				{	soap_flag_statusDescription1--;
					continue;
				}
			if (soap_flag_length1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerToxsd__nonNegativeInteger(soap, "fims:length", &(a->fims__QueueType::length), "xsd:nonNegativeInteger"))
				{	soap_flag_length1--;
					continue;
				}
			if (soap_flag_availability1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTobool(soap, "fims:availability", &(a->fims__QueueType::availability), "xsd:boolean"))
				{	soap_flag_availability1--;
					continue;
				}
			if (soap_flag_estimatedTotalCompletionDuration1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToxsd__duration(soap, "fims:estimatedTotalCompletionDuration", &(a->fims__QueueType::estimatedTotalCompletionDuration), "xsd:duration"))
				{	soap_flag_estimatedTotalCompletionDuration1--;
					continue;
				}
			if (soap_flag_jobs1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTofims__JobsType(soap, "fims:jobs", &(a->fims__QueueType::jobs), "fims:JobsType"))
				{	soap_flag_jobs1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (fims__QueueType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_fims__QueueType, 0, sizeof(fims__QueueType), 0, soap_copy_fims__QueueType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_resourceID3 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int fims__QueueType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_fims__QueueType);
	if (this->soap_out(soap, tag?tag:"fims:QueueType", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *fims__QueueType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_fims__QueueType(soap, this, tag, type);
}

SOAP_FMAC3 fims__QueueType * SOAP_FMAC4 soap_get_fims__QueueType(struct soap *soap, fims__QueueType *p, const char *tag, const char *type)
{
	if ((p = soap_in_fims__QueueType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 fims__QueueType * SOAP_FMAC2 soap_instantiate_fims__QueueType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_fims__QueueType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_fims__QueueType, n, EDLProvider_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(fims__QueueType);
		if (size)
			*size = sizeof(fims__QueueType);
		((fims__QueueType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(fims__QueueType, n);
		if (size)
			*size = n * sizeof(fims__QueueType);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((fims__QueueType*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (fims__QueueType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_fims__QueueType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying fims__QueueType %p -> %p\n", q, p));
	*(fims__QueueType*)p = *(fims__QueueType*)q;
}

void fims__ProfileType::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->fims__ResourceType::soap_default(soap);
	this->fims__ProfileType::service = NULL;
	this->fims__ProfileType::name = NULL;
	this->fims__ProfileType::description = NULL;
}

void fims__ProfileType::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTofims__ServiceType(soap, &this->fims__ProfileType::service);
	this->fims__ResourceType::soap_serialize(soap);
#endif
}

int fims__ProfileType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_fims__ProfileType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_fims__ProfileType(struct soap *soap, const char *tag, int id, const fims__ProfileType *a, const char *type)
{
	if (((fims__ProfileType*)a)->name)
		soap_set_attr(soap, "name", soap_wchar2s(soap, ((fims__ProfileType*)a)->name->c_str()), 2);
	if (((fims__ProfileType*)a)->description)
		soap_set_attr(soap, "description", soap_wchar2s(soap, ((fims__ProfileType*)a)->description->c_str()), 2);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_fims__ProfileType), "fims:ProfileType"))
		return soap->error;
	if (soap_out_fims__ResourceIDType(soap, "fims:resourceID", -1, &(a->fims__ResourceReferenceType::resourceID), ""))
		return soap->error;
	if (soap_out_PointerTofims__RevisionIDType(soap, "fims:revisionID", -1, &(a->fims__ResourceReferenceType::revisionID), ""))
		return soap->error;
	if (soap_out_PointerToxsd__anyURI(soap, "fims:location", -1, &(a->fims__ResourceReferenceType::location), ""))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_PointerTotime(soap, "fims:resourceCreationDate", -1, &(a->fims__ResourceType::resourceCreationDate), ""))
		return soap->error;
	if (soap_out_PointerTotime(soap, "fims:resourceModifiedDate", -1, &(a->fims__ResourceType::resourceModifiedDate), ""))
		return soap->error;
	if (soap_out_PointerTobool(soap, "fims:serviceGeneratedElement", -1, &(a->fims__ResourceType::serviceGeneratedElement), ""))
		return soap->error;
	if (soap_out_PointerTobool(soap, "fims:isFullyPopulated", -1, &(a->fims__ResourceType::isFullyPopulated), ""))
		return soap->error;
	if (soap_out_PointerTofims__AsyncEndpointType(soap, "fims:notifyAt", -1, &(a->fims__ResourceType::notifyAt), ""))
		return soap->error;
	if (soap_out_PointerTofims__ExtensionGroup(soap, "fims:ExtensionGroup", -1, &(a->fims__ResourceType::ExtensionGroup), ""))
		return soap->error;
	if (soap_out_PointerTofims__ExtensionAttributes(soap, "fims:ExtensionAttributes", -1, &(a->fims__ResourceType::ExtensionAttributes), ""))
		return soap->error;
	if (soap_out_PointerTofims__ServiceType(soap, "fims:service", -1, &(a->fims__ProfileType::service), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *fims__ProfileType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_fims__ProfileType(soap, tag, this, type);
}

SOAP_FMAC3 fims__ProfileType * SOAP_FMAC4 soap_in_fims__ProfileType(struct soap *soap, const char *tag, fims__ProfileType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (fims__ProfileType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_fims__ProfileType, sizeof(fims__ProfileType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_fims__ProfileType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (fims__ProfileType *)a->soap_in(soap, tag, type);
		}
	}
	{	const char *t = soap_attr_value(soap, "name", 0);
		if (t)
		{
			if (!(((fims__ProfileType*)a)->name = (std::wstring *)soap_malloc(soap, sizeof(std::wstring))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			wchar_t *s = NULL;
			if (soap_s2wchar(soap, t, &s, 0, -1))
				return NULL;
			if (s)
			{	((fims__ProfileType*)a)->name = soap_new_std__wstring(soap, -1);
				((fims__ProfileType*)a)->name->assign(s);
			}
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "description", 0);
		if (t)
		{
			if (!(((fims__ProfileType*)a)->description = (std::wstring *)soap_malloc(soap, sizeof(std::wstring))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			wchar_t *s = NULL;
			if (soap_s2wchar(soap, t, &s, 0, -1))
				return NULL;
			if (s)
			{	((fims__ProfileType*)a)->description = soap_new_std__wstring(soap, -1);
				((fims__ProfileType*)a)->description->assign(s);
			}
		}
		else if (soap->error)
			return NULL;
	}
	size_t soap_flag_resourceID3 = 1;
	size_t soap_flag_revisionID3 = 1;
	size_t soap_flag_location3 = 1;
	size_t soap_flag_resourceCreationDate2 = 1;
	size_t soap_flag_resourceModifiedDate2 = 1;
	size_t soap_flag_serviceGeneratedElement2 = 1;
	size_t soap_flag_isFullyPopulated2 = 1;
	size_t soap_flag_notifyAt2 = 1;
	size_t soap_flag_ExtensionGroup2 = 1;
	size_t soap_flag_ExtensionAttributes2 = 1;
	size_t soap_flag_service1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_resourceID3 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_fims__ResourceIDType(soap, "fims:resourceID", &(a->fims__ResourceReferenceType::resourceID), "fims:ResourceIDType"))
				{	soap_flag_resourceID3--;
					continue;
				}
			if (soap_flag_revisionID3 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTofims__RevisionIDType(soap, "fims:revisionID", &(a->fims__ResourceReferenceType::revisionID), "fims:RevisionIDType"))
				{	soap_flag_revisionID3--;
					continue;
				}
			if (soap_flag_location3 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerToxsd__anyURI(soap, "fims:location", &(a->fims__ResourceReferenceType::location), "xsd:anyURI"))
				{	soap_flag_location3--;
					continue;
				}
			/* transient soap skipped */
			if (soap_flag_resourceCreationDate2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTotime(soap, "fims:resourceCreationDate", &(a->fims__ResourceType::resourceCreationDate), "xsd:dateTime"))
				{	soap_flag_resourceCreationDate2--;
					continue;
				}
			if (soap_flag_resourceModifiedDate2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTotime(soap, "fims:resourceModifiedDate", &(a->fims__ResourceType::resourceModifiedDate), "xsd:dateTime"))
				{	soap_flag_resourceModifiedDate2--;
					continue;
				}
			if (soap_flag_serviceGeneratedElement2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTobool(soap, "fims:serviceGeneratedElement", &(a->fims__ResourceType::serviceGeneratedElement), "xsd:boolean"))
				{	soap_flag_serviceGeneratedElement2--;
					continue;
				}
			if (soap_flag_isFullyPopulated2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTobool(soap, "fims:isFullyPopulated", &(a->fims__ResourceType::isFullyPopulated), "xsd:boolean"))
				{	soap_flag_isFullyPopulated2--;
					continue;
				}
			if (soap_flag_notifyAt2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTofims__AsyncEndpointType(soap, "fims:notifyAt", &(a->fims__ResourceType::notifyAt), "fims:AsyncEndpointType"))
				{	soap_flag_notifyAt2--;
					continue;
				}
			if (soap_flag_ExtensionGroup2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTofims__ExtensionGroup(soap, "fims:ExtensionGroup", &(a->fims__ResourceType::ExtensionGroup), "fims:ExtensionGroup"))
				{	soap_flag_ExtensionGroup2--;
					continue;
				}
			if (soap_flag_ExtensionAttributes2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTofims__ExtensionAttributes(soap, "fims:ExtensionAttributes", &(a->fims__ResourceType::ExtensionAttributes), "fims:ExtensionAttributes"))
				{	soap_flag_ExtensionAttributes2--;
					continue;
				}
			if (soap_flag_service1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTofims__ServiceType(soap, "fims:service", &(a->fims__ProfileType::service), "fims:ServiceType"))
				{	soap_flag_service1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (fims__ProfileType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_fims__ProfileType, 0, sizeof(fims__ProfileType), 0, soap_copy_fims__ProfileType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_resourceID3 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int fims__ProfileType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_fims__ProfileType);
	if (this->soap_out(soap, tag?tag:"fims:ProfileType", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *fims__ProfileType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_fims__ProfileType(soap, this, tag, type);
}

SOAP_FMAC3 fims__ProfileType * SOAP_FMAC4 soap_get_fims__ProfileType(struct soap *soap, fims__ProfileType *p, const char *tag, const char *type)
{
	if ((p = soap_in_fims__ProfileType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 fims__ProfileType * SOAP_FMAC2 soap_instantiate_fims__ProfileType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_fims__ProfileType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_fims__ProfileType, n, EDLProvider_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(fims__ProfileType);
		if (size)
			*size = sizeof(fims__ProfileType);
		((fims__ProfileType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(fims__ProfileType, n);
		if (size)
			*size = n * sizeof(fims__ProfileType);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((fims__ProfileType*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (fims__ProfileType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_fims__ProfileType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying fims__ProfileType %p -> %p\n", q, p));
	*(fims__ProfileType*)p = *(fims__ProfileType*)q;
}

void fims__ServiceType::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->fims__ResourceType::soap_default(soap);
	this->fims__ServiceType::providerName = NULL;
	this->fims__ServiceType::providerEndPoint = NULL;
	this->fims__ServiceType::serviceDescription = NULL;
}

void fims__ServiceType::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__wstring(soap, &this->fims__ServiceType::providerName);
	soap_serialize_PointerToxsd__anyURI(soap, &this->fims__ServiceType::providerEndPoint);
	soap_serialize_PointerTo_fims__ServiceType_serviceDescription(soap, &this->fims__ServiceType::serviceDescription);
	this->fims__ResourceType::soap_serialize(soap);
#endif
}

int fims__ServiceType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_fims__ServiceType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_fims__ServiceType(struct soap *soap, const char *tag, int id, const fims__ServiceType *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_fims__ServiceType), "fims:ServiceType"))
		return soap->error;
	if (soap_out_fims__ResourceIDType(soap, "fims:resourceID", -1, &(a->fims__ResourceReferenceType::resourceID), ""))
		return soap->error;
	if (soap_out_PointerTofims__RevisionIDType(soap, "fims:revisionID", -1, &(a->fims__ResourceReferenceType::revisionID), ""))
		return soap->error;
	if (soap_out_PointerToxsd__anyURI(soap, "fims:location", -1, &(a->fims__ResourceReferenceType::location), ""))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_PointerTotime(soap, "fims:resourceCreationDate", -1, &(a->fims__ResourceType::resourceCreationDate), ""))
		return soap->error;
	if (soap_out_PointerTotime(soap, "fims:resourceModifiedDate", -1, &(a->fims__ResourceType::resourceModifiedDate), ""))
		return soap->error;
	if (soap_out_PointerTobool(soap, "fims:serviceGeneratedElement", -1, &(a->fims__ResourceType::serviceGeneratedElement), ""))
		return soap->error;
	if (soap_out_PointerTobool(soap, "fims:isFullyPopulated", -1, &(a->fims__ResourceType::isFullyPopulated), ""))
		return soap->error;
	if (soap_out_PointerTofims__AsyncEndpointType(soap, "fims:notifyAt", -1, &(a->fims__ResourceType::notifyAt), ""))
		return soap->error;
	if (soap_out_PointerTofims__ExtensionGroup(soap, "fims:ExtensionGroup", -1, &(a->fims__ResourceType::ExtensionGroup), ""))
		return soap->error;
	if (soap_out_PointerTofims__ExtensionAttributes(soap, "fims:ExtensionAttributes", -1, &(a->fims__ResourceType::ExtensionAttributes), ""))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "fims:providerName", -1, &(a->fims__ServiceType::providerName), ""))
		return soap->error;
	if (soap_out_PointerToxsd__anyURI(soap, "fims:providerEndPoint", -1, &(a->fims__ServiceType::providerEndPoint), ""))
		return soap->error;
	if (soap_out_PointerTo_fims__ServiceType_serviceDescription(soap, "fims:serviceDescription", -1, &(a->fims__ServiceType::serviceDescription), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *fims__ServiceType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_fims__ServiceType(soap, tag, this, type);
}

SOAP_FMAC3 fims__ServiceType * SOAP_FMAC4 soap_in_fims__ServiceType(struct soap *soap, const char *tag, fims__ServiceType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (fims__ServiceType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_fims__ServiceType, sizeof(fims__ServiceType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_fims__ServiceType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (fims__ServiceType *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_resourceID3 = 1;
	size_t soap_flag_revisionID3 = 1;
	size_t soap_flag_location3 = 1;
	size_t soap_flag_resourceCreationDate2 = 1;
	size_t soap_flag_resourceModifiedDate2 = 1;
	size_t soap_flag_serviceGeneratedElement2 = 1;
	size_t soap_flag_isFullyPopulated2 = 1;
	size_t soap_flag_notifyAt2 = 1;
	size_t soap_flag_ExtensionGroup2 = 1;
	size_t soap_flag_ExtensionAttributes2 = 1;
	size_t soap_flag_providerName1 = 1;
	size_t soap_flag_providerEndPoint1 = 1;
	size_t soap_flag_serviceDescription1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_resourceID3 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_fims__ResourceIDType(soap, "fims:resourceID", &(a->fims__ResourceReferenceType::resourceID), "fims:ResourceIDType"))
				{	soap_flag_resourceID3--;
					continue;
				}
			if (soap_flag_revisionID3 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTofims__RevisionIDType(soap, "fims:revisionID", &(a->fims__ResourceReferenceType::revisionID), "fims:RevisionIDType"))
				{	soap_flag_revisionID3--;
					continue;
				}
			if (soap_flag_location3 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerToxsd__anyURI(soap, "fims:location", &(a->fims__ResourceReferenceType::location), "xsd:anyURI"))
				{	soap_flag_location3--;
					continue;
				}
			/* transient soap skipped */
			if (soap_flag_resourceCreationDate2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTotime(soap, "fims:resourceCreationDate", &(a->fims__ResourceType::resourceCreationDate), "xsd:dateTime"))
				{	soap_flag_resourceCreationDate2--;
					continue;
				}
			if (soap_flag_resourceModifiedDate2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTotime(soap, "fims:resourceModifiedDate", &(a->fims__ResourceType::resourceModifiedDate), "xsd:dateTime"))
				{	soap_flag_resourceModifiedDate2--;
					continue;
				}
			if (soap_flag_serviceGeneratedElement2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTobool(soap, "fims:serviceGeneratedElement", &(a->fims__ResourceType::serviceGeneratedElement), "xsd:boolean"))
				{	soap_flag_serviceGeneratedElement2--;
					continue;
				}
			if (soap_flag_isFullyPopulated2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTobool(soap, "fims:isFullyPopulated", &(a->fims__ResourceType::isFullyPopulated), "xsd:boolean"))
				{	soap_flag_isFullyPopulated2--;
					continue;
				}
			if (soap_flag_notifyAt2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTofims__AsyncEndpointType(soap, "fims:notifyAt", &(a->fims__ResourceType::notifyAt), "fims:AsyncEndpointType"))
				{	soap_flag_notifyAt2--;
					continue;
				}
			if (soap_flag_ExtensionGroup2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTofims__ExtensionGroup(soap, "fims:ExtensionGroup", &(a->fims__ResourceType::ExtensionGroup), "fims:ExtensionGroup"))
				{	soap_flag_ExtensionGroup2--;
					continue;
				}
			if (soap_flag_ExtensionAttributes2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTofims__ExtensionAttributes(soap, "fims:ExtensionAttributes", &(a->fims__ResourceType::ExtensionAttributes), "fims:ExtensionAttributes"))
				{	soap_flag_ExtensionAttributes2--;
					continue;
				}
			if (soap_flag_providerName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "fims:providerName", &(a->fims__ServiceType::providerName), "xsd:string"))
				{	soap_flag_providerName1--;
					continue;
				}
			if (soap_flag_providerEndPoint1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerToxsd__anyURI(soap, "fims:providerEndPoint", &(a->fims__ServiceType::providerEndPoint), "xsd:anyURI"))
				{	soap_flag_providerEndPoint1--;
					continue;
				}
			if (soap_flag_serviceDescription1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_fims__ServiceType_serviceDescription(soap, "fims:serviceDescription", &(a->fims__ServiceType::serviceDescription), ""))
				{	soap_flag_serviceDescription1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (fims__ServiceType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_fims__ServiceType, 0, sizeof(fims__ServiceType), 0, soap_copy_fims__ServiceType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_resourceID3 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int fims__ServiceType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_fims__ServiceType);
	if (this->soap_out(soap, tag?tag:"fims:ServiceType", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *fims__ServiceType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_fims__ServiceType(soap, this, tag, type);
}

SOAP_FMAC3 fims__ServiceType * SOAP_FMAC4 soap_get_fims__ServiceType(struct soap *soap, fims__ServiceType *p, const char *tag, const char *type)
{
	if ((p = soap_in_fims__ServiceType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 fims__ServiceType * SOAP_FMAC2 soap_instantiate_fims__ServiceType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_fims__ServiceType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_fims__ServiceType, n, EDLProvider_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(fims__ServiceType);
		if (size)
			*size = sizeof(fims__ServiceType);
		((fims__ServiceType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(fims__ServiceType, n);
		if (size)
			*size = n * sizeof(fims__ServiceType);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((fims__ServiceType*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (fims__ServiceType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_fims__ServiceType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying fims__ServiceType %p -> %p\n", q, p));
	*(fims__ServiceType*)p = *(fims__ServiceType*)q;
}

void fims__AsyncEndpointType::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_xsd__anyURI(soap, &this->fims__AsyncEndpointType::replyTo);
	soap_default_xsd__anyURI(soap, &this->fims__AsyncEndpointType::faultTo);
	/* transient soap skipped */
}

void fims__AsyncEndpointType::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &this->fims__AsyncEndpointType::replyTo, SOAP_TYPE_xsd__anyURI);
	soap_serialize_xsd__anyURI(soap, &this->fims__AsyncEndpointType::replyTo);
	soap_embedded(soap, &this->fims__AsyncEndpointType::faultTo, SOAP_TYPE_xsd__anyURI);
	soap_serialize_xsd__anyURI(soap, &this->fims__AsyncEndpointType::faultTo);
	/* transient soap skipped */
#endif
}

int fims__AsyncEndpointType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_fims__AsyncEndpointType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_fims__AsyncEndpointType(struct soap *soap, const char *tag, int id, const fims__AsyncEndpointType *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_fims__AsyncEndpointType), type))
		return soap->error;
	if (soap_out_xsd__anyURI(soap, "fims:replyTo", -1, &(a->fims__AsyncEndpointType::replyTo), ""))
		return soap->error;
	if (soap_out_xsd__anyURI(soap, "fims:faultTo", -1, &(a->fims__AsyncEndpointType::faultTo), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *fims__AsyncEndpointType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_fims__AsyncEndpointType(soap, tag, this, type);
}

SOAP_FMAC3 fims__AsyncEndpointType * SOAP_FMAC4 soap_in_fims__AsyncEndpointType(struct soap *soap, const char *tag, fims__AsyncEndpointType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (fims__AsyncEndpointType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_fims__AsyncEndpointType, sizeof(fims__AsyncEndpointType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_fims__AsyncEndpointType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (fims__AsyncEndpointType *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_replyTo1 = 1;
	size_t soap_flag_faultTo1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_replyTo1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__anyURI(soap, "fims:replyTo", &(a->fims__AsyncEndpointType::replyTo), "xsd:anyURI"))
				{	soap_flag_replyTo1--;
					continue;
				}
			if (soap_flag_faultTo1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__anyURI(soap, "fims:faultTo", &(a->fims__AsyncEndpointType::faultTo), "xsd:anyURI"))
				{	soap_flag_faultTo1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (fims__AsyncEndpointType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_fims__AsyncEndpointType, 0, sizeof(fims__AsyncEndpointType), 0, soap_copy_fims__AsyncEndpointType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_replyTo1 > 0 || soap_flag_faultTo1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int fims__AsyncEndpointType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_fims__AsyncEndpointType);
	if (this->soap_out(soap, tag?tag:"fims:AsyncEndpointType", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *fims__AsyncEndpointType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_fims__AsyncEndpointType(soap, this, tag, type);
}

SOAP_FMAC3 fims__AsyncEndpointType * SOAP_FMAC4 soap_get_fims__AsyncEndpointType(struct soap *soap, fims__AsyncEndpointType *p, const char *tag, const char *type)
{
	if ((p = soap_in_fims__AsyncEndpointType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 fims__AsyncEndpointType * SOAP_FMAC2 soap_instantiate_fims__AsyncEndpointType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_fims__AsyncEndpointType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_fims__AsyncEndpointType, n, EDLProvider_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(fims__AsyncEndpointType);
		if (size)
			*size = sizeof(fims__AsyncEndpointType);
		((fims__AsyncEndpointType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(fims__AsyncEndpointType, n);
		if (size)
			*size = n * sizeof(fims__AsyncEndpointType);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((fims__AsyncEndpointType*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (fims__AsyncEndpointType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_fims__AsyncEndpointType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying fims__AsyncEndpointType %p -> %p\n", q, p));
	*(fims__AsyncEndpointType*)p = *(fims__AsyncEndpointType*)q;
}

void fims__ExtensionBaseType::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->fims__ExtensionBaseType::ExtensionGroup = NULL;
	this->fims__ExtensionBaseType::ExtensionAttributes = NULL;
	/* transient soap skipped */
}

void fims__ExtensionBaseType::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTofims__ExtensionGroup(soap, &this->fims__ExtensionBaseType::ExtensionGroup);
	soap_serialize_PointerTofims__ExtensionAttributes(soap, &this->fims__ExtensionBaseType::ExtensionAttributes);
	/* transient soap skipped */
#endif
}

int fims__ExtensionBaseType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_fims__ExtensionBaseType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_fims__ExtensionBaseType(struct soap *soap, const char *tag, int id, const fims__ExtensionBaseType *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_fims__ExtensionBaseType), type))
		return soap->error;
	if (soap_out_PointerTofims__ExtensionGroup(soap, "fims:ExtensionGroup", -1, &(a->fims__ExtensionBaseType::ExtensionGroup), ""))
		return soap->error;
	if (soap_out_PointerTofims__ExtensionAttributes(soap, "fims:ExtensionAttributes", -1, &(a->fims__ExtensionBaseType::ExtensionAttributes), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *fims__ExtensionBaseType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_fims__ExtensionBaseType(soap, tag, this, type);
}

SOAP_FMAC3 fims__ExtensionBaseType * SOAP_FMAC4 soap_in_fims__ExtensionBaseType(struct soap *soap, const char *tag, fims__ExtensionBaseType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (fims__ExtensionBaseType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_fims__ExtensionBaseType, sizeof(fims__ExtensionBaseType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_fims__ExtensionBaseType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (fims__ExtensionBaseType *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_ExtensionGroup1 = 1;
	size_t soap_flag_ExtensionAttributes1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ExtensionGroup1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTofims__ExtensionGroup(soap, "fims:ExtensionGroup", &(a->fims__ExtensionBaseType::ExtensionGroup), "fims:ExtensionGroup"))
				{	soap_flag_ExtensionGroup1--;
					continue;
				}
			if (soap_flag_ExtensionAttributes1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTofims__ExtensionAttributes(soap, "fims:ExtensionAttributes", &(a->fims__ExtensionBaseType::ExtensionAttributes), "fims:ExtensionAttributes"))
				{	soap_flag_ExtensionAttributes1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (fims__ExtensionBaseType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_fims__ExtensionBaseType, 0, sizeof(fims__ExtensionBaseType), 0, soap_copy_fims__ExtensionBaseType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int fims__ExtensionBaseType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_fims__ExtensionBaseType);
	if (this->soap_out(soap, tag?tag:"fims:ExtensionBaseType", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *fims__ExtensionBaseType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_fims__ExtensionBaseType(soap, this, tag, type);
}

SOAP_FMAC3 fims__ExtensionBaseType * SOAP_FMAC4 soap_get_fims__ExtensionBaseType(struct soap *soap, fims__ExtensionBaseType *p, const char *tag, const char *type)
{
	if ((p = soap_in_fims__ExtensionBaseType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 fims__ExtensionBaseType * SOAP_FMAC2 soap_instantiate_fims__ExtensionBaseType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_fims__ExtensionBaseType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_fims__ExtensionBaseType, n, EDLProvider_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(fims__ExtensionBaseType);
		if (size)
			*size = sizeof(fims__ExtensionBaseType);
		((fims__ExtensionBaseType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(fims__ExtensionBaseType, n);
		if (size)
			*size = n * sizeof(fims__ExtensionBaseType);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((fims__ExtensionBaseType*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (fims__ExtensionBaseType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_fims__ExtensionBaseType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying fims__ExtensionBaseType %p -> %p\n", q, p));
	*(fims__ExtensionBaseType*)p = *(fims__ExtensionBaseType*)q;
}

void fims__ResourceType::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->fims__ResourceReferenceType::soap_default(soap);
	this->fims__ResourceType::resourceCreationDate = NULL;
	this->fims__ResourceType::resourceModifiedDate = NULL;
	this->fims__ResourceType::serviceGeneratedElement = NULL;
	this->fims__ResourceType::isFullyPopulated = NULL;
	this->fims__ResourceType::notifyAt = NULL;
	this->fims__ResourceType::ExtensionGroup = NULL;
	this->fims__ResourceType::ExtensionAttributes = NULL;
}

void fims__ResourceType::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTotime(soap, &this->fims__ResourceType::resourceCreationDate);
	soap_serialize_PointerTotime(soap, &this->fims__ResourceType::resourceModifiedDate);
	soap_serialize_PointerTobool(soap, &this->fims__ResourceType::serviceGeneratedElement);
	soap_serialize_PointerTobool(soap, &this->fims__ResourceType::isFullyPopulated);
	soap_serialize_PointerTofims__AsyncEndpointType(soap, &this->fims__ResourceType::notifyAt);
	soap_serialize_PointerTofims__ExtensionGroup(soap, &this->fims__ResourceType::ExtensionGroup);
	soap_serialize_PointerTofims__ExtensionAttributes(soap, &this->fims__ResourceType::ExtensionAttributes);
	this->fims__ResourceReferenceType::soap_serialize(soap);
#endif
}

int fims__ResourceType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_fims__ResourceType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_fims__ResourceType(struct soap *soap, const char *tag, int id, const fims__ResourceType *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_fims__ResourceType), "fims:ResourceType"))
		return soap->error;
	if (soap_out_fims__ResourceIDType(soap, "fims:resourceID", -1, &(a->fims__ResourceReferenceType::resourceID), ""))
		return soap->error;
	if (soap_out_PointerTofims__RevisionIDType(soap, "fims:revisionID", -1, &(a->fims__ResourceReferenceType::revisionID), ""))
		return soap->error;
	if (soap_out_PointerToxsd__anyURI(soap, "fims:location", -1, &(a->fims__ResourceReferenceType::location), ""))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_PointerTotime(soap, "fims:resourceCreationDate", -1, &(a->fims__ResourceType::resourceCreationDate), ""))
		return soap->error;
	if (soap_out_PointerTotime(soap, "fims:resourceModifiedDate", -1, &(a->fims__ResourceType::resourceModifiedDate), ""))
		return soap->error;
	if (soap_out_PointerTobool(soap, "fims:serviceGeneratedElement", -1, &(a->fims__ResourceType::serviceGeneratedElement), ""))
		return soap->error;
	if (soap_out_PointerTobool(soap, "fims:isFullyPopulated", -1, &(a->fims__ResourceType::isFullyPopulated), ""))
		return soap->error;
	if (soap_out_PointerTofims__AsyncEndpointType(soap, "fims:notifyAt", -1, &(a->fims__ResourceType::notifyAt), ""))
		return soap->error;
	if (soap_out_PointerTofims__ExtensionGroup(soap, "fims:ExtensionGroup", -1, &(a->fims__ResourceType::ExtensionGroup), ""))
		return soap->error;
	if (soap_out_PointerTofims__ExtensionAttributes(soap, "fims:ExtensionAttributes", -1, &(a->fims__ResourceType::ExtensionAttributes), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *fims__ResourceType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_fims__ResourceType(soap, tag, this, type);
}

SOAP_FMAC3 fims__ResourceType * SOAP_FMAC4 soap_in_fims__ResourceType(struct soap *soap, const char *tag, fims__ResourceType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (fims__ResourceType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_fims__ResourceType, sizeof(fims__ResourceType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_fims__ResourceType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (fims__ResourceType *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_resourceID2 = 1;
	size_t soap_flag_revisionID2 = 1;
	size_t soap_flag_location2 = 1;
	size_t soap_flag_resourceCreationDate1 = 1;
	size_t soap_flag_resourceModifiedDate1 = 1;
	size_t soap_flag_serviceGeneratedElement1 = 1;
	size_t soap_flag_isFullyPopulated1 = 1;
	size_t soap_flag_notifyAt1 = 1;
	size_t soap_flag_ExtensionGroup1 = 1;
	size_t soap_flag_ExtensionAttributes1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_resourceID2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_fims__ResourceIDType(soap, "fims:resourceID", &(a->fims__ResourceReferenceType::resourceID), "fims:ResourceIDType"))
				{	soap_flag_resourceID2--;
					continue;
				}
			if (soap_flag_revisionID2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTofims__RevisionIDType(soap, "fims:revisionID", &(a->fims__ResourceReferenceType::revisionID), "fims:RevisionIDType"))
				{	soap_flag_revisionID2--;
					continue;
				}
			if (soap_flag_location2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerToxsd__anyURI(soap, "fims:location", &(a->fims__ResourceReferenceType::location), "xsd:anyURI"))
				{	soap_flag_location2--;
					continue;
				}
			/* transient soap skipped */
			if (soap_flag_resourceCreationDate1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTotime(soap, "fims:resourceCreationDate", &(a->fims__ResourceType::resourceCreationDate), "xsd:dateTime"))
				{	soap_flag_resourceCreationDate1--;
					continue;
				}
			if (soap_flag_resourceModifiedDate1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTotime(soap, "fims:resourceModifiedDate", &(a->fims__ResourceType::resourceModifiedDate), "xsd:dateTime"))
				{	soap_flag_resourceModifiedDate1--;
					continue;
				}
			if (soap_flag_serviceGeneratedElement1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTobool(soap, "fims:serviceGeneratedElement", &(a->fims__ResourceType::serviceGeneratedElement), "xsd:boolean"))
				{	soap_flag_serviceGeneratedElement1--;
					continue;
				}
			if (soap_flag_isFullyPopulated1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTobool(soap, "fims:isFullyPopulated", &(a->fims__ResourceType::isFullyPopulated), "xsd:boolean"))
				{	soap_flag_isFullyPopulated1--;
					continue;
				}
			if (soap_flag_notifyAt1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTofims__AsyncEndpointType(soap, "fims:notifyAt", &(a->fims__ResourceType::notifyAt), "fims:AsyncEndpointType"))
				{	soap_flag_notifyAt1--;
					continue;
				}
			if (soap_flag_ExtensionGroup1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTofims__ExtensionGroup(soap, "fims:ExtensionGroup", &(a->fims__ResourceType::ExtensionGroup), "fims:ExtensionGroup"))
				{	soap_flag_ExtensionGroup1--;
					continue;
				}
			if (soap_flag_ExtensionAttributes1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTofims__ExtensionAttributes(soap, "fims:ExtensionAttributes", &(a->fims__ResourceType::ExtensionAttributes), "fims:ExtensionAttributes"))
				{	soap_flag_ExtensionAttributes1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (fims__ResourceType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_fims__ResourceType, 0, sizeof(fims__ResourceType), 0, soap_copy_fims__ResourceType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_resourceID2 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int fims__ResourceType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_fims__ResourceType);
	if (this->soap_out(soap, tag?tag:"fims:ResourceType", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *fims__ResourceType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_fims__ResourceType(soap, this, tag, type);
}

SOAP_FMAC3 fims__ResourceType * SOAP_FMAC4 soap_get_fims__ResourceType(struct soap *soap, fims__ResourceType *p, const char *tag, const char *type)
{
	if ((p = soap_in_fims__ResourceType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 fims__ResourceType * SOAP_FMAC2 soap_instantiate_fims__ResourceType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_fims__ResourceType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_fims__ResourceType, n, EDLProvider_fdelete);
	if (!cp)
		return NULL;
	if (type && !soap_match_tag(soap, type, "fims:ServiceType"))
	{	cp->type = SOAP_TYPE_fims__ServiceType;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(fims__ServiceType);
			if (size)
				*size = sizeof(fims__ServiceType);
			((fims__ServiceType*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW_ARRAY(fims__ServiceType, n);
			if (size)
				*size = n * sizeof(fims__ServiceType);
			if (cp->ptr)
				for (int i = 0; i < n; i++)
					((fims__ServiceType*)cp->ptr)[i].soap = soap;
		}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		if (!cp->ptr)
			soap->error = SOAP_EOM;
		return (fims__ServiceType*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "fims:ProfileType"))
	{	cp->type = SOAP_TYPE_fims__ProfileType;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(fims__ProfileType);
			if (size)
				*size = sizeof(fims__ProfileType);
			((fims__ProfileType*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW_ARRAY(fims__ProfileType, n);
			if (size)
				*size = n * sizeof(fims__ProfileType);
			if (cp->ptr)
				for (int i = 0; i < n; i++)
					((fims__ProfileType*)cp->ptr)[i].soap = soap;
		}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		if (!cp->ptr)
			soap->error = SOAP_EOM;
		return (fims__ProfileType*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "fims:QueueType"))
	{	cp->type = SOAP_TYPE_fims__QueueType;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(fims__QueueType);
			if (size)
				*size = sizeof(fims__QueueType);
			((fims__QueueType*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW_ARRAY(fims__QueueType, n);
			if (size)
				*size = n * sizeof(fims__QueueType);
			if (cp->ptr)
				for (int i = 0; i < n; i++)
					((fims__QueueType*)cp->ptr)[i].soap = soap;
		}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		if (!cp->ptr)
			soap->error = SOAP_EOM;
		return (fims__QueueType*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "fims:JobType"))
	{	cp->type = SOAP_TYPE_fims__JobType;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(fims__JobType);
			if (size)
				*size = sizeof(fims__JobType);
			((fims__JobType*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW_ARRAY(fims__JobType, n);
			if (size)
				*size = n * sizeof(fims__JobType);
			if (cp->ptr)
				for (int i = 0; i < n; i++)
					((fims__JobType*)cp->ptr)[i].soap = soap;
		}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		if (!cp->ptr)
			soap->error = SOAP_EOM;
		return (fims__JobType*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "fims:FormatType"))
	{	cp->type = SOAP_TYPE_fims__FormatType;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(fims__FormatType);
			if (size)
				*size = sizeof(fims__FormatType);
			((fims__FormatType*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW_ARRAY(fims__FormatType, n);
			if (size)
				*size = n * sizeof(fims__FormatType);
			if (cp->ptr)
				for (int i = 0; i < n; i++)
					((fims__FormatType*)cp->ptr)[i].soap = soap;
		}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		if (!cp->ptr)
			soap->error = SOAP_EOM;
		return (fims__FormatType*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "fims:BMObjectType"))
	{	cp->type = SOAP_TYPE_fims__BMObjectType;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(fims__BMObjectType);
			if (size)
				*size = sizeof(fims__BMObjectType);
			((fims__BMObjectType*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW_ARRAY(fims__BMObjectType, n);
			if (size)
				*size = n * sizeof(fims__BMObjectType);
			if (cp->ptr)
				for (int i = 0; i < n; i++)
					((fims__BMObjectType*)cp->ptr)[i].soap = soap;
		}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		if (!cp->ptr)
			soap->error = SOAP_EOM;
		return (fims__BMObjectType*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "fims:BMContentType"))
	{	cp->type = SOAP_TYPE_fims__BMContentType;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(fims__BMContentType);
			if (size)
				*size = sizeof(fims__BMContentType);
			((fims__BMContentType*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW_ARRAY(fims__BMContentType, n);
			if (size)
				*size = n * sizeof(fims__BMContentType);
			if (cp->ptr)
				for (int i = 0; i < n; i++)
					((fims__BMContentType*)cp->ptr)[i].soap = soap;
		}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		if (!cp->ptr)
			soap->error = SOAP_EOM;
		return (fims__BMContentType*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "fims:DescriptionType"))
	{	cp->type = SOAP_TYPE_fims__DescriptionType;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(fims__DescriptionType);
			if (size)
				*size = sizeof(fims__DescriptionType);
			((fims__DescriptionType*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW_ARRAY(fims__DescriptionType, n);
			if (size)
				*size = n * sizeof(fims__DescriptionType);
			if (cp->ptr)
				for (int i = 0; i < n; i++)
					((fims__DescriptionType*)cp->ptr)[i].soap = soap;
		}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		if (!cp->ptr)
			soap->error = SOAP_EOM;
		return (fims__DescriptionType*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "fims:BMContentFormatType"))
	{	cp->type = SOAP_TYPE_fims__BMContentFormatType;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(fims__BMContentFormatType);
			if (size)
				*size = sizeof(fims__BMContentFormatType);
			((fims__BMContentFormatType*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW_ARRAY(fims__BMContentFormatType, n);
			if (size)
				*size = n * sizeof(fims__BMContentFormatType);
			if (cp->ptr)
				for (int i = 0; i < n; i++)
					((fims__BMContentFormatType*)cp->ptr)[i].soap = soap;
		}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		if (!cp->ptr)
			soap->error = SOAP_EOM;
		return (fims__BMContentFormatType*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "fims:BMEssenceLocatorType"))
	{	cp->type = SOAP_TYPE_fims__BMEssenceLocatorType;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(fims__BMEssenceLocatorType);
			if (size)
				*size = sizeof(fims__BMEssenceLocatorType);
			((fims__BMEssenceLocatorType*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW_ARRAY(fims__BMEssenceLocatorType, n);
			if (size)
				*size = n * sizeof(fims__BMEssenceLocatorType);
			if (cp->ptr)
				for (int i = 0; i < n; i++)
					((fims__BMEssenceLocatorType*)cp->ptr)[i].soap = soap;
		}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		if (!cp->ptr)
			soap->error = SOAP_EOM;
		return (fims__BMEssenceLocatorType*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "fims:BMCustomStatusExtensionType"))
	{	cp->type = SOAP_TYPE_fims__BMCustomStatusExtensionType;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(fims__BMCustomStatusExtensionType);
			if (size)
				*size = sizeof(fims__BMCustomStatusExtensionType);
			((fims__BMCustomStatusExtensionType*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW_ARRAY(fims__BMCustomStatusExtensionType, n);
			if (size)
				*size = n * sizeof(fims__BMCustomStatusExtensionType);
			if (cp->ptr)
				for (int i = 0; i < n; i++)
					((fims__BMCustomStatusExtensionType*)cp->ptr)[i].soap = soap;
		}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		if (!cp->ptr)
			soap->error = SOAP_EOM;
		return (fims__BMCustomStatusExtensionType*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "fims:BMContentStatusType"))
	{	cp->type = SOAP_TYPE_fims__BMContentStatusType;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(fims__BMContentStatusType);
			if (size)
				*size = sizeof(fims__BMContentStatusType);
			((fims__BMContentStatusType*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW_ARRAY(fims__BMContentStatusType, n);
			if (size)
				*size = n * sizeof(fims__BMContentStatusType);
			if (cp->ptr)
				for (int i = 0; i < n; i++)
					((fims__BMContentStatusType*)cp->ptr)[i].soap = soap;
		}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		if (!cp->ptr)
			soap->error = SOAP_EOM;
		return (fims__BMContentStatusType*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "fims:BMEssenceLocatorStatusType"))
	{	cp->type = SOAP_TYPE_fims__BMEssenceLocatorStatusType;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(fims__BMEssenceLocatorStatusType);
			if (size)
				*size = sizeof(fims__BMEssenceLocatorStatusType);
			((fims__BMEssenceLocatorStatusType*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW_ARRAY(fims__BMEssenceLocatorStatusType, n);
			if (size)
				*size = n * sizeof(fims__BMEssenceLocatorStatusType);
			if (cp->ptr)
				for (int i = 0; i < n; i++)
					((fims__BMEssenceLocatorStatusType*)cp->ptr)[i].soap = soap;
		}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		if (!cp->ptr)
			soap->error = SOAP_EOM;
		return (fims__BMEssenceLocatorStatusType*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "fims:LockTokenType"))
	{	cp->type = SOAP_TYPE_fims__LockTokenType;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(fims__LockTokenType);
			if (size)
				*size = sizeof(fims__LockTokenType);
			((fims__LockTokenType*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW_ARRAY(fims__LockTokenType, n);
			if (size)
				*size = n * sizeof(fims__LockTokenType);
			if (cp->ptr)
				for (int i = 0; i < n; i++)
					((fims__LockTokenType*)cp->ptr)[i].soap = soap;
		}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		if (!cp->ptr)
			soap->error = SOAP_EOM;
		return (fims__LockTokenType*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "fims:SuperLockTokenType"))
	{	cp->type = SOAP_TYPE_fims__SuperLockTokenType;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(fims__SuperLockTokenType);
			if (size)
				*size = sizeof(fims__SuperLockTokenType);
			((fims__SuperLockTokenType*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW_ARRAY(fims__SuperLockTokenType, n);
			if (size)
				*size = n * sizeof(fims__SuperLockTokenType);
			if (cp->ptr)
				for (int i = 0; i < n; i++)
					((fims__SuperLockTokenType*)cp->ptr)[i].soap = soap;
		}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		if (!cp->ptr)
			soap->error = SOAP_EOM;
		return (fims__SuperLockTokenType*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "fims:VideoFormatType"))
	{	cp->type = SOAP_TYPE_fims__VideoFormatType;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(fims__VideoFormatType);
			if (size)
				*size = sizeof(fims__VideoFormatType);
			((fims__VideoFormatType*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW_ARRAY(fims__VideoFormatType, n);
			if (size)
				*size = n * sizeof(fims__VideoFormatType);
			if (cp->ptr)
				for (int i = 0; i < n; i++)
					((fims__VideoFormatType*)cp->ptr)[i].soap = soap;
		}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		if (!cp->ptr)
			soap->error = SOAP_EOM;
		return (fims__VideoFormatType*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "fims:AudioFormatType"))
	{	cp->type = SOAP_TYPE_fims__AudioFormatType;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(fims__AudioFormatType);
			if (size)
				*size = sizeof(fims__AudioFormatType);
			((fims__AudioFormatType*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW_ARRAY(fims__AudioFormatType, n);
			if (size)
				*size = n * sizeof(fims__AudioFormatType);
			if (cp->ptr)
				for (int i = 0; i < n; i++)
					((fims__AudioFormatType*)cp->ptr)[i].soap = soap;
		}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		if (!cp->ptr)
			soap->error = SOAP_EOM;
		return (fims__AudioFormatType*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "fims:DataFormatType"))
	{	cp->type = SOAP_TYPE_fims__DataFormatType;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(fims__DataFormatType);
			if (size)
				*size = sizeof(fims__DataFormatType);
			((fims__DataFormatType*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW_ARRAY(fims__DataFormatType, n);
			if (size)
				*size = n * sizeof(fims__DataFormatType);
			if (cp->ptr)
				for (int i = 0; i < n; i++)
					((fims__DataFormatType*)cp->ptr)[i].soap = soap;
		}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		if (!cp->ptr)
			soap->error = SOAP_EOM;
		return (fims__DataFormatType*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "fims:ContainerFormatType"))
	{	cp->type = SOAP_TYPE_fims__ContainerFormatType;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(fims__ContainerFormatType);
			if (size)
				*size = sizeof(fims__ContainerFormatType);
			((fims__ContainerFormatType*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW_ARRAY(fims__ContainerFormatType, n);
			if (size)
				*size = n * sizeof(fims__ContainerFormatType);
			if (cp->ptr)
				for (int i = 0; i < n; i++)
					((fims__ContainerFormatType*)cp->ptr)[i].soap = soap;
		}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		if (!cp->ptr)
			soap->error = SOAP_EOM;
		return (fims__ContainerFormatType*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "fims:SimpleFileLocatorType"))
	{	cp->type = SOAP_TYPE_fims__SimpleFileLocatorType;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(fims__SimpleFileLocatorType);
			if (size)
				*size = sizeof(fims__SimpleFileLocatorType);
			((fims__SimpleFileLocatorType*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW_ARRAY(fims__SimpleFileLocatorType, n);
			if (size)
				*size = n * sizeof(fims__SimpleFileLocatorType);
			if (cp->ptr)
				for (int i = 0; i < n; i++)
					((fims__SimpleFileLocatorType*)cp->ptr)[i].soap = soap;
		}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		if (!cp->ptr)
			soap->error = SOAP_EOM;
		return (fims__SimpleFileLocatorType*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "fims:ListFileLocatorType"))
	{	cp->type = SOAP_TYPE_fims__ListFileLocatorType;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(fims__ListFileLocatorType);
			if (size)
				*size = sizeof(fims__ListFileLocatorType);
			((fims__ListFileLocatorType*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW_ARRAY(fims__ListFileLocatorType, n);
			if (size)
				*size = n * sizeof(fims__ListFileLocatorType);
			if (cp->ptr)
				for (int i = 0; i < n; i++)
					((fims__ListFileLocatorType*)cp->ptr)[i].soap = soap;
		}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		if (!cp->ptr)
			soap->error = SOAP_EOM;
		return (fims__ListFileLocatorType*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "fims:FolderLocatorType"))
	{	cp->type = SOAP_TYPE_fims__FolderLocatorType;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(fims__FolderLocatorType);
			if (size)
				*size = sizeof(fims__FolderLocatorType);
			((fims__FolderLocatorType*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW_ARRAY(fims__FolderLocatorType, n);
			if (size)
				*size = n * sizeof(fims__FolderLocatorType);
			if (cp->ptr)
				for (int i = 0; i < n; i++)
					((fims__FolderLocatorType*)cp->ptr)[i].soap = soap;
		}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		if (!cp->ptr)
			soap->error = SOAP_EOM;
		return (fims__FolderLocatorType*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "fims:EssencePlaceholderLocatorType"))
	{	cp->type = SOAP_TYPE_fims__EssencePlaceholderLocatorType;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(fims__EssencePlaceholderLocatorType);
			if (size)
				*size = sizeof(fims__EssencePlaceholderLocatorType);
			((fims__EssencePlaceholderLocatorType*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW_ARRAY(fims__EssencePlaceholderLocatorType, n);
			if (size)
				*size = n * sizeof(fims__EssencePlaceholderLocatorType);
			if (cp->ptr)
				for (int i = 0; i < n; i++)
					((fims__EssencePlaceholderLocatorType*)cp->ptr)[i].soap = soap;
		}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		if (!cp->ptr)
			soap->error = SOAP_EOM;
		return (fims__EssencePlaceholderLocatorType*)cp->ptr;
	}
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(fims__ResourceType);
		if (size)
			*size = sizeof(fims__ResourceType);
		((fims__ResourceType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(fims__ResourceType, n);
		if (size)
			*size = n * sizeof(fims__ResourceType);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((fims__ResourceType*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (fims__ResourceType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_fims__ResourceType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying fims__ResourceType %p -> %p\n", q, p));
	*(fims__ResourceType*)p = *(fims__ResourceType*)q;
}

void fims__ResourceReferenceType::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_fims__ResourceIDType(soap, &this->fims__ResourceReferenceType::resourceID);
	this->fims__ResourceReferenceType::revisionID = NULL;
	this->fims__ResourceReferenceType::location = NULL;
	/* transient soap skipped */
}

void fims__ResourceReferenceType::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &this->fims__ResourceReferenceType::resourceID, SOAP_TYPE_fims__ResourceIDType);
	soap_serialize_fims__ResourceIDType(soap, &this->fims__ResourceReferenceType::resourceID);
	soap_serialize_PointerTofims__RevisionIDType(soap, &this->fims__ResourceReferenceType::revisionID);
	soap_serialize_PointerToxsd__anyURI(soap, &this->fims__ResourceReferenceType::location);
	/* transient soap skipped */
#endif
}

int fims__ResourceReferenceType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_fims__ResourceReferenceType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_fims__ResourceReferenceType(struct soap *soap, const char *tag, int id, const fims__ResourceReferenceType *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_fims__ResourceReferenceType), type))
		return soap->error;
	if (soap_out_fims__ResourceIDType(soap, "fims:resourceID", -1, &(a->fims__ResourceReferenceType::resourceID), ""))
		return soap->error;
	if (soap_out_PointerTofims__RevisionIDType(soap, "fims:revisionID", -1, &(a->fims__ResourceReferenceType::revisionID), ""))
		return soap->error;
	if (soap_out_PointerToxsd__anyURI(soap, "fims:location", -1, &(a->fims__ResourceReferenceType::location), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *fims__ResourceReferenceType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_fims__ResourceReferenceType(soap, tag, this, type);
}

SOAP_FMAC3 fims__ResourceReferenceType * SOAP_FMAC4 soap_in_fims__ResourceReferenceType(struct soap *soap, const char *tag, fims__ResourceReferenceType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (fims__ResourceReferenceType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_fims__ResourceReferenceType, sizeof(fims__ResourceReferenceType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_fims__ResourceReferenceType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (fims__ResourceReferenceType *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_resourceID1 = 1;
	size_t soap_flag_revisionID1 = 1;
	size_t soap_flag_location1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_resourceID1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_fims__ResourceIDType(soap, "fims:resourceID", &(a->fims__ResourceReferenceType::resourceID), "fims:ResourceIDType"))
				{	soap_flag_resourceID1--;
					continue;
				}
			if (soap_flag_revisionID1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTofims__RevisionIDType(soap, "fims:revisionID", &(a->fims__ResourceReferenceType::revisionID), "fims:RevisionIDType"))
				{	soap_flag_revisionID1--;
					continue;
				}
			if (soap_flag_location1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerToxsd__anyURI(soap, "fims:location", &(a->fims__ResourceReferenceType::location), "xsd:anyURI"))
				{	soap_flag_location1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (fims__ResourceReferenceType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_fims__ResourceReferenceType, 0, sizeof(fims__ResourceReferenceType), 0, soap_copy_fims__ResourceReferenceType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_resourceID1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int fims__ResourceReferenceType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_fims__ResourceReferenceType);
	if (this->soap_out(soap, tag?tag:"fims:ResourceReferenceType", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *fims__ResourceReferenceType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_fims__ResourceReferenceType(soap, this, tag, type);
}

SOAP_FMAC3 fims__ResourceReferenceType * SOAP_FMAC4 soap_get_fims__ResourceReferenceType(struct soap *soap, fims__ResourceReferenceType *p, const char *tag, const char *type)
{
	if ((p = soap_in_fims__ResourceReferenceType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 fims__ResourceReferenceType * SOAP_FMAC2 soap_instantiate_fims__ResourceReferenceType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_fims__ResourceReferenceType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_fims__ResourceReferenceType, n, EDLProvider_fdelete);
	if (!cp)
		return NULL;
	if (type && !soap_match_tag(soap, type, "fims:ResourceType"))
	{	cp->type = SOAP_TYPE_fims__ResourceType;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(fims__ResourceType);
			if (size)
				*size = sizeof(fims__ResourceType);
			((fims__ResourceType*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW_ARRAY(fims__ResourceType, n);
			if (size)
				*size = n * sizeof(fims__ResourceType);
			if (cp->ptr)
				for (int i = 0; i < n; i++)
					((fims__ResourceType*)cp->ptr)[i].soap = soap;
		}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		if (!cp->ptr)
			soap->error = SOAP_EOM;
		return (fims__ResourceType*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "fims:ServiceType"))
	{	cp->type = SOAP_TYPE_fims__ServiceType;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(fims__ServiceType);
			if (size)
				*size = sizeof(fims__ServiceType);
			((fims__ServiceType*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW_ARRAY(fims__ServiceType, n);
			if (size)
				*size = n * sizeof(fims__ServiceType);
			if (cp->ptr)
				for (int i = 0; i < n; i++)
					((fims__ServiceType*)cp->ptr)[i].soap = soap;
		}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		if (!cp->ptr)
			soap->error = SOAP_EOM;
		return (fims__ServiceType*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "fims:ProfileType"))
	{	cp->type = SOAP_TYPE_fims__ProfileType;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(fims__ProfileType);
			if (size)
				*size = sizeof(fims__ProfileType);
			((fims__ProfileType*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW_ARRAY(fims__ProfileType, n);
			if (size)
				*size = n * sizeof(fims__ProfileType);
			if (cp->ptr)
				for (int i = 0; i < n; i++)
					((fims__ProfileType*)cp->ptr)[i].soap = soap;
		}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		if (!cp->ptr)
			soap->error = SOAP_EOM;
		return (fims__ProfileType*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "fims:QueueType"))
	{	cp->type = SOAP_TYPE_fims__QueueType;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(fims__QueueType);
			if (size)
				*size = sizeof(fims__QueueType);
			((fims__QueueType*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW_ARRAY(fims__QueueType, n);
			if (size)
				*size = n * sizeof(fims__QueueType);
			if (cp->ptr)
				for (int i = 0; i < n; i++)
					((fims__QueueType*)cp->ptr)[i].soap = soap;
		}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		if (!cp->ptr)
			soap->error = SOAP_EOM;
		return (fims__QueueType*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "fims:JobType"))
	{	cp->type = SOAP_TYPE_fims__JobType;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(fims__JobType);
			if (size)
				*size = sizeof(fims__JobType);
			((fims__JobType*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW_ARRAY(fims__JobType, n);
			if (size)
				*size = n * sizeof(fims__JobType);
			if (cp->ptr)
				for (int i = 0; i < n; i++)
					((fims__JobType*)cp->ptr)[i].soap = soap;
		}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		if (!cp->ptr)
			soap->error = SOAP_EOM;
		return (fims__JobType*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "fims:FormatType"))
	{	cp->type = SOAP_TYPE_fims__FormatType;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(fims__FormatType);
			if (size)
				*size = sizeof(fims__FormatType);
			((fims__FormatType*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW_ARRAY(fims__FormatType, n);
			if (size)
				*size = n * sizeof(fims__FormatType);
			if (cp->ptr)
				for (int i = 0; i < n; i++)
					((fims__FormatType*)cp->ptr)[i].soap = soap;
		}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		if (!cp->ptr)
			soap->error = SOAP_EOM;
		return (fims__FormatType*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "fims:BMObjectType"))
	{	cp->type = SOAP_TYPE_fims__BMObjectType;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(fims__BMObjectType);
			if (size)
				*size = sizeof(fims__BMObjectType);
			((fims__BMObjectType*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW_ARRAY(fims__BMObjectType, n);
			if (size)
				*size = n * sizeof(fims__BMObjectType);
			if (cp->ptr)
				for (int i = 0; i < n; i++)
					((fims__BMObjectType*)cp->ptr)[i].soap = soap;
		}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		if (!cp->ptr)
			soap->error = SOAP_EOM;
		return (fims__BMObjectType*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "fims:BMContentType"))
	{	cp->type = SOAP_TYPE_fims__BMContentType;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(fims__BMContentType);
			if (size)
				*size = sizeof(fims__BMContentType);
			((fims__BMContentType*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW_ARRAY(fims__BMContentType, n);
			if (size)
				*size = n * sizeof(fims__BMContentType);
			if (cp->ptr)
				for (int i = 0; i < n; i++)
					((fims__BMContentType*)cp->ptr)[i].soap = soap;
		}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		if (!cp->ptr)
			soap->error = SOAP_EOM;
		return (fims__BMContentType*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "fims:DescriptionType"))
	{	cp->type = SOAP_TYPE_fims__DescriptionType;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(fims__DescriptionType);
			if (size)
				*size = sizeof(fims__DescriptionType);
			((fims__DescriptionType*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW_ARRAY(fims__DescriptionType, n);
			if (size)
				*size = n * sizeof(fims__DescriptionType);
			if (cp->ptr)
				for (int i = 0; i < n; i++)
					((fims__DescriptionType*)cp->ptr)[i].soap = soap;
		}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		if (!cp->ptr)
			soap->error = SOAP_EOM;
		return (fims__DescriptionType*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "fims:BMContentFormatType"))
	{	cp->type = SOAP_TYPE_fims__BMContentFormatType;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(fims__BMContentFormatType);
			if (size)
				*size = sizeof(fims__BMContentFormatType);
			((fims__BMContentFormatType*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW_ARRAY(fims__BMContentFormatType, n);
			if (size)
				*size = n * sizeof(fims__BMContentFormatType);
			if (cp->ptr)
				for (int i = 0; i < n; i++)
					((fims__BMContentFormatType*)cp->ptr)[i].soap = soap;
		}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		if (!cp->ptr)
			soap->error = SOAP_EOM;
		return (fims__BMContentFormatType*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "fims:BMEssenceLocatorType"))
	{	cp->type = SOAP_TYPE_fims__BMEssenceLocatorType;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(fims__BMEssenceLocatorType);
			if (size)
				*size = sizeof(fims__BMEssenceLocatorType);
			((fims__BMEssenceLocatorType*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW_ARRAY(fims__BMEssenceLocatorType, n);
			if (size)
				*size = n * sizeof(fims__BMEssenceLocatorType);
			if (cp->ptr)
				for (int i = 0; i < n; i++)
					((fims__BMEssenceLocatorType*)cp->ptr)[i].soap = soap;
		}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		if (!cp->ptr)
			soap->error = SOAP_EOM;
		return (fims__BMEssenceLocatorType*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "fims:BMCustomStatusExtensionType"))
	{	cp->type = SOAP_TYPE_fims__BMCustomStatusExtensionType;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(fims__BMCustomStatusExtensionType);
			if (size)
				*size = sizeof(fims__BMCustomStatusExtensionType);
			((fims__BMCustomStatusExtensionType*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW_ARRAY(fims__BMCustomStatusExtensionType, n);
			if (size)
				*size = n * sizeof(fims__BMCustomStatusExtensionType);
			if (cp->ptr)
				for (int i = 0; i < n; i++)
					((fims__BMCustomStatusExtensionType*)cp->ptr)[i].soap = soap;
		}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		if (!cp->ptr)
			soap->error = SOAP_EOM;
		return (fims__BMCustomStatusExtensionType*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "fims:BMContentStatusType"))
	{	cp->type = SOAP_TYPE_fims__BMContentStatusType;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(fims__BMContentStatusType);
			if (size)
				*size = sizeof(fims__BMContentStatusType);
			((fims__BMContentStatusType*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW_ARRAY(fims__BMContentStatusType, n);
			if (size)
				*size = n * sizeof(fims__BMContentStatusType);
			if (cp->ptr)
				for (int i = 0; i < n; i++)
					((fims__BMContentStatusType*)cp->ptr)[i].soap = soap;
		}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		if (!cp->ptr)
			soap->error = SOAP_EOM;
		return (fims__BMContentStatusType*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "fims:BMEssenceLocatorStatusType"))
	{	cp->type = SOAP_TYPE_fims__BMEssenceLocatorStatusType;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(fims__BMEssenceLocatorStatusType);
			if (size)
				*size = sizeof(fims__BMEssenceLocatorStatusType);
			((fims__BMEssenceLocatorStatusType*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW_ARRAY(fims__BMEssenceLocatorStatusType, n);
			if (size)
				*size = n * sizeof(fims__BMEssenceLocatorStatusType);
			if (cp->ptr)
				for (int i = 0; i < n; i++)
					((fims__BMEssenceLocatorStatusType*)cp->ptr)[i].soap = soap;
		}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		if (!cp->ptr)
			soap->error = SOAP_EOM;
		return (fims__BMEssenceLocatorStatusType*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "fims:LockTokenType"))
	{	cp->type = SOAP_TYPE_fims__LockTokenType;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(fims__LockTokenType);
			if (size)
				*size = sizeof(fims__LockTokenType);
			((fims__LockTokenType*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW_ARRAY(fims__LockTokenType, n);
			if (size)
				*size = n * sizeof(fims__LockTokenType);
			if (cp->ptr)
				for (int i = 0; i < n; i++)
					((fims__LockTokenType*)cp->ptr)[i].soap = soap;
		}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		if (!cp->ptr)
			soap->error = SOAP_EOM;
		return (fims__LockTokenType*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "fims:SuperLockTokenType"))
	{	cp->type = SOAP_TYPE_fims__SuperLockTokenType;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(fims__SuperLockTokenType);
			if (size)
				*size = sizeof(fims__SuperLockTokenType);
			((fims__SuperLockTokenType*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW_ARRAY(fims__SuperLockTokenType, n);
			if (size)
				*size = n * sizeof(fims__SuperLockTokenType);
			if (cp->ptr)
				for (int i = 0; i < n; i++)
					((fims__SuperLockTokenType*)cp->ptr)[i].soap = soap;
		}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		if (!cp->ptr)
			soap->error = SOAP_EOM;
		return (fims__SuperLockTokenType*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "fims:VideoFormatType"))
	{	cp->type = SOAP_TYPE_fims__VideoFormatType;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(fims__VideoFormatType);
			if (size)
				*size = sizeof(fims__VideoFormatType);
			((fims__VideoFormatType*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW_ARRAY(fims__VideoFormatType, n);
			if (size)
				*size = n * sizeof(fims__VideoFormatType);
			if (cp->ptr)
				for (int i = 0; i < n; i++)
					((fims__VideoFormatType*)cp->ptr)[i].soap = soap;
		}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		if (!cp->ptr)
			soap->error = SOAP_EOM;
		return (fims__VideoFormatType*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "fims:AudioFormatType"))
	{	cp->type = SOAP_TYPE_fims__AudioFormatType;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(fims__AudioFormatType);
			if (size)
				*size = sizeof(fims__AudioFormatType);
			((fims__AudioFormatType*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW_ARRAY(fims__AudioFormatType, n);
			if (size)
				*size = n * sizeof(fims__AudioFormatType);
			if (cp->ptr)
				for (int i = 0; i < n; i++)
					((fims__AudioFormatType*)cp->ptr)[i].soap = soap;
		}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		if (!cp->ptr)
			soap->error = SOAP_EOM;
		return (fims__AudioFormatType*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "fims:DataFormatType"))
	{	cp->type = SOAP_TYPE_fims__DataFormatType;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(fims__DataFormatType);
			if (size)
				*size = sizeof(fims__DataFormatType);
			((fims__DataFormatType*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW_ARRAY(fims__DataFormatType, n);
			if (size)
				*size = n * sizeof(fims__DataFormatType);
			if (cp->ptr)
				for (int i = 0; i < n; i++)
					((fims__DataFormatType*)cp->ptr)[i].soap = soap;
		}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		if (!cp->ptr)
			soap->error = SOAP_EOM;
		return (fims__DataFormatType*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "fims:ContainerFormatType"))
	{	cp->type = SOAP_TYPE_fims__ContainerFormatType;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(fims__ContainerFormatType);
			if (size)
				*size = sizeof(fims__ContainerFormatType);
			((fims__ContainerFormatType*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW_ARRAY(fims__ContainerFormatType, n);
			if (size)
				*size = n * sizeof(fims__ContainerFormatType);
			if (cp->ptr)
				for (int i = 0; i < n; i++)
					((fims__ContainerFormatType*)cp->ptr)[i].soap = soap;
		}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		if (!cp->ptr)
			soap->error = SOAP_EOM;
		return (fims__ContainerFormatType*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "fims:SimpleFileLocatorType"))
	{	cp->type = SOAP_TYPE_fims__SimpleFileLocatorType;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(fims__SimpleFileLocatorType);
			if (size)
				*size = sizeof(fims__SimpleFileLocatorType);
			((fims__SimpleFileLocatorType*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW_ARRAY(fims__SimpleFileLocatorType, n);
			if (size)
				*size = n * sizeof(fims__SimpleFileLocatorType);
			if (cp->ptr)
				for (int i = 0; i < n; i++)
					((fims__SimpleFileLocatorType*)cp->ptr)[i].soap = soap;
		}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		if (!cp->ptr)
			soap->error = SOAP_EOM;
		return (fims__SimpleFileLocatorType*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "fims:ListFileLocatorType"))
	{	cp->type = SOAP_TYPE_fims__ListFileLocatorType;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(fims__ListFileLocatorType);
			if (size)
				*size = sizeof(fims__ListFileLocatorType);
			((fims__ListFileLocatorType*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW_ARRAY(fims__ListFileLocatorType, n);
			if (size)
				*size = n * sizeof(fims__ListFileLocatorType);
			if (cp->ptr)
				for (int i = 0; i < n; i++)
					((fims__ListFileLocatorType*)cp->ptr)[i].soap = soap;
		}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		if (!cp->ptr)
			soap->error = SOAP_EOM;
		return (fims__ListFileLocatorType*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "fims:FolderLocatorType"))
	{	cp->type = SOAP_TYPE_fims__FolderLocatorType;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(fims__FolderLocatorType);
			if (size)
				*size = sizeof(fims__FolderLocatorType);
			((fims__FolderLocatorType*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW_ARRAY(fims__FolderLocatorType, n);
			if (size)
				*size = n * sizeof(fims__FolderLocatorType);
			if (cp->ptr)
				for (int i = 0; i < n; i++)
					((fims__FolderLocatorType*)cp->ptr)[i].soap = soap;
		}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		if (!cp->ptr)
			soap->error = SOAP_EOM;
		return (fims__FolderLocatorType*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "fims:EssencePlaceholderLocatorType"))
	{	cp->type = SOAP_TYPE_fims__EssencePlaceholderLocatorType;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(fims__EssencePlaceholderLocatorType);
			if (size)
				*size = sizeof(fims__EssencePlaceholderLocatorType);
			((fims__EssencePlaceholderLocatorType*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW_ARRAY(fims__EssencePlaceholderLocatorType, n);
			if (size)
				*size = n * sizeof(fims__EssencePlaceholderLocatorType);
			if (cp->ptr)
				for (int i = 0; i < n; i++)
					((fims__EssencePlaceholderLocatorType*)cp->ptr)[i].soap = soap;
		}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		if (!cp->ptr)
			soap->error = SOAP_EOM;
		return (fims__EssencePlaceholderLocatorType*)cp->ptr;
	}
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(fims__ResourceReferenceType);
		if (size)
			*size = sizeof(fims__ResourceReferenceType);
		((fims__ResourceReferenceType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(fims__ResourceReferenceType, n);
		if (size)
			*size = n * sizeof(fims__ResourceReferenceType);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((fims__ResourceReferenceType*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (fims__ResourceReferenceType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_fims__ResourceReferenceType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying fims__ResourceReferenceType %p -> %p\n", q, p));
	*(fims__ResourceReferenceType*)p = *(fims__ResourceReferenceType*)q;
}

void fims__ExtensionAttributes::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->fims__ExtensionAttributes::__anyAttribute = NULL;
	/* transient soap skipped */
}

void fims__ExtensionAttributes::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
#endif
}

int fims__ExtensionAttributes::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_fims__ExtensionAttributes(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_fims__ExtensionAttributes(struct soap *soap, const char *tag, int id, const fims__ExtensionAttributes *a, const char *type)
{
	if (((fims__ExtensionAttributes*)a)->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", ((fims__ExtensionAttributes*)a)->__anyAttribute, 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_fims__ExtensionAttributes), type))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *fims__ExtensionAttributes::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_fims__ExtensionAttributes(soap, tag, this, type);
}

SOAP_FMAC3 fims__ExtensionAttributes * SOAP_FMAC4 soap_in_fims__ExtensionAttributes(struct soap *soap, const char *tag, fims__ExtensionAttributes *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (fims__ExtensionAttributes *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_fims__ExtensionAttributes, sizeof(fims__ExtensionAttributes), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_fims__ExtensionAttributes)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (fims__ExtensionAttributes *)a->soap_in(soap, tag, type);
		}
	}
	if (soap_s2string(soap, soap_attr_value(soap, "-anyAttribute", 0), &((fims__ExtensionAttributes*)a)->__anyAttribute, 0, -1))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (fims__ExtensionAttributes *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_fims__ExtensionAttributes, 0, sizeof(fims__ExtensionAttributes), 0, soap_copy_fims__ExtensionAttributes);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int fims__ExtensionAttributes::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_fims__ExtensionAttributes);
	if (this->soap_out(soap, tag?tag:"fims:ExtensionAttributes", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *fims__ExtensionAttributes::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_fims__ExtensionAttributes(soap, this, tag, type);
}

SOAP_FMAC3 fims__ExtensionAttributes * SOAP_FMAC4 soap_get_fims__ExtensionAttributes(struct soap *soap, fims__ExtensionAttributes *p, const char *tag, const char *type)
{
	if ((p = soap_in_fims__ExtensionAttributes(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 fims__ExtensionAttributes * SOAP_FMAC2 soap_instantiate_fims__ExtensionAttributes(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_fims__ExtensionAttributes(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_fims__ExtensionAttributes, n, EDLProvider_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(fims__ExtensionAttributes);
		if (size)
			*size = sizeof(fims__ExtensionAttributes);
		((fims__ExtensionAttributes*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(fims__ExtensionAttributes, n);
		if (size)
			*size = n * sizeof(fims__ExtensionAttributes);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((fims__ExtensionAttributes*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (fims__ExtensionAttributes*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_fims__ExtensionAttributes(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying fims__ExtensionAttributes %p -> %p\n", q, p));
	*(fims__ExtensionAttributes*)p = *(fims__ExtensionAttributes*)q;
}

void fims__ExtensionGroup::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOf_XML(soap, &this->fims__ExtensionGroup::__any);
	/* transient soap skipped */
}

void fims__ExtensionGroup::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOf_XML(soap, &this->fims__ExtensionGroup::__any);
	/* transient soap skipped */
#endif
}

int fims__ExtensionGroup::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_fims__ExtensionGroup(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_fims__ExtensionGroup(struct soap *soap, const char *tag, int id, const fims__ExtensionGroup *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_fims__ExtensionGroup), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOf_XML(soap, "-any", -1, &(a->fims__ExtensionGroup::__any), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *fims__ExtensionGroup::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_fims__ExtensionGroup(soap, tag, this, type);
}

SOAP_FMAC3 fims__ExtensionGroup * SOAP_FMAC4 soap_in_fims__ExtensionGroup(struct soap *soap, const char *tag, fims__ExtensionGroup *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (fims__ExtensionGroup *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_fims__ExtensionGroup, sizeof(fims__ExtensionGroup), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_fims__ExtensionGroup)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (fims__ExtensionGroup *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOf_XML(soap, "-any", &(a->fims__ExtensionGroup::__any), ""))
					continue;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (fims__ExtensionGroup *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_fims__ExtensionGroup, 0, sizeof(fims__ExtensionGroup), 0, soap_copy_fims__ExtensionGroup);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int fims__ExtensionGroup::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_fims__ExtensionGroup);
	if (this->soap_out(soap, tag?tag:"fims:ExtensionGroup", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *fims__ExtensionGroup::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_fims__ExtensionGroup(soap, this, tag, type);
}

SOAP_FMAC3 fims__ExtensionGroup * SOAP_FMAC4 soap_get_fims__ExtensionGroup(struct soap *soap, fims__ExtensionGroup *p, const char *tag, const char *type)
{
	if ((p = soap_in_fims__ExtensionGroup(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 fims__ExtensionGroup * SOAP_FMAC2 soap_instantiate_fims__ExtensionGroup(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_fims__ExtensionGroup(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_fims__ExtensionGroup, n, EDLProvider_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(fims__ExtensionGroup);
		if (size)
			*size = sizeof(fims__ExtensionGroup);
		((fims__ExtensionGroup*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(fims__ExtensionGroup, n);
		if (size)
			*size = n * sizeof(fims__ExtensionGroup);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((fims__ExtensionGroup*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (fims__ExtensionGroup*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_fims__ExtensionGroup(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying fims__ExtensionGroup %p -> %p\n", q, p));
	*(fims__ExtensionGroup*)p = *(fims__ExtensionGroup*)q;
}

void _edlprovider__Map::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerToedlprovider__MapItemType(soap, &this->_edlprovider__Map::item);
	/* transient soap skipped */
}

void _edlprovider__Map::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfPointerToedlprovider__MapItemType(soap, &this->_edlprovider__Map::item);
	/* transient soap skipped */
#endif
}

int _edlprovider__Map::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__edlprovider__Map(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__edlprovider__Map(struct soap *soap, const char *tag, int id, const _edlprovider__Map *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__edlprovider__Map), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerToedlprovider__MapItemType(soap, "item", -1, &(a->_edlprovider__Map::item), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_edlprovider__Map::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__edlprovider__Map(soap, tag, this, type);
}

SOAP_FMAC3 _edlprovider__Map * SOAP_FMAC4 soap_in__edlprovider__Map(struct soap *soap, const char *tag, _edlprovider__Map *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_edlprovider__Map *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__edlprovider__Map, sizeof(_edlprovider__Map), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__edlprovider__Map)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_edlprovider__Map *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerToedlprovider__MapItemType(soap, "item", &(a->_edlprovider__Map::item), "edlprovider:MapItemType"))
					continue;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_edlprovider__Map *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__edlprovider__Map, 0, sizeof(_edlprovider__Map), 0, soap_copy__edlprovider__Map);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int _edlprovider__Map::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__edlprovider__Map);
	if (this->soap_out(soap, tag?tag:"edlprovider:Map", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_edlprovider__Map::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__edlprovider__Map(soap, this, tag, type);
}

SOAP_FMAC3 _edlprovider__Map * SOAP_FMAC4 soap_get__edlprovider__Map(struct soap *soap, _edlprovider__Map *p, const char *tag, const char *type)
{
	if ((p = soap_in__edlprovider__Map(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _edlprovider__Map * SOAP_FMAC2 soap_instantiate__edlprovider__Map(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__edlprovider__Map(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__edlprovider__Map, n, EDLProvider_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_edlprovider__Map);
		if (size)
			*size = sizeof(_edlprovider__Map);
		((_edlprovider__Map*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(_edlprovider__Map, n);
		if (size)
			*size = n * sizeof(_edlprovider__Map);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((_edlprovider__Map*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (_edlprovider__Map*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__edlprovider__Map(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _edlprovider__Map %p -> %p\n", q, p));
	*(_edlprovider__Map*)p = *(_edlprovider__Map*)q;
}

void edlprovider__EdlProviderFaultType::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->fims__FaultType::soap_default(soap);
	this->edlprovider__EdlProviderFaultType::extendedCode = NULL;
}

void edlprovider__EdlProviderFaultType::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerToedlprovider__EdlProviderErrorCodeType(soap, &this->edlprovider__EdlProviderFaultType::extendedCode);
	this->fims__FaultType::soap_serialize(soap);
#endif
}

int edlprovider__EdlProviderFaultType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_edlprovider__EdlProviderFaultType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_edlprovider__EdlProviderFaultType(struct soap *soap, const char *tag, int id, const edlprovider__EdlProviderFaultType *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_edlprovider__EdlProviderFaultType), "edlprovider:EdlProviderFaultType"))
		return soap->error;
	if (soap_out_fims__ErrorCodeType(soap, "fims:code", -1, &(a->fims__FaultType::code), ""))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "fims:description", -1, &(a->fims__FaultType::description), ""))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "fims:detail", -1, &(a->fims__FaultType::detail), ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTofims__InnerFaultType(soap, "fims:innerFault", -1, &(a->fims__FaultType::innerFault), ""))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_PointerToedlprovider__EdlProviderErrorCodeType(soap, "extendedCode", -1, &(a->edlprovider__EdlProviderFaultType::extendedCode), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *edlprovider__EdlProviderFaultType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_edlprovider__EdlProviderFaultType(soap, tag, this, type);
}

SOAP_FMAC3 edlprovider__EdlProviderFaultType * SOAP_FMAC4 soap_in_edlprovider__EdlProviderFaultType(struct soap *soap, const char *tag, edlprovider__EdlProviderFaultType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (edlprovider__EdlProviderFaultType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_edlprovider__EdlProviderFaultType, sizeof(edlprovider__EdlProviderFaultType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_edlprovider__EdlProviderFaultType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (edlprovider__EdlProviderFaultType *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_code2 = 1;
	size_t soap_flag_description2 = 1;
	size_t soap_flag_detail2 = 1;
	size_t soap_flag_extendedCode1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_code2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_fims__ErrorCodeType(soap, "fims:code", &(a->fims__FaultType::code), "fims:ErrorCodeType"))
				{	soap_flag_code2--;
					continue;
				}
			if (soap_flag_description2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "fims:description", &(a->fims__FaultType::description), "xsd:string"))
				{	soap_flag_description2--;
					continue;
				}
			if (soap_flag_detail2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "fims:detail", &(a->fims__FaultType::detail), "xsd:string"))
				{	soap_flag_detail2--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTofims__InnerFaultType(soap, "fims:innerFault", &(a->fims__FaultType::innerFault), "fims:InnerFaultType"))
					continue;
			/* transient soap skipped */
			if (soap_flag_extendedCode1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToedlprovider__EdlProviderErrorCodeType(soap, "extendedCode", &(a->edlprovider__EdlProviderFaultType::extendedCode), "edlprovider:EdlProviderErrorCodeType"))
				{	soap_flag_extendedCode1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (edlprovider__EdlProviderFaultType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_edlprovider__EdlProviderFaultType, 0, sizeof(edlprovider__EdlProviderFaultType), 0, soap_copy_edlprovider__EdlProviderFaultType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_code2 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int edlprovider__EdlProviderFaultType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_edlprovider__EdlProviderFaultType);
	if (this->soap_out(soap, tag?tag:"edlprovider:EdlProviderFaultType", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *edlprovider__EdlProviderFaultType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_edlprovider__EdlProviderFaultType(soap, this, tag, type);
}

SOAP_FMAC3 edlprovider__EdlProviderFaultType * SOAP_FMAC4 soap_get_edlprovider__EdlProviderFaultType(struct soap *soap, edlprovider__EdlProviderFaultType *p, const char *tag, const char *type)
{
	if ((p = soap_in_edlprovider__EdlProviderFaultType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 edlprovider__EdlProviderFaultType * SOAP_FMAC2 soap_instantiate_edlprovider__EdlProviderFaultType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_edlprovider__EdlProviderFaultType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_edlprovider__EdlProviderFaultType, n, EDLProvider_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(edlprovider__EdlProviderFaultType);
		if (size)
			*size = sizeof(edlprovider__EdlProviderFaultType);
		((edlprovider__EdlProviderFaultType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(edlprovider__EdlProviderFaultType, n);
		if (size)
			*size = n * sizeof(edlprovider__EdlProviderFaultType);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((edlprovider__EdlProviderFaultType*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (edlprovider__EdlProviderFaultType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_edlprovider__EdlProviderFaultType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying edlprovider__EdlProviderFaultType %p -> %p\n", q, p));
	*(edlprovider__EdlProviderFaultType*)p = *(edlprovider__EdlProviderFaultType*)q;
}

void edlprovider__InstalledEdlsResponseType::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->edlprovider__InstalledEdlsResponseType::edlprovider__Map = NULL;
	/* transient soap skipped */
}

void edlprovider__InstalledEdlsResponseType::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTo_edlprovider__Map(soap, &this->edlprovider__InstalledEdlsResponseType::edlprovider__Map);
	/* transient soap skipped */
#endif
}

int edlprovider__InstalledEdlsResponseType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_edlprovider__InstalledEdlsResponseType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_edlprovider__InstalledEdlsResponseType(struct soap *soap, const char *tag, int id, const edlprovider__InstalledEdlsResponseType *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_edlprovider__InstalledEdlsResponseType), type))
		return soap->error;
	if (a->edlprovider__Map)
		soap_element_result(soap, "edlprovider:Map");
	if (a->edlprovider__InstalledEdlsResponseType::edlprovider__Map)
	{	if (soap_out_PointerTo_edlprovider__Map(soap, "edlprovider:Map", -1, &a->edlprovider__InstalledEdlsResponseType::edlprovider__Map, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "edlprovider:Map"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *edlprovider__InstalledEdlsResponseType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_edlprovider__InstalledEdlsResponseType(soap, tag, this, type);
}

SOAP_FMAC3 edlprovider__InstalledEdlsResponseType * SOAP_FMAC4 soap_in_edlprovider__InstalledEdlsResponseType(struct soap *soap, const char *tag, edlprovider__InstalledEdlsResponseType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (edlprovider__InstalledEdlsResponseType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_edlprovider__InstalledEdlsResponseType, sizeof(edlprovider__InstalledEdlsResponseType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_edlprovider__InstalledEdlsResponseType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (edlprovider__InstalledEdlsResponseType *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_edlprovider__Map1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_edlprovider__Map1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_edlprovider__Map(soap, "edlprovider:Map", &(a->edlprovider__InstalledEdlsResponseType::edlprovider__Map), ""))
				{	soap_flag_edlprovider__Map1--;
					continue;
				}
			/* transient soap skipped */
			soap_check_result(soap, "edlprovider:Map");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (edlprovider__InstalledEdlsResponseType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_edlprovider__InstalledEdlsResponseType, 0, sizeof(edlprovider__InstalledEdlsResponseType), 0, soap_copy_edlprovider__InstalledEdlsResponseType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_edlprovider__Map1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int edlprovider__InstalledEdlsResponseType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_edlprovider__InstalledEdlsResponseType);
	if (this->soap_out(soap, tag?tag:"edlprovider:InstalledEdlsResponseType", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *edlprovider__InstalledEdlsResponseType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_edlprovider__InstalledEdlsResponseType(soap, this, tag, type);
}

SOAP_FMAC3 edlprovider__InstalledEdlsResponseType * SOAP_FMAC4 soap_get_edlprovider__InstalledEdlsResponseType(struct soap *soap, edlprovider__InstalledEdlsResponseType *p, const char *tag, const char *type)
{
	if ((p = soap_in_edlprovider__InstalledEdlsResponseType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 edlprovider__InstalledEdlsResponseType * SOAP_FMAC2 soap_instantiate_edlprovider__InstalledEdlsResponseType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_edlprovider__InstalledEdlsResponseType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_edlprovider__InstalledEdlsResponseType, n, EDLProvider_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(edlprovider__InstalledEdlsResponseType);
		if (size)
			*size = sizeof(edlprovider__InstalledEdlsResponseType);
		((edlprovider__InstalledEdlsResponseType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(edlprovider__InstalledEdlsResponseType, n);
		if (size)
			*size = n * sizeof(edlprovider__InstalledEdlsResponseType);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((edlprovider__InstalledEdlsResponseType*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (edlprovider__InstalledEdlsResponseType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_edlprovider__InstalledEdlsResponseType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying edlprovider__InstalledEdlsResponseType %p -> %p\n", q, p));
	*(edlprovider__InstalledEdlsResponseType*)p = *(edlprovider__InstalledEdlsResponseType*)q;
}

void edlprovider__EdlCreateResponseType::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->edlprovider__EdlCreateResponseType::getEdlResult = NULL;
	/* transient soap skipped */
}

void edlprovider__EdlCreateResponseType::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerToxsd__base64Binary(soap, &this->edlprovider__EdlCreateResponseType::getEdlResult);
	/* transient soap skipped */
#endif
}

int edlprovider__EdlCreateResponseType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_edlprovider__EdlCreateResponseType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_edlprovider__EdlCreateResponseType(struct soap *soap, const char *tag, int id, const edlprovider__EdlCreateResponseType *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_edlprovider__EdlCreateResponseType), type))
		return soap->error;
	if (soap_out_PointerToxsd__base64Binary(soap, "getEdlResult", -1, &(a->edlprovider__EdlCreateResponseType::getEdlResult), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *edlprovider__EdlCreateResponseType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_edlprovider__EdlCreateResponseType(soap, tag, this, type);
}

SOAP_FMAC3 edlprovider__EdlCreateResponseType * SOAP_FMAC4 soap_in_edlprovider__EdlCreateResponseType(struct soap *soap, const char *tag, edlprovider__EdlCreateResponseType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (edlprovider__EdlCreateResponseType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_edlprovider__EdlCreateResponseType, sizeof(edlprovider__EdlCreateResponseType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_edlprovider__EdlCreateResponseType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (edlprovider__EdlCreateResponseType *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_getEdlResult1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_getEdlResult1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToxsd__base64Binary(soap, "getEdlResult", &(a->edlprovider__EdlCreateResponseType::getEdlResult), "xsd:base64Binary"))
				{	soap_flag_getEdlResult1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (edlprovider__EdlCreateResponseType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_edlprovider__EdlCreateResponseType, 0, sizeof(edlprovider__EdlCreateResponseType), 0, soap_copy_edlprovider__EdlCreateResponseType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int edlprovider__EdlCreateResponseType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_edlprovider__EdlCreateResponseType);
	if (this->soap_out(soap, tag?tag:"edlprovider:EdlCreateResponseType", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *edlprovider__EdlCreateResponseType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_edlprovider__EdlCreateResponseType(soap, this, tag, type);
}

SOAP_FMAC3 edlprovider__EdlCreateResponseType * SOAP_FMAC4 soap_get_edlprovider__EdlCreateResponseType(struct soap *soap, edlprovider__EdlCreateResponseType *p, const char *tag, const char *type)
{
	if ((p = soap_in_edlprovider__EdlCreateResponseType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 edlprovider__EdlCreateResponseType * SOAP_FMAC2 soap_instantiate_edlprovider__EdlCreateResponseType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_edlprovider__EdlCreateResponseType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_edlprovider__EdlCreateResponseType, n, EDLProvider_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(edlprovider__EdlCreateResponseType);
		if (size)
			*size = sizeof(edlprovider__EdlCreateResponseType);
		((edlprovider__EdlCreateResponseType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(edlprovider__EdlCreateResponseType, n);
		if (size)
			*size = n * sizeof(edlprovider__EdlCreateResponseType);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((edlprovider__EdlCreateResponseType*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (edlprovider__EdlCreateResponseType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_edlprovider__EdlCreateResponseType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying edlprovider__EdlCreateResponseType %p -> %p\n", q, p));
	*(edlprovider__EdlCreateResponseType*)p = *(edlprovider__EdlCreateResponseType*)q;
}

void edlprovider__EdlCreateRequestDoubleType::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->edlprovider__EdlCreateRequestBaseType::soap_default(soap);
	soap_default_double(soap, &this->edlprovider__EdlCreateRequestDoubleType::edlFramesPerSecond);
}

void edlprovider__EdlCreateRequestDoubleType::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	this->edlprovider__EdlCreateRequestBaseType::soap_serialize(soap);
#endif
}

int edlprovider__EdlCreateRequestDoubleType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_edlprovider__EdlCreateRequestDoubleType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_edlprovider__EdlCreateRequestDoubleType(struct soap *soap, const char *tag, int id, const edlprovider__EdlCreateRequestDoubleType *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_edlprovider__EdlCreateRequestDoubleType), "edlprovider:EdlCreateRequestDoubleType"))
		return soap->error;
	if (soap_out_std__wstring(soap, "edlType", -1, &(a->edlprovider__EdlCreateRequestBaseType::edlType), ""))
		return soap->error;
	if (soap_out_PointerToedlprovider__ArrayOfClips(soap, "clips", -1, &(a->edlprovider__EdlCreateRequestBaseType::clips), ""))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "edlSequenceName", -1, &(a->edlprovider__EdlCreateRequestBaseType::edlSequenceName), ""))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_double(soap, "edlFramesPerSecond", -1, &(a->edlprovider__EdlCreateRequestDoubleType::edlFramesPerSecond), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *edlprovider__EdlCreateRequestDoubleType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_edlprovider__EdlCreateRequestDoubleType(soap, tag, this, type);
}

SOAP_FMAC3 edlprovider__EdlCreateRequestDoubleType * SOAP_FMAC4 soap_in_edlprovider__EdlCreateRequestDoubleType(struct soap *soap, const char *tag, edlprovider__EdlCreateRequestDoubleType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (edlprovider__EdlCreateRequestDoubleType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_edlprovider__EdlCreateRequestDoubleType, sizeof(edlprovider__EdlCreateRequestDoubleType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_edlprovider__EdlCreateRequestDoubleType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (edlprovider__EdlCreateRequestDoubleType *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_edlType2 = 1;
	size_t soap_flag_clips2 = 1;
	size_t soap_flag_edlSequenceName2 = 1;
	size_t soap_flag_edlFramesPerSecond1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_edlType2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__wstring(soap, "edlType", &(a->edlprovider__EdlCreateRequestBaseType::edlType), "xsd:string"))
				{	soap_flag_edlType2--;
					continue;
				}
			if (soap_flag_clips2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToedlprovider__ArrayOfClips(soap, "clips", &(a->edlprovider__EdlCreateRequestBaseType::clips), "edlprovider:ArrayOfClips"))
				{	soap_flag_clips2--;
					continue;
				}
			if (soap_flag_edlSequenceName2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "edlSequenceName", &(a->edlprovider__EdlCreateRequestBaseType::edlSequenceName), "xsd:string"))
				{	soap_flag_edlSequenceName2--;
					continue;
				}
			/* transient soap skipped */
			if (soap_flag_edlFramesPerSecond1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "edlFramesPerSecond", &(a->edlprovider__EdlCreateRequestDoubleType::edlFramesPerSecond), "xsd:double"))
				{	soap_flag_edlFramesPerSecond1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (edlprovider__EdlCreateRequestDoubleType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_edlprovider__EdlCreateRequestDoubleType, 0, sizeof(edlprovider__EdlCreateRequestDoubleType), 0, soap_copy_edlprovider__EdlCreateRequestDoubleType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_edlType2 > 0 || soap_flag_edlFramesPerSecond1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int edlprovider__EdlCreateRequestDoubleType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_edlprovider__EdlCreateRequestDoubleType);
	if (this->soap_out(soap, tag?tag:"edlprovider:EdlCreateRequestDoubleType", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *edlprovider__EdlCreateRequestDoubleType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_edlprovider__EdlCreateRequestDoubleType(soap, this, tag, type);
}

SOAP_FMAC3 edlprovider__EdlCreateRequestDoubleType * SOAP_FMAC4 soap_get_edlprovider__EdlCreateRequestDoubleType(struct soap *soap, edlprovider__EdlCreateRequestDoubleType *p, const char *tag, const char *type)
{
	if ((p = soap_in_edlprovider__EdlCreateRequestDoubleType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 edlprovider__EdlCreateRequestDoubleType * SOAP_FMAC2 soap_instantiate_edlprovider__EdlCreateRequestDoubleType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_edlprovider__EdlCreateRequestDoubleType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_edlprovider__EdlCreateRequestDoubleType, n, EDLProvider_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(edlprovider__EdlCreateRequestDoubleType);
		if (size)
			*size = sizeof(edlprovider__EdlCreateRequestDoubleType);
		((edlprovider__EdlCreateRequestDoubleType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(edlprovider__EdlCreateRequestDoubleType, n);
		if (size)
			*size = n * sizeof(edlprovider__EdlCreateRequestDoubleType);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((edlprovider__EdlCreateRequestDoubleType*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (edlprovider__EdlCreateRequestDoubleType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_edlprovider__EdlCreateRequestDoubleType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying edlprovider__EdlCreateRequestDoubleType %p -> %p\n", q, p));
	*(edlprovider__EdlCreateRequestDoubleType*)p = *(edlprovider__EdlCreateRequestDoubleType*)q;
}

void edlprovider__EdlCreateRequestType::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->edlprovider__EdlCreateRequestBaseType::soap_default(soap);
	this->edlprovider__EdlCreateRequestType::edlFramesPerSecond = NULL;
}

void edlprovider__EdlCreateRequestType::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTofims__RationalType(soap, &this->edlprovider__EdlCreateRequestType::edlFramesPerSecond);
	this->edlprovider__EdlCreateRequestBaseType::soap_serialize(soap);
#endif
}

int edlprovider__EdlCreateRequestType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_edlprovider__EdlCreateRequestType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_edlprovider__EdlCreateRequestType(struct soap *soap, const char *tag, int id, const edlprovider__EdlCreateRequestType *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_edlprovider__EdlCreateRequestType), "edlprovider:EdlCreateRequestType"))
		return soap->error;
	if (soap_out_std__wstring(soap, "edlType", -1, &(a->edlprovider__EdlCreateRequestBaseType::edlType), ""))
		return soap->error;
	if (soap_out_PointerToedlprovider__ArrayOfClips(soap, "clips", -1, &(a->edlprovider__EdlCreateRequestBaseType::clips), ""))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "edlSequenceName", -1, &(a->edlprovider__EdlCreateRequestBaseType::edlSequenceName), ""))
		return soap->error;
	/* transient soap skipped */
	if (a->edlprovider__EdlCreateRequestType::edlFramesPerSecond)
	{	if (soap_out_PointerTofims__RationalType(soap, "edlFramesPerSecond", -1, &a->edlprovider__EdlCreateRequestType::edlFramesPerSecond, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "edlFramesPerSecond"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *edlprovider__EdlCreateRequestType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_edlprovider__EdlCreateRequestType(soap, tag, this, type);
}

SOAP_FMAC3 edlprovider__EdlCreateRequestType * SOAP_FMAC4 soap_in_edlprovider__EdlCreateRequestType(struct soap *soap, const char *tag, edlprovider__EdlCreateRequestType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (edlprovider__EdlCreateRequestType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_edlprovider__EdlCreateRequestType, sizeof(edlprovider__EdlCreateRequestType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_edlprovider__EdlCreateRequestType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (edlprovider__EdlCreateRequestType *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_edlType2 = 1;
	size_t soap_flag_clips2 = 1;
	size_t soap_flag_edlSequenceName2 = 1;
	size_t soap_flag_edlFramesPerSecond1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_edlType2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__wstring(soap, "edlType", &(a->edlprovider__EdlCreateRequestBaseType::edlType), "xsd:string"))
				{	soap_flag_edlType2--;
					continue;
				}
			if (soap_flag_clips2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToedlprovider__ArrayOfClips(soap, "clips", &(a->edlprovider__EdlCreateRequestBaseType::clips), "edlprovider:ArrayOfClips"))
				{	soap_flag_clips2--;
					continue;
				}
			if (soap_flag_edlSequenceName2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "edlSequenceName", &(a->edlprovider__EdlCreateRequestBaseType::edlSequenceName), "xsd:string"))
				{	soap_flag_edlSequenceName2--;
					continue;
				}
			/* transient soap skipped */
			if (soap_flag_edlFramesPerSecond1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTofims__RationalType(soap, "edlFramesPerSecond", &(a->edlprovider__EdlCreateRequestType::edlFramesPerSecond), "fims:RationalType"))
				{	soap_flag_edlFramesPerSecond1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (edlprovider__EdlCreateRequestType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_edlprovider__EdlCreateRequestType, 0, sizeof(edlprovider__EdlCreateRequestType), 0, soap_copy_edlprovider__EdlCreateRequestType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_edlType2 > 0 || soap_flag_edlFramesPerSecond1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int edlprovider__EdlCreateRequestType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_edlprovider__EdlCreateRequestType);
	if (this->soap_out(soap, tag?tag:"edlprovider:EdlCreateRequestType", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *edlprovider__EdlCreateRequestType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_edlprovider__EdlCreateRequestType(soap, this, tag, type);
}

SOAP_FMAC3 edlprovider__EdlCreateRequestType * SOAP_FMAC4 soap_get_edlprovider__EdlCreateRequestType(struct soap *soap, edlprovider__EdlCreateRequestType *p, const char *tag, const char *type)
{
	if ((p = soap_in_edlprovider__EdlCreateRequestType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 edlprovider__EdlCreateRequestType * SOAP_FMAC2 soap_instantiate_edlprovider__EdlCreateRequestType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_edlprovider__EdlCreateRequestType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_edlprovider__EdlCreateRequestType, n, EDLProvider_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(edlprovider__EdlCreateRequestType);
		if (size)
			*size = sizeof(edlprovider__EdlCreateRequestType);
		((edlprovider__EdlCreateRequestType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(edlprovider__EdlCreateRequestType, n);
		if (size)
			*size = n * sizeof(edlprovider__EdlCreateRequestType);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((edlprovider__EdlCreateRequestType*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (edlprovider__EdlCreateRequestType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_edlprovider__EdlCreateRequestType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying edlprovider__EdlCreateRequestType %p -> %p\n", q, p));
	*(edlprovider__EdlCreateRequestType*)p = *(edlprovider__EdlCreateRequestType*)q;
}

void edlprovider__EdlCreateRequestBaseType::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__wstring(soap, &this->edlprovider__EdlCreateRequestBaseType::edlType);
	this->edlprovider__EdlCreateRequestBaseType::clips = NULL;
	this->edlprovider__EdlCreateRequestBaseType::edlSequenceName = NULL;
	/* transient soap skipped */
}

void edlprovider__EdlCreateRequestBaseType::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &this->edlprovider__EdlCreateRequestBaseType::edlType, SOAP_TYPE_std__wstring);
	soap_serialize_std__wstring(soap, &this->edlprovider__EdlCreateRequestBaseType::edlType);
	soap_serialize_PointerToedlprovider__ArrayOfClips(soap, &this->edlprovider__EdlCreateRequestBaseType::clips);
	soap_serialize_PointerTostd__wstring(soap, &this->edlprovider__EdlCreateRequestBaseType::edlSequenceName);
	/* transient soap skipped */
#endif
}

int edlprovider__EdlCreateRequestBaseType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_edlprovider__EdlCreateRequestBaseType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_edlprovider__EdlCreateRequestBaseType(struct soap *soap, const char *tag, int id, const edlprovider__EdlCreateRequestBaseType *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_edlprovider__EdlCreateRequestBaseType), type))
		return soap->error;
	if (soap_out_std__wstring(soap, "edlType", -1, &(a->edlprovider__EdlCreateRequestBaseType::edlType), ""))
		return soap->error;
	if (soap_out_PointerToedlprovider__ArrayOfClips(soap, "clips", -1, &(a->edlprovider__EdlCreateRequestBaseType::clips), ""))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "edlSequenceName", -1, &(a->edlprovider__EdlCreateRequestBaseType::edlSequenceName), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *edlprovider__EdlCreateRequestBaseType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_edlprovider__EdlCreateRequestBaseType(soap, tag, this, type);
}

SOAP_FMAC3 edlprovider__EdlCreateRequestBaseType * SOAP_FMAC4 soap_in_edlprovider__EdlCreateRequestBaseType(struct soap *soap, const char *tag, edlprovider__EdlCreateRequestBaseType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (edlprovider__EdlCreateRequestBaseType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_edlprovider__EdlCreateRequestBaseType, sizeof(edlprovider__EdlCreateRequestBaseType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_edlprovider__EdlCreateRequestBaseType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (edlprovider__EdlCreateRequestBaseType *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_edlType1 = 1;
	size_t soap_flag_clips1 = 1;
	size_t soap_flag_edlSequenceName1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_edlType1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__wstring(soap, "edlType", &(a->edlprovider__EdlCreateRequestBaseType::edlType), "xsd:string"))
				{	soap_flag_edlType1--;
					continue;
				}
			if (soap_flag_clips1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToedlprovider__ArrayOfClips(soap, "clips", &(a->edlprovider__EdlCreateRequestBaseType::clips), "edlprovider:ArrayOfClips"))
				{	soap_flag_clips1--;
					continue;
				}
			if (soap_flag_edlSequenceName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "edlSequenceName", &(a->edlprovider__EdlCreateRequestBaseType::edlSequenceName), "xsd:string"))
				{	soap_flag_edlSequenceName1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (edlprovider__EdlCreateRequestBaseType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_edlprovider__EdlCreateRequestBaseType, 0, sizeof(edlprovider__EdlCreateRequestBaseType), 0, soap_copy_edlprovider__EdlCreateRequestBaseType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_edlType1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int edlprovider__EdlCreateRequestBaseType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_edlprovider__EdlCreateRequestBaseType);
	if (this->soap_out(soap, tag?tag:"edlprovider:EdlCreateRequestBaseType", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *edlprovider__EdlCreateRequestBaseType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_edlprovider__EdlCreateRequestBaseType(soap, this, tag, type);
}

SOAP_FMAC3 edlprovider__EdlCreateRequestBaseType * SOAP_FMAC4 soap_get_edlprovider__EdlCreateRequestBaseType(struct soap *soap, edlprovider__EdlCreateRequestBaseType *p, const char *tag, const char *type)
{
	if ((p = soap_in_edlprovider__EdlCreateRequestBaseType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 edlprovider__EdlCreateRequestBaseType * SOAP_FMAC2 soap_instantiate_edlprovider__EdlCreateRequestBaseType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_edlprovider__EdlCreateRequestBaseType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_edlprovider__EdlCreateRequestBaseType, n, EDLProvider_fdelete);
	if (!cp)
		return NULL;
	if (type && !soap_match_tag(soap, type, "edlprovider:EdlCreateRequestType"))
	{	cp->type = SOAP_TYPE_edlprovider__EdlCreateRequestType;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(edlprovider__EdlCreateRequestType);
			if (size)
				*size = sizeof(edlprovider__EdlCreateRequestType);
			((edlprovider__EdlCreateRequestType*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW_ARRAY(edlprovider__EdlCreateRequestType, n);
			if (size)
				*size = n * sizeof(edlprovider__EdlCreateRequestType);
			if (cp->ptr)
				for (int i = 0; i < n; i++)
					((edlprovider__EdlCreateRequestType*)cp->ptr)[i].soap = soap;
		}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		if (!cp->ptr)
			soap->error = SOAP_EOM;
		return (edlprovider__EdlCreateRequestType*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "edlprovider:EdlCreateRequestDoubleType"))
	{	cp->type = SOAP_TYPE_edlprovider__EdlCreateRequestDoubleType;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(edlprovider__EdlCreateRequestDoubleType);
			if (size)
				*size = sizeof(edlprovider__EdlCreateRequestDoubleType);
			((edlprovider__EdlCreateRequestDoubleType*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW_ARRAY(edlprovider__EdlCreateRequestDoubleType, n);
			if (size)
				*size = n * sizeof(edlprovider__EdlCreateRequestDoubleType);
			if (cp->ptr)
				for (int i = 0; i < n; i++)
					((edlprovider__EdlCreateRequestDoubleType*)cp->ptr)[i].soap = soap;
		}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		if (!cp->ptr)
			soap->error = SOAP_EOM;
		return (edlprovider__EdlCreateRequestDoubleType*)cp->ptr;
	}
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(edlprovider__EdlCreateRequestBaseType);
		if (size)
			*size = sizeof(edlprovider__EdlCreateRequestBaseType);
		((edlprovider__EdlCreateRequestBaseType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(edlprovider__EdlCreateRequestBaseType, n);
		if (size)
			*size = n * sizeof(edlprovider__EdlCreateRequestBaseType);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((edlprovider__EdlCreateRequestBaseType*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (edlprovider__EdlCreateRequestBaseType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_edlprovider__EdlCreateRequestBaseType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying edlprovider__EdlCreateRequestBaseType %p -> %p\n", q, p));
	*(edlprovider__EdlCreateRequestBaseType*)p = *(edlprovider__EdlCreateRequestBaseType*)q;
}

void edlprovider__MapItemType::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__wstring(soap, &this->edlprovider__MapItemType::edlType);
	soap_default_std__wstring(soap, &this->edlprovider__MapItemType::edlExtension);
	/* transient soap skipped */
}

void edlprovider__MapItemType::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &this->edlprovider__MapItemType::edlType, SOAP_TYPE_std__wstring);
	soap_serialize_std__wstring(soap, &this->edlprovider__MapItemType::edlType);
	soap_embedded(soap, &this->edlprovider__MapItemType::edlExtension, SOAP_TYPE_std__wstring);
	soap_serialize_std__wstring(soap, &this->edlprovider__MapItemType::edlExtension);
	/* transient soap skipped */
#endif
}

int edlprovider__MapItemType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_edlprovider__MapItemType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_edlprovider__MapItemType(struct soap *soap, const char *tag, int id, const edlprovider__MapItemType *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_edlprovider__MapItemType), type))
		return soap->error;
	if (soap_out_std__wstring(soap, "edlType", -1, &(a->edlprovider__MapItemType::edlType), ""))
		return soap->error;
	if (soap_out_std__wstring(soap, "edlExtension", -1, &(a->edlprovider__MapItemType::edlExtension), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *edlprovider__MapItemType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_edlprovider__MapItemType(soap, tag, this, type);
}

SOAP_FMAC3 edlprovider__MapItemType * SOAP_FMAC4 soap_in_edlprovider__MapItemType(struct soap *soap, const char *tag, edlprovider__MapItemType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (edlprovider__MapItemType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_edlprovider__MapItemType, sizeof(edlprovider__MapItemType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_edlprovider__MapItemType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (edlprovider__MapItemType *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_edlType1 = 1;
	size_t soap_flag_edlExtension1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_edlType1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__wstring(soap, "edlType", &(a->edlprovider__MapItemType::edlType), "xsd:string"))
				{	soap_flag_edlType1--;
					continue;
				}
			if (soap_flag_edlExtension1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__wstring(soap, "edlExtension", &(a->edlprovider__MapItemType::edlExtension), "xsd:string"))
				{	soap_flag_edlExtension1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (edlprovider__MapItemType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_edlprovider__MapItemType, 0, sizeof(edlprovider__MapItemType), 0, soap_copy_edlprovider__MapItemType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_edlType1 > 0 || soap_flag_edlExtension1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int edlprovider__MapItemType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_edlprovider__MapItemType);
	if (this->soap_out(soap, tag?tag:"edlprovider:MapItemType", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *edlprovider__MapItemType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_edlprovider__MapItemType(soap, this, tag, type);
}

SOAP_FMAC3 edlprovider__MapItemType * SOAP_FMAC4 soap_get_edlprovider__MapItemType(struct soap *soap, edlprovider__MapItemType *p, const char *tag, const char *type)
{
	if ((p = soap_in_edlprovider__MapItemType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 edlprovider__MapItemType * SOAP_FMAC2 soap_instantiate_edlprovider__MapItemType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_edlprovider__MapItemType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_edlprovider__MapItemType, n, EDLProvider_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(edlprovider__MapItemType);
		if (size)
			*size = sizeof(edlprovider__MapItemType);
		((edlprovider__MapItemType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(edlprovider__MapItemType, n);
		if (size)
			*size = n * sizeof(edlprovider__MapItemType);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((edlprovider__MapItemType*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (edlprovider__MapItemType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_edlprovider__MapItemType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying edlprovider__MapItemType %p -> %p\n", q, p));
	*(edlprovider__MapItemType*)p = *(edlprovider__MapItemType*)q;
}

void edlprovider__ClipType::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->edlprovider__ClipType::markIn = NULL;
	this->edlprovider__ClipType::markOut = NULL;
	this->edlprovider__ClipType::clipInfo = NULL;
	/* transient soap skipped */
}

void edlprovider__ClipType::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTofimstime__TimeType(soap, &this->edlprovider__ClipType::markIn);
	soap_serialize_PointerTofimstime__TimeType(soap, &this->edlprovider__ClipType::markOut);
	soap_serialize_PointerTofims__BMObjectType(soap, &this->edlprovider__ClipType::clipInfo);
	/* transient soap skipped */
#endif
}

int edlprovider__ClipType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_edlprovider__ClipType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_edlprovider__ClipType(struct soap *soap, const char *tag, int id, const edlprovider__ClipType *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_edlprovider__ClipType), type))
		return soap->error;
	if (a->edlprovider__ClipType::markIn)
	{	if (soap_out_PointerTofimstime__TimeType(soap, "markIn", -1, &a->edlprovider__ClipType::markIn, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "markIn"))
		return soap->error;
	if (a->edlprovider__ClipType::markOut)
	{	if (soap_out_PointerTofimstime__TimeType(soap, "markOut", -1, &a->edlprovider__ClipType::markOut, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "markOut"))
		return soap->error;
	if (a->edlprovider__ClipType::clipInfo)
	{	if (soap_out_PointerTofims__BMObjectType(soap, "clipInfo", -1, &a->edlprovider__ClipType::clipInfo, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "clipInfo"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *edlprovider__ClipType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_edlprovider__ClipType(soap, tag, this, type);
}

SOAP_FMAC3 edlprovider__ClipType * SOAP_FMAC4 soap_in_edlprovider__ClipType(struct soap *soap, const char *tag, edlprovider__ClipType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (edlprovider__ClipType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_edlprovider__ClipType, sizeof(edlprovider__ClipType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_edlprovider__ClipType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (edlprovider__ClipType *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_markIn1 = 1;
	size_t soap_flag_markOut1 = 1;
	size_t soap_flag_clipInfo1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_markIn1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTofimstime__TimeType(soap, "markIn", &(a->edlprovider__ClipType::markIn), "fimstime:TimeType"))
				{	soap_flag_markIn1--;
					continue;
				}
			if (soap_flag_markOut1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTofimstime__TimeType(soap, "markOut", &(a->edlprovider__ClipType::markOut), "fimstime:TimeType"))
				{	soap_flag_markOut1--;
					continue;
				}
			if (soap_flag_clipInfo1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTofims__BMObjectType(soap, "clipInfo", &(a->edlprovider__ClipType::clipInfo), "fims:BMObjectType"))
				{	soap_flag_clipInfo1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (edlprovider__ClipType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_edlprovider__ClipType, 0, sizeof(edlprovider__ClipType), 0, soap_copy_edlprovider__ClipType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_markIn1 > 0 || soap_flag_markOut1 > 0 || soap_flag_clipInfo1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int edlprovider__ClipType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_edlprovider__ClipType);
	if (this->soap_out(soap, tag?tag:"edlprovider:ClipType", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *edlprovider__ClipType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_edlprovider__ClipType(soap, this, tag, type);
}

SOAP_FMAC3 edlprovider__ClipType * SOAP_FMAC4 soap_get_edlprovider__ClipType(struct soap *soap, edlprovider__ClipType *p, const char *tag, const char *type)
{
	if ((p = soap_in_edlprovider__ClipType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 edlprovider__ClipType * SOAP_FMAC2 soap_instantiate_edlprovider__ClipType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_edlprovider__ClipType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_edlprovider__ClipType, n, EDLProvider_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(edlprovider__ClipType);
		if (size)
			*size = sizeof(edlprovider__ClipType);
		((edlprovider__ClipType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(edlprovider__ClipType, n);
		if (size)
			*size = n * sizeof(edlprovider__ClipType);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((edlprovider__ClipType*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (edlprovider__ClipType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_edlprovider__ClipType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying edlprovider__ClipType %p -> %p\n", q, p));
	*(edlprovider__ClipType*)p = *(edlprovider__ClipType*)q;
}

void edlprovider__ArrayOfClips::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerToedlprovider__ClipType(soap, &this->edlprovider__ArrayOfClips::clips);
	/* transient soap skipped */
}

void edlprovider__ArrayOfClips::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfPointerToedlprovider__ClipType(soap, &this->edlprovider__ArrayOfClips::clips);
	/* transient soap skipped */
#endif
}

int edlprovider__ArrayOfClips::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_edlprovider__ArrayOfClips(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_edlprovider__ArrayOfClips(struct soap *soap, const char *tag, int id, const edlprovider__ArrayOfClips *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_edlprovider__ArrayOfClips), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerToedlprovider__ClipType(soap, "clips", -1, &(a->edlprovider__ArrayOfClips::clips), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *edlprovider__ArrayOfClips::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_edlprovider__ArrayOfClips(soap, tag, this, type);
}

SOAP_FMAC3 edlprovider__ArrayOfClips * SOAP_FMAC4 soap_in_edlprovider__ArrayOfClips(struct soap *soap, const char *tag, edlprovider__ArrayOfClips *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (edlprovider__ArrayOfClips *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_edlprovider__ArrayOfClips, sizeof(edlprovider__ArrayOfClips), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_edlprovider__ArrayOfClips)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (edlprovider__ArrayOfClips *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerToedlprovider__ClipType(soap, "clips", &(a->edlprovider__ArrayOfClips::clips), "edlprovider:ClipType"))
					continue;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (edlprovider__ArrayOfClips *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_edlprovider__ArrayOfClips, 0, sizeof(edlprovider__ArrayOfClips), 0, soap_copy_edlprovider__ArrayOfClips);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int edlprovider__ArrayOfClips::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_edlprovider__ArrayOfClips);
	if (this->soap_out(soap, tag?tag:"edlprovider:ArrayOfClips", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *edlprovider__ArrayOfClips::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_edlprovider__ArrayOfClips(soap, this, tag, type);
}

SOAP_FMAC3 edlprovider__ArrayOfClips * SOAP_FMAC4 soap_get_edlprovider__ArrayOfClips(struct soap *soap, edlprovider__ArrayOfClips *p, const char *tag, const char *type)
{
	if ((p = soap_in_edlprovider__ArrayOfClips(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 edlprovider__ArrayOfClips * SOAP_FMAC2 soap_instantiate_edlprovider__ArrayOfClips(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_edlprovider__ArrayOfClips(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_edlprovider__ArrayOfClips, n, EDLProvider_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(edlprovider__ArrayOfClips);
		if (size)
			*size = sizeof(edlprovider__ArrayOfClips);
		((edlprovider__ArrayOfClips*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(edlprovider__ArrayOfClips, n);
		if (size)
			*size = n * sizeof(edlprovider__ArrayOfClips);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((edlprovider__ArrayOfClips*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (edlprovider__ArrayOfClips*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_edlprovider__ArrayOfClips(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying edlprovider__ArrayOfClips %p -> %p\n", q, p));
	*(edlprovider__ArrayOfClips*)p = *(edlprovider__ArrayOfClips*)q;
}

void edlprovider__ArrayOfstring::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfstd__wstring(soap, &this->edlprovider__ArrayOfstring::string);
	/* transient soap skipped */
}

void edlprovider__ArrayOfstring::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfstd__wstring(soap, &this->edlprovider__ArrayOfstring::string);
	/* transient soap skipped */
#endif
}

int edlprovider__ArrayOfstring::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_edlprovider__ArrayOfstring(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_edlprovider__ArrayOfstring(struct soap *soap, const char *tag, int id, const edlprovider__ArrayOfstring *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_edlprovider__ArrayOfstring), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfstd__wstring(soap, "string", -1, &(a->edlprovider__ArrayOfstring::string), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *edlprovider__ArrayOfstring::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_edlprovider__ArrayOfstring(soap, tag, this, type);
}

SOAP_FMAC3 edlprovider__ArrayOfstring * SOAP_FMAC4 soap_in_edlprovider__ArrayOfstring(struct soap *soap, const char *tag, edlprovider__ArrayOfstring *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (edlprovider__ArrayOfstring *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_edlprovider__ArrayOfstring, sizeof(edlprovider__ArrayOfstring), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_edlprovider__ArrayOfstring)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (edlprovider__ArrayOfstring *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfstd__wstring(soap, "string", &(a->edlprovider__ArrayOfstring::string), "xsd:string"))
					continue;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (edlprovider__ArrayOfstring *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_edlprovider__ArrayOfstring, 0, sizeof(edlprovider__ArrayOfstring), 0, soap_copy_edlprovider__ArrayOfstring);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int edlprovider__ArrayOfstring::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_edlprovider__ArrayOfstring);
	if (this->soap_out(soap, tag?tag:"edlprovider:ArrayOfstring", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *edlprovider__ArrayOfstring::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_edlprovider__ArrayOfstring(soap, this, tag, type);
}

SOAP_FMAC3 edlprovider__ArrayOfstring * SOAP_FMAC4 soap_get_edlprovider__ArrayOfstring(struct soap *soap, edlprovider__ArrayOfstring *p, const char *tag, const char *type)
{
	if ((p = soap_in_edlprovider__ArrayOfstring(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 edlprovider__ArrayOfstring * SOAP_FMAC2 soap_instantiate_edlprovider__ArrayOfstring(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_edlprovider__ArrayOfstring(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_edlprovider__ArrayOfstring, n, EDLProvider_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(edlprovider__ArrayOfstring);
		if (size)
			*size = sizeof(edlprovider__ArrayOfstring);
		((edlprovider__ArrayOfstring*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(edlprovider__ArrayOfstring, n);
		if (size)
			*size = n * sizeof(edlprovider__ArrayOfstring);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((edlprovider__ArrayOfstring*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (edlprovider__ArrayOfstring*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_edlprovider__ArrayOfstring(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying edlprovider__ArrayOfstring %p -> %p\n", q, p));
	*(edlprovider__ArrayOfstring*)p = *(edlprovider__ArrayOfstring*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_xsd__time(struct soap *soap, const std::wstring *a)
{	(void)soap; (void)a; /* appease -Wall -Werror */
}
SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__time(struct soap *soap, const char *tag, int id, const std::wstring *s, const char *type)
{
	if ((soap->mode & SOAP_C_NILSTRING) && s->empty())
		return soap_element_null(soap, tag, id, type);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, s, SOAP_TYPE_xsd__time), type) || soap_wstring_out(soap, s->c_str(), 0) || soap_element_end_out(soap, tag))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 std::wstring * SOAP_FMAC4 soap_in_xsd__time(struct soap *soap, const char *tag, std::wstring *s, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!s)
		s = soap_new_std__wstring(soap, -1);
	if (soap->null)
		if (s)
			s->erase();
	if (soap->body && !*soap->href)
	{	wchar_t *t;
		s = (std::wstring*)soap_class_id_enter(soap, soap->id, s, SOAP_TYPE_xsd__time, sizeof(std::wstring), soap->type, soap->arrayType);
		if (s)
		{	if (!(t = soap_wstring_in(soap, 1, 0, -1)))
				return NULL;
			s->assign(t);
		}
	}
	else
		s = (std::wstring*)soap_id_forward(soap, soap->href, soap_class_id_enter(soap, soap->id, s, SOAP_TYPE_xsd__time, sizeof(std::wstring), soap->type, soap->arrayType), 0, SOAP_TYPE_xsd__time, 0, sizeof(std::wstring), 0, soap_copy_xsd__time);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	return s;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xsd__time(struct soap *soap, const std::wstring *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_xsd__time);
	if (soap_out_xsd__time(soap, tag?tag:"xsd:time", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::wstring * SOAP_FMAC4 soap_get_xsd__time(struct soap *soap, std::wstring *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__time(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_xsd__positiveInteger(struct soap *soap, const std::wstring *a)
{	(void)soap; (void)a; /* appease -Wall -Werror */
}
SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__positiveInteger(struct soap *soap, const char *tag, int id, const std::wstring *s, const char *type)
{
	if ((soap->mode & SOAP_C_NILSTRING) && s->empty())
		return soap_element_null(soap, tag, id, type);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, s, SOAP_TYPE_xsd__positiveInteger), type) || soap_wstring_out(soap, s->c_str(), 0) || soap_element_end_out(soap, tag))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 std::wstring * SOAP_FMAC4 soap_in_xsd__positiveInteger(struct soap *soap, const char *tag, std::wstring *s, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!s)
		s = soap_new_std__wstring(soap, -1);
	if (soap->null)
		if (s)
			s->erase();
	if (soap->body && !*soap->href)
	{	wchar_t *t;
		s = (std::wstring*)soap_class_id_enter(soap, soap->id, s, SOAP_TYPE_xsd__positiveInteger, sizeof(std::wstring), soap->type, soap->arrayType);
		if (s)
		{	if (!(t = soap_wstring_in(soap, 1, 0, -1)))
				return NULL;
			s->assign(t);
		}
	}
	else
		s = (std::wstring*)soap_id_forward(soap, soap->href, soap_class_id_enter(soap, soap->id, s, SOAP_TYPE_xsd__positiveInteger, sizeof(std::wstring), soap->type, soap->arrayType), 0, SOAP_TYPE_xsd__positiveInteger, 0, sizeof(std::wstring), 0, soap_copy_xsd__positiveInteger);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	return s;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xsd__positiveInteger(struct soap *soap, const std::wstring *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_xsd__positiveInteger);
	if (soap_out_xsd__positiveInteger(soap, tag?tag:"xsd:positiveInteger", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::wstring * SOAP_FMAC4 soap_get_xsd__positiveInteger(struct soap *soap, std::wstring *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__positiveInteger(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_xsd__nonNegativeInteger(struct soap *soap, const std::wstring *a)
{	(void)soap; (void)a; /* appease -Wall -Werror */
}
SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__nonNegativeInteger(struct soap *soap, const char *tag, int id, const std::wstring *s, const char *type)
{
	if ((soap->mode & SOAP_C_NILSTRING) && s->empty())
		return soap_element_null(soap, tag, id, type);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, s, SOAP_TYPE_xsd__nonNegativeInteger), type) || soap_wstring_out(soap, s->c_str(), 0) || soap_element_end_out(soap, tag))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 std::wstring * SOAP_FMAC4 soap_in_xsd__nonNegativeInteger(struct soap *soap, const char *tag, std::wstring *s, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!s)
		s = soap_new_std__wstring(soap, -1);
	if (soap->null)
		if (s)
			s->erase();
	if (soap->body && !*soap->href)
	{	wchar_t *t;
		s = (std::wstring*)soap_class_id_enter(soap, soap->id, s, SOAP_TYPE_xsd__nonNegativeInteger, sizeof(std::wstring), soap->type, soap->arrayType);
		if (s)
		{	if (!(t = soap_wstring_in(soap, 1, 0, -1)))
				return NULL;
			s->assign(t);
		}
	}
	else
		s = (std::wstring*)soap_id_forward(soap, soap->href, soap_class_id_enter(soap, soap->id, s, SOAP_TYPE_xsd__nonNegativeInteger, sizeof(std::wstring), soap->type, soap->arrayType), 0, SOAP_TYPE_xsd__nonNegativeInteger, 0, sizeof(std::wstring), 0, soap_copy_xsd__nonNegativeInteger);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	return s;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xsd__nonNegativeInteger(struct soap *soap, const std::wstring *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_xsd__nonNegativeInteger);
	if (soap_out_xsd__nonNegativeInteger(soap, tag?tag:"xsd:nonNegativeInteger", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::wstring * SOAP_FMAC4 soap_get_xsd__nonNegativeInteger(struct soap *soap, std::wstring *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__nonNegativeInteger(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_xsd__language(struct soap *soap, const std::wstring *a)
{	(void)soap; (void)a; /* appease -Wall -Werror */
}
SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__language(struct soap *soap, const char *tag, int id, const std::wstring *s, const char *type)
{
	if ((soap->mode & SOAP_C_NILSTRING) && s->empty())
		return soap_element_null(soap, tag, id, type);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, s, SOAP_TYPE_xsd__language), type) || soap_wstring_out(soap, s->c_str(), 0) || soap_element_end_out(soap, tag))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 std::wstring * SOAP_FMAC4 soap_in_xsd__language(struct soap *soap, const char *tag, std::wstring *s, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!s)
		s = soap_new_std__wstring(soap, -1);
	if (soap->null)
		if (s)
			s->erase();
	if (soap->body && !*soap->href)
	{	wchar_t *t;
		s = (std::wstring*)soap_class_id_enter(soap, soap->id, s, SOAP_TYPE_xsd__language, sizeof(std::wstring), soap->type, soap->arrayType);
		if (s)
		{	if (!(t = soap_wstring_in(soap, 1, 0, -1)))
				return NULL;
			s->assign(t);
		}
	}
	else
		s = (std::wstring*)soap_id_forward(soap, soap->href, soap_class_id_enter(soap, soap->id, s, SOAP_TYPE_xsd__language, sizeof(std::wstring), soap->type, soap->arrayType), 0, SOAP_TYPE_xsd__language, 0, sizeof(std::wstring), 0, soap_copy_xsd__language);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	return s;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xsd__language(struct soap *soap, const std::wstring *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_xsd__language);
	if (soap_out_xsd__language(soap, tag?tag:"xsd:language", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::wstring * SOAP_FMAC4 soap_get_xsd__language(struct soap *soap, std::wstring *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__language(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_xsd__integer(struct soap *soap, const std::wstring *a)
{	(void)soap; (void)a; /* appease -Wall -Werror */
}
SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__integer(struct soap *soap, const char *tag, int id, const std::wstring *s, const char *type)
{
	if ((soap->mode & SOAP_C_NILSTRING) && s->empty())
		return soap_element_null(soap, tag, id, type);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, s, SOAP_TYPE_xsd__integer), type) || soap_wstring_out(soap, s->c_str(), 0) || soap_element_end_out(soap, tag))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 std::wstring * SOAP_FMAC4 soap_in_xsd__integer(struct soap *soap, const char *tag, std::wstring *s, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!s)
		s = soap_new_std__wstring(soap, -1);
	if (soap->null)
		if (s)
			s->erase();
	if (soap->body && !*soap->href)
	{	wchar_t *t;
		s = (std::wstring*)soap_class_id_enter(soap, soap->id, s, SOAP_TYPE_xsd__integer, sizeof(std::wstring), soap->type, soap->arrayType);
		if (s)
		{	if (!(t = soap_wstring_in(soap, 1, 0, -1)))
				return NULL;
			s->assign(t);
		}
	}
	else
		s = (std::wstring*)soap_id_forward(soap, soap->href, soap_class_id_enter(soap, soap->id, s, SOAP_TYPE_xsd__integer, sizeof(std::wstring), soap->type, soap->arrayType), 0, SOAP_TYPE_xsd__integer, 0, sizeof(std::wstring), 0, soap_copy_xsd__integer);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	return s;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xsd__integer(struct soap *soap, const std::wstring *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_xsd__integer);
	if (soap_out_xsd__integer(soap, tag?tag:"xsd:integer", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::wstring * SOAP_FMAC4 soap_get_xsd__integer(struct soap *soap, std::wstring *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__integer(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_xsd__gYear(struct soap *soap, const std::wstring *a)
{	(void)soap; (void)a; /* appease -Wall -Werror */
}
SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__gYear(struct soap *soap, const char *tag, int id, const std::wstring *s, const char *type)
{
	if ((soap->mode & SOAP_C_NILSTRING) && s->empty())
		return soap_element_null(soap, tag, id, type);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, s, SOAP_TYPE_xsd__gYear), type) || soap_wstring_out(soap, s->c_str(), 0) || soap_element_end_out(soap, tag))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 std::wstring * SOAP_FMAC4 soap_in_xsd__gYear(struct soap *soap, const char *tag, std::wstring *s, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!s)
		s = soap_new_std__wstring(soap, -1);
	if (soap->null)
		if (s)
			s->erase();
	if (soap->body && !*soap->href)
	{	wchar_t *t;
		s = (std::wstring*)soap_class_id_enter(soap, soap->id, s, SOAP_TYPE_xsd__gYear, sizeof(std::wstring), soap->type, soap->arrayType);
		if (s)
		{	if (!(t = soap_wstring_in(soap, 1, 0, -1)))
				return NULL;
			s->assign(t);
		}
	}
	else
		s = (std::wstring*)soap_id_forward(soap, soap->href, soap_class_id_enter(soap, soap->id, s, SOAP_TYPE_xsd__gYear, sizeof(std::wstring), soap->type, soap->arrayType), 0, SOAP_TYPE_xsd__gYear, 0, sizeof(std::wstring), 0, soap_copy_xsd__gYear);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	return s;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xsd__gYear(struct soap *soap, const std::wstring *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_xsd__gYear);
	if (soap_out_xsd__gYear(soap, tag?tag:"xsd:gYear", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::wstring * SOAP_FMAC4 soap_get_xsd__gYear(struct soap *soap, std::wstring *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__gYear(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_xsd__decimal(struct soap *soap, const std::wstring *a)
{	(void)soap; (void)a; /* appease -Wall -Werror */
}
SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__decimal(struct soap *soap, const char *tag, int id, const std::wstring *s, const char *type)
{
	if ((soap->mode & SOAP_C_NILSTRING) && s->empty())
		return soap_element_null(soap, tag, id, type);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, s, SOAP_TYPE_xsd__decimal), type) || soap_wstring_out(soap, s->c_str(), 0) || soap_element_end_out(soap, tag))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 std::wstring * SOAP_FMAC4 soap_in_xsd__decimal(struct soap *soap, const char *tag, std::wstring *s, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!s)
		s = soap_new_std__wstring(soap, -1);
	if (soap->null)
		if (s)
			s->erase();
	if (soap->body && !*soap->href)
	{	wchar_t *t;
		s = (std::wstring*)soap_class_id_enter(soap, soap->id, s, SOAP_TYPE_xsd__decimal, sizeof(std::wstring), soap->type, soap->arrayType);
		if (s)
		{	if (!(t = soap_wstring_in(soap, 1, 0, -1)))
				return NULL;
			s->assign(t);
		}
	}
	else
		s = (std::wstring*)soap_id_forward(soap, soap->href, soap_class_id_enter(soap, soap->id, s, SOAP_TYPE_xsd__decimal, sizeof(std::wstring), soap->type, soap->arrayType), 0, SOAP_TYPE_xsd__decimal, 0, sizeof(std::wstring), 0, soap_copy_xsd__decimal);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	return s;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xsd__decimal(struct soap *soap, const std::wstring *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_xsd__decimal);
	if (soap_out_xsd__decimal(soap, tag?tag:"xsd:decimal", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::wstring * SOAP_FMAC4 soap_get_xsd__decimal(struct soap *soap, std::wstring *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__decimal(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_xsd__date(struct soap *soap, const std::wstring *a)
{	(void)soap; (void)a; /* appease -Wall -Werror */
}
SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__date(struct soap *soap, const char *tag, int id, const std::wstring *s, const char *type)
{
	if ((soap->mode & SOAP_C_NILSTRING) && s->empty())
		return soap_element_null(soap, tag, id, type);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, s, SOAP_TYPE_xsd__date), type) || soap_wstring_out(soap, s->c_str(), 0) || soap_element_end_out(soap, tag))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 std::wstring * SOAP_FMAC4 soap_in_xsd__date(struct soap *soap, const char *tag, std::wstring *s, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!s)
		s = soap_new_std__wstring(soap, -1);
	if (soap->null)
		if (s)
			s->erase();
	if (soap->body && !*soap->href)
	{	wchar_t *t;
		s = (std::wstring*)soap_class_id_enter(soap, soap->id, s, SOAP_TYPE_xsd__date, sizeof(std::wstring), soap->type, soap->arrayType);
		if (s)
		{	if (!(t = soap_wstring_in(soap, 1, 0, -1)))
				return NULL;
			s->assign(t);
		}
	}
	else
		s = (std::wstring*)soap_id_forward(soap, soap->href, soap_class_id_enter(soap, soap->id, s, SOAP_TYPE_xsd__date, sizeof(std::wstring), soap->type, soap->arrayType), 0, SOAP_TYPE_xsd__date, 0, sizeof(std::wstring), 0, soap_copy_xsd__date);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	return s;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xsd__date(struct soap *soap, const std::wstring *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_xsd__date);
	if (soap_out_xsd__date(soap, tag?tag:"xsd:date", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::wstring * SOAP_FMAC4 soap_get_xsd__date(struct soap *soap, std::wstring *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__date(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_xsd__anyURI(struct soap *soap, const std::wstring *a)
{	(void)soap; (void)a; /* appease -Wall -Werror */
}
SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__anyURI(struct soap *soap, const char *tag, int id, const std::wstring *s, const char *type)
{
	if ((soap->mode & SOAP_C_NILSTRING) && s->empty())
		return soap_element_null(soap, tag, id, type);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, s, SOAP_TYPE_xsd__anyURI), type) || soap_wstring_out(soap, s->c_str(), 0) || soap_element_end_out(soap, tag))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 std::wstring * SOAP_FMAC4 soap_in_xsd__anyURI(struct soap *soap, const char *tag, std::wstring *s, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!s)
		s = soap_new_std__wstring(soap, -1);
	if (soap->null)
		if (s)
			s->erase();
	if (soap->body && !*soap->href)
	{	wchar_t *t;
		s = (std::wstring*)soap_class_id_enter(soap, soap->id, s, SOAP_TYPE_xsd__anyURI, sizeof(std::wstring), soap->type, soap->arrayType);
		if (s)
		{	if (!(t = soap_wstring_in(soap, 1, 0, -1)))
				return NULL;
			s->assign(t);
		}
	}
	else
		s = (std::wstring*)soap_id_forward(soap, soap->href, soap_class_id_enter(soap, soap->id, s, SOAP_TYPE_xsd__anyURI, sizeof(std::wstring), soap->type, soap->arrayType), 0, SOAP_TYPE_xsd__anyURI, 0, sizeof(std::wstring), 0, soap_copy_xsd__anyURI);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	return s;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xsd__anyURI(struct soap *soap, const std::wstring *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_xsd__anyURI);
	if (soap_out_xsd__anyURI(soap, tag?tag:"xsd:anyURI", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::wstring * SOAP_FMAC4 soap_get_xsd__anyURI(struct soap *soap, std::wstring *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__anyURI(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_xsd__NMTOKEN(struct soap *soap, const std::wstring *a)
{	(void)soap; (void)a; /* appease -Wall -Werror */
}
SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__NMTOKEN(struct soap *soap, const char *tag, int id, const std::wstring *s, const char *type)
{
	if ((soap->mode & SOAP_C_NILSTRING) && s->empty())
		return soap_element_null(soap, tag, id, type);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, s, SOAP_TYPE_xsd__NMTOKEN), type) || soap_wstring_out(soap, s->c_str(), 0) || soap_element_end_out(soap, tag))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 std::wstring * SOAP_FMAC4 soap_in_xsd__NMTOKEN(struct soap *soap, const char *tag, std::wstring *s, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!s)
		s = soap_new_std__wstring(soap, -1);
	if (soap->null)
		if (s)
			s->erase();
	if (soap->body && !*soap->href)
	{	wchar_t *t;
		s = (std::wstring*)soap_class_id_enter(soap, soap->id, s, SOAP_TYPE_xsd__NMTOKEN, sizeof(std::wstring), soap->type, soap->arrayType);
		if (s)
		{	if (!(t = soap_wstring_in(soap, 1, 0, -1)))
				return NULL;
			s->assign(t);
		}
	}
	else
		s = (std::wstring*)soap_id_forward(soap, soap->href, soap_class_id_enter(soap, soap->id, s, SOAP_TYPE_xsd__NMTOKEN, sizeof(std::wstring), soap->type, soap->arrayType), 0, SOAP_TYPE_xsd__NMTOKEN, 0, sizeof(std::wstring), 0, soap_copy_xsd__NMTOKEN);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	return s;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xsd__NMTOKEN(struct soap *soap, const std::wstring *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_xsd__NMTOKEN);
	if (soap_out_xsd__NMTOKEN(soap, tag?tag:"xsd:NMTOKEN", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::wstring * SOAP_FMAC4 soap_get_xsd__NMTOKEN(struct soap *soap, std::wstring *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__NMTOKEN(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__wstring(struct soap *soap, std::wstring *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->erase();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__wstring(struct soap *soap, const std::wstring *a)
{	(void)soap; (void)a; /* appease -Wall -Werror */
}
SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__wstring(struct soap *soap, const char *tag, int id, const std::wstring *s, const char *type)
{
	if ((soap->mode & SOAP_C_NILSTRING) && s->empty())
		return soap_element_null(soap, tag, id, type);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, s, SOAP_TYPE_std__wstring), type) || soap_wstring_out(soap, s->c_str(), 0) || soap_element_end_out(soap, tag))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 std::wstring * SOAP_FMAC4 soap_in_std__wstring(struct soap *soap, const char *tag, std::wstring *s, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!s)
		s = soap_new_std__wstring(soap, -1);
	if (soap->null)
		if (s)
			s->erase();
	if (soap->body && !*soap->href)
	{	wchar_t *t;
		s = (std::wstring*)soap_class_id_enter(soap, soap->id, s, SOAP_TYPE_std__wstring, sizeof(std::wstring), soap->type, soap->arrayType);
		if (s)
		{	if (!(t = soap_wstring_in(soap, 1, 0, -1)))
				return NULL;
			s->assign(t);
		}
	}
	else
		s = (std::wstring*)soap_id_forward(soap, soap->href, soap_class_id_enter(soap, soap->id, s, SOAP_TYPE_std__wstring, sizeof(std::wstring), soap->type, soap->arrayType), 0, SOAP_TYPE_std__wstring, 0, sizeof(std::wstring), 0, soap_copy_std__wstring);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	return s;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_std__wstring(struct soap *soap, const std::wstring *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_std__wstring);
	if (soap_out_std__wstring(soap, tag?tag:"string", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::wstring * SOAP_FMAC4 soap_get_std__wstring(struct soap *soap, std::wstring *p, const char *tag, const char *type)
{
	if ((p = soap_in_std__wstring(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 std::wstring * SOAP_FMAC2 soap_instantiate_std__wstring(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__wstring(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__wstring, n, EDLProvider_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(std::wstring);
		if (size)
			*size = sizeof(std::wstring);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(std::wstring, n);
		if (size)
			*size = n * sizeof(std::wstring);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (std::wstring*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__wstring(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::wstring %p -> %p\n", q, p));
	*(std::wstring*)p = *(std::wstring*)q;
}

void xsd__hexBinary::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	this->__size = 0;
	this->__ptr = NULL;
}

void xsd__hexBinary::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	if (this->__ptr)
		soap_array_reference(soap, this, (struct soap_array*)(void*)&this->__ptr, 1, SOAP_TYPE_xsd__hexBinary);
#endif
}

int xsd__hexBinary::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{	return soap_out_xsd__hexBinary(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__hexBinary(struct soap *soap, const char *tag, int id, const xsd__hexBinary *a, const char *type)
{
	id = soap_element_id(soap, tag, id, a, (struct soap_array*)(void*)&a->__ptr, 1, type, SOAP_TYPE_xsd__hexBinary);
	if (id < 0)
		return soap->error;
	if (soap_element_begin_out(soap, tag, id, type))
		return soap->error;
	if (soap_puthex(soap, a->__ptr, a->__size))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *xsd__hexBinary::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_xsd__hexBinary(soap, tag, this, type);
}

SOAP_FMAC3 xsd__hexBinary * SOAP_FMAC4 soap_in_xsd__hexBinary(struct soap *soap, const char *tag, xsd__hexBinary *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type) && soap_match_tag(soap, soap->type, ":hexBinary"))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (xsd__hexBinary *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_xsd__hexBinary, sizeof(xsd__hexBinary), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && !*soap->href)
	{
		a->__ptr = soap_gethex(soap, &a->__size);
		if ((!a->__ptr && soap->error) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (xsd__hexBinary *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_xsd__hexBinary, 0, sizeof(xsd__hexBinary), 0, soap_copy_xsd__hexBinary);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int xsd__hexBinary::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, (struct soap_array*)(void*)&this->__ptr, 1, tag, SOAP_TYPE_xsd__hexBinary);
	if (this->soap_out(soap, tag?tag:"xsd:hexBinary", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *xsd__hexBinary::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_xsd__hexBinary(soap, this, tag, type);
}

SOAP_FMAC3 xsd__hexBinary * SOAP_FMAC4 soap_get_xsd__hexBinary(struct soap *soap, xsd__hexBinary *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__hexBinary(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 xsd__hexBinary * SOAP_FMAC2 soap_instantiate_xsd__hexBinary(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_xsd__hexBinary(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_xsd__hexBinary, n, EDLProvider_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(xsd__hexBinary);
		if (size)
			*size = sizeof(xsd__hexBinary);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(xsd__hexBinary, n);
		if (size)
			*size = n * sizeof(xsd__hexBinary);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (xsd__hexBinary*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_xsd__hexBinary(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying xsd__hexBinary %p -> %p\n", q, p));
	*(xsd__hexBinary*)p = *(xsd__hexBinary*)q;
}

void xsd__base64Binary::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->__size = 0;
	this->__ptr = NULL;
	this->id = NULL;
	this->type = NULL;
	this->options = NULL;
}

void xsd__base64Binary::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	if (this->__ptr && !soap_array_reference(soap, this, (struct soap_array*)(void*)&this->__ptr, 1, SOAP_TYPE_xsd__base64Binary))
		if (this->id || this->type)
			soap->mode |= SOAP_ENC_DIME;
#endif
}

int xsd__base64Binary::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{	return soap_out_xsd__base64Binary(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__base64Binary(struct soap *soap, const char *tag, int id, const xsd__base64Binary *a, const char *type)
{
#ifndef WITH_LEANER
	id = soap_attachment(soap, tag, id, a, (struct soap_array*)(void*)&a->__ptr, a->id, a->type, a->options, 1, type, SOAP_TYPE_xsd__base64Binary);
#else
	id = soap_element_id(soap, tag, id, a, (struct soap_array*)(void*)&a->__ptr, 1, type, SOAP_TYPE_xsd__base64Binary);
#endif
	if (id < 0)
		return soap->error;
	if (soap_element_begin_out(soap, tag, id, type))
		return soap->error;
	if (soap_putbase64(soap, a->__ptr, a->__size))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *xsd__base64Binary::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_xsd__base64Binary(soap, tag, this, type);
}

SOAP_FMAC3 xsd__base64Binary * SOAP_FMAC4 soap_in_xsd__base64Binary(struct soap *soap, const char *tag, xsd__base64Binary *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type) && soap_match_tag(soap, soap->type, ":base64Binary") && soap_match_tag(soap, soap->type, ":base64"))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (xsd__base64Binary *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_xsd__base64Binary, sizeof(xsd__base64Binary), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && !*soap->href)
	{
		a->__ptr = soap_getbase64(soap, &a->__size, 0);
#ifndef WITH_LEANER
		if (soap_xop_forward(soap, &a->__ptr, &a->__size, &a->id, &a->type, &a->options))
			return NULL;
#endif
		if ((!a->__ptr && soap->error) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	
#ifndef WITH_LEANER
		if (*soap->href != '#')
		{	if (soap_dime_forward(soap, &a->__ptr, &a->__size, &a->id, &a->type, &a->options))
				return NULL;
		}
		else
#endif
			a = (xsd__base64Binary *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_xsd__base64Binary, 0, sizeof(xsd__base64Binary), 0, soap_copy_xsd__base64Binary);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int xsd__base64Binary::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, (struct soap_array*)(void*)&this->__ptr, 1, tag, SOAP_TYPE_xsd__base64Binary);
	if (this->soap_out(soap, tag?tag:"xsd:base64Binary", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *xsd__base64Binary::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_xsd__base64Binary(soap, this, tag, type);
}

SOAP_FMAC3 xsd__base64Binary * SOAP_FMAC4 soap_get_xsd__base64Binary(struct soap *soap, xsd__base64Binary *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__base64Binary(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 xsd__base64Binary * SOAP_FMAC2 soap_instantiate_xsd__base64Binary(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_xsd__base64Binary(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_xsd__base64Binary, n, EDLProvider_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(xsd__base64Binary);
		if (size)
			*size = sizeof(xsd__base64Binary);
		((xsd__base64Binary*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(xsd__base64Binary, n);
		if (size)
			*size = n * sizeof(xsd__base64Binary);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((xsd__base64Binary*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (xsd__base64Binary*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_xsd__base64Binary(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying xsd__base64Binary %p -> %p\n", q, p));
	*(xsd__base64Binary*)p = *(xsd__base64Binary*)q;
}

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Fault(struct soap *soap, struct SOAP_ENV__Fault *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default__QName(soap, &a->faultcode);
	soap_default_string(soap, &a->faultstring);
	soap_default_string(soap, &a->faultactor);
	a->detail = NULL;
	a->SOAP_ENV__Code = NULL;
	a->SOAP_ENV__Reason = NULL;
	soap_default_string(soap, &a->SOAP_ENV__Node);
	soap_default_string(soap, &a->SOAP_ENV__Role);
	a->SOAP_ENV__Detail = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Fault(struct soap *soap, const struct SOAP_ENV__Fault *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize__QName(soap, &a->faultcode);
	soap_serialize_string(soap, &a->faultstring);
	soap_serialize_string(soap, &a->faultactor);
	soap_serialize_PointerToSOAP_ENV__Detail(soap, &a->detail);
	soap_serialize_PointerToSOAP_ENV__Code(soap, &a->SOAP_ENV__Code);
	soap_serialize_PointerToSOAP_ENV__Reason(soap, &a->SOAP_ENV__Reason);
	soap_serialize_string(soap, &a->SOAP_ENV__Node);
	soap_serialize_string(soap, &a->SOAP_ENV__Role);
	soap_serialize_PointerToSOAP_ENV__Detail(soap, &a->SOAP_ENV__Detail);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Fault(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Fault *a, const char *type)
{
	const char *soap_tmp_faultcode = soap_QName2s(soap, a->faultcode);
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Fault), type))
		return soap->error;
	if (soap_out__QName(soap, "faultcode", -1, (char*const*)(void*)&soap_tmp_faultcode, ""))
		return soap->error;
	if (soap_out_string(soap, "faultstring", -1, &a->faultstring, ""))
		return soap->error;
	if (soap_out_string(soap, "faultactor", -1, &a->faultactor, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Detail(soap, "detail", -1, &a->detail, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Code", -1, &a->SOAP_ENV__Code, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Reason(soap, "SOAP-ENV:Reason", -1, &a->SOAP_ENV__Reason, ""))
		return soap->error;
	if (soap_out_string(soap, "SOAP-ENV:Node", -1, &a->SOAP_ENV__Node, ""))
		return soap->error;
	if (soap_out_string(soap, "SOAP-ENV:Role", -1, &a->SOAP_ENV__Role, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Detail(soap, "SOAP-ENV:Detail", -1, &a->SOAP_ENV__Detail, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Fault * SOAP_FMAC4 soap_in_SOAP_ENV__Fault(struct soap *soap, const char *tag, struct SOAP_ENV__Fault *a, const char *type)
{
	size_t soap_flag_faultcode = 1;
	size_t soap_flag_faultstring = 1;
	size_t soap_flag_faultactor = 1;
	size_t soap_flag_detail = 1;
	size_t soap_flag_SOAP_ENV__Code = 1;
	size_t soap_flag_SOAP_ENV__Reason = 1;
	size_t soap_flag_SOAP_ENV__Node = 1;
	size_t soap_flag_SOAP_ENV__Role = 1;
	size_t soap_flag_SOAP_ENV__Detail = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Fault *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Fault, sizeof(struct SOAP_ENV__Fault), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Fault(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_faultcode && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in__QName(soap, "faultcode", &a->faultcode, ""))
				{	soap_flag_faultcode--;
					continue;
				}
			if (soap_flag_faultstring && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "faultstring", &a->faultstring, "xsd:string"))
				{	soap_flag_faultstring--;
					continue;
				}
			if (soap_flag_faultactor && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "faultactor", &a->faultactor, "xsd:string"))
				{	soap_flag_faultactor--;
					continue;
				}
			if (soap_flag_detail && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Detail(soap, "detail", &a->detail, ""))
				{	soap_flag_detail--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Code && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Code", &a->SOAP_ENV__Code, ""))
				{	soap_flag_SOAP_ENV__Code--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Reason && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Reason(soap, "SOAP-ENV:Reason", &a->SOAP_ENV__Reason, ""))
				{	soap_flag_SOAP_ENV__Reason--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Node && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "SOAP-ENV:Node", &a->SOAP_ENV__Node, "xsd:string"))
				{	soap_flag_SOAP_ENV__Node--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Role && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "SOAP-ENV:Role", &a->SOAP_ENV__Role, "xsd:string"))
				{	soap_flag_SOAP_ENV__Role--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Detail && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Detail(soap, "SOAP-ENV:Detail", &a->SOAP_ENV__Detail, ""))
				{	soap_flag_SOAP_ENV__Detail--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Fault *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Fault, 0, sizeof(struct SOAP_ENV__Fault), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Fault(struct soap *soap, const struct SOAP_ENV__Fault *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_SOAP_ENV__Fault);
	if (soap_out_SOAP_ENV__Fault(soap, tag?tag:"SOAP-ENV:Fault", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Fault * SOAP_FMAC4 soap_get_SOAP_ENV__Fault(struct soap *soap, struct SOAP_ENV__Fault *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Fault(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct SOAP_ENV__Fault * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Fault(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Fault(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_SOAP_ENV__Fault, n, EDLProvider_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct SOAP_ENV__Fault);
		if (size)
			*size = sizeof(struct SOAP_ENV__Fault);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct SOAP_ENV__Fault, n);
		if (size)
			*size = n * sizeof(struct SOAP_ENV__Fault);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct SOAP_ENV__Fault*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_SOAP_ENV__Fault(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct SOAP_ENV__Fault %p -> %p\n", q, p));
	*(struct SOAP_ENV__Fault*)p = *(struct SOAP_ENV__Fault*)q;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->SOAP_ENV__Text);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Reason(struct soap *soap, const struct SOAP_ENV__Reason *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->SOAP_ENV__Text);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Reason(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Reason *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Reason), type))
		return soap->error;
	if (soap->lang)
		soap_set_attr(soap, "xml:lang", soap->lang, 1);
	if (soap_out_string(soap, "SOAP-ENV:Text", -1, &a->SOAP_ENV__Text, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Reason * SOAP_FMAC4 soap_in_SOAP_ENV__Reason(struct soap *soap, const char *tag, struct SOAP_ENV__Reason *a, const char *type)
{
	size_t soap_flag_SOAP_ENV__Text = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Reason *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Reason, sizeof(struct SOAP_ENV__Reason), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Reason(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SOAP_ENV__Text && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "SOAP-ENV:Text", &a->SOAP_ENV__Text, "xsd:string"))
				{	soap_flag_SOAP_ENV__Text--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Reason *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Reason, 0, sizeof(struct SOAP_ENV__Reason), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Reason(struct soap *soap, const struct SOAP_ENV__Reason *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_SOAP_ENV__Reason);
	if (soap_out_SOAP_ENV__Reason(soap, tag?tag:"SOAP-ENV:Reason", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Reason * SOAP_FMAC4 soap_get_SOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Reason(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct SOAP_ENV__Reason * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Reason(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Reason(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_SOAP_ENV__Reason, n, EDLProvider_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct SOAP_ENV__Reason);
		if (size)
			*size = sizeof(struct SOAP_ENV__Reason);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct SOAP_ENV__Reason, n);
		if (size)
			*size = n * sizeof(struct SOAP_ENV__Reason);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct SOAP_ENV__Reason*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_SOAP_ENV__Reason(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct SOAP_ENV__Reason %p -> %p\n", q, p));
	*(struct SOAP_ENV__Reason*)p = *(struct SOAP_ENV__Reason*)q;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default__QName(soap, &a->SOAP_ENV__Value);
	a->SOAP_ENV__Subcode = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Code(struct soap *soap, const struct SOAP_ENV__Code *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize__QName(soap, &a->SOAP_ENV__Value);
	soap_serialize_PointerToSOAP_ENV__Code(soap, &a->SOAP_ENV__Subcode);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Code(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Code *a, const char *type)
{
	const char *soap_tmp_SOAP_ENV__Value = soap_QName2s(soap, a->SOAP_ENV__Value);
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Code), type))
		return soap->error;
	if (soap_out__QName(soap, "SOAP-ENV:Value", -1, (char*const*)(void*)&soap_tmp_SOAP_ENV__Value, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Subcode", -1, &a->SOAP_ENV__Subcode, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Code * SOAP_FMAC4 soap_in_SOAP_ENV__Code(struct soap *soap, const char *tag, struct SOAP_ENV__Code *a, const char *type)
{
	size_t soap_flag_SOAP_ENV__Value = 1;
	size_t soap_flag_SOAP_ENV__Subcode = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Code *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Code, sizeof(struct SOAP_ENV__Code), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Code(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SOAP_ENV__Value && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in__QName(soap, "SOAP-ENV:Value", &a->SOAP_ENV__Value, ""))
				{	soap_flag_SOAP_ENV__Value--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Subcode && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Subcode", &a->SOAP_ENV__Subcode, ""))
				{	soap_flag_SOAP_ENV__Subcode--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Code *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Code, 0, sizeof(struct SOAP_ENV__Code), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Code(struct soap *soap, const struct SOAP_ENV__Code *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_SOAP_ENV__Code);
	if (soap_out_SOAP_ENV__Code(soap, tag?tag:"SOAP-ENV:Code", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Code * SOAP_FMAC4 soap_get_SOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Code(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct SOAP_ENV__Code * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Code(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Code(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_SOAP_ENV__Code, n, EDLProvider_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct SOAP_ENV__Code);
		if (size)
			*size = sizeof(struct SOAP_ENV__Code);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct SOAP_ENV__Code, n);
		if (size)
			*size = n * sizeof(struct SOAP_ENV__Code);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct SOAP_ENV__Code*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_SOAP_ENV__Code(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct SOAP_ENV__Code %p -> %p\n", q, p));
	*(struct SOAP_ENV__Code*)p = *(struct SOAP_ENV__Code*)q;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Header(struct soap *soap, struct SOAP_ENV__Header *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Header(struct soap *soap, const struct SOAP_ENV__Header *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Header(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Header *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Header), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Header * SOAP_FMAC4 soap_in_SOAP_ENV__Header(struct soap *soap, const char *tag, struct SOAP_ENV__Header *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Header *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Header, sizeof(struct SOAP_ENV__Header), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Header(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Header *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Header, 0, sizeof(struct SOAP_ENV__Header), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Header(struct soap *soap, const struct SOAP_ENV__Header *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_SOAP_ENV__Header);
	if (soap_out_SOAP_ENV__Header(soap, tag?tag:"SOAP-ENV:Header", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Header * SOAP_FMAC4 soap_get_SOAP_ENV__Header(struct soap *soap, struct SOAP_ENV__Header *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Header(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct SOAP_ENV__Header * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Header(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Header(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_SOAP_ENV__Header, n, EDLProvider_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct SOAP_ENV__Header);
		if (size)
			*size = sizeof(struct SOAP_ENV__Header);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct SOAP_ENV__Header, n);
		if (size)
			*size = n * sizeof(struct SOAP_ENV__Header);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct SOAP_ENV__Header*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_SOAP_ENV__Header(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct SOAP_ENV__Header %p -> %p\n", q, p));
	*(struct SOAP_ENV__Header*)p = *(struct SOAP_ENV__Header*)q;
}

#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_default___edlprovider__getEdlDouble(struct soap *soap, struct __edlprovider__getEdlDouble *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->edlprovider__getEdlDoubleRequest = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___edlprovider__getEdlDouble(struct soap *soap, const struct __edlprovider__getEdlDouble *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerToedlprovider__EdlCreateRequestDoubleType(soap, &a->edlprovider__getEdlDoubleRequest);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___edlprovider__getEdlDouble(struct soap *soap, const char *tag, int id, const struct __edlprovider__getEdlDouble *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerToedlprovider__EdlCreateRequestDoubleType(soap, "edlprovider:getEdlDoubleRequest", -1, &a->edlprovider__getEdlDoubleRequest, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __edlprovider__getEdlDouble * SOAP_FMAC4 soap_in___edlprovider__getEdlDouble(struct soap *soap, const char *tag, struct __edlprovider__getEdlDouble *a, const char *type)
{
	size_t soap_flag_edlprovider__getEdlDoubleRequest = 1;
	short soap_flag;
	a = (struct __edlprovider__getEdlDouble *)soap_id_enter(soap, "", a, SOAP_TYPE___edlprovider__getEdlDouble, sizeof(struct __edlprovider__getEdlDouble), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___edlprovider__getEdlDouble(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_edlprovider__getEdlDoubleRequest && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToedlprovider__EdlCreateRequestDoubleType(soap, "edlprovider:getEdlDoubleRequest", &a->edlprovider__getEdlDoubleRequest, "edlprovider:EdlCreateRequestDoubleType"))
				{	soap_flag_edlprovider__getEdlDoubleRequest--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___edlprovider__getEdlDouble(struct soap *soap, const struct __edlprovider__getEdlDouble *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___edlprovider__getEdlDouble(soap, tag?tag:"-edlprovider:getEdlDouble", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __edlprovider__getEdlDouble * SOAP_FMAC4 soap_get___edlprovider__getEdlDouble(struct soap *soap, struct __edlprovider__getEdlDouble *p, const char *tag, const char *type)
{
	if ((p = soap_in___edlprovider__getEdlDouble(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __edlprovider__getEdlDouble * SOAP_FMAC2 soap_instantiate___edlprovider__getEdlDouble(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___edlprovider__getEdlDouble(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___edlprovider__getEdlDouble, n, EDLProvider_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __edlprovider__getEdlDouble);
		if (size)
			*size = sizeof(struct __edlprovider__getEdlDouble);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __edlprovider__getEdlDouble, n);
		if (size)
			*size = n * sizeof(struct __edlprovider__getEdlDouble);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __edlprovider__getEdlDouble*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___edlprovider__getEdlDouble(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __edlprovider__getEdlDouble %p -> %p\n", q, p));
	*(struct __edlprovider__getEdlDouble*)p = *(struct __edlprovider__getEdlDouble*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___edlprovider__getEdl(struct soap *soap, struct __edlprovider__getEdl *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->edlprovider__getEdlRequest = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___edlprovider__getEdl(struct soap *soap, const struct __edlprovider__getEdl *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerToedlprovider__EdlCreateRequestType(soap, &a->edlprovider__getEdlRequest);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___edlprovider__getEdl(struct soap *soap, const char *tag, int id, const struct __edlprovider__getEdl *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerToedlprovider__EdlCreateRequestType(soap, "edlprovider:getEdlRequest", -1, &a->edlprovider__getEdlRequest, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __edlprovider__getEdl * SOAP_FMAC4 soap_in___edlprovider__getEdl(struct soap *soap, const char *tag, struct __edlprovider__getEdl *a, const char *type)
{
	size_t soap_flag_edlprovider__getEdlRequest = 1;
	short soap_flag;
	a = (struct __edlprovider__getEdl *)soap_id_enter(soap, "", a, SOAP_TYPE___edlprovider__getEdl, sizeof(struct __edlprovider__getEdl), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___edlprovider__getEdl(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_edlprovider__getEdlRequest && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToedlprovider__EdlCreateRequestType(soap, "edlprovider:getEdlRequest", &a->edlprovider__getEdlRequest, "edlprovider:EdlCreateRequestType"))
				{	soap_flag_edlprovider__getEdlRequest--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___edlprovider__getEdl(struct soap *soap, const struct __edlprovider__getEdl *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___edlprovider__getEdl(soap, tag?tag:"-edlprovider:getEdl", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __edlprovider__getEdl * SOAP_FMAC4 soap_get___edlprovider__getEdl(struct soap *soap, struct __edlprovider__getEdl *p, const char *tag, const char *type)
{
	if ((p = soap_in___edlprovider__getEdl(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __edlprovider__getEdl * SOAP_FMAC2 soap_instantiate___edlprovider__getEdl(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___edlprovider__getEdl(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___edlprovider__getEdl, n, EDLProvider_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __edlprovider__getEdl);
		if (size)
			*size = sizeof(struct __edlprovider__getEdl);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __edlprovider__getEdl, n);
		if (size)
			*size = n * sizeof(struct __edlprovider__getEdl);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __edlprovider__getEdl*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___edlprovider__getEdl(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __edlprovider__getEdl %p -> %p\n", q, p));
	*(struct __edlprovider__getEdl*)p = *(struct __edlprovider__getEdl*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___edlprovider__getInstalledEdls(struct soap *soap, struct __edlprovider__getInstalledEdls *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___edlprovider__getInstalledEdls(struct soap *soap, const struct __edlprovider__getInstalledEdls *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___edlprovider__getInstalledEdls(struct soap *soap, const char *tag, int id, const struct __edlprovider__getInstalledEdls *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	return SOAP_OK;
}

SOAP_FMAC3 struct __edlprovider__getInstalledEdls * SOAP_FMAC4 soap_in___edlprovider__getInstalledEdls(struct soap *soap, const char *tag, struct __edlprovider__getInstalledEdls *a, const char *type)
{
	a = (struct __edlprovider__getInstalledEdls *)soap_id_enter(soap, "", a, SOAP_TYPE___edlprovider__getInstalledEdls, sizeof(struct __edlprovider__getInstalledEdls), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___edlprovider__getInstalledEdls(soap, a);
	soap->error = SOAP_TAG_MISMATCH;
	a = NULL;
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___edlprovider__getInstalledEdls(struct soap *soap, const struct __edlprovider__getInstalledEdls *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___edlprovider__getInstalledEdls(soap, tag?tag:"-edlprovider:getInstalledEdls", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __edlprovider__getInstalledEdls * SOAP_FMAC4 soap_get___edlprovider__getInstalledEdls(struct soap *soap, struct __edlprovider__getInstalledEdls *p, const char *tag, const char *type)
{
	if ((p = soap_in___edlprovider__getInstalledEdls(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __edlprovider__getInstalledEdls * SOAP_FMAC2 soap_instantiate___edlprovider__getInstalledEdls(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___edlprovider__getInstalledEdls(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___edlprovider__getInstalledEdls, n, EDLProvider_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __edlprovider__getInstalledEdls);
		if (size)
			*size = sizeof(struct __edlprovider__getInstalledEdls);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __edlprovider__getInstalledEdls, n);
		if (size)
			*size = n * sizeof(struct __edlprovider__getInstalledEdls);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __edlprovider__getInstalledEdls*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___edlprovider__getInstalledEdls(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __edlprovider__getInstalledEdls %p -> %p\n", q, p));
	*(struct __edlprovider__getInstalledEdls*)p = *(struct __edlprovider__getInstalledEdls*)q;
}

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->edlprovider__edlProviderFault = NULL;
	a->__type = 0;
	a->fault = NULL;
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Detail(struct soap *soap, const struct SOAP_ENV__Detail *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerToedlprovider__EdlProviderFaultType(soap, &a->edlprovider__edlProviderFault);
	soap_markelement(soap, a->fault, a->__type);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Detail(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Detail *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Detail), type))
		return soap->error;
	if (soap_out_PointerToedlprovider__EdlProviderFaultType(soap, "edlprovider:edlProviderFault", -1, &a->edlprovider__edlProviderFault, ""))
		return soap->error;
	if (soap_putelement(soap, a->fault, "fault", -1, a->__type))
		return soap->error;
	soap_outliteral(soap, "-any", &a->__any, NULL);
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Detail * SOAP_FMAC4 soap_in_SOAP_ENV__Detail(struct soap *soap, const char *tag, struct SOAP_ENV__Detail *a, const char *type)
{
	size_t soap_flag_edlprovider__edlProviderFault = 1;
	size_t soap_flag_fault = 1;
	size_t soap_flag___any = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Detail *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Detail, sizeof(struct SOAP_ENV__Detail), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Detail(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_edlprovider__edlProviderFault && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToedlprovider__EdlProviderFaultType(soap, "edlprovider:edlProviderFault", &a->edlprovider__edlProviderFault, "edlprovider:EdlProviderFaultType"))
				{	soap_flag_edlprovider__edlProviderFault--;
					continue;
				}
			if (soap_flag_fault && soap->error == SOAP_TAG_MISMATCH)
				if ((a->fault = soap_getelement(soap, &a->__type)))
				{	soap_flag_fault = 0;
					continue;
				}
			if (soap_flag___any && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-any", &a->__any))
				{	soap_flag___any--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Detail *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Detail, 0, sizeof(struct SOAP_ENV__Detail), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_fault > 1))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Detail(struct soap *soap, const struct SOAP_ENV__Detail *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_SOAP_ENV__Detail);
	if (soap_out_SOAP_ENV__Detail(soap, tag?tag:"SOAP-ENV:Detail", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Detail * SOAP_FMAC4 soap_get_SOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Detail(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct SOAP_ENV__Detail * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Detail(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Detail(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_SOAP_ENV__Detail, n, EDLProvider_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct SOAP_ENV__Detail);
		if (size)
			*size = sizeof(struct SOAP_ENV__Detail);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct SOAP_ENV__Detail, n);
		if (size)
			*size = n * sizeof(struct SOAP_ENV__Detail);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct SOAP_ENV__Detail*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_SOAP_ENV__Detail(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct SOAP_ENV__Detail %p -> %p\n", q, p));
	*(struct SOAP_ENV__Detail*)p = *(struct SOAP_ENV__Detail*)q;
}

#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__fimstime__union_TimeType(struct soap *soap, int choice, const union _fimstime__union_TimeType *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	switch (choice)
	{
	case SOAP_UNION__fimstime__union_TimeType_timecode:
		soap_serialize_PointerTofimstime__Timecode(soap, &a->timecode);
		break;
	case SOAP_UNION__fimstime__union_TimeType_normalPlayTime:
		soap_serialize_PointerToxsd__time(soap, &a->normalPlayTime);
		break;
	case SOAP_UNION__fimstime__union_TimeType_editUnitNumber:
		soap_serialize_PointerTofimstime__EditUnitNumberType(soap, &a->editUnitNumber);
		break;
	default:
		break;
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__fimstime__union_TimeType(struct soap *soap, int choice, const union _fimstime__union_TimeType *a)
{
	switch (choice)
	{
	case SOAP_UNION__fimstime__union_TimeType_timecode:
		return soap_out_PointerTofimstime__Timecode(soap, "fimstime:timecode", -1, &a->timecode, "");
	case SOAP_UNION__fimstime__union_TimeType_normalPlayTime:
		return soap_out_PointerToxsd__time(soap, "fimstime:normalPlayTime", -1, &a->normalPlayTime, "");
	case SOAP_UNION__fimstime__union_TimeType_editUnitNumber:
		return soap_out_PointerTofimstime__EditUnitNumberType(soap, "fimstime:editUnitNumber", -1, &a->editUnitNumber, "");
	default:
		break;
	}
	return SOAP_OK;
}

SOAP_FMAC3 union _fimstime__union_TimeType * SOAP_FMAC4 soap_in__fimstime__union_TimeType(struct soap *soap, int *choice, union _fimstime__union_TimeType *a)
{	soap->error = SOAP_TAG_MISMATCH;
	a->timecode = NULL;
	if (soap->error == SOAP_TAG_MISMATCH && soap_in_PointerTofimstime__Timecode(soap, "fimstime:timecode", &a->timecode, "fimstime:Timecode"))
	{	*choice = SOAP_UNION__fimstime__union_TimeType_timecode;
		return a;
	}
	a->normalPlayTime = NULL;
	if (soap->error == SOAP_TAG_MISMATCH && soap_in_PointerToxsd__time(soap, "fimstime:normalPlayTime", &a->normalPlayTime, "xsd:time"))
	{	*choice = SOAP_UNION__fimstime__union_TimeType_normalPlayTime;
		return a;
	}
	a->editUnitNumber = NULL;
	if (soap->error == SOAP_TAG_MISMATCH && soap_in_PointerTofimstime__EditUnitNumberType(soap, "fimstime:editUnitNumber", &a->editUnitNumber, "fimstime:EditUnitNumberType"))
	{	*choice = SOAP_UNION__fimstime__union_TimeType_editUnitNumber;
		return a;
	}
	*choice = -1;
	if (!soap->error)
		soap->error = SOAP_TAG_MISMATCH;
	return NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__fimstime__union_DurationType(struct soap *soap, int choice, const union _fimstime__union_DurationType *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	switch (choice)
	{
	case SOAP_UNION__fimstime__union_DurationType_timecode:
		soap_serialize_PointerTofimstime__TimecodeDuration(soap, &a->timecode);
		break;
	case SOAP_UNION__fimstime__union_DurationType_normalPlayTime:
		soap_serialize_PointerToxsd__duration(soap, &a->normalPlayTime);
		break;
	case SOAP_UNION__fimstime__union_DurationType_editUnitNumber:
		soap_serialize_PointerTofimstime__EditUnitNumberType(soap, &a->editUnitNumber);
		break;
	default:
		break;
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__fimstime__union_DurationType(struct soap *soap, int choice, const union _fimstime__union_DurationType *a)
{
	switch (choice)
	{
	case SOAP_UNION__fimstime__union_DurationType_timecode:
		return soap_out_PointerTofimstime__TimecodeDuration(soap, "fimstime:timecode", -1, &a->timecode, "");
	case SOAP_UNION__fimstime__union_DurationType_normalPlayTime:
		return soap_out_PointerToxsd__duration(soap, "fimstime:normalPlayTime", -1, &a->normalPlayTime, "");
	case SOAP_UNION__fimstime__union_DurationType_editUnitNumber:
		return soap_out_PointerTofimstime__EditUnitNumberType(soap, "fimstime:editUnitNumber", -1, &a->editUnitNumber, "");
	default:
		break;
	}
	return SOAP_OK;
}

SOAP_FMAC3 union _fimstime__union_DurationType * SOAP_FMAC4 soap_in__fimstime__union_DurationType(struct soap *soap, int *choice, union _fimstime__union_DurationType *a)
{	soap->error = SOAP_TAG_MISMATCH;
	a->timecode = NULL;
	if (soap->error == SOAP_TAG_MISMATCH && soap_in_PointerTofimstime__TimecodeDuration(soap, "fimstime:timecode", &a->timecode, "fimstime:TimecodeDuration"))
	{	*choice = SOAP_UNION__fimstime__union_DurationType_timecode;
		return a;
	}
	a->normalPlayTime = NULL;
	if (soap->error == SOAP_TAG_MISMATCH && soap_in_PointerToxsd__duration(soap, "fimstime:normalPlayTime", &a->normalPlayTime, "xsd:duration"))
	{	*choice = SOAP_UNION__fimstime__union_DurationType_normalPlayTime;
		return a;
	}
	a->editUnitNumber = NULL;
	if (soap->error == SOAP_TAG_MISMATCH && soap_in_PointerTofimstime__EditUnitNumberType(soap, "fimstime:editUnitNumber", &a->editUnitNumber, "fimstime:EditUnitNumberType"))
	{	*choice = SOAP_UNION__fimstime__union_DurationType_editUnitNumber;
		return a;
	}
	*choice = -1;
	if (!soap->error)
		soap->error = SOAP_TAG_MISMATCH;
	return NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__fims__union_QueryGroupType(struct soap *soap, int choice, const union _fims__union_QueryGroupType *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	switch (choice)
	{
	case SOAP_UNION__fims__union_QueryGroupType_operator_:
		break;
	case SOAP_UNION__fims__union_QueryGroupType_customOperator:
		soap_serialize_PointerTofims__CustomQueryGroupOperatorType(soap, &a->customOperator);
		break;
	default:
		break;
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__fims__union_QueryGroupType(struct soap *soap, int choice, const union _fims__union_QueryGroupType *a)
{
	switch (choice)
	{
	case SOAP_UNION__fims__union_QueryGroupType_operator_:
		return soap_out_fims__QueryGroupOperatorType(soap, "fims:operator", -1, &a->operator_, "");
	case SOAP_UNION__fims__union_QueryGroupType_customOperator:
		return soap_out_PointerTofims__CustomQueryGroupOperatorType(soap, "fims:customOperator", -1, &a->customOperator, "");
	default:
		break;
	}
	return SOAP_OK;
}

SOAP_FMAC3 union _fims__union_QueryGroupType * SOAP_FMAC4 soap_in__fims__union_QueryGroupType(struct soap *soap, int *choice, union _fims__union_QueryGroupType *a)
{	soap->error = SOAP_TAG_MISMATCH;
	if (soap->error == SOAP_TAG_MISMATCH && soap_in_fims__QueryGroupOperatorType(soap, "fims:operator", &a->operator_, "fims:QueryGroupOperatorType"))
	{	*choice = SOAP_UNION__fims__union_QueryGroupType_operator_;
		return a;
	}
	a->customOperator = NULL;
	if (soap->error == SOAP_TAG_MISMATCH && soap_in_PointerTofims__CustomQueryGroupOperatorType(soap, "fims:customOperator", &a->customOperator, "fims:CustomQueryGroupOperatorType"))
	{	*choice = SOAP_UNION__fims__union_QueryGroupType_customOperator;
		return a;
	}
	*choice = -1;
	if (!soap->error)
		soap->error = SOAP_TAG_MISMATCH;
	return NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__fims__union_QueryParameterType_(struct soap *soap, int choice, const union _fims__union_QueryParameterType_ *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	switch (choice)
	{
	case SOAP_UNION__fims__union_QueryParameterType__operator_:
		break;
	case SOAP_UNION__fims__union_QueryParameterType__customOperator:
		soap_serialize_PointerTofims__CustomQueryParameterOperatorType(soap, &a->customOperator);
		break;
	default:
		break;
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__fims__union_QueryParameterType_(struct soap *soap, int choice, const union _fims__union_QueryParameterType_ *a)
{
	switch (choice)
	{
	case SOAP_UNION__fims__union_QueryParameterType__operator_:
		return soap_out_fims__QueryParameterOperatorType(soap, "fims:operator", -1, &a->operator_, "");
	case SOAP_UNION__fims__union_QueryParameterType__customOperator:
		return soap_out_PointerTofims__CustomQueryParameterOperatorType(soap, "fims:customOperator", -1, &a->customOperator, "");
	default:
		break;
	}
	return SOAP_OK;
}

SOAP_FMAC3 union _fims__union_QueryParameterType_ * SOAP_FMAC4 soap_in__fims__union_QueryParameterType_(struct soap *soap, int *choice, union _fims__union_QueryParameterType_ *a)
{	soap->error = SOAP_TAG_MISMATCH;
	if (soap->error == SOAP_TAG_MISMATCH && soap_in_fims__QueryParameterOperatorType(soap, "fims:operator", &a->operator_, "fims:QueryParameterOperatorType"))
	{	*choice = SOAP_UNION__fims__union_QueryParameterType__operator_;
		return a;
	}
	a->customOperator = NULL;
	if (soap->error == SOAP_TAG_MISMATCH && soap_in_PointerTofims__CustomQueryParameterOperatorType(soap, "fims:customOperator", &a->customOperator, "fims:CustomQueryParameterOperatorType"))
	{	*choice = SOAP_UNION__fims__union_QueryParameterType__customOperator;
		return a;
	}
	*choice = -1;
	if (!soap->error)
		soap->error = SOAP_TAG_MISMATCH;
	return NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__fims__union_QueryParameterType(struct soap *soap, int choice, const union _fims__union_QueryParameterType *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	switch (choice)
	{
	case SOAP_UNION__fims__union_QueryParameterType_value:
		soap_serialize_PointerTostd__wstring(soap, &a->value);
		break;
	case SOAP_UNION__fims__union_QueryParameterType_customValue:
		soap_serialize_PointerTofims__CustomValueType(soap, &a->customValue);
		break;
	default:
		break;
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__fims__union_QueryParameterType(struct soap *soap, int choice, const union _fims__union_QueryParameterType *a)
{
	switch (choice)
	{
	case SOAP_UNION__fims__union_QueryParameterType_value:
		return soap_out_PointerTostd__wstring(soap, "fims:value", -1, &a->value, "");
	case SOAP_UNION__fims__union_QueryParameterType_customValue:
		return soap_out_PointerTofims__CustomValueType(soap, "fims:customValue", -1, &a->customValue, "");
	default:
		break;
	}
	return SOAP_OK;
}

SOAP_FMAC3 union _fims__union_QueryParameterType * SOAP_FMAC4 soap_in__fims__union_QueryParameterType(struct soap *soap, int *choice, union _fims__union_QueryParameterType *a)
{	soap->error = SOAP_TAG_MISMATCH;
	a->value = NULL;
	if (soap->error == SOAP_TAG_MISMATCH && soap_in_PointerTostd__wstring(soap, "fims:value", &a->value, "xsd:string"))
	{	*choice = SOAP_UNION__fims__union_QueryParameterType_value;
		return a;
	}
	a->customValue = NULL;
	if (soap->error == SOAP_TAG_MISMATCH && soap_in_PointerTofims__CustomValueType(soap, "fims:customValue", &a->customValue, "fims:CustomValueType"))
	{	*choice = SOAP_UNION__fims__union_QueryParameterType_customValue;
		return a;
	}
	*choice = -1;
	if (!soap->error)
		soap->error = SOAP_TAG_MISMATCH;
	return NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__fims__union_QueryExpressionType(struct soap *soap, int choice, const union _fims__union_QueryExpressionType *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	switch (choice)
	{
	case SOAP_UNION__fims__union_QueryExpressionType_parameter:
		soap_serialize_PointerTofims__QueryParameterType(soap, &a->parameter);
		break;
	case SOAP_UNION__fims__union_QueryExpressionType_group:
		soap_serialize_PointerTofims__QueryGroupType(soap, &a->group);
		break;
	default:
		break;
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__fims__union_QueryExpressionType(struct soap *soap, int choice, const union _fims__union_QueryExpressionType *a)
{
	switch (choice)
	{
	case SOAP_UNION__fims__union_QueryExpressionType_parameter:
		return soap_out_PointerTofims__QueryParameterType(soap, "fims:parameter", -1, &a->parameter, "");
	case SOAP_UNION__fims__union_QueryExpressionType_group:
		return soap_out_PointerTofims__QueryGroupType(soap, "fims:group", -1, &a->group, "");
	default:
		break;
	}
	return SOAP_OK;
}

SOAP_FMAC3 union _fims__union_QueryExpressionType * SOAP_FMAC4 soap_in__fims__union_QueryExpressionType(struct soap *soap, int *choice, union _fims__union_QueryExpressionType *a)
{	soap->error = SOAP_TAG_MISMATCH;
	a->parameter = NULL;
	if (soap->error == SOAP_TAG_MISMATCH && soap_in_PointerTofims__QueryParameterType(soap, "fims:parameter", &a->parameter, "fims:QueryParameterType"))
	{	*choice = SOAP_UNION__fims__union_QueryExpressionType_parameter;
		return a;
	}
	a->group = NULL;
	if (soap->error == SOAP_TAG_MISMATCH && soap_in_PointerTofims__QueryGroupType(soap, "fims:group", &a->group, "fims:QueryGroupType"))
	{	*choice = SOAP_UNION__fims__union_QueryExpressionType_group;
		return a;
	}
	*choice = -1;
	if (!soap->error)
		soap->error = SOAP_TAG_MISMATCH;
	return NULL;
}

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_SOAP_ENV__Reason))
		soap_serialize_SOAP_ENV__Reason(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToSOAP_ENV__Reason(struct soap *soap, const char *tag, int id, struct SOAP_ENV__Reason *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_SOAP_ENV__Reason);
	if (id < 0)
		return soap->error;
	return soap_out_SOAP_ENV__Reason(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct SOAP_ENV__Reason ** SOAP_FMAC4 soap_in_PointerToSOAP_ENV__Reason(struct soap *soap, const char *tag, struct SOAP_ENV__Reason **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct SOAP_ENV__Reason **)soap_malloc(soap, sizeof(struct SOAP_ENV__Reason *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_SOAP_ENV__Reason(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Reason **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_SOAP_ENV__Reason, sizeof(struct SOAP_ENV__Reason), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToSOAP_ENV__Reason);
	if (soap_out_PointerToSOAP_ENV__Reason(soap, tag?tag:"SOAP-ENV:Reason", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Reason ** SOAP_FMAC4 soap_get_PointerToSOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToSOAP_ENV__Reason(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_SOAP_ENV__Detail))
		soap_serialize_SOAP_ENV__Detail(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToSOAP_ENV__Detail(struct soap *soap, const char *tag, int id, struct SOAP_ENV__Detail *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_SOAP_ENV__Detail);
	if (id < 0)
		return soap->error;
	return soap_out_SOAP_ENV__Detail(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct SOAP_ENV__Detail ** SOAP_FMAC4 soap_in_PointerToSOAP_ENV__Detail(struct soap *soap, const char *tag, struct SOAP_ENV__Detail **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct SOAP_ENV__Detail **)soap_malloc(soap, sizeof(struct SOAP_ENV__Detail *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_SOAP_ENV__Detail(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Detail **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_SOAP_ENV__Detail, sizeof(struct SOAP_ENV__Detail), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToSOAP_ENV__Detail);
	if (soap_out_PointerToSOAP_ENV__Detail(soap, tag?tag:"SOAP-ENV:Detail", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Detail ** SOAP_FMAC4 soap_get_PointerToSOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToSOAP_ENV__Detail(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_SOAP_ENV__Code))
		soap_serialize_SOAP_ENV__Code(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToSOAP_ENV__Code(struct soap *soap, const char *tag, int id, struct SOAP_ENV__Code *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_SOAP_ENV__Code);
	if (id < 0)
		return soap->error;
	return soap_out_SOAP_ENV__Code(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct SOAP_ENV__Code ** SOAP_FMAC4 soap_in_PointerToSOAP_ENV__Code(struct soap *soap, const char *tag, struct SOAP_ENV__Code **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct SOAP_ENV__Code **)soap_malloc(soap, sizeof(struct SOAP_ENV__Code *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_SOAP_ENV__Code(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Code **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_SOAP_ENV__Code, sizeof(struct SOAP_ENV__Code), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToSOAP_ENV__Code);
	if (soap_out_PointerToSOAP_ENV__Code(soap, tag?tag:"SOAP-ENV:Code", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Code ** SOAP_FMAC4 soap_get_PointerToSOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToSOAP_ENV__Code(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToedlprovider__EdlCreateRequestDoubleType(struct soap *soap, edlprovider__EdlCreateRequestDoubleType *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_edlprovider__EdlCreateRequestDoubleType))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToedlprovider__EdlCreateRequestDoubleType(struct soap *soap, const char *tag, int id, edlprovider__EdlCreateRequestDoubleType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_edlprovider__EdlCreateRequestDoubleType);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 edlprovider__EdlCreateRequestDoubleType ** SOAP_FMAC4 soap_in_PointerToedlprovider__EdlCreateRequestDoubleType(struct soap *soap, const char *tag, edlprovider__EdlCreateRequestDoubleType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (edlprovider__EdlCreateRequestDoubleType **)soap_malloc(soap, sizeof(edlprovider__EdlCreateRequestDoubleType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (edlprovider__EdlCreateRequestDoubleType *)soap_instantiate_edlprovider__EdlCreateRequestDoubleType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	edlprovider__EdlCreateRequestDoubleType ** p = (edlprovider__EdlCreateRequestDoubleType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_edlprovider__EdlCreateRequestDoubleType, sizeof(edlprovider__EdlCreateRequestDoubleType), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToedlprovider__EdlCreateRequestDoubleType(struct soap *soap, edlprovider__EdlCreateRequestDoubleType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToedlprovider__EdlCreateRequestDoubleType);
	if (soap_out_PointerToedlprovider__EdlCreateRequestDoubleType(soap, tag?tag:"edlprovider:EdlCreateRequestDoubleType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 edlprovider__EdlCreateRequestDoubleType ** SOAP_FMAC4 soap_get_PointerToedlprovider__EdlCreateRequestDoubleType(struct soap *soap, edlprovider__EdlCreateRequestDoubleType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToedlprovider__EdlCreateRequestDoubleType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToedlprovider__EdlCreateRequestType(struct soap *soap, edlprovider__EdlCreateRequestType *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_edlprovider__EdlCreateRequestType))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToedlprovider__EdlCreateRequestType(struct soap *soap, const char *tag, int id, edlprovider__EdlCreateRequestType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_edlprovider__EdlCreateRequestType);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 edlprovider__EdlCreateRequestType ** SOAP_FMAC4 soap_in_PointerToedlprovider__EdlCreateRequestType(struct soap *soap, const char *tag, edlprovider__EdlCreateRequestType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (edlprovider__EdlCreateRequestType **)soap_malloc(soap, sizeof(edlprovider__EdlCreateRequestType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (edlprovider__EdlCreateRequestType *)soap_instantiate_edlprovider__EdlCreateRequestType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	edlprovider__EdlCreateRequestType ** p = (edlprovider__EdlCreateRequestType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_edlprovider__EdlCreateRequestType, sizeof(edlprovider__EdlCreateRequestType), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToedlprovider__EdlCreateRequestType(struct soap *soap, edlprovider__EdlCreateRequestType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToedlprovider__EdlCreateRequestType);
	if (soap_out_PointerToedlprovider__EdlCreateRequestType(soap, tag?tag:"edlprovider:EdlCreateRequestType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 edlprovider__EdlCreateRequestType ** SOAP_FMAC4 soap_get_PointerToedlprovider__EdlCreateRequestType(struct soap *soap, edlprovider__EdlCreateRequestType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToedlprovider__EdlCreateRequestType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToedlprovider__EdlProviderFaultType(struct soap *soap, edlprovider__EdlProviderFaultType *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_edlprovider__EdlProviderFaultType))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToedlprovider__EdlProviderFaultType(struct soap *soap, const char *tag, int id, edlprovider__EdlProviderFaultType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_edlprovider__EdlProviderFaultType);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 edlprovider__EdlProviderFaultType ** SOAP_FMAC4 soap_in_PointerToedlprovider__EdlProviderFaultType(struct soap *soap, const char *tag, edlprovider__EdlProviderFaultType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (edlprovider__EdlProviderFaultType **)soap_malloc(soap, sizeof(edlprovider__EdlProviderFaultType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (edlprovider__EdlProviderFaultType *)soap_instantiate_edlprovider__EdlProviderFaultType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	edlprovider__EdlProviderFaultType ** p = (edlprovider__EdlProviderFaultType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_edlprovider__EdlProviderFaultType, sizeof(edlprovider__EdlProviderFaultType), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToedlprovider__EdlProviderFaultType(struct soap *soap, edlprovider__EdlProviderFaultType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToedlprovider__EdlProviderFaultType);
	if (soap_out_PointerToedlprovider__EdlProviderFaultType(soap, tag?tag:"edlprovider:EdlProviderFaultType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 edlprovider__EdlProviderFaultType ** SOAP_FMAC4 soap_get_PointerToedlprovider__EdlProviderFaultType(struct soap *soap, edlprovider__EdlProviderFaultType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToedlprovider__EdlProviderFaultType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_fims__ContainerFormatType_containerFormat(struct soap *soap, _fims__ContainerFormatType_containerFormat *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__fims__ContainerFormatType_containerFormat))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_fims__ContainerFormatType_containerFormat(struct soap *soap, const char *tag, int id, _fims__ContainerFormatType_containerFormat *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__fims__ContainerFormatType_containerFormat);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _fims__ContainerFormatType_containerFormat ** SOAP_FMAC4 soap_in_PointerTo_fims__ContainerFormatType_containerFormat(struct soap *soap, const char *tag, _fims__ContainerFormatType_containerFormat **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_fims__ContainerFormatType_containerFormat **)soap_malloc(soap, sizeof(_fims__ContainerFormatType_containerFormat *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_fims__ContainerFormatType_containerFormat *)soap_instantiate__fims__ContainerFormatType_containerFormat(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_fims__ContainerFormatType_containerFormat ** p = (_fims__ContainerFormatType_containerFormat **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__fims__ContainerFormatType_containerFormat, sizeof(_fims__ContainerFormatType_containerFormat), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_fims__ContainerFormatType_containerFormat(struct soap *soap, _fims__ContainerFormatType_containerFormat *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_fims__ContainerFormatType_containerFormat);
	if (soap_out_PointerTo_fims__ContainerFormatType_containerFormat(soap, tag?tag:"fims:ContainerFormatType-containerFormat", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _fims__ContainerFormatType_containerFormat ** SOAP_FMAC4 soap_get_PointerTo_fims__ContainerFormatType_containerFormat(struct soap *soap, _fims__ContainerFormatType_containerFormat **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_fims__ContainerFormatType_containerFormat(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTofims__AncillaryDataFormatType(struct soap *soap, fims__AncillaryDataFormatType *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_fims__AncillaryDataFormatType))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTofims__AncillaryDataFormatType(struct soap *soap, const char *tag, int id, fims__AncillaryDataFormatType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_fims__AncillaryDataFormatType);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 fims__AncillaryDataFormatType ** SOAP_FMAC4 soap_in_PointerTofims__AncillaryDataFormatType(struct soap *soap, const char *tag, fims__AncillaryDataFormatType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (fims__AncillaryDataFormatType **)soap_malloc(soap, sizeof(fims__AncillaryDataFormatType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (fims__AncillaryDataFormatType *)soap_instantiate_fims__AncillaryDataFormatType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	fims__AncillaryDataFormatType ** p = (fims__AncillaryDataFormatType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_fims__AncillaryDataFormatType, sizeof(fims__AncillaryDataFormatType), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTofims__AncillaryDataFormatType(struct soap *soap, fims__AncillaryDataFormatType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTofims__AncillaryDataFormatType);
	if (soap_out_PointerTofims__AncillaryDataFormatType(soap, tag?tag:"fims:AncillaryDataFormatType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 fims__AncillaryDataFormatType ** SOAP_FMAC4 soap_get_PointerTofims__AncillaryDataFormatType(struct soap *soap, fims__AncillaryDataFormatType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTofims__AncillaryDataFormatType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTofims__CaptioningFormatType(struct soap *soap, fims__CaptioningFormatType *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_fims__CaptioningFormatType))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTofims__CaptioningFormatType(struct soap *soap, const char *tag, int id, fims__CaptioningFormatType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_fims__CaptioningFormatType);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 fims__CaptioningFormatType ** SOAP_FMAC4 soap_in_PointerTofims__CaptioningFormatType(struct soap *soap, const char *tag, fims__CaptioningFormatType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (fims__CaptioningFormatType **)soap_malloc(soap, sizeof(fims__CaptioningFormatType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (fims__CaptioningFormatType *)soap_instantiate_fims__CaptioningFormatType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	fims__CaptioningFormatType ** p = (fims__CaptioningFormatType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_fims__CaptioningFormatType, sizeof(fims__CaptioningFormatType), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTofims__CaptioningFormatType(struct soap *soap, fims__CaptioningFormatType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTofims__CaptioningFormatType);
	if (soap_out_PointerTofims__CaptioningFormatType(soap, tag?tag:"fims:CaptioningFormatType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 fims__CaptioningFormatType ** SOAP_FMAC4 soap_get_PointerTofims__CaptioningFormatType(struct soap *soap, fims__CaptioningFormatType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTofims__CaptioningFormatType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTofims__AudioSampleType(struct soap *soap, enum fims__AudioSampleType *const*a)
{
#ifndef WITH_NOIDREF
	soap_reference(soap, *a, SOAP_TYPE_fims__AudioSampleType);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTofims__AudioSampleType(struct soap *soap, const char *tag, int id, enum fims__AudioSampleType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_fims__AudioSampleType);
	if (id < 0)
		return soap->error;
	return soap_out_fims__AudioSampleType(soap, tag, id, *a, type);
}

SOAP_FMAC3 enum fims__AudioSampleType ** SOAP_FMAC4 soap_in_PointerTofims__AudioSampleType(struct soap *soap, const char *tag, enum fims__AudioSampleType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (enum fims__AudioSampleType **)soap_malloc(soap, sizeof(enum fims__AudioSampleType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_fims__AudioSampleType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (enum fims__AudioSampleType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_fims__AudioSampleType, sizeof(enum fims__AudioSampleType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTofims__AudioSampleType(struct soap *soap, enum fims__AudioSampleType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTofims__AudioSampleType);
	if (soap_out_PointerTofims__AudioSampleType(soap, tag?tag:"fims:AudioSampleType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum fims__AudioSampleType ** SOAP_FMAC4 soap_get_PointerTofims__AudioSampleType(struct soap *soap, enum fims__AudioSampleType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTofims__AudioSampleType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_fims__AudioFormatType_trackConfiguration(struct soap *soap, _fims__AudioFormatType_trackConfiguration *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__fims__AudioFormatType_trackConfiguration))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_fims__AudioFormatType_trackConfiguration(struct soap *soap, const char *tag, int id, _fims__AudioFormatType_trackConfiguration *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__fims__AudioFormatType_trackConfiguration);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _fims__AudioFormatType_trackConfiguration ** SOAP_FMAC4 soap_in_PointerTo_fims__AudioFormatType_trackConfiguration(struct soap *soap, const char *tag, _fims__AudioFormatType_trackConfiguration **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_fims__AudioFormatType_trackConfiguration **)soap_malloc(soap, sizeof(_fims__AudioFormatType_trackConfiguration *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_fims__AudioFormatType_trackConfiguration *)soap_instantiate__fims__AudioFormatType_trackConfiguration(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_fims__AudioFormatType_trackConfiguration ** p = (_fims__AudioFormatType_trackConfiguration **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__fims__AudioFormatType_trackConfiguration, sizeof(_fims__AudioFormatType_trackConfiguration), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_fims__AudioFormatType_trackConfiguration(struct soap *soap, _fims__AudioFormatType_trackConfiguration *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_fims__AudioFormatType_trackConfiguration);
	if (soap_out_PointerTo_fims__AudioFormatType_trackConfiguration(soap, tag?tag:"fims:AudioFormatType-trackConfiguration", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _fims__AudioFormatType_trackConfiguration ** SOAP_FMAC4 soap_get_PointerTo_fims__AudioFormatType_trackConfiguration(struct soap *soap, _fims__AudioFormatType_trackConfiguration **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_fims__AudioFormatType_trackConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToxsd__decimal(struct soap *soap, std::wstring *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_xsd__decimal))
		soap_serialize_xsd__decimal(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToxsd__decimal(struct soap *soap, const char *tag, int id, std::wstring *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_xsd__decimal);
	if (id < 0)
		return soap->error;
	return soap_out_xsd__decimal(soap, tag, id, *a, type);
}

SOAP_FMAC3 std::wstring ** SOAP_FMAC4 soap_in_PointerToxsd__decimal(struct soap *soap, const char *tag, std::wstring **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (std::wstring **)soap_malloc(soap, sizeof(std::wstring *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_xsd__decimal(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (std::wstring **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_xsd__decimal, sizeof(std::wstring), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToxsd__decimal(struct soap *soap, std::wstring *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToxsd__decimal);
	if (soap_out_PointerToxsd__decimal(soap, tag?tag:"xsd:decimal", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::wstring ** SOAP_FMAC4 soap_get_PointerToxsd__decimal(struct soap *soap, std::wstring **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToxsd__decimal(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTofims__ScanningOrderType(struct soap *soap, enum fims__ScanningOrderType *const*a)
{
#ifndef WITH_NOIDREF
	soap_reference(soap, *a, SOAP_TYPE_fims__ScanningOrderType);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTofims__ScanningOrderType(struct soap *soap, const char *tag, int id, enum fims__ScanningOrderType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_fims__ScanningOrderType);
	if (id < 0)
		return soap->error;
	return soap_out_fims__ScanningOrderType(soap, tag, id, *a, type);
}

SOAP_FMAC3 enum fims__ScanningOrderType ** SOAP_FMAC4 soap_in_PointerTofims__ScanningOrderType(struct soap *soap, const char *tag, enum fims__ScanningOrderType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (enum fims__ScanningOrderType **)soap_malloc(soap, sizeof(enum fims__ScanningOrderType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_fims__ScanningOrderType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (enum fims__ScanningOrderType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_fims__ScanningOrderType, sizeof(enum fims__ScanningOrderType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTofims__ScanningOrderType(struct soap *soap, enum fims__ScanningOrderType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTofims__ScanningOrderType);
	if (soap_out_PointerTofims__ScanningOrderType(soap, tag?tag:"fims:ScanningOrderType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum fims__ScanningOrderType ** SOAP_FMAC4 soap_get_PointerTofims__ScanningOrderType(struct soap *soap, enum fims__ScanningOrderType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTofims__ScanningOrderType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTofims__ScanningFormatType(struct soap *soap, enum fims__ScanningFormatType *const*a)
{
#ifndef WITH_NOIDREF
	soap_reference(soap, *a, SOAP_TYPE_fims__ScanningFormatType);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTofims__ScanningFormatType(struct soap *soap, const char *tag, int id, enum fims__ScanningFormatType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_fims__ScanningFormatType);
	if (id < 0)
		return soap->error;
	return soap_out_fims__ScanningFormatType(soap, tag, id, *a, type);
}

SOAP_FMAC3 enum fims__ScanningFormatType ** SOAP_FMAC4 soap_in_PointerTofims__ScanningFormatType(struct soap *soap, const char *tag, enum fims__ScanningFormatType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (enum fims__ScanningFormatType **)soap_malloc(soap, sizeof(enum fims__ScanningFormatType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_fims__ScanningFormatType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (enum fims__ScanningFormatType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_fims__ScanningFormatType, sizeof(enum fims__ScanningFormatType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTofims__ScanningFormatType(struct soap *soap, enum fims__ScanningFormatType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTofims__ScanningFormatType);
	if (soap_out_PointerTofims__ScanningFormatType(soap, tag?tag:"fims:ScanningFormatType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum fims__ScanningFormatType ** SOAP_FMAC4 soap_get_PointerTofims__ScanningFormatType(struct soap *soap, enum fims__ScanningFormatType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTofims__ScanningFormatType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTofims__BitRateModeType(struct soap *soap, enum fims__BitRateModeType *const*a)
{
#ifndef WITH_NOIDREF
	soap_reference(soap, *a, SOAP_TYPE_fims__BitRateModeType);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTofims__BitRateModeType(struct soap *soap, const char *tag, int id, enum fims__BitRateModeType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_fims__BitRateModeType);
	if (id < 0)
		return soap->error;
	return soap_out_fims__BitRateModeType(soap, tag, id, *a, type);
}

SOAP_FMAC3 enum fims__BitRateModeType ** SOAP_FMAC4 soap_in_PointerTofims__BitRateModeType(struct soap *soap, const char *tag, enum fims__BitRateModeType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (enum fims__BitRateModeType **)soap_malloc(soap, sizeof(enum fims__BitRateModeType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_fims__BitRateModeType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (enum fims__BitRateModeType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_fims__BitRateModeType, sizeof(enum fims__BitRateModeType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTofims__BitRateModeType(struct soap *soap, enum fims__BitRateModeType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTofims__BitRateModeType);
	if (soap_out_PointerTofims__BitRateModeType(soap, tag?tag:"fims:BitRateModeType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum fims__BitRateModeType ** SOAP_FMAC4 soap_get_PointerTofims__BitRateModeType(struct soap *soap, enum fims__BitRateModeType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTofims__BitRateModeType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTofims__BMTrackType(struct soap *soap, fims__BMTrackType *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_fims__BMTrackType))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTofims__BMTrackType(struct soap *soap, const char *tag, int id, fims__BMTrackType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_fims__BMTrackType);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 fims__BMTrackType ** SOAP_FMAC4 soap_in_PointerTofims__BMTrackType(struct soap *soap, const char *tag, fims__BMTrackType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (fims__BMTrackType **)soap_malloc(soap, sizeof(fims__BMTrackType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (fims__BMTrackType *)soap_instantiate_fims__BMTrackType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	fims__BMTrackType ** p = (fims__BMTrackType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_fims__BMTrackType, sizeof(fims__BMTrackType), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTofims__BMTrackType(struct soap *soap, fims__BMTrackType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTofims__BMTrackType);
	if (soap_out_PointerTofims__BMTrackType(soap, tag?tag:"fims:BMTrackType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 fims__BMTrackType ** SOAP_FMAC4 soap_get_PointerTofims__BMTrackType(struct soap *soap, fims__BMTrackType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTofims__BMTrackType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTofims__CodecType(struct soap *soap, fims__CodecType *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_fims__CodecType))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTofims__CodecType(struct soap *soap, const char *tag, int id, fims__CodecType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_fims__CodecType);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 fims__CodecType ** SOAP_FMAC4 soap_in_PointerTofims__CodecType(struct soap *soap, const char *tag, fims__CodecType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (fims__CodecType **)soap_malloc(soap, sizeof(fims__CodecType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (fims__CodecType *)soap_instantiate_fims__CodecType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	fims__CodecType ** p = (fims__CodecType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_fims__CodecType, sizeof(fims__CodecType), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTofims__CodecType(struct soap *soap, fims__CodecType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTofims__CodecType);
	if (soap_out_PointerTofims__CodecType(soap, tag?tag:"fims:CodecType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 fims__CodecType ** SOAP_FMAC4 soap_get_PointerTofims__CodecType(struct soap *soap, fims__CodecType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTofims__CodecType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTofims__LengthType(struct soap *soap, fims__LengthType *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_fims__LengthType))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTofims__LengthType(struct soap *soap, const char *tag, int id, fims__LengthType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_fims__LengthType);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 fims__LengthType ** SOAP_FMAC4 soap_in_PointerTofims__LengthType(struct soap *soap, const char *tag, fims__LengthType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (fims__LengthType **)soap_malloc(soap, sizeof(fims__LengthType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (fims__LengthType *)soap_instantiate_fims__LengthType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	fims__LengthType ** p = (fims__LengthType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_fims__LengthType, sizeof(fims__LengthType), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTofims__LengthType(struct soap *soap, fims__LengthType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTofims__LengthType);
	if (soap_out_PointerTofims__LengthType(soap, tag?tag:"fims:LengthType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 fims__LengthType ** SOAP_FMAC4 soap_get_PointerTofims__LengthType(struct soap *soap, fims__LengthType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTofims__LengthType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTofims__ResourceReferencesType(struct soap *soap, fims__ResourceReferencesType *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_fims__ResourceReferencesType))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTofims__ResourceReferencesType(struct soap *soap, const char *tag, int id, fims__ResourceReferencesType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_fims__ResourceReferencesType);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 fims__ResourceReferencesType ** SOAP_FMAC4 soap_in_PointerTofims__ResourceReferencesType(struct soap *soap, const char *tag, fims__ResourceReferencesType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (fims__ResourceReferencesType **)soap_malloc(soap, sizeof(fims__ResourceReferencesType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (fims__ResourceReferencesType *)soap_instantiate_fims__ResourceReferencesType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	fims__ResourceReferencesType ** p = (fims__ResourceReferencesType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_fims__ResourceReferencesType, sizeof(fims__ResourceReferencesType), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTofims__ResourceReferencesType(struct soap *soap, fims__ResourceReferencesType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTofims__ResourceReferencesType);
	if (soap_out_PointerTofims__ResourceReferencesType(soap, tag?tag:"fims:ResourceReferencesType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 fims__ResourceReferencesType ** SOAP_FMAC4 soap_get_PointerTofims__ResourceReferencesType(struct soap *soap, fims__ResourceReferencesType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTofims__ResourceReferencesType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_fims__BMEssenceLocatorType_containerMimeType(struct soap *soap, _fims__BMEssenceLocatorType_containerMimeType *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__fims__BMEssenceLocatorType_containerMimeType))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_fims__BMEssenceLocatorType_containerMimeType(struct soap *soap, const char *tag, int id, _fims__BMEssenceLocatorType_containerMimeType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__fims__BMEssenceLocatorType_containerMimeType);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _fims__BMEssenceLocatorType_containerMimeType ** SOAP_FMAC4 soap_in_PointerTo_fims__BMEssenceLocatorType_containerMimeType(struct soap *soap, const char *tag, _fims__BMEssenceLocatorType_containerMimeType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_fims__BMEssenceLocatorType_containerMimeType **)soap_malloc(soap, sizeof(_fims__BMEssenceLocatorType_containerMimeType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_fims__BMEssenceLocatorType_containerMimeType *)soap_instantiate__fims__BMEssenceLocatorType_containerMimeType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_fims__BMEssenceLocatorType_containerMimeType ** p = (_fims__BMEssenceLocatorType_containerMimeType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__fims__BMEssenceLocatorType_containerMimeType, sizeof(_fims__BMEssenceLocatorType_containerMimeType), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_fims__BMEssenceLocatorType_containerMimeType(struct soap *soap, _fims__BMEssenceLocatorType_containerMimeType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_fims__BMEssenceLocatorType_containerMimeType);
	if (soap_out_PointerTo_fims__BMEssenceLocatorType_containerMimeType(soap, tag?tag:"fims:BMEssenceLocatorType-containerMimeType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _fims__BMEssenceLocatorType_containerMimeType ** SOAP_FMAC4 soap_get_PointerTo_fims__BMEssenceLocatorType_containerMimeType(struct soap *soap, _fims__BMEssenceLocatorType_containerMimeType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_fims__BMEssenceLocatorType_containerMimeType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTofims__StorageType(struct soap *soap, fims__StorageType *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_fims__StorageType))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTofims__StorageType(struct soap *soap, const char *tag, int id, fims__StorageType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_fims__StorageType);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 fims__StorageType ** SOAP_FMAC4 soap_in_PointerTofims__StorageType(struct soap *soap, const char *tag, fims__StorageType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (fims__StorageType **)soap_malloc(soap, sizeof(fims__StorageType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (fims__StorageType *)soap_instantiate_fims__StorageType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	fims__StorageType ** p = (fims__StorageType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_fims__StorageType, sizeof(fims__StorageType), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTofims__StorageType(struct soap *soap, fims__StorageType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTofims__StorageType);
	if (soap_out_PointerTofims__StorageType(soap, tag?tag:"fims:StorageType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 fims__StorageType ** SOAP_FMAC4 soap_get_PointerTofims__StorageType(struct soap *soap, fims__StorageType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTofims__StorageType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_fims__BMContentFormatType_mimeType(struct soap *soap, _fims__BMContentFormatType_mimeType *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__fims__BMContentFormatType_mimeType))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_fims__BMContentFormatType_mimeType(struct soap *soap, const char *tag, int id, _fims__BMContentFormatType_mimeType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__fims__BMContentFormatType_mimeType);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _fims__BMContentFormatType_mimeType ** SOAP_FMAC4 soap_in_PointerTo_fims__BMContentFormatType_mimeType(struct soap *soap, const char *tag, _fims__BMContentFormatType_mimeType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_fims__BMContentFormatType_mimeType **)soap_malloc(soap, sizeof(_fims__BMContentFormatType_mimeType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_fims__BMContentFormatType_mimeType *)soap_instantiate__fims__BMContentFormatType_mimeType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_fims__BMContentFormatType_mimeType ** p = (_fims__BMContentFormatType_mimeType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__fims__BMContentFormatType_mimeType, sizeof(_fims__BMContentFormatType_mimeType), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_fims__BMContentFormatType_mimeType(struct soap *soap, _fims__BMContentFormatType_mimeType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_fims__BMContentFormatType_mimeType);
	if (soap_out_PointerTo_fims__BMContentFormatType_mimeType(soap, tag?tag:"fims:BMContentFormatType-mimeType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _fims__BMContentFormatType_mimeType ** SOAP_FMAC4 soap_get_PointerTo_fims__BMContentFormatType_mimeType(struct soap *soap, _fims__BMContentFormatType_mimeType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_fims__BMContentFormatType_mimeType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTounsignedLONG64(struct soap *soap, ULONG64 *const*a)
{
#ifndef WITH_NOIDREF
	soap_reference(soap, *a, SOAP_TYPE_unsignedLONG64);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTounsignedLONG64(struct soap *soap, const char *tag, int id, ULONG64 *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_unsignedLONG64);
	if (id < 0)
		return soap->error;
	return soap_out_unsignedLONG64(soap, tag, id, *a, type);
}

SOAP_FMAC3 ULONG64 ** SOAP_FMAC4 soap_in_PointerTounsignedLONG64(struct soap *soap, const char *tag, ULONG64 **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ULONG64 **)soap_malloc(soap, sizeof(ULONG64 *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_unsignedLONG64(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (ULONG64 **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_unsignedLONG64, sizeof(ULONG64), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTounsignedLONG64(struct soap *soap, ULONG64 *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTounsignedLONG64);
	if (soap_out_PointerTounsignedLONG64(soap, tag?tag:"unsignedLong", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ULONG64 ** SOAP_FMAC4 soap_get_PointerTounsignedLONG64(struct soap *soap, ULONG64 **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTounsignedLONG64(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTofims__HashType(struct soap *soap, fims__HashType *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_fims__HashType))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTofims__HashType(struct soap *soap, const char *tag, int id, fims__HashType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_fims__HashType);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 fims__HashType ** SOAP_FMAC4 soap_in_PointerTofims__HashType(struct soap *soap, const char *tag, fims__HashType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (fims__HashType **)soap_malloc(soap, sizeof(fims__HashType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (fims__HashType *)soap_instantiate_fims__HashType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	fims__HashType ** p = (fims__HashType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_fims__HashType, sizeof(fims__HashType), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTofims__HashType(struct soap *soap, fims__HashType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTofims__HashType);
	if (soap_out_PointerTofims__HashType(soap, tag?tag:"fims:HashType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 fims__HashType ** SOAP_FMAC4 soap_get_PointerTofims__HashType(struct soap *soap, fims__HashType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTofims__HashType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_fims__formatCollection(struct soap *soap, _fims__formatCollection *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__fims__formatCollection))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_fims__formatCollection(struct soap *soap, const char *tag, int id, _fims__formatCollection *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__fims__formatCollection);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _fims__formatCollection ** SOAP_FMAC4 soap_in_PointerTo_fims__formatCollection(struct soap *soap, const char *tag, _fims__formatCollection **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_fims__formatCollection **)soap_malloc(soap, sizeof(_fims__formatCollection *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_fims__formatCollection *)soap_instantiate__fims__formatCollection(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_fims__formatCollection ** p = (_fims__formatCollection **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__fims__formatCollection, sizeof(_fims__formatCollection), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_fims__formatCollection(struct soap *soap, _fims__formatCollection *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_fims__formatCollection);
	if (soap_out_PointerTo_fims__formatCollection(soap, tag?tag:"fims:formatCollection", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _fims__formatCollection ** SOAP_FMAC4 soap_get_PointerTo_fims__formatCollection(struct soap *soap, _fims__formatCollection **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_fims__formatCollection(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTofims__BMEssenceLocatorsType(struct soap *soap, fims__BMEssenceLocatorsType *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_fims__BMEssenceLocatorsType))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTofims__BMEssenceLocatorsType(struct soap *soap, const char *tag, int id, fims__BMEssenceLocatorsType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_fims__BMEssenceLocatorsType);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 fims__BMEssenceLocatorsType ** SOAP_FMAC4 soap_in_PointerTofims__BMEssenceLocatorsType(struct soap *soap, const char *tag, fims__BMEssenceLocatorsType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (fims__BMEssenceLocatorsType **)soap_malloc(soap, sizeof(fims__BMEssenceLocatorsType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (fims__BMEssenceLocatorsType *)soap_instantiate_fims__BMEssenceLocatorsType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	fims__BMEssenceLocatorsType ** p = (fims__BMEssenceLocatorsType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_fims__BMEssenceLocatorsType, sizeof(fims__BMEssenceLocatorsType), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTofims__BMEssenceLocatorsType(struct soap *soap, fims__BMEssenceLocatorsType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTofims__BMEssenceLocatorsType);
	if (soap_out_PointerTofims__BMEssenceLocatorsType(soap, tag?tag:"fims:BMEssenceLocatorsType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 fims__BMEssenceLocatorsType ** SOAP_FMAC4 soap_get_PointerTofims__BMEssenceLocatorsType(struct soap *soap, fims__BMEssenceLocatorsType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTofims__BMEssenceLocatorsType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTofimsdescription__bmContentDescriptionType(struct soap *soap, fimsdescription__bmContentDescriptionType *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_fimsdescription__bmContentDescriptionType))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTofimsdescription__bmContentDescriptionType(struct soap *soap, const char *tag, int id, fimsdescription__bmContentDescriptionType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_fimsdescription__bmContentDescriptionType);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 fimsdescription__bmContentDescriptionType ** SOAP_FMAC4 soap_in_PointerTofimsdescription__bmContentDescriptionType(struct soap *soap, const char *tag, fimsdescription__bmContentDescriptionType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (fimsdescription__bmContentDescriptionType **)soap_malloc(soap, sizeof(fimsdescription__bmContentDescriptionType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (fimsdescription__bmContentDescriptionType *)soap_instantiate_fimsdescription__bmContentDescriptionType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	fimsdescription__bmContentDescriptionType ** p = (fimsdescription__bmContentDescriptionType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_fimsdescription__bmContentDescriptionType, sizeof(fimsdescription__bmContentDescriptionType), 0);
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (fimsdescription__bmContentDescriptionType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_fimsdescription__partType, sizeof(fimsdescription__partType), 0);
		}
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTofimsdescription__bmContentDescriptionType(struct soap *soap, fimsdescription__bmContentDescriptionType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTofimsdescription__bmContentDescriptionType);
	if (soap_out_PointerTofimsdescription__bmContentDescriptionType(soap, tag?tag:"fimsdescription:bmContentDescriptionType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 fimsdescription__bmContentDescriptionType ** SOAP_FMAC4 soap_get_PointerTofimsdescription__bmContentDescriptionType(struct soap *soap, fimsdescription__bmContentDescriptionType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTofimsdescription__bmContentDescriptionType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTofims__DescriptionsType(struct soap *soap, fims__DescriptionsType *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_fims__DescriptionsType))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTofims__DescriptionsType(struct soap *soap, const char *tag, int id, fims__DescriptionsType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_fims__DescriptionsType);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 fims__DescriptionsType ** SOAP_FMAC4 soap_in_PointerTofims__DescriptionsType(struct soap *soap, const char *tag, fims__DescriptionsType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (fims__DescriptionsType **)soap_malloc(soap, sizeof(fims__DescriptionsType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (fims__DescriptionsType *)soap_instantiate_fims__DescriptionsType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	fims__DescriptionsType ** p = (fims__DescriptionsType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_fims__DescriptionsType, sizeof(fims__DescriptionsType), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTofims__DescriptionsType(struct soap *soap, fims__DescriptionsType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTofims__DescriptionsType);
	if (soap_out_PointerTofims__DescriptionsType(soap, tag?tag:"fims:DescriptionsType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 fims__DescriptionsType ** SOAP_FMAC4 soap_get_PointerTofims__DescriptionsType(struct soap *soap, fims__DescriptionsType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTofims__DescriptionsType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTofims__BMContentFormatsType(struct soap *soap, fims__BMContentFormatsType *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_fims__BMContentFormatsType))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTofims__BMContentFormatsType(struct soap *soap, const char *tag, int id, fims__BMContentFormatsType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_fims__BMContentFormatsType);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 fims__BMContentFormatsType ** SOAP_FMAC4 soap_in_PointerTofims__BMContentFormatsType(struct soap *soap, const char *tag, fims__BMContentFormatsType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (fims__BMContentFormatsType **)soap_malloc(soap, sizeof(fims__BMContentFormatsType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (fims__BMContentFormatsType *)soap_instantiate_fims__BMContentFormatsType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	fims__BMContentFormatsType ** p = (fims__BMContentFormatsType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_fims__BMContentFormatsType, sizeof(fims__BMContentFormatsType), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTofims__BMContentFormatsType(struct soap *soap, fims__BMContentFormatsType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTofims__BMContentFormatsType);
	if (soap_out_PointerTofims__BMContentFormatsType(soap, tag?tag:"fims:BMContentFormatsType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 fims__BMContentFormatsType ** SOAP_FMAC4 soap_get_PointerTofims__BMContentFormatsType(struct soap *soap, fims__BMContentFormatsType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTofims__BMContentFormatsType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTofims__BMContentsType(struct soap *soap, fims__BMContentsType *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_fims__BMContentsType))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTofims__BMContentsType(struct soap *soap, const char *tag, int id, fims__BMContentsType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_fims__BMContentsType);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 fims__BMContentsType ** SOAP_FMAC4 soap_in_PointerTofims__BMContentsType(struct soap *soap, const char *tag, fims__BMContentsType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (fims__BMContentsType **)soap_malloc(soap, sizeof(fims__BMContentsType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (fims__BMContentsType *)soap_instantiate_fims__BMContentsType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	fims__BMContentsType ** p = (fims__BMContentsType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_fims__BMContentsType, sizeof(fims__BMContentsType), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTofims__BMContentsType(struct soap *soap, fims__BMContentsType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTofims__BMContentsType);
	if (soap_out_PointerTofims__BMContentsType(soap, tag?tag:"fims:BMContentsType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 fims__BMContentsType ** SOAP_FMAC4 soap_get_PointerTofims__BMContentsType(struct soap *soap, fims__BMContentsType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTofims__BMContentsType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTofims__TechnicalAttributeType(struct soap *soap, fims__TechnicalAttributeType *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_fims__TechnicalAttributeType))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTofims__TechnicalAttributeType(struct soap *soap, const char *tag, int id, fims__TechnicalAttributeType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_fims__TechnicalAttributeType);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 fims__TechnicalAttributeType ** SOAP_FMAC4 soap_in_PointerTofims__TechnicalAttributeType(struct soap *soap, const char *tag, fims__TechnicalAttributeType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (fims__TechnicalAttributeType **)soap_malloc(soap, sizeof(fims__TechnicalAttributeType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (fims__TechnicalAttributeType *)soap_instantiate_fims__TechnicalAttributeType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	fims__TechnicalAttributeType ** p = (fims__TechnicalAttributeType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_fims__TechnicalAttributeType, sizeof(fims__TechnicalAttributeType), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTofims__TechnicalAttributeType(struct soap *soap, fims__TechnicalAttributeType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTofims__TechnicalAttributeType);
	if (soap_out_PointerTofims__TechnicalAttributeType(soap, tag?tag:"fims:TechnicalAttributeType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 fims__TechnicalAttributeType ** SOAP_FMAC4 soap_get_PointerTofims__TechnicalAttributeType(struct soap *soap, fims__TechnicalAttributeType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTofims__TechnicalAttributeType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTofims__ProcessedInfoType(struct soap *soap, fims__ProcessedInfoType *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_fims__ProcessedInfoType))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTofims__ProcessedInfoType(struct soap *soap, const char *tag, int id, fims__ProcessedInfoType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_fims__ProcessedInfoType);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 fims__ProcessedInfoType ** SOAP_FMAC4 soap_in_PointerTofims__ProcessedInfoType(struct soap *soap, const char *tag, fims__ProcessedInfoType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (fims__ProcessedInfoType **)soap_malloc(soap, sizeof(fims__ProcessedInfoType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (fims__ProcessedInfoType *)soap_instantiate_fims__ProcessedInfoType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	fims__ProcessedInfoType ** p = (fims__ProcessedInfoType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_fims__ProcessedInfoType, sizeof(fims__ProcessedInfoType), 0);
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (fims__ProcessedInfoType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_fims__ProcessedInfoByBytesType, sizeof(fims__ProcessedInfoByBytesType), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (fims__ProcessedInfoType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_fims__ProcessedInfoByFramesType, sizeof(fims__ProcessedInfoByFramesType), 0);
		}
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTofims__ProcessedInfoType(struct soap *soap, fims__ProcessedInfoType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTofims__ProcessedInfoType);
	if (soap_out_PointerTofims__ProcessedInfoType(soap, tag?tag:"fims:ProcessedInfoType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 fims__ProcessedInfoType ** SOAP_FMAC4 soap_get_PointerTofims__ProcessedInfoType(struct soap *soap, fims__ProcessedInfoType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTofims__ProcessedInfoType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTofims__StartJobType(struct soap *soap, fims__StartJobType *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_fims__StartJobType))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTofims__StartJobType(struct soap *soap, const char *tag, int id, fims__StartJobType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_fims__StartJobType);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 fims__StartJobType ** SOAP_FMAC4 soap_in_PointerTofims__StartJobType(struct soap *soap, const char *tag, fims__StartJobType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (fims__StartJobType **)soap_malloc(soap, sizeof(fims__StartJobType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (fims__StartJobType *)soap_instantiate_fims__StartJobType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	fims__StartJobType ** p = (fims__StartJobType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_fims__StartJobType, sizeof(fims__StartJobType), 0);
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (fims__StartJobType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_fims__StartJobByNoWaitType, sizeof(fims__StartJobByNoWaitType), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (fims__StartJobType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_fims__StartJobByTimeType, sizeof(fims__StartJobByTimeType), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (fims__StartJobType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_fims__StartJobByLatestType, sizeof(fims__StartJobByLatestType), 0);
		}
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTofims__StartJobType(struct soap *soap, fims__StartJobType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTofims__StartJobType);
	if (soap_out_PointerTofims__StartJobType(soap, tag?tag:"fims:StartJobType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 fims__StartJobType ** SOAP_FMAC4 soap_get_PointerTofims__StartJobType(struct soap *soap, fims__StartJobType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTofims__StartJobType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTofims__BMObjectsType(struct soap *soap, fims__BMObjectsType *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_fims__BMObjectsType))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTofims__BMObjectsType(struct soap *soap, const char *tag, int id, fims__BMObjectsType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_fims__BMObjectsType);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 fims__BMObjectsType ** SOAP_FMAC4 soap_in_PointerTofims__BMObjectsType(struct soap *soap, const char *tag, fims__BMObjectsType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (fims__BMObjectsType **)soap_malloc(soap, sizeof(fims__BMObjectsType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (fims__BMObjectsType *)soap_instantiate_fims__BMObjectsType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	fims__BMObjectsType ** p = (fims__BMObjectsType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_fims__BMObjectsType, sizeof(fims__BMObjectsType), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTofims__BMObjectsType(struct soap *soap, fims__BMObjectsType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTofims__BMObjectsType);
	if (soap_out_PointerTofims__BMObjectsType(soap, tag?tag:"fims:BMObjectsType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 fims__BMObjectsType ** SOAP_FMAC4 soap_get_PointerTofims__BMObjectsType(struct soap *soap, fims__BMObjectsType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTofims__BMObjectsType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTofims__JobStatusType(struct soap *soap, enum fims__JobStatusType *const*a)
{
#ifndef WITH_NOIDREF
	soap_reference(soap, *a, SOAP_TYPE_fims__JobStatusType);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTofims__JobStatusType(struct soap *soap, const char *tag, int id, enum fims__JobStatusType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_fims__JobStatusType);
	if (id < 0)
		return soap->error;
	return soap_out_fims__JobStatusType(soap, tag, id, *a, type);
}

SOAP_FMAC3 enum fims__JobStatusType ** SOAP_FMAC4 soap_in_PointerTofims__JobStatusType(struct soap *soap, const char *tag, enum fims__JobStatusType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (enum fims__JobStatusType **)soap_malloc(soap, sizeof(enum fims__JobStatusType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_fims__JobStatusType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (enum fims__JobStatusType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_fims__JobStatusType, sizeof(enum fims__JobStatusType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTofims__JobStatusType(struct soap *soap, enum fims__JobStatusType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTofims__JobStatusType);
	if (soap_out_PointerTofims__JobStatusType(soap, tag?tag:"fims:JobStatusType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum fims__JobStatusType ** SOAP_FMAC4 soap_get_PointerTofims__JobStatusType(struct soap *soap, enum fims__JobStatusType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTofims__JobStatusType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTofims__QueueStatusType(struct soap *soap, enum fims__QueueStatusType *const*a)
{
#ifndef WITH_NOIDREF
	soap_reference(soap, *a, SOAP_TYPE_fims__QueueStatusType);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTofims__QueueStatusType(struct soap *soap, const char *tag, int id, enum fims__QueueStatusType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_fims__QueueStatusType);
	if (id < 0)
		return soap->error;
	return soap_out_fims__QueueStatusType(soap, tag, id, *a, type);
}

SOAP_FMAC3 enum fims__QueueStatusType ** SOAP_FMAC4 soap_in_PointerTofims__QueueStatusType(struct soap *soap, const char *tag, enum fims__QueueStatusType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (enum fims__QueueStatusType **)soap_malloc(soap, sizeof(enum fims__QueueStatusType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_fims__QueueStatusType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (enum fims__QueueStatusType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_fims__QueueStatusType, sizeof(enum fims__QueueStatusType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTofims__QueueStatusType(struct soap *soap, enum fims__QueueStatusType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTofims__QueueStatusType);
	if (soap_out_PointerTofims__QueueStatusType(soap, tag?tag:"fims:QueueStatusType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum fims__QueueStatusType ** SOAP_FMAC4 soap_get_PointerTofims__QueueStatusType(struct soap *soap, enum fims__QueueStatusType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTofims__QueueStatusType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_fims__ServiceType_serviceDescription(struct soap *soap, _fims__ServiceType_serviceDescription *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__fims__ServiceType_serviceDescription))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_fims__ServiceType_serviceDescription(struct soap *soap, const char *tag, int id, _fims__ServiceType_serviceDescription *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__fims__ServiceType_serviceDescription);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _fims__ServiceType_serviceDescription ** SOAP_FMAC4 soap_in_PointerTo_fims__ServiceType_serviceDescription(struct soap *soap, const char *tag, _fims__ServiceType_serviceDescription **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_fims__ServiceType_serviceDescription **)soap_malloc(soap, sizeof(_fims__ServiceType_serviceDescription *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_fims__ServiceType_serviceDescription *)soap_instantiate__fims__ServiceType_serviceDescription(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_fims__ServiceType_serviceDescription ** p = (_fims__ServiceType_serviceDescription **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__fims__ServiceType_serviceDescription, sizeof(_fims__ServiceType_serviceDescription), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_fims__ServiceType_serviceDescription(struct soap *soap, _fims__ServiceType_serviceDescription *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_fims__ServiceType_serviceDescription);
	if (soap_out_PointerTo_fims__ServiceType_serviceDescription(soap, tag?tag:"fims:ServiceType-serviceDescription", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _fims__ServiceType_serviceDescription ** SOAP_FMAC4 soap_get_PointerTo_fims__ServiceType_serviceDescription(struct soap *soap, _fims__ServiceType_serviceDescription **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_fims__ServiceType_serviceDescription(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToxsd__NMTOKEN(struct soap *soap, std::wstring *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_xsd__NMTOKEN))
		soap_serialize_xsd__NMTOKEN(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToxsd__NMTOKEN(struct soap *soap, const char *tag, int id, std::wstring *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_xsd__NMTOKEN);
	if (id < 0)
		return soap->error;
	return soap_out_xsd__NMTOKEN(soap, tag, id, *a, type);
}

SOAP_FMAC3 std::wstring ** SOAP_FMAC4 soap_in_PointerToxsd__NMTOKEN(struct soap *soap, const char *tag, std::wstring **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (std::wstring **)soap_malloc(soap, sizeof(std::wstring *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_xsd__NMTOKEN(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (std::wstring **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_xsd__NMTOKEN, sizeof(std::wstring), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToxsd__NMTOKEN(struct soap *soap, std::wstring *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToxsd__NMTOKEN);
	if (soap_out_PointerToxsd__NMTOKEN(soap, tag?tag:"xsd:NMTOKEN", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::wstring ** SOAP_FMAC4 soap_get_PointerToxsd__NMTOKEN(struct soap *soap, std::wstring **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToxsd__NMTOKEN(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTofims__ListFilterType(struct soap *soap, fims__ListFilterType *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_fims__ListFilterType))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTofims__ListFilterType(struct soap *soap, const char *tag, int id, fims__ListFilterType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_fims__ListFilterType);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 fims__ListFilterType ** SOAP_FMAC4 soap_in_PointerTofims__ListFilterType(struct soap *soap, const char *tag, fims__ListFilterType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (fims__ListFilterType **)soap_malloc(soap, sizeof(fims__ListFilterType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (fims__ListFilterType *)soap_instantiate_fims__ListFilterType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	fims__ListFilterType ** p = (fims__ListFilterType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_fims__ListFilterType, sizeof(fims__ListFilterType), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTofims__ListFilterType(struct soap *soap, fims__ListFilterType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTofims__ListFilterType);
	if (soap_out_PointerTofims__ListFilterType(soap, tag?tag:"fims:ListFilterType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 fims__ListFilterType ** SOAP_FMAC4 soap_get_PointerTofims__ListFilterType(struct soap *soap, fims__ListFilterType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTofims__ListFilterType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTofimstime__DurationType(struct soap *soap, fimstime__DurationType *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_fimstime__DurationType))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTofimstime__DurationType(struct soap *soap, const char *tag, int id, fimstime__DurationType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_fimstime__DurationType);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 fimstime__DurationType ** SOAP_FMAC4 soap_in_PointerTofimstime__DurationType(struct soap *soap, const char *tag, fimstime__DurationType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (fimstime__DurationType **)soap_malloc(soap, sizeof(fimstime__DurationType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (fimstime__DurationType *)soap_instantiate_fimstime__DurationType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	fimstime__DurationType ** p = (fimstime__DurationType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_fimstime__DurationType, sizeof(fimstime__DurationType), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTofimstime__DurationType(struct soap *soap, fimstime__DurationType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTofimstime__DurationType);
	if (soap_out_PointerTofimstime__DurationType(soap, tag?tag:"fimstime:DurationType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 fimstime__DurationType ** SOAP_FMAC4 soap_get_PointerTofimstime__DurationType(struct soap *soap, fimstime__DurationType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTofimstime__DurationType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTofims__AsyncEndpointType(struct soap *soap, fims__AsyncEndpointType *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_fims__AsyncEndpointType))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTofims__AsyncEndpointType(struct soap *soap, const char *tag, int id, fims__AsyncEndpointType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_fims__AsyncEndpointType);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 fims__AsyncEndpointType ** SOAP_FMAC4 soap_in_PointerTofims__AsyncEndpointType(struct soap *soap, const char *tag, fims__AsyncEndpointType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (fims__AsyncEndpointType **)soap_malloc(soap, sizeof(fims__AsyncEndpointType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (fims__AsyncEndpointType *)soap_instantiate_fims__AsyncEndpointType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	fims__AsyncEndpointType ** p = (fims__AsyncEndpointType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_fims__AsyncEndpointType, sizeof(fims__AsyncEndpointType), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTofims__AsyncEndpointType(struct soap *soap, fims__AsyncEndpointType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTofims__AsyncEndpointType);
	if (soap_out_PointerTofims__AsyncEndpointType(soap, tag?tag:"fims:AsyncEndpointType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 fims__AsyncEndpointType ** SOAP_FMAC4 soap_get_PointerTofims__AsyncEndpointType(struct soap *soap, fims__AsyncEndpointType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTofims__AsyncEndpointType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToedlprovider__EdlProviderErrorCodeType(struct soap *soap, enum edlprovider__EdlProviderErrorCodeType *const*a)
{
#ifndef WITH_NOIDREF
	soap_reference(soap, *a, SOAP_TYPE_edlprovider__EdlProviderErrorCodeType);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToedlprovider__EdlProviderErrorCodeType(struct soap *soap, const char *tag, int id, enum edlprovider__EdlProviderErrorCodeType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_edlprovider__EdlProviderErrorCodeType);
	if (id < 0)
		return soap->error;
	return soap_out_edlprovider__EdlProviderErrorCodeType(soap, tag, id, *a, type);
}

SOAP_FMAC3 enum edlprovider__EdlProviderErrorCodeType ** SOAP_FMAC4 soap_in_PointerToedlprovider__EdlProviderErrorCodeType(struct soap *soap, const char *tag, enum edlprovider__EdlProviderErrorCodeType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (enum edlprovider__EdlProviderErrorCodeType **)soap_malloc(soap, sizeof(enum edlprovider__EdlProviderErrorCodeType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_edlprovider__EdlProviderErrorCodeType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (enum edlprovider__EdlProviderErrorCodeType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_edlprovider__EdlProviderErrorCodeType, sizeof(enum edlprovider__EdlProviderErrorCodeType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToedlprovider__EdlProviderErrorCodeType(struct soap *soap, enum edlprovider__EdlProviderErrorCodeType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToedlprovider__EdlProviderErrorCodeType);
	if (soap_out_PointerToedlprovider__EdlProviderErrorCodeType(soap, tag?tag:"edlprovider:EdlProviderErrorCodeType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum edlprovider__EdlProviderErrorCodeType ** SOAP_FMAC4 soap_get_PointerToedlprovider__EdlProviderErrorCodeType(struct soap *soap, enum edlprovider__EdlProviderErrorCodeType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToedlprovider__EdlProviderErrorCodeType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTofims__RationalType(struct soap *soap, fims__RationalType *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_fims__RationalType))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTofims__RationalType(struct soap *soap, const char *tag, int id, fims__RationalType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_fims__RationalType);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 fims__RationalType ** SOAP_FMAC4 soap_in_PointerTofims__RationalType(struct soap *soap, const char *tag, fims__RationalType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (fims__RationalType **)soap_malloc(soap, sizeof(fims__RationalType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (fims__RationalType *)soap_instantiate_fims__RationalType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	fims__RationalType ** p = (fims__RationalType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_fims__RationalType, sizeof(fims__RationalType), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTofims__RationalType(struct soap *soap, fims__RationalType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTofims__RationalType);
	if (soap_out_PointerTofims__RationalType(soap, tag?tag:"fims:RationalType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 fims__RationalType ** SOAP_FMAC4 soap_get_PointerTofims__RationalType(struct soap *soap, fims__RationalType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTofims__RationalType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_fimsdescription__addressType_country(struct soap *soap, _fimsdescription__addressType_country *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__fimsdescription__addressType_country))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_fimsdescription__addressType_country(struct soap *soap, const char *tag, int id, _fimsdescription__addressType_country *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__fimsdescription__addressType_country);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _fimsdescription__addressType_country ** SOAP_FMAC4 soap_in_PointerTo_fimsdescription__addressType_country(struct soap *soap, const char *tag, _fimsdescription__addressType_country **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_fimsdescription__addressType_country **)soap_malloc(soap, sizeof(_fimsdescription__addressType_country *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_fimsdescription__addressType_country *)soap_instantiate__fimsdescription__addressType_country(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_fimsdescription__addressType_country ** p = (_fimsdescription__addressType_country **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__fimsdescription__addressType_country, sizeof(_fimsdescription__addressType_country), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_fimsdescription__addressType_country(struct soap *soap, _fimsdescription__addressType_country *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_fimsdescription__addressType_country);
	if (soap_out_PointerTo_fimsdescription__addressType_country(soap, tag?tag:"fimsdescription:addressType-country", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _fimsdescription__addressType_country ** SOAP_FMAC4 soap_get_PointerTo_fimsdescription__addressType_country(struct soap *soap, _fimsdescription__addressType_country **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_fimsdescription__addressType_country(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTofimsdescription__addressType(struct soap *soap, fimsdescription__addressType *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_fimsdescription__addressType))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTofimsdescription__addressType(struct soap *soap, const char *tag, int id, fimsdescription__addressType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_fimsdescription__addressType);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 fimsdescription__addressType ** SOAP_FMAC4 soap_in_PointerTofimsdescription__addressType(struct soap *soap, const char *tag, fimsdescription__addressType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (fimsdescription__addressType **)soap_malloc(soap, sizeof(fimsdescription__addressType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (fimsdescription__addressType *)soap_instantiate_fimsdescription__addressType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	fimsdescription__addressType ** p = (fimsdescription__addressType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_fimsdescription__addressType, sizeof(fimsdescription__addressType), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTofimsdescription__addressType(struct soap *soap, fimsdescription__addressType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTofimsdescription__addressType);
	if (soap_out_PointerTofimsdescription__addressType(soap, tag?tag:"fimsdescription:addressType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 fimsdescription__addressType ** SOAP_FMAC4 soap_get_PointerTofimsdescription__addressType(struct soap *soap, fimsdescription__addressType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTofimsdescription__addressType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_fimsdescription__organisationDetailsType_organisationDepartment(struct soap *soap, _fimsdescription__organisationDetailsType_organisationDepartment *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__fimsdescription__organisationDetailsType_organisationDepartment))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_fimsdescription__organisationDetailsType_organisationDepartment(struct soap *soap, const char *tag, int id, _fimsdescription__organisationDetailsType_organisationDepartment *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__fimsdescription__organisationDetailsType_organisationDepartment);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _fimsdescription__organisationDetailsType_organisationDepartment ** SOAP_FMAC4 soap_in_PointerTo_fimsdescription__organisationDetailsType_organisationDepartment(struct soap *soap, const char *tag, _fimsdescription__organisationDetailsType_organisationDepartment **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_fimsdescription__organisationDetailsType_organisationDepartment **)soap_malloc(soap, sizeof(_fimsdescription__organisationDetailsType_organisationDepartment *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_fimsdescription__organisationDetailsType_organisationDepartment *)soap_instantiate__fimsdescription__organisationDetailsType_organisationDepartment(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_fimsdescription__organisationDetailsType_organisationDepartment ** p = (_fimsdescription__organisationDetailsType_organisationDepartment **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__fimsdescription__organisationDetailsType_organisationDepartment, sizeof(_fimsdescription__organisationDetailsType_organisationDepartment), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_fimsdescription__organisationDetailsType_organisationDepartment(struct soap *soap, _fimsdescription__organisationDetailsType_organisationDepartment *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_fimsdescription__organisationDetailsType_organisationDepartment);
	if (soap_out_PointerTo_fimsdescription__organisationDetailsType_organisationDepartment(soap, tag?tag:"fimsdescription:organisationDetailsType-organisationDepartment", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _fimsdescription__organisationDetailsType_organisationDepartment ** SOAP_FMAC4 soap_get_PointerTo_fimsdescription__organisationDetailsType_organisationDepartment(struct soap *soap, _fimsdescription__organisationDetailsType_organisationDepartment **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_fimsdescription__organisationDetailsType_organisationDepartment(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTofimsdescription__detailsType(struct soap *soap, fimsdescription__detailsType *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_fimsdescription__detailsType))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTofimsdescription__detailsType(struct soap *soap, const char *tag, int id, fimsdescription__detailsType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_fimsdescription__detailsType);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 fimsdescription__detailsType ** SOAP_FMAC4 soap_in_PointerTofimsdescription__detailsType(struct soap *soap, const char *tag, fimsdescription__detailsType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (fimsdescription__detailsType **)soap_malloc(soap, sizeof(fimsdescription__detailsType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (fimsdescription__detailsType *)soap_instantiate_fimsdescription__detailsType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	fimsdescription__detailsType ** p = (fimsdescription__detailsType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_fimsdescription__detailsType, sizeof(fimsdescription__detailsType), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTofimsdescription__detailsType(struct soap *soap, fimsdescription__detailsType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTofimsdescription__detailsType);
	if (soap_out_PointerTofimsdescription__detailsType(soap, tag?tag:"fimsdescription:detailsType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 fimsdescription__detailsType ** SOAP_FMAC4 soap_get_PointerTofimsdescription__detailsType(struct soap *soap, fimsdescription__detailsType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTofimsdescription__detailsType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTostd__vectorTemplateOf_fimsdescription__entityType_role(struct soap *soap, std::vector<_fimsdescription__entityType_role >*const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_std__vectorTemplateOf_fimsdescription__entityType_role))
		soap_serialize_std__vectorTemplateOf_fimsdescription__entityType_role(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTostd__vectorTemplateOf_fimsdescription__entityType_role(struct soap *soap, const char *tag, int id, std::vector<_fimsdescription__entityType_role >*const*a, const char *type)
{
	if (!*a)
		return soap_element_null(soap, tag, id, type);
	return soap_out_std__vectorTemplateOf_fimsdescription__entityType_role(soap, tag, id, *a, type);
}

SOAP_FMAC3 std::vector<_fimsdescription__entityType_role >** SOAP_FMAC4 soap_in_PointerTostd__vectorTemplateOf_fimsdescription__entityType_role(struct soap *soap, const char *tag, std::vector<_fimsdescription__entityType_role >**a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	soap_revert(soap);
	if (!a)
	{	if (!(a = (std::vector<_fimsdescription__entityType_role >**)soap_malloc(soap, sizeof(std::vector<_fimsdescription__entityType_role >*))))
			return NULL;
		*a = NULL;
	}
	if (!(*a = soap_in_std__vectorTemplateOf_fimsdescription__entityType_role(soap, tag, *a, type)))
		return NULL;
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTostd__vectorTemplateOf_fimsdescription__entityType_role(struct soap *soap, std::vector<_fimsdescription__entityType_role >*const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTostd__vectorTemplateOf_fimsdescription__entityType_role);
	if (soap_out_PointerTostd__vectorTemplateOf_fimsdescription__entityType_role(soap, tag?tag:"", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::vector<_fimsdescription__entityType_role >** SOAP_FMAC4 soap_get_PointerTostd__vectorTemplateOf_fimsdescription__entityType_role(struct soap *soap, std::vector<_fimsdescription__entityType_role >**p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTostd__vectorTemplateOf_fimsdescription__entityType_role(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTofimsdescription__organisationDetailsType(struct soap *soap, fimsdescription__organisationDetailsType *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_fimsdescription__organisationDetailsType))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTofimsdescription__organisationDetailsType(struct soap *soap, const char *tag, int id, fimsdescription__organisationDetailsType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_fimsdescription__organisationDetailsType);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 fimsdescription__organisationDetailsType ** SOAP_FMAC4 soap_in_PointerTofimsdescription__organisationDetailsType(struct soap *soap, const char *tag, fimsdescription__organisationDetailsType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (fimsdescription__organisationDetailsType **)soap_malloc(soap, sizeof(fimsdescription__organisationDetailsType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (fimsdescription__organisationDetailsType *)soap_instantiate_fimsdescription__organisationDetailsType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	fimsdescription__organisationDetailsType ** p = (fimsdescription__organisationDetailsType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_fimsdescription__organisationDetailsType, sizeof(fimsdescription__organisationDetailsType), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTofimsdescription__organisationDetailsType(struct soap *soap, fimsdescription__organisationDetailsType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTofimsdescription__organisationDetailsType);
	if (soap_out_PointerTofimsdescription__organisationDetailsType(soap, tag?tag:"fimsdescription:organisationDetailsType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 fimsdescription__organisationDetailsType ** SOAP_FMAC4 soap_get_PointerTofimsdescription__organisationDetailsType(struct soap *soap, fimsdescription__organisationDetailsType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTofimsdescription__organisationDetailsType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_fimsdescription__dateType_alternative(struct soap *soap, _fimsdescription__dateType_alternative *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__fimsdescription__dateType_alternative))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_fimsdescription__dateType_alternative(struct soap *soap, const char *tag, int id, _fimsdescription__dateType_alternative *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__fimsdescription__dateType_alternative);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _fimsdescription__dateType_alternative ** SOAP_FMAC4 soap_in_PointerTo_fimsdescription__dateType_alternative(struct soap *soap, const char *tag, _fimsdescription__dateType_alternative **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_fimsdescription__dateType_alternative **)soap_malloc(soap, sizeof(_fimsdescription__dateType_alternative *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_fimsdescription__dateType_alternative *)soap_instantiate__fimsdescription__dateType_alternative(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_fimsdescription__dateType_alternative ** p = (_fimsdescription__dateType_alternative **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__fimsdescription__dateType_alternative, sizeof(_fimsdescription__dateType_alternative), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_fimsdescription__dateType_alternative(struct soap *soap, _fimsdescription__dateType_alternative *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_fimsdescription__dateType_alternative);
	if (soap_out_PointerTo_fimsdescription__dateType_alternative(soap, tag?tag:"fimsdescription:dateType-alternative", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _fimsdescription__dateType_alternative ** SOAP_FMAC4 soap_get_PointerTo_fimsdescription__dateType_alternative(struct soap *soap, _fimsdescription__dateType_alternative **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_fimsdescription__dateType_alternative(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_fimsdescription__dateType_issued(struct soap *soap, _fimsdescription__dateType_issued *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__fimsdescription__dateType_issued))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_fimsdescription__dateType_issued(struct soap *soap, const char *tag, int id, _fimsdescription__dateType_issued *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__fimsdescription__dateType_issued);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _fimsdescription__dateType_issued ** SOAP_FMAC4 soap_in_PointerTo_fimsdescription__dateType_issued(struct soap *soap, const char *tag, _fimsdescription__dateType_issued **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_fimsdescription__dateType_issued **)soap_malloc(soap, sizeof(_fimsdescription__dateType_issued *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_fimsdescription__dateType_issued *)soap_instantiate__fimsdescription__dateType_issued(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_fimsdescription__dateType_issued ** p = (_fimsdescription__dateType_issued **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__fimsdescription__dateType_issued, sizeof(_fimsdescription__dateType_issued), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_fimsdescription__dateType_issued(struct soap *soap, _fimsdescription__dateType_issued *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_fimsdescription__dateType_issued);
	if (soap_out_PointerTo_fimsdescription__dateType_issued(soap, tag?tag:"fimsdescription:dateType-issued", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _fimsdescription__dateType_issued ** SOAP_FMAC4 soap_get_PointerTo_fimsdescription__dateType_issued(struct soap *soap, _fimsdescription__dateType_issued **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_fimsdescription__dateType_issued(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_fimsdescription__dateType_modified(struct soap *soap, _fimsdescription__dateType_modified *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__fimsdescription__dateType_modified))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_fimsdescription__dateType_modified(struct soap *soap, const char *tag, int id, _fimsdescription__dateType_modified *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__fimsdescription__dateType_modified);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _fimsdescription__dateType_modified ** SOAP_FMAC4 soap_in_PointerTo_fimsdescription__dateType_modified(struct soap *soap, const char *tag, _fimsdescription__dateType_modified **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_fimsdescription__dateType_modified **)soap_malloc(soap, sizeof(_fimsdescription__dateType_modified *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_fimsdescription__dateType_modified *)soap_instantiate__fimsdescription__dateType_modified(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_fimsdescription__dateType_modified ** p = (_fimsdescription__dateType_modified **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__fimsdescription__dateType_modified, sizeof(_fimsdescription__dateType_modified), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_fimsdescription__dateType_modified(struct soap *soap, _fimsdescription__dateType_modified *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_fimsdescription__dateType_modified);
	if (soap_out_PointerTo_fimsdescription__dateType_modified(soap, tag?tag:"fimsdescription:dateType-modified", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _fimsdescription__dateType_modified ** SOAP_FMAC4 soap_get_PointerTo_fimsdescription__dateType_modified(struct soap *soap, _fimsdescription__dateType_modified **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_fimsdescription__dateType_modified(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_fimsdescription__dateType_created(struct soap *soap, _fimsdescription__dateType_created *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__fimsdescription__dateType_created))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_fimsdescription__dateType_created(struct soap *soap, const char *tag, int id, _fimsdescription__dateType_created *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__fimsdescription__dateType_created);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _fimsdescription__dateType_created ** SOAP_FMAC4 soap_in_PointerTo_fimsdescription__dateType_created(struct soap *soap, const char *tag, _fimsdescription__dateType_created **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_fimsdescription__dateType_created **)soap_malloc(soap, sizeof(_fimsdescription__dateType_created *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_fimsdescription__dateType_created *)soap_instantiate__fimsdescription__dateType_created(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_fimsdescription__dateType_created ** p = (_fimsdescription__dateType_created **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__fimsdescription__dateType_created, sizeof(_fimsdescription__dateType_created), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_fimsdescription__dateType_created(struct soap *soap, _fimsdescription__dateType_created *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_fimsdescription__dateType_created);
	if (soap_out_PointerTo_fimsdescription__dateType_created(soap, tag?tag:"fimsdescription:dateType-created", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _fimsdescription__dateType_created ** SOAP_FMAC4 soap_get_PointerTo_fimsdescription__dateType_created(struct soap *soap, _fimsdescription__dateType_created **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_fimsdescription__dateType_created(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToxsd__date(struct soap *soap, std::wstring *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_xsd__date))
		soap_serialize_xsd__date(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToxsd__date(struct soap *soap, const char *tag, int id, std::wstring *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_xsd__date);
	if (id < 0)
		return soap->error;
	return soap_out_xsd__date(soap, tag, id, *a, type);
}

SOAP_FMAC3 std::wstring ** SOAP_FMAC4 soap_in_PointerToxsd__date(struct soap *soap, const char *tag, std::wstring **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (std::wstring **)soap_malloc(soap, sizeof(std::wstring *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_xsd__date(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (std::wstring **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_xsd__date, sizeof(std::wstring), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToxsd__date(struct soap *soap, std::wstring *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToxsd__date);
	if (soap_out_PointerToxsd__date(soap, tag?tag:"xsd:date", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::wstring ** SOAP_FMAC4 soap_get_PointerToxsd__date(struct soap *soap, std::wstring **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToxsd__date(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToxsd__gYear(struct soap *soap, std::wstring *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_xsd__gYear))
		soap_serialize_xsd__gYear(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToxsd__gYear(struct soap *soap, const char *tag, int id, std::wstring *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_xsd__gYear);
	if (id < 0)
		return soap->error;
	return soap_out_xsd__gYear(soap, tag, id, *a, type);
}

SOAP_FMAC3 std::wstring ** SOAP_FMAC4 soap_in_PointerToxsd__gYear(struct soap *soap, const char *tag, std::wstring **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (std::wstring **)soap_malloc(soap, sizeof(std::wstring *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_xsd__gYear(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (std::wstring **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_xsd__gYear, sizeof(std::wstring), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToxsd__gYear(struct soap *soap, std::wstring *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToxsd__gYear);
	if (soap_out_PointerToxsd__gYear(soap, tag?tag:"xsd:gYear", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::wstring ** SOAP_FMAC4 soap_get_PointerToxsd__gYear(struct soap *soap, std::wstring **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToxsd__gYear(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTofimsdescription__contactDetailsType(struct soap *soap, fimsdescription__contactDetailsType *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_fimsdescription__contactDetailsType))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTofimsdescription__contactDetailsType(struct soap *soap, const char *tag, int id, fimsdescription__contactDetailsType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_fimsdescription__contactDetailsType);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 fimsdescription__contactDetailsType ** SOAP_FMAC4 soap_in_PointerTofimsdescription__contactDetailsType(struct soap *soap, const char *tag, fimsdescription__contactDetailsType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (fimsdescription__contactDetailsType **)soap_malloc(soap, sizeof(fimsdescription__contactDetailsType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (fimsdescription__contactDetailsType *)soap_instantiate_fimsdescription__contactDetailsType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	fimsdescription__contactDetailsType ** p = (fimsdescription__contactDetailsType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_fimsdescription__contactDetailsType, sizeof(fimsdescription__contactDetailsType), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTofimsdescription__contactDetailsType(struct soap *soap, fimsdescription__contactDetailsType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTofimsdescription__contactDetailsType);
	if (soap_out_PointerTofimsdescription__contactDetailsType(soap, tag?tag:"fimsdescription:contactDetailsType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 fimsdescription__contactDetailsType ** SOAP_FMAC4 soap_get_PointerTofimsdescription__contactDetailsType(struct soap *soap, fimsdescription__contactDetailsType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTofimsdescription__contactDetailsType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_fimsdescription__coverageType_spatial(struct soap *soap, _fimsdescription__coverageType_spatial *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__fimsdescription__coverageType_spatial))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_fimsdescription__coverageType_spatial(struct soap *soap, const char *tag, int id, _fimsdescription__coverageType_spatial *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__fimsdescription__coverageType_spatial);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _fimsdescription__coverageType_spatial ** SOAP_FMAC4 soap_in_PointerTo_fimsdescription__coverageType_spatial(struct soap *soap, const char *tag, _fimsdescription__coverageType_spatial **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_fimsdescription__coverageType_spatial **)soap_malloc(soap, sizeof(_fimsdescription__coverageType_spatial *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_fimsdescription__coverageType_spatial *)soap_instantiate__fimsdescription__coverageType_spatial(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_fimsdescription__coverageType_spatial ** p = (_fimsdescription__coverageType_spatial **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__fimsdescription__coverageType_spatial, sizeof(_fimsdescription__coverageType_spatial), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_fimsdescription__coverageType_spatial(struct soap *soap, _fimsdescription__coverageType_spatial *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_fimsdescription__coverageType_spatial);
	if (soap_out_PointerTo_fimsdescription__coverageType_spatial(soap, tag?tag:"fimsdescription:coverageType-spatial", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _fimsdescription__coverageType_spatial ** SOAP_FMAC4 soap_get_PointerTo_fimsdescription__coverageType_spatial(struct soap *soap, _fimsdescription__coverageType_spatial **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_fimsdescription__coverageType_spatial(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_fimsdescription__coverageType_spatial_coordinates(struct soap *soap, _fimsdescription__coverageType_spatial_coordinates *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__fimsdescription__coverageType_spatial_coordinates))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_fimsdescription__coverageType_spatial_coordinates(struct soap *soap, const char *tag, int id, _fimsdescription__coverageType_spatial_coordinates *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__fimsdescription__coverageType_spatial_coordinates);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _fimsdescription__coverageType_spatial_coordinates ** SOAP_FMAC4 soap_in_PointerTo_fimsdescription__coverageType_spatial_coordinates(struct soap *soap, const char *tag, _fimsdescription__coverageType_spatial_coordinates **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_fimsdescription__coverageType_spatial_coordinates **)soap_malloc(soap, sizeof(_fimsdescription__coverageType_spatial_coordinates *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_fimsdescription__coverageType_spatial_coordinates *)soap_instantiate__fimsdescription__coverageType_spatial_coordinates(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_fimsdescription__coverageType_spatial_coordinates ** p = (_fimsdescription__coverageType_spatial_coordinates **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__fimsdescription__coverageType_spatial_coordinates, sizeof(_fimsdescription__coverageType_spatial_coordinates), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_fimsdescription__coverageType_spatial_coordinates(struct soap *soap, _fimsdescription__coverageType_spatial_coordinates *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_fimsdescription__coverageType_spatial_coordinates);
	if (soap_out_PointerTo_fimsdescription__coverageType_spatial_coordinates(soap, tag?tag:"fimsdescription:coverageType-spatial-coordinates", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _fimsdescription__coverageType_spatial_coordinates ** SOAP_FMAC4 soap_get_PointerTo_fimsdescription__coverageType_spatial_coordinates(struct soap *soap, _fimsdescription__coverageType_spatial_coordinates **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_fimsdescription__coverageType_spatial_coordinates(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_fimsdescription__coverageType_temporal(struct soap *soap, _fimsdescription__coverageType_temporal *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__fimsdescription__coverageType_temporal))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_fimsdescription__coverageType_temporal(struct soap *soap, const char *tag, int id, _fimsdescription__coverageType_temporal *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__fimsdescription__coverageType_temporal);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _fimsdescription__coverageType_temporal ** SOAP_FMAC4 soap_in_PointerTo_fimsdescription__coverageType_temporal(struct soap *soap, const char *tag, _fimsdescription__coverageType_temporal **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_fimsdescription__coverageType_temporal **)soap_malloc(soap, sizeof(_fimsdescription__coverageType_temporal *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_fimsdescription__coverageType_temporal *)soap_instantiate__fimsdescription__coverageType_temporal(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_fimsdescription__coverageType_temporal ** p = (_fimsdescription__coverageType_temporal **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__fimsdescription__coverageType_temporal, sizeof(_fimsdescription__coverageType_temporal), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_fimsdescription__coverageType_temporal(struct soap *soap, _fimsdescription__coverageType_temporal *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_fimsdescription__coverageType_temporal);
	if (soap_out_PointerTo_fimsdescription__coverageType_temporal(soap, tag?tag:"fimsdescription:coverageType-temporal", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _fimsdescription__coverageType_temporal ** SOAP_FMAC4 soap_get_PointerTo_fimsdescription__coverageType_temporal(struct soap *soap, _fimsdescription__coverageType_temporal **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_fimsdescription__coverageType_temporal(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTostd__vectorTemplateOf_fimsdescription__typeType_targetAudience(struct soap *soap, std::vector<_fimsdescription__typeType_targetAudience >*const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_std__vectorTemplateOf_fimsdescription__typeType_targetAudience))
		soap_serialize_std__vectorTemplateOf_fimsdescription__typeType_targetAudience(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTostd__vectorTemplateOf_fimsdescription__typeType_targetAudience(struct soap *soap, const char *tag, int id, std::vector<_fimsdescription__typeType_targetAudience >*const*a, const char *type)
{
	if (!*a)
		return soap_element_null(soap, tag, id, type);
	return soap_out_std__vectorTemplateOf_fimsdescription__typeType_targetAudience(soap, tag, id, *a, type);
}

SOAP_FMAC3 std::vector<_fimsdescription__typeType_targetAudience >** SOAP_FMAC4 soap_in_PointerTostd__vectorTemplateOf_fimsdescription__typeType_targetAudience(struct soap *soap, const char *tag, std::vector<_fimsdescription__typeType_targetAudience >**a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	soap_revert(soap);
	if (!a)
	{	if (!(a = (std::vector<_fimsdescription__typeType_targetAudience >**)soap_malloc(soap, sizeof(std::vector<_fimsdescription__typeType_targetAudience >*))))
			return NULL;
		*a = NULL;
	}
	if (!(*a = soap_in_std__vectorTemplateOf_fimsdescription__typeType_targetAudience(soap, tag, *a, type)))
		return NULL;
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTostd__vectorTemplateOf_fimsdescription__typeType_targetAudience(struct soap *soap, std::vector<_fimsdescription__typeType_targetAudience >*const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTostd__vectorTemplateOf_fimsdescription__typeType_targetAudience);
	if (soap_out_PointerTostd__vectorTemplateOf_fimsdescription__typeType_targetAudience(soap, tag?tag:"", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::vector<_fimsdescription__typeType_targetAudience >** SOAP_FMAC4 soap_get_PointerTostd__vectorTemplateOf_fimsdescription__typeType_targetAudience(struct soap *soap, std::vector<_fimsdescription__typeType_targetAudience >**p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTostd__vectorTemplateOf_fimsdescription__typeType_targetAudience(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTostd__vectorTemplateOf_fimsdescription__typeType_objectType(struct soap *soap, std::vector<_fimsdescription__typeType_objectType >*const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_std__vectorTemplateOf_fimsdescription__typeType_objectType))
		soap_serialize_std__vectorTemplateOf_fimsdescription__typeType_objectType(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTostd__vectorTemplateOf_fimsdescription__typeType_objectType(struct soap *soap, const char *tag, int id, std::vector<_fimsdescription__typeType_objectType >*const*a, const char *type)
{
	if (!*a)
		return soap_element_null(soap, tag, id, type);
	return soap_out_std__vectorTemplateOf_fimsdescription__typeType_objectType(soap, tag, id, *a, type);
}

SOAP_FMAC3 std::vector<_fimsdescription__typeType_objectType >** SOAP_FMAC4 soap_in_PointerTostd__vectorTemplateOf_fimsdescription__typeType_objectType(struct soap *soap, const char *tag, std::vector<_fimsdescription__typeType_objectType >**a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	soap_revert(soap);
	if (!a)
	{	if (!(a = (std::vector<_fimsdescription__typeType_objectType >**)soap_malloc(soap, sizeof(std::vector<_fimsdescription__typeType_objectType >*))))
			return NULL;
		*a = NULL;
	}
	if (!(*a = soap_in_std__vectorTemplateOf_fimsdescription__typeType_objectType(soap, tag, *a, type)))
		return NULL;
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTostd__vectorTemplateOf_fimsdescription__typeType_objectType(struct soap *soap, std::vector<_fimsdescription__typeType_objectType >*const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTostd__vectorTemplateOf_fimsdescription__typeType_objectType);
	if (soap_out_PointerTostd__vectorTemplateOf_fimsdescription__typeType_objectType(soap, tag?tag:"", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::vector<_fimsdescription__typeType_objectType >** SOAP_FMAC4 soap_get_PointerTostd__vectorTemplateOf_fimsdescription__typeType_objectType(struct soap *soap, std::vector<_fimsdescription__typeType_objectType >**p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTostd__vectorTemplateOf_fimsdescription__typeType_objectType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTostd__vectorTemplateOf_fimsdescription__typeType_genre(struct soap *soap, std::vector<_fimsdescription__typeType_genre >*const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_std__vectorTemplateOf_fimsdescription__typeType_genre))
		soap_serialize_std__vectorTemplateOf_fimsdescription__typeType_genre(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTostd__vectorTemplateOf_fimsdescription__typeType_genre(struct soap *soap, const char *tag, int id, std::vector<_fimsdescription__typeType_genre >*const*a, const char *type)
{
	if (!*a)
		return soap_element_null(soap, tag, id, type);
	return soap_out_std__vectorTemplateOf_fimsdescription__typeType_genre(soap, tag, id, *a, type);
}

SOAP_FMAC3 std::vector<_fimsdescription__typeType_genre >** SOAP_FMAC4 soap_in_PointerTostd__vectorTemplateOf_fimsdescription__typeType_genre(struct soap *soap, const char *tag, std::vector<_fimsdescription__typeType_genre >**a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	soap_revert(soap);
	if (!a)
	{	if (!(a = (std::vector<_fimsdescription__typeType_genre >**)soap_malloc(soap, sizeof(std::vector<_fimsdescription__typeType_genre >*))))
			return NULL;
		*a = NULL;
	}
	if (!(*a = soap_in_std__vectorTemplateOf_fimsdescription__typeType_genre(soap, tag, *a, type)))
		return NULL;
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTostd__vectorTemplateOf_fimsdescription__typeType_genre(struct soap *soap, std::vector<_fimsdescription__typeType_genre >*const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTostd__vectorTemplateOf_fimsdescription__typeType_genre);
	if (soap_out_PointerTostd__vectorTemplateOf_fimsdescription__typeType_genre(soap, tag?tag:"", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::vector<_fimsdescription__typeType_genre >** SOAP_FMAC4 soap_get_PointerTostd__vectorTemplateOf_fimsdescription__typeType_genre(struct soap *soap, std::vector<_fimsdescription__typeType_genre >**p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTostd__vectorTemplateOf_fimsdescription__typeType_genre(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_xml__lang(struct soap *soap, std::wstring *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__xml__lang))
		soap_serialize__xml__lang(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_xml__lang(struct soap *soap, const char *tag, int id, std::wstring *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__xml__lang);
	if (id < 0)
		return soap->error;
	return soap_out__xml__lang(soap, tag, id, *a, type);
}

SOAP_FMAC3 std::wstring ** SOAP_FMAC4 soap_in_PointerTo_xml__lang(struct soap *soap, const char *tag, std::wstring **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (std::wstring **)soap_malloc(soap, sizeof(std::wstring *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__xml__lang(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (std::wstring **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__xml__lang, sizeof(std::wstring), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_xml__lang(struct soap *soap, std::wstring *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_xml__lang);
	if (soap_out_PointerTo_xml__lang(soap, tag?tag:"xml:lang", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::wstring ** SOAP_FMAC4 soap_get_PointerTo_xml__lang(struct soap *soap, std::wstring **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_xml__lang(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTofimsdescription__partType(struct soap *soap, fimsdescription__partType *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_fimsdescription__partType))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTofimsdescription__partType(struct soap *soap, const char *tag, int id, fimsdescription__partType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_fimsdescription__partType);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 fimsdescription__partType ** SOAP_FMAC4 soap_in_PointerTofimsdescription__partType(struct soap *soap, const char *tag, fimsdescription__partType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (fimsdescription__partType **)soap_malloc(soap, sizeof(fimsdescription__partType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (fimsdescription__partType *)soap_instantiate_fimsdescription__partType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	fimsdescription__partType ** p = (fimsdescription__partType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_fimsdescription__partType, sizeof(fimsdescription__partType), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTofimsdescription__partType(struct soap *soap, fimsdescription__partType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTofimsdescription__partType);
	if (soap_out_PointerTofimsdescription__partType(soap, tag?tag:"fimsdescription:partType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 fimsdescription__partType ** SOAP_FMAC4 soap_get_PointerTofimsdescription__partType(struct soap *soap, fimsdescription__partType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTofimsdescription__partType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTofimsdescription__rightsType(struct soap *soap, fimsdescription__rightsType *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_fimsdescription__rightsType))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTofimsdescription__rightsType(struct soap *soap, const char *tag, int id, fimsdescription__rightsType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_fimsdescription__rightsType);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 fimsdescription__rightsType ** SOAP_FMAC4 soap_in_PointerTofimsdescription__rightsType(struct soap *soap, const char *tag, fimsdescription__rightsType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (fimsdescription__rightsType **)soap_malloc(soap, sizeof(fimsdescription__rightsType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (fimsdescription__rightsType *)soap_instantiate_fimsdescription__rightsType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	fimsdescription__rightsType ** p = (fimsdescription__rightsType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_fimsdescription__rightsType, sizeof(fimsdescription__rightsType), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTofimsdescription__rightsType(struct soap *soap, fimsdescription__rightsType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTofimsdescription__rightsType);
	if (soap_out_PointerTofimsdescription__rightsType(soap, tag?tag:"fimsdescription:rightsType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 fimsdescription__rightsType ** SOAP_FMAC4 soap_get_PointerTofimsdescription__rightsType(struct soap *soap, fimsdescription__rightsType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTofimsdescription__rightsType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTofimsdescription__coverageType(struct soap *soap, fimsdescription__coverageType *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_fimsdescription__coverageType))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTofimsdescription__coverageType(struct soap *soap, const char *tag, int id, fimsdescription__coverageType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_fimsdescription__coverageType);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 fimsdescription__coverageType ** SOAP_FMAC4 soap_in_PointerTofimsdescription__coverageType(struct soap *soap, const char *tag, fimsdescription__coverageType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (fimsdescription__coverageType **)soap_malloc(soap, sizeof(fimsdescription__coverageType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (fimsdescription__coverageType *)soap_instantiate_fimsdescription__coverageType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	fimsdescription__coverageType ** p = (fimsdescription__coverageType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_fimsdescription__coverageType, sizeof(fimsdescription__coverageType), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTofimsdescription__coverageType(struct soap *soap, fimsdescription__coverageType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTofimsdescription__coverageType);
	if (soap_out_PointerTofimsdescription__coverageType(soap, tag?tag:"fimsdescription:coverageType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 fimsdescription__coverageType ** SOAP_FMAC4 soap_get_PointerTofimsdescription__coverageType(struct soap *soap, fimsdescription__coverageType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTofimsdescription__coverageType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTofimsdescription__relationType(struct soap *soap, fimsdescription__relationType *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_fimsdescription__relationType))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTofimsdescription__relationType(struct soap *soap, const char *tag, int id, fimsdescription__relationType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_fimsdescription__relationType);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 fimsdescription__relationType ** SOAP_FMAC4 soap_in_PointerTofimsdescription__relationType(struct soap *soap, const char *tag, fimsdescription__relationType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (fimsdescription__relationType **)soap_malloc(soap, sizeof(fimsdescription__relationType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (fimsdescription__relationType *)soap_instantiate_fimsdescription__relationType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	fimsdescription__relationType ** p = (fimsdescription__relationType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_fimsdescription__relationType, sizeof(fimsdescription__relationType), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTofimsdescription__relationType(struct soap *soap, fimsdescription__relationType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTofimsdescription__relationType);
	if (soap_out_PointerTofimsdescription__relationType(soap, tag?tag:"fimsdescription:relationType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 fimsdescription__relationType ** SOAP_FMAC4 soap_get_PointerTofimsdescription__relationType(struct soap *soap, fimsdescription__relationType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTofimsdescription__relationType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTofimsdescription__languageType(struct soap *soap, fimsdescription__languageType *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_fimsdescription__languageType))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTofimsdescription__languageType(struct soap *soap, const char *tag, int id, fimsdescription__languageType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_fimsdescription__languageType);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 fimsdescription__languageType ** SOAP_FMAC4 soap_in_PointerTofimsdescription__languageType(struct soap *soap, const char *tag, fimsdescription__languageType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (fimsdescription__languageType **)soap_malloc(soap, sizeof(fimsdescription__languageType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (fimsdescription__languageType *)soap_instantiate_fimsdescription__languageType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	fimsdescription__languageType ** p = (fimsdescription__languageType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_fimsdescription__languageType, sizeof(fimsdescription__languageType), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTofimsdescription__languageType(struct soap *soap, fimsdescription__languageType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTofimsdescription__languageType);
	if (soap_out_PointerTofimsdescription__languageType(soap, tag?tag:"fimsdescription:languageType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 fimsdescription__languageType ** SOAP_FMAC4 soap_get_PointerTofimsdescription__languageType(struct soap *soap, fimsdescription__languageType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTofimsdescription__languageType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTofimsdescription__identifierType(struct soap *soap, fimsdescription__identifierType *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_fimsdescription__identifierType))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTofimsdescription__identifierType(struct soap *soap, const char *tag, int id, fimsdescription__identifierType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_fimsdescription__identifierType);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 fimsdescription__identifierType ** SOAP_FMAC4 soap_in_PointerTofimsdescription__identifierType(struct soap *soap, const char *tag, fimsdescription__identifierType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (fimsdescription__identifierType **)soap_malloc(soap, sizeof(fimsdescription__identifierType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (fimsdescription__identifierType *)soap_instantiate_fimsdescription__identifierType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	fimsdescription__identifierType ** p = (fimsdescription__identifierType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_fimsdescription__identifierType, sizeof(fimsdescription__identifierType), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTofimsdescription__identifierType(struct soap *soap, fimsdescription__identifierType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTofimsdescription__identifierType);
	if (soap_out_PointerTofimsdescription__identifierType(soap, tag?tag:"fimsdescription:identifierType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 fimsdescription__identifierType ** SOAP_FMAC4 soap_get_PointerTofimsdescription__identifierType(struct soap *soap, fimsdescription__identifierType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTofimsdescription__identifierType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTofimsdescription__typeType(struct soap *soap, fimsdescription__typeType *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_fimsdescription__typeType))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTofimsdescription__typeType(struct soap *soap, const char *tag, int id, fimsdescription__typeType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_fimsdescription__typeType);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 fimsdescription__typeType ** SOAP_FMAC4 soap_in_PointerTofimsdescription__typeType(struct soap *soap, const char *tag, fimsdescription__typeType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (fimsdescription__typeType **)soap_malloc(soap, sizeof(fimsdescription__typeType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (fimsdescription__typeType *)soap_instantiate_fimsdescription__typeType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	fimsdescription__typeType ** p = (fimsdescription__typeType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_fimsdescription__typeType, sizeof(fimsdescription__typeType), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTofimsdescription__typeType(struct soap *soap, fimsdescription__typeType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTofimsdescription__typeType);
	if (soap_out_PointerTofimsdescription__typeType(soap, tag?tag:"fimsdescription:typeType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 fimsdescription__typeType ** SOAP_FMAC4 soap_get_PointerTofimsdescription__typeType(struct soap *soap, fimsdescription__typeType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTofimsdescription__typeType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTofimsdescription__dateType(struct soap *soap, fimsdescription__dateType *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_fimsdescription__dateType))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTofimsdescription__dateType(struct soap *soap, const char *tag, int id, fimsdescription__dateType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_fimsdescription__dateType);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 fimsdescription__dateType ** SOAP_FMAC4 soap_in_PointerTofimsdescription__dateType(struct soap *soap, const char *tag, fimsdescription__dateType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (fimsdescription__dateType **)soap_malloc(soap, sizeof(fimsdescription__dateType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (fimsdescription__dateType *)soap_instantiate_fimsdescription__dateType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	fimsdescription__dateType ** p = (fimsdescription__dateType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_fimsdescription__dateType, sizeof(fimsdescription__dateType), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTofimsdescription__dateType(struct soap *soap, fimsdescription__dateType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTofimsdescription__dateType);
	if (soap_out_PointerTofimsdescription__dateType(soap, tag?tag:"fimsdescription:dateType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 fimsdescription__dateType ** SOAP_FMAC4 soap_get_PointerTofimsdescription__dateType(struct soap *soap, fimsdescription__dateType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTofimsdescription__dateType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTofimsdescription__descriptionType(struct soap *soap, fimsdescription__descriptionType *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_fimsdescription__descriptionType))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTofimsdescription__descriptionType(struct soap *soap, const char *tag, int id, fimsdescription__descriptionType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_fimsdescription__descriptionType);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 fimsdescription__descriptionType ** SOAP_FMAC4 soap_in_PointerTofimsdescription__descriptionType(struct soap *soap, const char *tag, fimsdescription__descriptionType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (fimsdescription__descriptionType **)soap_malloc(soap, sizeof(fimsdescription__descriptionType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (fimsdescription__descriptionType *)soap_instantiate_fimsdescription__descriptionType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	fimsdescription__descriptionType ** p = (fimsdescription__descriptionType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_fimsdescription__descriptionType, sizeof(fimsdescription__descriptionType), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTofimsdescription__descriptionType(struct soap *soap, fimsdescription__descriptionType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTofimsdescription__descriptionType);
	if (soap_out_PointerTofimsdescription__descriptionType(soap, tag?tag:"fimsdescription:descriptionType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 fimsdescription__descriptionType ** SOAP_FMAC4 soap_get_PointerTofimsdescription__descriptionType(struct soap *soap, fimsdescription__descriptionType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTofimsdescription__descriptionType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTofimsdescription__subjectType(struct soap *soap, fimsdescription__subjectType *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_fimsdescription__subjectType))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTofimsdescription__subjectType(struct soap *soap, const char *tag, int id, fimsdescription__subjectType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_fimsdescription__subjectType);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 fimsdescription__subjectType ** SOAP_FMAC4 soap_in_PointerTofimsdescription__subjectType(struct soap *soap, const char *tag, fimsdescription__subjectType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (fimsdescription__subjectType **)soap_malloc(soap, sizeof(fimsdescription__subjectType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (fimsdescription__subjectType *)soap_instantiate_fimsdescription__subjectType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	fimsdescription__subjectType ** p = (fimsdescription__subjectType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_fimsdescription__subjectType, sizeof(fimsdescription__subjectType), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTofimsdescription__subjectType(struct soap *soap, fimsdescription__subjectType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTofimsdescription__subjectType);
	if (soap_out_PointerTofimsdescription__subjectType(soap, tag?tag:"fimsdescription:subjectType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 fimsdescription__subjectType ** SOAP_FMAC4 soap_get_PointerTofimsdescription__subjectType(struct soap *soap, fimsdescription__subjectType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTofimsdescription__subjectType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTofimsdescription__entityType(struct soap *soap, fimsdescription__entityType *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_fimsdescription__entityType))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTofimsdescription__entityType(struct soap *soap, const char *tag, int id, fimsdescription__entityType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_fimsdescription__entityType);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 fimsdescription__entityType ** SOAP_FMAC4 soap_in_PointerTofimsdescription__entityType(struct soap *soap, const char *tag, fimsdescription__entityType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (fimsdescription__entityType **)soap_malloc(soap, sizeof(fimsdescription__entityType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (fimsdescription__entityType *)soap_instantiate_fimsdescription__entityType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	fimsdescription__entityType ** p = (fimsdescription__entityType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_fimsdescription__entityType, sizeof(fimsdescription__entityType), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTofimsdescription__entityType(struct soap *soap, fimsdescription__entityType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTofimsdescription__entityType);
	if (soap_out_PointerTofimsdescription__entityType(soap, tag?tag:"fimsdescription:entityType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 fimsdescription__entityType ** SOAP_FMAC4 soap_get_PointerTofimsdescription__entityType(struct soap *soap, fimsdescription__entityType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTofimsdescription__entityType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTofimsdescription__titleType(struct soap *soap, fimsdescription__titleType *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_fimsdescription__titleType))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTofimsdescription__titleType(struct soap *soap, const char *tag, int id, fimsdescription__titleType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_fimsdescription__titleType);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 fimsdescription__titleType ** SOAP_FMAC4 soap_in_PointerTofimsdescription__titleType(struct soap *soap, const char *tag, fimsdescription__titleType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (fimsdescription__titleType **)soap_malloc(soap, sizeof(fimsdescription__titleType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (fimsdescription__titleType *)soap_instantiate_fimsdescription__titleType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	fimsdescription__titleType ** p = (fimsdescription__titleType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_fimsdescription__titleType, sizeof(fimsdescription__titleType), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTofimsdescription__titleType(struct soap *soap, fimsdescription__titleType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTofimsdescription__titleType);
	if (soap_out_PointerTofimsdescription__titleType(soap, tag?tag:"fimsdescription:titleType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 fimsdescription__titleType ** SOAP_FMAC4 soap_get_PointerTofimsdescription__titleType(struct soap *soap, fimsdescription__titleType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTofimsdescription__titleType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTofimsdescription__textElementType(struct soap *soap, fimsdescription__textElementType *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_fimsdescription__textElementType))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTofimsdescription__textElementType(struct soap *soap, const char *tag, int id, fimsdescription__textElementType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_fimsdescription__textElementType);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 fimsdescription__textElementType ** SOAP_FMAC4 soap_in_PointerTofimsdescription__textElementType(struct soap *soap, const char *tag, fimsdescription__textElementType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (fimsdescription__textElementType **)soap_malloc(soap, sizeof(fimsdescription__textElementType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (fimsdescription__textElementType *)soap_instantiate_fimsdescription__textElementType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	fimsdescription__textElementType ** p = (fimsdescription__textElementType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_fimsdescription__textElementType, sizeof(fimsdescription__textElementType), 0);
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (fimsdescription__textElementType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_fimsdescription__titleType, sizeof(fimsdescription__titleType), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (fimsdescription__textElementType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_fimsdescription__subjectType, sizeof(fimsdescription__subjectType), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (fimsdescription__textElementType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_fimsdescription__descriptionType, sizeof(fimsdescription__descriptionType), 0);
		}
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTofimsdescription__textElementType(struct soap *soap, fimsdescription__textElementType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTofimsdescription__textElementType);
	if (soap_out_PointerTofimsdescription__textElementType(soap, tag?tag:"fimsdescription:textElementType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 fimsdescription__textElementType ** SOAP_FMAC4 soap_get_PointerTofimsdescription__textElementType(struct soap *soap, fimsdescription__textElementType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTofimsdescription__textElementType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToxsd__time(struct soap *soap, std::wstring *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_xsd__time))
		soap_serialize_xsd__time(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToxsd__time(struct soap *soap, const char *tag, int id, std::wstring *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_xsd__time);
	if (id < 0)
		return soap->error;
	return soap_out_xsd__time(soap, tag, id, *a, type);
}

SOAP_FMAC3 std::wstring ** SOAP_FMAC4 soap_in_PointerToxsd__time(struct soap *soap, const char *tag, std::wstring **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (std::wstring **)soap_malloc(soap, sizeof(std::wstring *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_xsd__time(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (std::wstring **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_xsd__time, sizeof(std::wstring), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToxsd__time(struct soap *soap, std::wstring *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToxsd__time);
	if (soap_out_PointerToxsd__time(soap, tag?tag:"xsd:time", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::wstring ** SOAP_FMAC4 soap_get_PointerToxsd__time(struct soap *soap, std::wstring **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToxsd__time(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTofimstime__Timecode(struct soap *soap, std::wstring *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_fimstime__Timecode))
		soap_serialize_fimstime__Timecode(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTofimstime__Timecode(struct soap *soap, const char *tag, int id, std::wstring *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_fimstime__Timecode);
	if (id < 0)
		return soap->error;
	return soap_out_fimstime__Timecode(soap, tag, id, *a, type);
}

SOAP_FMAC3 std::wstring ** SOAP_FMAC4 soap_in_PointerTofimstime__Timecode(struct soap *soap, const char *tag, std::wstring **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (std::wstring **)soap_malloc(soap, sizeof(std::wstring *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_fimstime__Timecode(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (std::wstring **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_fimstime__Timecode, sizeof(std::wstring), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTofimstime__Timecode(struct soap *soap, std::wstring *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTofimstime__Timecode);
	if (soap_out_PointerTofimstime__Timecode(soap, tag?tag:"fimstime:Timecode", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::wstring ** SOAP_FMAC4 soap_get_PointerTofimstime__Timecode(struct soap *soap, std::wstring **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTofimstime__Timecode(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTofimstime__EditUnitNumberType(struct soap *soap, fimstime__EditUnitNumberType *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_fimstime__EditUnitNumberType))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTofimstime__EditUnitNumberType(struct soap *soap, const char *tag, int id, fimstime__EditUnitNumberType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_fimstime__EditUnitNumberType);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 fimstime__EditUnitNumberType ** SOAP_FMAC4 soap_in_PointerTofimstime__EditUnitNumberType(struct soap *soap, const char *tag, fimstime__EditUnitNumberType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (fimstime__EditUnitNumberType **)soap_malloc(soap, sizeof(fimstime__EditUnitNumberType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (fimstime__EditUnitNumberType *)soap_instantiate_fimstime__EditUnitNumberType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	fimstime__EditUnitNumberType ** p = (fimstime__EditUnitNumberType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_fimstime__EditUnitNumberType, sizeof(fimstime__EditUnitNumberType), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTofimstime__EditUnitNumberType(struct soap *soap, fimstime__EditUnitNumberType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTofimstime__EditUnitNumberType);
	if (soap_out_PointerTofimstime__EditUnitNumberType(soap, tag?tag:"fimstime:EditUnitNumberType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 fimstime__EditUnitNumberType ** SOAP_FMAC4 soap_get_PointerTofimstime__EditUnitNumberType(struct soap *soap, fimstime__EditUnitNumberType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTofimstime__EditUnitNumberType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToxsd__duration(struct soap *soap, LONG64 *const*a)
{
#ifndef WITH_NOIDREF
	soap_reference(soap, *a, SOAP_TYPE_xsd__duration);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToxsd__duration(struct soap *soap, const char *tag, int id, LONG64 *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_xsd__duration);
	if (id < 0)
		return soap->error;
	return soap_out_xsd__duration(soap, tag, id, *a, type);
}

SOAP_FMAC3 LONG64 ** SOAP_FMAC4 soap_in_PointerToxsd__duration(struct soap *soap, const char *tag, LONG64 **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (LONG64 **)soap_malloc(soap, sizeof(LONG64 *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_xsd__duration(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (LONG64 **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_xsd__duration, sizeof(LONG64), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToxsd__duration(struct soap *soap, LONG64 *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToxsd__duration);
	if (soap_out_PointerToxsd__duration(soap, tag?tag:"xsd:duration", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 LONG64 ** SOAP_FMAC4 soap_get_PointerToxsd__duration(struct soap *soap, LONG64 **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToxsd__duration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTofimstime__TimecodeDuration(struct soap *soap, std::wstring *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_fimstime__TimecodeDuration))
		soap_serialize_fimstime__TimecodeDuration(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTofimstime__TimecodeDuration(struct soap *soap, const char *tag, int id, std::wstring *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_fimstime__TimecodeDuration);
	if (id < 0)
		return soap->error;
	return soap_out_fimstime__TimecodeDuration(soap, tag, id, *a, type);
}

SOAP_FMAC3 std::wstring ** SOAP_FMAC4 soap_in_PointerTofimstime__TimecodeDuration(struct soap *soap, const char *tag, std::wstring **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (std::wstring **)soap_malloc(soap, sizeof(std::wstring *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_fimstime__TimecodeDuration(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (std::wstring **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_fimstime__TimecodeDuration, sizeof(std::wstring), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTofimstime__TimecodeDuration(struct soap *soap, std::wstring *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTofimstime__TimecodeDuration);
	if (soap_out_PointerTofimstime__TimecodeDuration(soap, tag?tag:"fimstime:TimecodeDuration", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::wstring ** SOAP_FMAC4 soap_get_PointerTofimstime__TimecodeDuration(struct soap *soap, std::wstring **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTofimstime__TimecodeDuration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTofims__SystemPerformanceEventType(struct soap *soap, fims__SystemPerformanceEventType *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_fims__SystemPerformanceEventType))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTofims__SystemPerformanceEventType(struct soap *soap, const char *tag, int id, fims__SystemPerformanceEventType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_fims__SystemPerformanceEventType);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 fims__SystemPerformanceEventType ** SOAP_FMAC4 soap_in_PointerTofims__SystemPerformanceEventType(struct soap *soap, const char *tag, fims__SystemPerformanceEventType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (fims__SystemPerformanceEventType **)soap_malloc(soap, sizeof(fims__SystemPerformanceEventType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (fims__SystemPerformanceEventType *)soap_instantiate_fims__SystemPerformanceEventType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	fims__SystemPerformanceEventType ** p = (fims__SystemPerformanceEventType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_fims__SystemPerformanceEventType, sizeof(fims__SystemPerformanceEventType), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTofims__SystemPerformanceEventType(struct soap *soap, fims__SystemPerformanceEventType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTofims__SystemPerformanceEventType);
	if (soap_out_PointerTofims__SystemPerformanceEventType(soap, tag?tag:"fims:SystemPerformanceEventType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 fims__SystemPerformanceEventType ** SOAP_FMAC4 soap_get_PointerTofims__SystemPerformanceEventType(struct soap *soap, fims__SystemPerformanceEventType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTofims__SystemPerformanceEventType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTofims__SystemExceptionEventType(struct soap *soap, fims__SystemExceptionEventType *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_fims__SystemExceptionEventType))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTofims__SystemExceptionEventType(struct soap *soap, const char *tag, int id, fims__SystemExceptionEventType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_fims__SystemExceptionEventType);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 fims__SystemExceptionEventType ** SOAP_FMAC4 soap_in_PointerTofims__SystemExceptionEventType(struct soap *soap, const char *tag, fims__SystemExceptionEventType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (fims__SystemExceptionEventType **)soap_malloc(soap, sizeof(fims__SystemExceptionEventType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (fims__SystemExceptionEventType *)soap_instantiate_fims__SystemExceptionEventType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	fims__SystemExceptionEventType ** p = (fims__SystemExceptionEventType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_fims__SystemExceptionEventType, sizeof(fims__SystemExceptionEventType), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTofims__SystemExceptionEventType(struct soap *soap, fims__SystemExceptionEventType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTofims__SystemExceptionEventType);
	if (soap_out_PointerTofims__SystemExceptionEventType(soap, tag?tag:"fims:SystemExceptionEventType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 fims__SystemExceptionEventType ** SOAP_FMAC4 soap_get_PointerTofims__SystemExceptionEventType(struct soap *soap, fims__SystemExceptionEventType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTofims__SystemExceptionEventType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTofims__SystemEventType(struct soap *soap, fims__SystemEventType *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_fims__SystemEventType))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTofims__SystemEventType(struct soap *soap, const char *tag, int id, fims__SystemEventType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_fims__SystemEventType);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 fims__SystemEventType ** SOAP_FMAC4 soap_in_PointerTofims__SystemEventType(struct soap *soap, const char *tag, fims__SystemEventType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (fims__SystemEventType **)soap_malloc(soap, sizeof(fims__SystemEventType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (fims__SystemEventType *)soap_instantiate_fims__SystemEventType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	fims__SystemEventType ** p = (fims__SystemEventType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_fims__SystemEventType, sizeof(fims__SystemEventType), 0);
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (fims__SystemEventType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_fims__SystemExceptionEventType, sizeof(fims__SystemExceptionEventType), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (fims__SystemEventType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_fims__SystemPerformanceEventType, sizeof(fims__SystemPerformanceEventType), 0);
		}
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTofims__SystemEventType(struct soap *soap, fims__SystemEventType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTofims__SystemEventType);
	if (soap_out_PointerTofims__SystemEventType(soap, tag?tag:"fims:SystemEventType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 fims__SystemEventType ** SOAP_FMAC4 soap_get_PointerTofims__SystemEventType(struct soap *soap, fims__SystemEventType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTofims__SystemEventType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTofims__ContentCustomEventType(struct soap *soap, fims__ContentCustomEventType *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_fims__ContentCustomEventType))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTofims__ContentCustomEventType(struct soap *soap, const char *tag, int id, fims__ContentCustomEventType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_fims__ContentCustomEventType);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 fims__ContentCustomEventType ** SOAP_FMAC4 soap_in_PointerTofims__ContentCustomEventType(struct soap *soap, const char *tag, fims__ContentCustomEventType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (fims__ContentCustomEventType **)soap_malloc(soap, sizeof(fims__ContentCustomEventType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (fims__ContentCustomEventType *)soap_instantiate_fims__ContentCustomEventType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	fims__ContentCustomEventType ** p = (fims__ContentCustomEventType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_fims__ContentCustomEventType, sizeof(fims__ContentCustomEventType), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTofims__ContentCustomEventType(struct soap *soap, fims__ContentCustomEventType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTofims__ContentCustomEventType);
	if (soap_out_PointerTofims__ContentCustomEventType(soap, tag?tag:"fims:ContentCustomEventType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 fims__ContentCustomEventType ** SOAP_FMAC4 soap_get_PointerTofims__ContentCustomEventType(struct soap *soap, fims__ContentCustomEventType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTofims__ContentCustomEventType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTofims__ContentStatusEventType(struct soap *soap, fims__ContentStatusEventType *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_fims__ContentStatusEventType))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTofims__ContentStatusEventType(struct soap *soap, const char *tag, int id, fims__ContentStatusEventType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_fims__ContentStatusEventType);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 fims__ContentStatusEventType ** SOAP_FMAC4 soap_in_PointerTofims__ContentStatusEventType(struct soap *soap, const char *tag, fims__ContentStatusEventType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (fims__ContentStatusEventType **)soap_malloc(soap, sizeof(fims__ContentStatusEventType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (fims__ContentStatusEventType *)soap_instantiate_fims__ContentStatusEventType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	fims__ContentStatusEventType ** p = (fims__ContentStatusEventType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_fims__ContentStatusEventType, sizeof(fims__ContentStatusEventType), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTofims__ContentStatusEventType(struct soap *soap, fims__ContentStatusEventType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTofims__ContentStatusEventType);
	if (soap_out_PointerTofims__ContentStatusEventType(soap, tag?tag:"fims:ContentStatusEventType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 fims__ContentStatusEventType ** SOAP_FMAC4 soap_get_PointerTofims__ContentStatusEventType(struct soap *soap, fims__ContentStatusEventType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTofims__ContentStatusEventType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTofims__ContentEventType(struct soap *soap, fims__ContentEventType *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_fims__ContentEventType))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTofims__ContentEventType(struct soap *soap, const char *tag, int id, fims__ContentEventType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_fims__ContentEventType);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 fims__ContentEventType ** SOAP_FMAC4 soap_in_PointerTofims__ContentEventType(struct soap *soap, const char *tag, fims__ContentEventType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (fims__ContentEventType **)soap_malloc(soap, sizeof(fims__ContentEventType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (fims__ContentEventType *)soap_instantiate_fims__ContentEventType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	fims__ContentEventType ** p = (fims__ContentEventType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_fims__ContentEventType, sizeof(fims__ContentEventType), 0);
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (fims__ContentEventType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_fims__ContentStatusEventType, sizeof(fims__ContentStatusEventType), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (fims__ContentEventType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_fims__ContentCustomEventType, sizeof(fims__ContentCustomEventType), 0);
		}
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTofims__ContentEventType(struct soap *soap, fims__ContentEventType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTofims__ContentEventType);
	if (soap_out_PointerTofims__ContentEventType(soap, tag?tag:"fims:ContentEventType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 fims__ContentEventType ** SOAP_FMAC4 soap_get_PointerTofims__ContentEventType(struct soap *soap, fims__ContentEventType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTofims__ContentEventType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTofims__EventEnvelopeType(struct soap *soap, fims__EventEnvelopeType *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_fims__EventEnvelopeType))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTofims__EventEnvelopeType(struct soap *soap, const char *tag, int id, fims__EventEnvelopeType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_fims__EventEnvelopeType);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 fims__EventEnvelopeType ** SOAP_FMAC4 soap_in_PointerTofims__EventEnvelopeType(struct soap *soap, const char *tag, fims__EventEnvelopeType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (fims__EventEnvelopeType **)soap_malloc(soap, sizeof(fims__EventEnvelopeType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (fims__EventEnvelopeType *)soap_instantiate_fims__EventEnvelopeType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	fims__EventEnvelopeType ** p = (fims__EventEnvelopeType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_fims__EventEnvelopeType, sizeof(fims__EventEnvelopeType), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTofims__EventEnvelopeType(struct soap *soap, fims__EventEnvelopeType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTofims__EventEnvelopeType);
	if (soap_out_PointerTofims__EventEnvelopeType(soap, tag?tag:"fims:EventEnvelopeType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 fims__EventEnvelopeType ** SOAP_FMAC4 soap_get_PointerTofims__EventEnvelopeType(struct soap *soap, fims__EventEnvelopeType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTofims__EventEnvelopeType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTofims__EventPayloadType(struct soap *soap, fims__EventPayloadType *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_fims__EventPayloadType))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTofims__EventPayloadType(struct soap *soap, const char *tag, int id, fims__EventPayloadType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_fims__EventPayloadType);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 fims__EventPayloadType ** SOAP_FMAC4 soap_in_PointerTofims__EventPayloadType(struct soap *soap, const char *tag, fims__EventPayloadType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (fims__EventPayloadType **)soap_malloc(soap, sizeof(fims__EventPayloadType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (fims__EventPayloadType *)soap_instantiate_fims__EventPayloadType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	fims__EventPayloadType ** p = (fims__EventPayloadType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_fims__EventPayloadType, sizeof(fims__EventPayloadType), 0);
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (fims__EventPayloadType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_fims__ContentEventType, sizeof(fims__ContentEventType), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (fims__EventPayloadType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_fims__SystemEventType, sizeof(fims__SystemEventType), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (fims__EventPayloadType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_fims__ContentStatusEventType, sizeof(fims__ContentStatusEventType), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (fims__EventPayloadType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_fims__ContentCustomEventType, sizeof(fims__ContentCustomEventType), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (fims__EventPayloadType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_fims__SystemExceptionEventType, sizeof(fims__SystemExceptionEventType), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (fims__EventPayloadType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_fims__SystemPerformanceEventType, sizeof(fims__SystemPerformanceEventType), 0);
		}
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTofims__EventPayloadType(struct soap *soap, fims__EventPayloadType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTofims__EventPayloadType);
	if (soap_out_PointerTofims__EventPayloadType(soap, tag?tag:"fims:EventPayloadType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 fims__EventPayloadType ** SOAP_FMAC4 soap_get_PointerTofims__EventPayloadType(struct soap *soap, fims__EventPayloadType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTofims__EventPayloadType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTofims__EventClassificationType(struct soap *soap, enum fims__EventClassificationType *const*a)
{
#ifndef WITH_NOIDREF
	soap_reference(soap, *a, SOAP_TYPE_fims__EventClassificationType);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTofims__EventClassificationType(struct soap *soap, const char *tag, int id, enum fims__EventClassificationType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_fims__EventClassificationType);
	if (id < 0)
		return soap->error;
	return soap_out_fims__EventClassificationType(soap, tag, id, *a, type);
}

SOAP_FMAC3 enum fims__EventClassificationType ** SOAP_FMAC4 soap_in_PointerTofims__EventClassificationType(struct soap *soap, const char *tag, enum fims__EventClassificationType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (enum fims__EventClassificationType **)soap_malloc(soap, sizeof(enum fims__EventClassificationType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_fims__EventClassificationType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (enum fims__EventClassificationType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_fims__EventClassificationType, sizeof(enum fims__EventClassificationType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTofims__EventClassificationType(struct soap *soap, enum fims__EventClassificationType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTofims__EventClassificationType);
	if (soap_out_PointerTofims__EventClassificationType(soap, tag?tag:"fims:EventClassificationType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum fims__EventClassificationType ** SOAP_FMAC4 soap_get_PointerTofims__EventClassificationType(struct soap *soap, enum fims__EventClassificationType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTofims__EventClassificationType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTofims__EventSubType(struct soap *soap, enum fims__EventSubType *const*a)
{
#ifndef WITH_NOIDREF
	soap_reference(soap, *a, SOAP_TYPE_fims__EventSubType);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTofims__EventSubType(struct soap *soap, const char *tag, int id, enum fims__EventSubType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_fims__EventSubType);
	if (id < 0)
		return soap->error;
	return soap_out_fims__EventSubType(soap, tag, id, *a, type);
}

SOAP_FMAC3 enum fims__EventSubType ** SOAP_FMAC4 soap_in_PointerTofims__EventSubType(struct soap *soap, const char *tag, enum fims__EventSubType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (enum fims__EventSubType **)soap_malloc(soap, sizeof(enum fims__EventSubType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_fims__EventSubType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (enum fims__EventSubType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_fims__EventSubType, sizeof(enum fims__EventSubType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTofims__EventSubType(struct soap *soap, enum fims__EventSubType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTofims__EventSubType);
	if (soap_out_PointerTofims__EventSubType(soap, tag?tag:"fims:EventSubType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum fims__EventSubType ** SOAP_FMAC4 soap_get_PointerTofims__EventSubType(struct soap *soap, enum fims__EventSubType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTofims__EventSubType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTofims__EventType(struct soap *soap, enum fims__EventType *const*a)
{
#ifndef WITH_NOIDREF
	soap_reference(soap, *a, SOAP_TYPE_fims__EventType);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTofims__EventType(struct soap *soap, const char *tag, int id, enum fims__EventType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_fims__EventType);
	if (id < 0)
		return soap->error;
	return soap_out_fims__EventType(soap, tag, id, *a, type);
}

SOAP_FMAC3 enum fims__EventType ** SOAP_FMAC4 soap_in_PointerTofims__EventType(struct soap *soap, const char *tag, enum fims__EventType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (enum fims__EventType **)soap_malloc(soap, sizeof(enum fims__EventType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_fims__EventType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (enum fims__EventType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_fims__EventType, sizeof(enum fims__EventType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTofims__EventType(struct soap *soap, enum fims__EventType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTofims__EventType);
	if (soap_out_PointerTofims__EventType(soap, tag?tag:"fims:EventType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum fims__EventType ** SOAP_FMAC4 soap_get_PointerTofims__EventType(struct soap *soap, enum fims__EventType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTofims__EventType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTofims__CustomEventTemplateType(struct soap *soap, fims__CustomEventTemplateType *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_fims__CustomEventTemplateType))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTofims__CustomEventTemplateType(struct soap *soap, const char *tag, int id, fims__CustomEventTemplateType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_fims__CustomEventTemplateType);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 fims__CustomEventTemplateType ** SOAP_FMAC4 soap_in_PointerTofims__CustomEventTemplateType(struct soap *soap, const char *tag, fims__CustomEventTemplateType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (fims__CustomEventTemplateType **)soap_malloc(soap, sizeof(fims__CustomEventTemplateType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (fims__CustomEventTemplateType *)soap_instantiate_fims__CustomEventTemplateType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	fims__CustomEventTemplateType ** p = (fims__CustomEventTemplateType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_fims__CustomEventTemplateType, sizeof(fims__CustomEventTemplateType), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTofims__CustomEventTemplateType(struct soap *soap, fims__CustomEventTemplateType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTofims__CustomEventTemplateType);
	if (soap_out_PointerTofims__CustomEventTemplateType(soap, tag?tag:"fims:CustomEventTemplateType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 fims__CustomEventTemplateType ** SOAP_FMAC4 soap_get_PointerTofims__CustomEventTemplateType(struct soap *soap, fims__CustomEventTemplateType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTofims__CustomEventTemplateType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTofims__QueryExpressionsType(struct soap *soap, fims__QueryExpressionsType *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_fims__QueryExpressionsType))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTofims__QueryExpressionsType(struct soap *soap, const char *tag, int id, fims__QueryExpressionsType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_fims__QueryExpressionsType);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 fims__QueryExpressionsType ** SOAP_FMAC4 soap_in_PointerTofims__QueryExpressionsType(struct soap *soap, const char *tag, fims__QueryExpressionsType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (fims__QueryExpressionsType **)soap_malloc(soap, sizeof(fims__QueryExpressionsType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (fims__QueryExpressionsType *)soap_instantiate_fims__QueryExpressionsType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	fims__QueryExpressionsType ** p = (fims__QueryExpressionsType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_fims__QueryExpressionsType, sizeof(fims__QueryExpressionsType), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTofims__QueryExpressionsType(struct soap *soap, fims__QueryExpressionsType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTofims__QueryExpressionsType);
	if (soap_out_PointerTofims__QueryExpressionsType(soap, tag?tag:"fims:QueryExpressionsType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 fims__QueryExpressionsType ** SOAP_FMAC4 soap_get_PointerTofims__QueryExpressionsType(struct soap *soap, fims__QueryExpressionsType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTofims__QueryExpressionsType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTofims__ResourceIDType(struct soap *soap, std::wstring *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_fims__ResourceIDType))
		soap_serialize_fims__ResourceIDType(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTofims__ResourceIDType(struct soap *soap, const char *tag, int id, std::wstring *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_fims__ResourceIDType);
	if (id < 0)
		return soap->error;
	return soap_out_fims__ResourceIDType(soap, tag, id, *a, type);
}

SOAP_FMAC3 std::wstring ** SOAP_FMAC4 soap_in_PointerTofims__ResourceIDType(struct soap *soap, const char *tag, std::wstring **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (std::wstring **)soap_malloc(soap, sizeof(std::wstring *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_fims__ResourceIDType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (std::wstring **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_fims__ResourceIDType, sizeof(std::wstring), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTofims__ResourceIDType(struct soap *soap, std::wstring *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTofims__ResourceIDType);
	if (soap_out_PointerTofims__ResourceIDType(soap, tag?tag:"fims:ResourceIDType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::wstring ** SOAP_FMAC4 soap_get_PointerTofims__ResourceIDType(struct soap *soap, std::wstring **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTofims__ResourceIDType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTofims__QueryGroupsType(struct soap *soap, fims__QueryGroupsType *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_fims__QueryGroupsType))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTofims__QueryGroupsType(struct soap *soap, const char *tag, int id, fims__QueryGroupsType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_fims__QueryGroupsType);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 fims__QueryGroupsType ** SOAP_FMAC4 soap_in_PointerTofims__QueryGroupsType(struct soap *soap, const char *tag, fims__QueryGroupsType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (fims__QueryGroupsType **)soap_malloc(soap, sizeof(fims__QueryGroupsType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (fims__QueryGroupsType *)soap_instantiate_fims__QueryGroupsType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	fims__QueryGroupsType ** p = (fims__QueryGroupsType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_fims__QueryGroupsType, sizeof(fims__QueryGroupsType), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTofims__QueryGroupsType(struct soap *soap, fims__QueryGroupsType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTofims__QueryGroupsType);
	if (soap_out_PointerTofims__QueryGroupsType(soap, tag?tag:"fims:QueryGroupsType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 fims__QueryGroupsType ** SOAP_FMAC4 soap_get_PointerTofims__QueryGroupsType(struct soap *soap, fims__QueryGroupsType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTofims__QueryGroupsType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTofims__QueryParametersType(struct soap *soap, fims__QueryParametersType *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_fims__QueryParametersType))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTofims__QueryParametersType(struct soap *soap, const char *tag, int id, fims__QueryParametersType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_fims__QueryParametersType);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 fims__QueryParametersType ** SOAP_FMAC4 soap_in_PointerTofims__QueryParametersType(struct soap *soap, const char *tag, fims__QueryParametersType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (fims__QueryParametersType **)soap_malloc(soap, sizeof(fims__QueryParametersType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (fims__QueryParametersType *)soap_instantiate_fims__QueryParametersType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	fims__QueryParametersType ** p = (fims__QueryParametersType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_fims__QueryParametersType, sizeof(fims__QueryParametersType), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTofims__QueryParametersType(struct soap *soap, fims__QueryParametersType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTofims__QueryParametersType);
	if (soap_out_PointerTofims__QueryParametersType(soap, tag?tag:"fims:QueryParametersType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 fims__QueryParametersType ** SOAP_FMAC4 soap_get_PointerTofims__QueryParametersType(struct soap *soap, fims__QueryParametersType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTofims__QueryParametersType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTofims__CustomQueryGroupOperatorType(struct soap *soap, fims__CustomQueryGroupOperatorType *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_fims__CustomQueryGroupOperatorType))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTofims__CustomQueryGroupOperatorType(struct soap *soap, const char *tag, int id, fims__CustomQueryGroupOperatorType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_fims__CustomQueryGroupOperatorType);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 fims__CustomQueryGroupOperatorType ** SOAP_FMAC4 soap_in_PointerTofims__CustomQueryGroupOperatorType(struct soap *soap, const char *tag, fims__CustomQueryGroupOperatorType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (fims__CustomQueryGroupOperatorType **)soap_malloc(soap, sizeof(fims__CustomQueryGroupOperatorType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (fims__CustomQueryGroupOperatorType *)soap_instantiate_fims__CustomQueryGroupOperatorType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	fims__CustomQueryGroupOperatorType ** p = (fims__CustomQueryGroupOperatorType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_fims__CustomQueryGroupOperatorType, sizeof(fims__CustomQueryGroupOperatorType), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTofims__CustomQueryGroupOperatorType(struct soap *soap, fims__CustomQueryGroupOperatorType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTofims__CustomQueryGroupOperatorType);
	if (soap_out_PointerTofims__CustomQueryGroupOperatorType(soap, tag?tag:"fims:CustomQueryGroupOperatorType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 fims__CustomQueryGroupOperatorType ** SOAP_FMAC4 soap_get_PointerTofims__CustomQueryGroupOperatorType(struct soap *soap, fims__CustomQueryGroupOperatorType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTofims__CustomQueryGroupOperatorType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTobool(struct soap *soap, bool *const*a)
{
#ifndef WITH_NOIDREF
	soap_reference(soap, *a, SOAP_TYPE_bool);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTobool(struct soap *soap, const char *tag, int id, bool *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_bool);
	if (id < 0)
		return soap->error;
	return soap_out_bool(soap, tag, id, *a, type);
}

SOAP_FMAC3 bool ** SOAP_FMAC4 soap_in_PointerTobool(struct soap *soap, const char *tag, bool **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (bool **)soap_malloc(soap, sizeof(bool *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_bool(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (bool **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_bool, sizeof(bool), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTobool(struct soap *soap, bool *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTobool);
	if (soap_out_PointerTobool(soap, tag?tag:"boolean", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 bool ** SOAP_FMAC4 soap_get_PointerTobool(struct soap *soap, bool **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTobool(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTofims__CustomQueryParameterOperatorType(struct soap *soap, fims__CustomQueryParameterOperatorType *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_fims__CustomQueryParameterOperatorType))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTofims__CustomQueryParameterOperatorType(struct soap *soap, const char *tag, int id, fims__CustomQueryParameterOperatorType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_fims__CustomQueryParameterOperatorType);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 fims__CustomQueryParameterOperatorType ** SOAP_FMAC4 soap_in_PointerTofims__CustomQueryParameterOperatorType(struct soap *soap, const char *tag, fims__CustomQueryParameterOperatorType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (fims__CustomQueryParameterOperatorType **)soap_malloc(soap, sizeof(fims__CustomQueryParameterOperatorType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (fims__CustomQueryParameterOperatorType *)soap_instantiate_fims__CustomQueryParameterOperatorType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	fims__CustomQueryParameterOperatorType ** p = (fims__CustomQueryParameterOperatorType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_fims__CustomQueryParameterOperatorType, sizeof(fims__CustomQueryParameterOperatorType), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTofims__CustomQueryParameterOperatorType(struct soap *soap, fims__CustomQueryParameterOperatorType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTofims__CustomQueryParameterOperatorType);
	if (soap_out_PointerTofims__CustomQueryParameterOperatorType(soap, tag?tag:"fims:CustomQueryParameterOperatorType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 fims__CustomQueryParameterOperatorType ** SOAP_FMAC4 soap_get_PointerTofims__CustomQueryParameterOperatorType(struct soap *soap, fims__CustomQueryParameterOperatorType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTofims__CustomQueryParameterOperatorType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTofims__QueryExpressionType(struct soap *soap, fims__QueryExpressionType *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_fims__QueryExpressionType))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTofims__QueryExpressionType(struct soap *soap, const char *tag, int id, fims__QueryExpressionType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_fims__QueryExpressionType);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 fims__QueryExpressionType ** SOAP_FMAC4 soap_in_PointerTofims__QueryExpressionType(struct soap *soap, const char *tag, fims__QueryExpressionType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (fims__QueryExpressionType **)soap_malloc(soap, sizeof(fims__QueryExpressionType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (fims__QueryExpressionType *)soap_instantiate_fims__QueryExpressionType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	fims__QueryExpressionType ** p = (fims__QueryExpressionType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_fims__QueryExpressionType, sizeof(fims__QueryExpressionType), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTofims__QueryExpressionType(struct soap *soap, fims__QueryExpressionType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTofims__QueryExpressionType);
	if (soap_out_PointerTofims__QueryExpressionType(soap, tag?tag:"fims:QueryExpressionType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 fims__QueryExpressionType ** SOAP_FMAC4 soap_get_PointerTofims__QueryExpressionType(struct soap *soap, fims__QueryExpressionType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTofims__QueryExpressionType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTofims__QueryGroupType(struct soap *soap, fims__QueryGroupType *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_fims__QueryGroupType))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTofims__QueryGroupType(struct soap *soap, const char *tag, int id, fims__QueryGroupType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_fims__QueryGroupType);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 fims__QueryGroupType ** SOAP_FMAC4 soap_in_PointerTofims__QueryGroupType(struct soap *soap, const char *tag, fims__QueryGroupType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (fims__QueryGroupType **)soap_malloc(soap, sizeof(fims__QueryGroupType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (fims__QueryGroupType *)soap_instantiate_fims__QueryGroupType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	fims__QueryGroupType ** p = (fims__QueryGroupType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_fims__QueryGroupType, sizeof(fims__QueryGroupType), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTofims__QueryGroupType(struct soap *soap, fims__QueryGroupType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTofims__QueryGroupType);
	if (soap_out_PointerTofims__QueryGroupType(soap, tag?tag:"fims:QueryGroupType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 fims__QueryGroupType ** SOAP_FMAC4 soap_get_PointerTofims__QueryGroupType(struct soap *soap, fims__QueryGroupType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTofims__QueryGroupType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTofims__QueryParameterType(struct soap *soap, fims__QueryParameterType *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_fims__QueryParameterType))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTofims__QueryParameterType(struct soap *soap, const char *tag, int id, fims__QueryParameterType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_fims__QueryParameterType);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 fims__QueryParameterType ** SOAP_FMAC4 soap_in_PointerTofims__QueryParameterType(struct soap *soap, const char *tag, fims__QueryParameterType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (fims__QueryParameterType **)soap_malloc(soap, sizeof(fims__QueryParameterType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (fims__QueryParameterType *)soap_instantiate_fims__QueryParameterType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	fims__QueryParameterType ** p = (fims__QueryParameterType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_fims__QueryParameterType, sizeof(fims__QueryParameterType), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTofims__QueryParameterType(struct soap *soap, fims__QueryParameterType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTofims__QueryParameterType);
	if (soap_out_PointerTofims__QueryParameterType(soap, tag?tag:"fims:QueryParameterType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 fims__QueryParameterType ** SOAP_FMAC4 soap_get_PointerTofims__QueryParameterType(struct soap *soap, fims__QueryParameterType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTofims__QueryParameterType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTofims__SuperLockTokenType(struct soap *soap, fims__SuperLockTokenType *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_fims__SuperLockTokenType))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTofims__SuperLockTokenType(struct soap *soap, const char *tag, int id, fims__SuperLockTokenType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_fims__SuperLockTokenType);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 fims__SuperLockTokenType ** SOAP_FMAC4 soap_in_PointerTofims__SuperLockTokenType(struct soap *soap, const char *tag, fims__SuperLockTokenType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (fims__SuperLockTokenType **)soap_malloc(soap, sizeof(fims__SuperLockTokenType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (fims__SuperLockTokenType *)soap_instantiate_fims__SuperLockTokenType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	fims__SuperLockTokenType ** p = (fims__SuperLockTokenType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_fims__SuperLockTokenType, sizeof(fims__SuperLockTokenType), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTofims__SuperLockTokenType(struct soap *soap, fims__SuperLockTokenType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTofims__SuperLockTokenType);
	if (soap_out_PointerTofims__SuperLockTokenType(soap, tag?tag:"fims:SuperLockTokenType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 fims__SuperLockTokenType ** SOAP_FMAC4 soap_get_PointerTofims__SuperLockTokenType(struct soap *soap, fims__SuperLockTokenType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTofims__SuperLockTokenType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTofims__LockTokenType(struct soap *soap, fims__LockTokenType *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_fims__LockTokenType))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTofims__LockTokenType(struct soap *soap, const char *tag, int id, fims__LockTokenType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_fims__LockTokenType);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 fims__LockTokenType ** SOAP_FMAC4 soap_in_PointerTofims__LockTokenType(struct soap *soap, const char *tag, fims__LockTokenType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (fims__LockTokenType **)soap_malloc(soap, sizeof(fims__LockTokenType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (fims__LockTokenType *)soap_instantiate_fims__LockTokenType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	fims__LockTokenType ** p = (fims__LockTokenType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_fims__LockTokenType, sizeof(fims__LockTokenType), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTofims__LockTokenType(struct soap *soap, fims__LockTokenType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTofims__LockTokenType);
	if (soap_out_PointerTofims__LockTokenType(soap, tag?tag:"fims:LockTokenType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 fims__LockTokenType ** SOAP_FMAC4 soap_get_PointerTofims__LockTokenType(struct soap *soap, fims__LockTokenType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTofims__LockTokenType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTofims__CredentialType(struct soap *soap, fims__CredentialType *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_fims__CredentialType))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTofims__CredentialType(struct soap *soap, const char *tag, int id, fims__CredentialType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_fims__CredentialType);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 fims__CredentialType ** SOAP_FMAC4 soap_in_PointerTofims__CredentialType(struct soap *soap, const char *tag, fims__CredentialType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (fims__CredentialType **)soap_malloc(soap, sizeof(fims__CredentialType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (fims__CredentialType *)soap_instantiate_fims__CredentialType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	fims__CredentialType ** p = (fims__CredentialType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_fims__CredentialType, sizeof(fims__CredentialType), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTofims__CredentialType(struct soap *soap, fims__CredentialType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTofims__CredentialType);
	if (soap_out_PointerTofims__CredentialType(soap, tag?tag:"fims:CredentialType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 fims__CredentialType ** SOAP_FMAC4 soap_get_PointerTofims__CredentialType(struct soap *soap, fims__CredentialType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTofims__CredentialType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTofims__BMEssenceLocatorStatusType(struct soap *soap, fims__BMEssenceLocatorStatusType *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_fims__BMEssenceLocatorStatusType))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTofims__BMEssenceLocatorStatusType(struct soap *soap, const char *tag, int id, fims__BMEssenceLocatorStatusType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_fims__BMEssenceLocatorStatusType);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 fims__BMEssenceLocatorStatusType ** SOAP_FMAC4 soap_in_PointerTofims__BMEssenceLocatorStatusType(struct soap *soap, const char *tag, fims__BMEssenceLocatorStatusType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (fims__BMEssenceLocatorStatusType **)soap_malloc(soap, sizeof(fims__BMEssenceLocatorStatusType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (fims__BMEssenceLocatorStatusType *)soap_instantiate_fims__BMEssenceLocatorStatusType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	fims__BMEssenceLocatorStatusType ** p = (fims__BMEssenceLocatorStatusType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_fims__BMEssenceLocatorStatusType, sizeof(fims__BMEssenceLocatorStatusType), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTofims__BMEssenceLocatorStatusType(struct soap *soap, fims__BMEssenceLocatorStatusType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTofims__BMEssenceLocatorStatusType);
	if (soap_out_PointerTofims__BMEssenceLocatorStatusType(soap, tag?tag:"fims:BMEssenceLocatorStatusType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 fims__BMEssenceLocatorStatusType ** SOAP_FMAC4 soap_get_PointerTofims__BMEssenceLocatorStatusType(struct soap *soap, fims__BMEssenceLocatorStatusType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTofims__BMEssenceLocatorStatusType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTofims__BMContentStatusType(struct soap *soap, fims__BMContentStatusType *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_fims__BMContentStatusType))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTofims__BMContentStatusType(struct soap *soap, const char *tag, int id, fims__BMContentStatusType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_fims__BMContentStatusType);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 fims__BMContentStatusType ** SOAP_FMAC4 soap_in_PointerTofims__BMContentStatusType(struct soap *soap, const char *tag, fims__BMContentStatusType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (fims__BMContentStatusType **)soap_malloc(soap, sizeof(fims__BMContentStatusType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (fims__BMContentStatusType *)soap_instantiate_fims__BMContentStatusType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	fims__BMContentStatusType ** p = (fims__BMContentStatusType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_fims__BMContentStatusType, sizeof(fims__BMContentStatusType), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTofims__BMContentStatusType(struct soap *soap, fims__BMContentStatusType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTofims__BMContentStatusType);
	if (soap_out_PointerTofims__BMContentStatusType(soap, tag?tag:"fims:BMContentStatusType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 fims__BMContentStatusType ** SOAP_FMAC4 soap_get_PointerTofims__BMContentStatusType(struct soap *soap, fims__BMContentStatusType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTofims__BMContentStatusType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTofims__BMCustomStatusExtensionType(struct soap *soap, fims__BMCustomStatusExtensionType *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_fims__BMCustomStatusExtensionType))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTofims__BMCustomStatusExtensionType(struct soap *soap, const char *tag, int id, fims__BMCustomStatusExtensionType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_fims__BMCustomStatusExtensionType);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 fims__BMCustomStatusExtensionType ** SOAP_FMAC4 soap_in_PointerTofims__BMCustomStatusExtensionType(struct soap *soap, const char *tag, fims__BMCustomStatusExtensionType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (fims__BMCustomStatusExtensionType **)soap_malloc(soap, sizeof(fims__BMCustomStatusExtensionType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (fims__BMCustomStatusExtensionType *)soap_instantiate_fims__BMCustomStatusExtensionType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	fims__BMCustomStatusExtensionType ** p = (fims__BMCustomStatusExtensionType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_fims__BMCustomStatusExtensionType, sizeof(fims__BMCustomStatusExtensionType), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTofims__BMCustomStatusExtensionType(struct soap *soap, fims__BMCustomStatusExtensionType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTofims__BMCustomStatusExtensionType);
	if (soap_out_PointerTofims__BMCustomStatusExtensionType(soap, tag?tag:"fims:BMCustomStatusExtensionType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 fims__BMCustomStatusExtensionType ** SOAP_FMAC4 soap_get_PointerTofims__BMCustomStatusExtensionType(struct soap *soap, fims__BMCustomStatusExtensionType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTofims__BMCustomStatusExtensionType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTofims__CustomValueType(struct soap *soap, fims__CustomValueType *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_fims__CustomValueType))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTofims__CustomValueType(struct soap *soap, const char *tag, int id, fims__CustomValueType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_fims__CustomValueType);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 fims__CustomValueType ** SOAP_FMAC4 soap_in_PointerTofims__CustomValueType(struct soap *soap, const char *tag, fims__CustomValueType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (fims__CustomValueType **)soap_malloc(soap, sizeof(fims__CustomValueType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (fims__CustomValueType *)soap_instantiate_fims__CustomValueType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	fims__CustomValueType ** p = (fims__CustomValueType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_fims__CustomValueType, sizeof(fims__CustomValueType), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTofims__CustomValueType(struct soap *soap, fims__CustomValueType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTofims__CustomValueType);
	if (soap_out_PointerTofims__CustomValueType(soap, tag?tag:"fims:CustomValueType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 fims__CustomValueType ** SOAP_FMAC4 soap_get_PointerTofims__CustomValueType(struct soap *soap, fims__CustomValueType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTofims__CustomValueType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTofims__ResourceReferenceType(struct soap *soap, fims__ResourceReferenceType *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_fims__ResourceReferenceType))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTofims__ResourceReferenceType(struct soap *soap, const char *tag, int id, fims__ResourceReferenceType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_fims__ResourceReferenceType);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 fims__ResourceReferenceType ** SOAP_FMAC4 soap_in_PointerTofims__ResourceReferenceType(struct soap *soap, const char *tag, fims__ResourceReferenceType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (fims__ResourceReferenceType **)soap_malloc(soap, sizeof(fims__ResourceReferenceType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (fims__ResourceReferenceType *)soap_instantiate_fims__ResourceReferenceType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	fims__ResourceReferenceType ** p = (fims__ResourceReferenceType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_fims__ResourceReferenceType, sizeof(fims__ResourceReferenceType), 0);
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (fims__ResourceReferenceType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_fims__ResourceType, sizeof(fims__ResourceType), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (fims__ResourceReferenceType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_fims__ServiceType, sizeof(fims__ServiceType), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (fims__ResourceReferenceType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_fims__ProfileType, sizeof(fims__ProfileType), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (fims__ResourceReferenceType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_fims__QueueType, sizeof(fims__QueueType), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (fims__ResourceReferenceType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_fims__JobType, sizeof(fims__JobType), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (fims__ResourceReferenceType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_fims__FormatType, sizeof(fims__FormatType), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (fims__ResourceReferenceType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_fims__BMObjectType, sizeof(fims__BMObjectType), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (fims__ResourceReferenceType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_fims__BMContentType, sizeof(fims__BMContentType), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (fims__ResourceReferenceType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_fims__DescriptionType, sizeof(fims__DescriptionType), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (fims__ResourceReferenceType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_fims__BMContentFormatType, sizeof(fims__BMContentFormatType), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (fims__ResourceReferenceType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_fims__BMEssenceLocatorType, sizeof(fims__BMEssenceLocatorType), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (fims__ResourceReferenceType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_fims__BMCustomStatusExtensionType, sizeof(fims__BMCustomStatusExtensionType), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (fims__ResourceReferenceType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_fims__BMContentStatusType, sizeof(fims__BMContentStatusType), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (fims__ResourceReferenceType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_fims__BMEssenceLocatorStatusType, sizeof(fims__BMEssenceLocatorStatusType), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (fims__ResourceReferenceType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_fims__LockTokenType, sizeof(fims__LockTokenType), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (fims__ResourceReferenceType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_fims__SuperLockTokenType, sizeof(fims__SuperLockTokenType), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (fims__ResourceReferenceType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_fims__VideoFormatType, sizeof(fims__VideoFormatType), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (fims__ResourceReferenceType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_fims__AudioFormatType, sizeof(fims__AudioFormatType), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (fims__ResourceReferenceType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_fims__DataFormatType, sizeof(fims__DataFormatType), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (fims__ResourceReferenceType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_fims__ContainerFormatType, sizeof(fims__ContainerFormatType), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (fims__ResourceReferenceType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_fims__SimpleFileLocatorType, sizeof(fims__SimpleFileLocatorType), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (fims__ResourceReferenceType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_fims__ListFileLocatorType, sizeof(fims__ListFileLocatorType), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (fims__ResourceReferenceType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_fims__FolderLocatorType, sizeof(fims__FolderLocatorType), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (fims__ResourceReferenceType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_fims__EssencePlaceholderLocatorType, sizeof(fims__EssencePlaceholderLocatorType), 0);
		}
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTofims__ResourceReferenceType(struct soap *soap, fims__ResourceReferenceType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTofims__ResourceReferenceType);
	if (soap_out_PointerTofims__ResourceReferenceType(soap, tag?tag:"fims:ResourceReferenceType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 fims__ResourceReferenceType ** SOAP_FMAC4 soap_get_PointerTofims__ResourceReferenceType(struct soap *soap, fims__ResourceReferenceType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTofims__ResourceReferenceType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTofims__DescriptionType(struct soap *soap, fims__DescriptionType *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_fims__DescriptionType))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTofims__DescriptionType(struct soap *soap, const char *tag, int id, fims__DescriptionType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_fims__DescriptionType);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 fims__DescriptionType ** SOAP_FMAC4 soap_in_PointerTofims__DescriptionType(struct soap *soap, const char *tag, fims__DescriptionType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (fims__DescriptionType **)soap_malloc(soap, sizeof(fims__DescriptionType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (fims__DescriptionType *)soap_instantiate_fims__DescriptionType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	fims__DescriptionType ** p = (fims__DescriptionType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_fims__DescriptionType, sizeof(fims__DescriptionType), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTofims__DescriptionType(struct soap *soap, fims__DescriptionType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTofims__DescriptionType);
	if (soap_out_PointerTofims__DescriptionType(soap, tag?tag:"fims:DescriptionType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 fims__DescriptionType ** SOAP_FMAC4 soap_get_PointerTofims__DescriptionType(struct soap *soap, fims__DescriptionType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTofims__DescriptionType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTofims__BMEssenceLocatorType(struct soap *soap, fims__BMEssenceLocatorType *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_fims__BMEssenceLocatorType))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTofims__BMEssenceLocatorType(struct soap *soap, const char *tag, int id, fims__BMEssenceLocatorType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_fims__BMEssenceLocatorType);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 fims__BMEssenceLocatorType ** SOAP_FMAC4 soap_in_PointerTofims__BMEssenceLocatorType(struct soap *soap, const char *tag, fims__BMEssenceLocatorType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (fims__BMEssenceLocatorType **)soap_malloc(soap, sizeof(fims__BMEssenceLocatorType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (fims__BMEssenceLocatorType *)soap_instantiate_fims__BMEssenceLocatorType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	fims__BMEssenceLocatorType ** p = (fims__BMEssenceLocatorType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_fims__BMEssenceLocatorType, sizeof(fims__BMEssenceLocatorType), 0);
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (fims__BMEssenceLocatorType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_fims__SimpleFileLocatorType, sizeof(fims__SimpleFileLocatorType), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (fims__BMEssenceLocatorType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_fims__ListFileLocatorType, sizeof(fims__ListFileLocatorType), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (fims__BMEssenceLocatorType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_fims__FolderLocatorType, sizeof(fims__FolderLocatorType), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (fims__BMEssenceLocatorType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_fims__EssencePlaceholderLocatorType, sizeof(fims__EssencePlaceholderLocatorType), 0);
		}
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTofims__BMEssenceLocatorType(struct soap *soap, fims__BMEssenceLocatorType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTofims__BMEssenceLocatorType);
	if (soap_out_PointerTofims__BMEssenceLocatorType(soap, tag?tag:"fims:BMEssenceLocatorType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 fims__BMEssenceLocatorType ** SOAP_FMAC4 soap_get_PointerTofims__BMEssenceLocatorType(struct soap *soap, fims__BMEssenceLocatorType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTofims__BMEssenceLocatorType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTofims__BMContentFormatType(struct soap *soap, fims__BMContentFormatType *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_fims__BMContentFormatType))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTofims__BMContentFormatType(struct soap *soap, const char *tag, int id, fims__BMContentFormatType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_fims__BMContentFormatType);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 fims__BMContentFormatType ** SOAP_FMAC4 soap_in_PointerTofims__BMContentFormatType(struct soap *soap, const char *tag, fims__BMContentFormatType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (fims__BMContentFormatType **)soap_malloc(soap, sizeof(fims__BMContentFormatType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (fims__BMContentFormatType *)soap_instantiate_fims__BMContentFormatType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	fims__BMContentFormatType ** p = (fims__BMContentFormatType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_fims__BMContentFormatType, sizeof(fims__BMContentFormatType), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTofims__BMContentFormatType(struct soap *soap, fims__BMContentFormatType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTofims__BMContentFormatType);
	if (soap_out_PointerTofims__BMContentFormatType(soap, tag?tag:"fims:BMContentFormatType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 fims__BMContentFormatType ** SOAP_FMAC4 soap_get_PointerTofims__BMContentFormatType(struct soap *soap, fims__BMContentFormatType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTofims__BMContentFormatType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTofims__BMContentType(struct soap *soap, fims__BMContentType *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_fims__BMContentType))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTofims__BMContentType(struct soap *soap, const char *tag, int id, fims__BMContentType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_fims__BMContentType);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 fims__BMContentType ** SOAP_FMAC4 soap_in_PointerTofims__BMContentType(struct soap *soap, const char *tag, fims__BMContentType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (fims__BMContentType **)soap_malloc(soap, sizeof(fims__BMContentType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (fims__BMContentType *)soap_instantiate_fims__BMContentType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	fims__BMContentType ** p = (fims__BMContentType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_fims__BMContentType, sizeof(fims__BMContentType), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTofims__BMContentType(struct soap *soap, fims__BMContentType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTofims__BMContentType);
	if (soap_out_PointerTofims__BMContentType(soap, tag?tag:"fims:BMContentType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 fims__BMContentType ** SOAP_FMAC4 soap_get_PointerTofims__BMContentType(struct soap *soap, fims__BMContentType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTofims__BMContentType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTofims__DataFormatType(struct soap *soap, fims__DataFormatType *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_fims__DataFormatType))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTofims__DataFormatType(struct soap *soap, const char *tag, int id, fims__DataFormatType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_fims__DataFormatType);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 fims__DataFormatType ** SOAP_FMAC4 soap_in_PointerTofims__DataFormatType(struct soap *soap, const char *tag, fims__DataFormatType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (fims__DataFormatType **)soap_malloc(soap, sizeof(fims__DataFormatType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (fims__DataFormatType *)soap_instantiate_fims__DataFormatType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	fims__DataFormatType ** p = (fims__DataFormatType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_fims__DataFormatType, sizeof(fims__DataFormatType), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTofims__DataFormatType(struct soap *soap, fims__DataFormatType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTofims__DataFormatType);
	if (soap_out_PointerTofims__DataFormatType(soap, tag?tag:"fims:DataFormatType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 fims__DataFormatType ** SOAP_FMAC4 soap_get_PointerTofims__DataFormatType(struct soap *soap, fims__DataFormatType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTofims__DataFormatType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTofims__ProfileType(struct soap *soap, fims__ProfileType *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_fims__ProfileType))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTofims__ProfileType(struct soap *soap, const char *tag, int id, fims__ProfileType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_fims__ProfileType);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 fims__ProfileType ** SOAP_FMAC4 soap_in_PointerTofims__ProfileType(struct soap *soap, const char *tag, fims__ProfileType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (fims__ProfileType **)soap_malloc(soap, sizeof(fims__ProfileType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (fims__ProfileType *)soap_instantiate_fims__ProfileType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	fims__ProfileType ** p = (fims__ProfileType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_fims__ProfileType, sizeof(fims__ProfileType), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTofims__ProfileType(struct soap *soap, fims__ProfileType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTofims__ProfileType);
	if (soap_out_PointerTofims__ProfileType(soap, tag?tag:"fims:ProfileType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 fims__ProfileType ** SOAP_FMAC4 soap_get_PointerTofims__ProfileType(struct soap *soap, fims__ProfileType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTofims__ProfileType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTofims__ResourceType(struct soap *soap, fims__ResourceType *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_fims__ResourceType))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTofims__ResourceType(struct soap *soap, const char *tag, int id, fims__ResourceType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_fims__ResourceType);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 fims__ResourceType ** SOAP_FMAC4 soap_in_PointerTofims__ResourceType(struct soap *soap, const char *tag, fims__ResourceType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (fims__ResourceType **)soap_malloc(soap, sizeof(fims__ResourceType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (fims__ResourceType *)soap_instantiate_fims__ResourceType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	fims__ResourceType ** p = (fims__ResourceType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_fims__ResourceType, sizeof(fims__ResourceType), 0);
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (fims__ResourceType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_fims__ServiceType, sizeof(fims__ServiceType), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (fims__ResourceType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_fims__ProfileType, sizeof(fims__ProfileType), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (fims__ResourceType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_fims__QueueType, sizeof(fims__QueueType), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (fims__ResourceType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_fims__JobType, sizeof(fims__JobType), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (fims__ResourceType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_fims__FormatType, sizeof(fims__FormatType), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (fims__ResourceType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_fims__BMObjectType, sizeof(fims__BMObjectType), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (fims__ResourceType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_fims__BMContentType, sizeof(fims__BMContentType), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (fims__ResourceType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_fims__DescriptionType, sizeof(fims__DescriptionType), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (fims__ResourceType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_fims__BMContentFormatType, sizeof(fims__BMContentFormatType), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (fims__ResourceType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_fims__BMEssenceLocatorType, sizeof(fims__BMEssenceLocatorType), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (fims__ResourceType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_fims__BMCustomStatusExtensionType, sizeof(fims__BMCustomStatusExtensionType), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (fims__ResourceType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_fims__BMContentStatusType, sizeof(fims__BMContentStatusType), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (fims__ResourceType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_fims__BMEssenceLocatorStatusType, sizeof(fims__BMEssenceLocatorStatusType), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (fims__ResourceType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_fims__LockTokenType, sizeof(fims__LockTokenType), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (fims__ResourceType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_fims__SuperLockTokenType, sizeof(fims__SuperLockTokenType), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (fims__ResourceType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_fims__VideoFormatType, sizeof(fims__VideoFormatType), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (fims__ResourceType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_fims__AudioFormatType, sizeof(fims__AudioFormatType), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (fims__ResourceType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_fims__DataFormatType, sizeof(fims__DataFormatType), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (fims__ResourceType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_fims__ContainerFormatType, sizeof(fims__ContainerFormatType), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (fims__ResourceType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_fims__SimpleFileLocatorType, sizeof(fims__SimpleFileLocatorType), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (fims__ResourceType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_fims__ListFileLocatorType, sizeof(fims__ListFileLocatorType), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (fims__ResourceType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_fims__FolderLocatorType, sizeof(fims__FolderLocatorType), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (fims__ResourceType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_fims__EssencePlaceholderLocatorType, sizeof(fims__EssencePlaceholderLocatorType), 0);
		}
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTofims__ResourceType(struct soap *soap, fims__ResourceType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTofims__ResourceType);
	if (soap_out_PointerTofims__ResourceType(soap, tag?tag:"fims:ResourceType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 fims__ResourceType ** SOAP_FMAC4 soap_get_PointerTofims__ResourceType(struct soap *soap, fims__ResourceType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTofims__ResourceType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTofims__InnerFaultType(struct soap *soap, fims__InnerFaultType *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_fims__InnerFaultType))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTofims__InnerFaultType(struct soap *soap, const char *tag, int id, fims__InnerFaultType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_fims__InnerFaultType);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 fims__InnerFaultType ** SOAP_FMAC4 soap_in_PointerTofims__InnerFaultType(struct soap *soap, const char *tag, fims__InnerFaultType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (fims__InnerFaultType **)soap_malloc(soap, sizeof(fims__InnerFaultType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (fims__InnerFaultType *)soap_instantiate_fims__InnerFaultType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	fims__InnerFaultType ** p = (fims__InnerFaultType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_fims__InnerFaultType, sizeof(fims__InnerFaultType), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTofims__InnerFaultType(struct soap *soap, fims__InnerFaultType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTofims__InnerFaultType);
	if (soap_out_PointerTofims__InnerFaultType(soap, tag?tag:"fims:InnerFaultType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 fims__InnerFaultType ** SOAP_FMAC4 soap_get_PointerTofims__InnerFaultType(struct soap *soap, fims__InnerFaultType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTofims__InnerFaultType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTotime(struct soap *soap, time_t *const*a)
{
#ifndef WITH_NOIDREF
	soap_reference(soap, *a, SOAP_TYPE_time);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTotime(struct soap *soap, const char *tag, int id, time_t *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_time);
	if (id < 0)
		return soap->error;
	return soap_out_time(soap, tag, id, *a, type);
}

SOAP_FMAC3 time_t ** SOAP_FMAC4 soap_in_PointerTotime(struct soap *soap, const char *tag, time_t **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (time_t **)soap_malloc(soap, sizeof(time_t *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_time(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (time_t **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_time, sizeof(time_t), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTotime(struct soap *soap, time_t *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTotime);
	if (soap_out_PointerTotime(soap, tag?tag:"dateTime", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 time_t ** SOAP_FMAC4 soap_get_PointerTotime(struct soap *soap, time_t **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTotime(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTofims__ServiceType(struct soap *soap, fims__ServiceType *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_fims__ServiceType))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTofims__ServiceType(struct soap *soap, const char *tag, int id, fims__ServiceType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_fims__ServiceType);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 fims__ServiceType ** SOAP_FMAC4 soap_in_PointerTofims__ServiceType(struct soap *soap, const char *tag, fims__ServiceType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (fims__ServiceType **)soap_malloc(soap, sizeof(fims__ServiceType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (fims__ServiceType *)soap_instantiate_fims__ServiceType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	fims__ServiceType ** p = (fims__ServiceType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_fims__ServiceType, sizeof(fims__ServiceType), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTofims__ServiceType(struct soap *soap, fims__ServiceType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTofims__ServiceType);
	if (soap_out_PointerTofims__ServiceType(soap, tag?tag:"fims:ServiceType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 fims__ServiceType ** SOAP_FMAC4 soap_get_PointerTofims__ServiceType(struct soap *soap, fims__ServiceType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTofims__ServiceType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToxsd__nonNegativeInteger(struct soap *soap, std::wstring *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_xsd__nonNegativeInteger))
		soap_serialize_xsd__nonNegativeInteger(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToxsd__nonNegativeInteger(struct soap *soap, const char *tag, int id, std::wstring *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_xsd__nonNegativeInteger);
	if (id < 0)
		return soap->error;
	return soap_out_xsd__nonNegativeInteger(soap, tag, id, *a, type);
}

SOAP_FMAC3 std::wstring ** SOAP_FMAC4 soap_in_PointerToxsd__nonNegativeInteger(struct soap *soap, const char *tag, std::wstring **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (std::wstring **)soap_malloc(soap, sizeof(std::wstring *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_xsd__nonNegativeInteger(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (std::wstring **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_xsd__nonNegativeInteger, sizeof(std::wstring), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToxsd__nonNegativeInteger(struct soap *soap, std::wstring *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToxsd__nonNegativeInteger);
	if (soap_out_PointerToxsd__nonNegativeInteger(soap, tag?tag:"xsd:nonNegativeInteger", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::wstring ** SOAP_FMAC4 soap_get_PointerToxsd__nonNegativeInteger(struct soap *soap, std::wstring **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToxsd__nonNegativeInteger(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTofims__JobsType(struct soap *soap, fims__JobsType *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_fims__JobsType))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTofims__JobsType(struct soap *soap, const char *tag, int id, fims__JobsType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_fims__JobsType);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 fims__JobsType ** SOAP_FMAC4 soap_in_PointerTofims__JobsType(struct soap *soap, const char *tag, fims__JobsType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (fims__JobsType **)soap_malloc(soap, sizeof(fims__JobsType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (fims__JobsType *)soap_instantiate_fims__JobsType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	fims__JobsType ** p = (fims__JobsType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_fims__JobsType, sizeof(fims__JobsType), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTofims__JobsType(struct soap *soap, fims__JobsType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTofims__JobsType);
	if (soap_out_PointerTofims__JobsType(soap, tag?tag:"fims:JobsType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 fims__JobsType ** SOAP_FMAC4 soap_get_PointerTofims__JobsType(struct soap *soap, fims__JobsType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTofims__JobsType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTofims__QueueType(struct soap *soap, fims__QueueType *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_fims__QueueType))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTofims__QueueType(struct soap *soap, const char *tag, int id, fims__QueueType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_fims__QueueType);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 fims__QueueType ** SOAP_FMAC4 soap_in_PointerTofims__QueueType(struct soap *soap, const char *tag, fims__QueueType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (fims__QueueType **)soap_malloc(soap, sizeof(fims__QueueType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (fims__QueueType *)soap_instantiate_fims__QueueType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	fims__QueueType ** p = (fims__QueueType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_fims__QueueType, sizeof(fims__QueueType), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTofims__QueueType(struct soap *soap, fims__QueueType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTofims__QueueType);
	if (soap_out_PointerTofims__QueueType(soap, tag?tag:"fims:QueueType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 fims__QueueType ** SOAP_FMAC4 soap_get_PointerTofims__QueueType(struct soap *soap, fims__QueueType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTofims__QueueType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTofims__JobType(struct soap *soap, fims__JobType *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_fims__JobType))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTofims__JobType(struct soap *soap, const char *tag, int id, fims__JobType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_fims__JobType);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 fims__JobType ** SOAP_FMAC4 soap_in_PointerTofims__JobType(struct soap *soap, const char *tag, fims__JobType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (fims__JobType **)soap_malloc(soap, sizeof(fims__JobType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (fims__JobType *)soap_instantiate_fims__JobType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	fims__JobType ** p = (fims__JobType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_fims__JobType, sizeof(fims__JobType), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTofims__JobType(struct soap *soap, fims__JobType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTofims__JobType);
	if (soap_out_PointerTofims__JobType(soap, tag?tag:"fims:JobType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 fims__JobType ** SOAP_FMAC4 soap_get_PointerTofims__JobType(struct soap *soap, fims__JobType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTofims__JobType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTofims__PriorityType(struct soap *soap, enum fims__PriorityType *const*a)
{
#ifndef WITH_NOIDREF
	soap_reference(soap, *a, SOAP_TYPE_fims__PriorityType);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTofims__PriorityType(struct soap *soap, const char *tag, int id, enum fims__PriorityType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_fims__PriorityType);
	if (id < 0)
		return soap->error;
	return soap_out_fims__PriorityType(soap, tag, id, *a, type);
}

SOAP_FMAC3 enum fims__PriorityType ** SOAP_FMAC4 soap_in_PointerTofims__PriorityType(struct soap *soap, const char *tag, enum fims__PriorityType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (enum fims__PriorityType **)soap_malloc(soap, sizeof(enum fims__PriorityType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_fims__PriorityType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (enum fims__PriorityType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_fims__PriorityType, sizeof(enum fims__PriorityType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTofims__PriorityType(struct soap *soap, enum fims__PriorityType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTofims__PriorityType);
	if (soap_out_PointerTofims__PriorityType(soap, tag?tag:"fims:PriorityType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum fims__PriorityType ** SOAP_FMAC4 soap_get_PointerTofims__PriorityType(struct soap *soap, enum fims__PriorityType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTofims__PriorityType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTofims__HashFunctionType(struct soap *soap, fims__HashFunctionType *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_fims__HashFunctionType))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTofims__HashFunctionType(struct soap *soap, const char *tag, int id, fims__HashFunctionType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_fims__HashFunctionType);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 fims__HashFunctionType ** SOAP_FMAC4 soap_in_PointerTofims__HashFunctionType(struct soap *soap, const char *tag, fims__HashFunctionType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (fims__HashFunctionType **)soap_malloc(soap, sizeof(fims__HashFunctionType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (fims__HashFunctionType *)soap_instantiate_fims__HashFunctionType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	fims__HashFunctionType ** p = (fims__HashFunctionType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_fims__HashFunctionType, sizeof(fims__HashFunctionType), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTofims__HashFunctionType(struct soap *soap, fims__HashFunctionType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTofims__HashFunctionType);
	if (soap_out_PointerTofims__HashFunctionType(soap, tag?tag:"fims:HashFunctionType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 fims__HashFunctionType ** SOAP_FMAC4 soap_get_PointerTofims__HashFunctionType(struct soap *soap, fims__HashFunctionType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTofims__HashFunctionType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTofims__ContainerFormatType(struct soap *soap, fims__ContainerFormatType *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_fims__ContainerFormatType))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTofims__ContainerFormatType(struct soap *soap, const char *tag, int id, fims__ContainerFormatType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_fims__ContainerFormatType);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 fims__ContainerFormatType ** SOAP_FMAC4 soap_in_PointerTofims__ContainerFormatType(struct soap *soap, const char *tag, fims__ContainerFormatType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (fims__ContainerFormatType **)soap_malloc(soap, sizeof(fims__ContainerFormatType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (fims__ContainerFormatType *)soap_instantiate_fims__ContainerFormatType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	fims__ContainerFormatType ** p = (fims__ContainerFormatType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_fims__ContainerFormatType, sizeof(fims__ContainerFormatType), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTofims__ContainerFormatType(struct soap *soap, fims__ContainerFormatType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTofims__ContainerFormatType);
	if (soap_out_PointerTofims__ContainerFormatType(soap, tag?tag:"fims:ContainerFormatType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 fims__ContainerFormatType ** SOAP_FMAC4 soap_get_PointerTofims__ContainerFormatType(struct soap *soap, fims__ContainerFormatType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTofims__ContainerFormatType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTofims__AudioFormatType(struct soap *soap, fims__AudioFormatType *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_fims__AudioFormatType))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTofims__AudioFormatType(struct soap *soap, const char *tag, int id, fims__AudioFormatType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_fims__AudioFormatType);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 fims__AudioFormatType ** SOAP_FMAC4 soap_in_PointerTofims__AudioFormatType(struct soap *soap, const char *tag, fims__AudioFormatType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (fims__AudioFormatType **)soap_malloc(soap, sizeof(fims__AudioFormatType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (fims__AudioFormatType *)soap_instantiate_fims__AudioFormatType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	fims__AudioFormatType ** p = (fims__AudioFormatType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_fims__AudioFormatType, sizeof(fims__AudioFormatType), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTofims__AudioFormatType(struct soap *soap, fims__AudioFormatType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTofims__AudioFormatType);
	if (soap_out_PointerTofims__AudioFormatType(soap, tag?tag:"fims:AudioFormatType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 fims__AudioFormatType ** SOAP_FMAC4 soap_get_PointerTofims__AudioFormatType(struct soap *soap, fims__AudioFormatType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTofims__AudioFormatType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTofims__VideoFormatType(struct soap *soap, fims__VideoFormatType *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_fims__VideoFormatType))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTofims__VideoFormatType(struct soap *soap, const char *tag, int id, fims__VideoFormatType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_fims__VideoFormatType);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 fims__VideoFormatType ** SOAP_FMAC4 soap_in_PointerTofims__VideoFormatType(struct soap *soap, const char *tag, fims__VideoFormatType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (fims__VideoFormatType **)soap_malloc(soap, sizeof(fims__VideoFormatType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (fims__VideoFormatType *)soap_instantiate_fims__VideoFormatType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	fims__VideoFormatType ** p = (fims__VideoFormatType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_fims__VideoFormatType, sizeof(fims__VideoFormatType), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTofims__VideoFormatType(struct soap *soap, fims__VideoFormatType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTofims__VideoFormatType);
	if (soap_out_PointerTofims__VideoFormatType(soap, tag?tag:"fims:VideoFormatType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 fims__VideoFormatType ** SOAP_FMAC4 soap_get_PointerTofims__VideoFormatType(struct soap *soap, fims__VideoFormatType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTofims__VideoFormatType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToxsd__language(struct soap *soap, std::wstring *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_xsd__language))
		soap_serialize_xsd__language(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToxsd__language(struct soap *soap, const char *tag, int id, std::wstring *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_xsd__language);
	if (id < 0)
		return soap->error;
	return soap_out_xsd__language(soap, tag, id, *a, type);
}

SOAP_FMAC3 std::wstring ** SOAP_FMAC4 soap_in_PointerToxsd__language(struct soap *soap, const char *tag, std::wstring **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (std::wstring **)soap_malloc(soap, sizeof(std::wstring *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_xsd__language(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (std::wstring **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_xsd__language, sizeof(std::wstring), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToxsd__language(struct soap *soap, std::wstring *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToxsd__language);
	if (soap_out_PointerToxsd__language(soap, tag?tag:"xsd:language", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::wstring ** SOAP_FMAC4 soap_get_PointerToxsd__language(struct soap *soap, std::wstring **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToxsd__language(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTofims__UID(struct soap *soap, std::wstring *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_fims__UID))
		soap_serialize_fims__UID(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTofims__UID(struct soap *soap, const char *tag, int id, std::wstring *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_fims__UID);
	if (id < 0)
		return soap->error;
	return soap_out_fims__UID(soap, tag, id, *a, type);
}

SOAP_FMAC3 std::wstring ** SOAP_FMAC4 soap_in_PointerTofims__UID(struct soap *soap, const char *tag, std::wstring **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (std::wstring **)soap_malloc(soap, sizeof(std::wstring *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_fims__UID(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (std::wstring **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_fims__UID, sizeof(std::wstring), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTofims__UID(struct soap *soap, std::wstring *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTofims__UID);
	if (soap_out_PointerTofims__UID(soap, tag?tag:"fims:UID", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::wstring ** SOAP_FMAC4 soap_get_PointerTofims__UID(struct soap *soap, std::wstring **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTofims__UID(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToxsd__integer(struct soap *soap, std::wstring *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_xsd__integer))
		soap_serialize_xsd__integer(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToxsd__integer(struct soap *soap, const char *tag, int id, std::wstring *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_xsd__integer);
	if (id < 0)
		return soap->error;
	return soap_out_xsd__integer(soap, tag, id, *a, type);
}

SOAP_FMAC3 std::wstring ** SOAP_FMAC4 soap_in_PointerToxsd__integer(struct soap *soap, const char *tag, std::wstring **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (std::wstring **)soap_malloc(soap, sizeof(std::wstring *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_xsd__integer(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (std::wstring **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_xsd__integer, sizeof(std::wstring), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToxsd__integer(struct soap *soap, std::wstring *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToxsd__integer);
	if (soap_out_PointerToxsd__integer(soap, tag?tag:"xsd:integer", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::wstring ** SOAP_FMAC4 soap_get_PointerToxsd__integer(struct soap *soap, std::wstring **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToxsd__integer(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTofims__ExtensionAttributes(struct soap *soap, fims__ExtensionAttributes *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_fims__ExtensionAttributes))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTofims__ExtensionAttributes(struct soap *soap, const char *tag, int id, fims__ExtensionAttributes *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_fims__ExtensionAttributes);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 fims__ExtensionAttributes ** SOAP_FMAC4 soap_in_PointerTofims__ExtensionAttributes(struct soap *soap, const char *tag, fims__ExtensionAttributes **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (fims__ExtensionAttributes **)soap_malloc(soap, sizeof(fims__ExtensionAttributes *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (fims__ExtensionAttributes *)soap_instantiate_fims__ExtensionAttributes(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	fims__ExtensionAttributes ** p = (fims__ExtensionAttributes **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_fims__ExtensionAttributes, sizeof(fims__ExtensionAttributes), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTofims__ExtensionAttributes(struct soap *soap, fims__ExtensionAttributes *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTofims__ExtensionAttributes);
	if (soap_out_PointerTofims__ExtensionAttributes(soap, tag?tag:"fims:ExtensionAttributes", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 fims__ExtensionAttributes ** SOAP_FMAC4 soap_get_PointerTofims__ExtensionAttributes(struct soap *soap, fims__ExtensionAttributes **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTofims__ExtensionAttributes(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTofims__ExtensionGroup(struct soap *soap, fims__ExtensionGroup *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_fims__ExtensionGroup))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTofims__ExtensionGroup(struct soap *soap, const char *tag, int id, fims__ExtensionGroup *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_fims__ExtensionGroup);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 fims__ExtensionGroup ** SOAP_FMAC4 soap_in_PointerTofims__ExtensionGroup(struct soap *soap, const char *tag, fims__ExtensionGroup **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (fims__ExtensionGroup **)soap_malloc(soap, sizeof(fims__ExtensionGroup *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (fims__ExtensionGroup *)soap_instantiate_fims__ExtensionGroup(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	fims__ExtensionGroup ** p = (fims__ExtensionGroup **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_fims__ExtensionGroup, sizeof(fims__ExtensionGroup), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTofims__ExtensionGroup(struct soap *soap, fims__ExtensionGroup *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTofims__ExtensionGroup);
	if (soap_out_PointerTofims__ExtensionGroup(soap, tag?tag:"fims:ExtensionGroup", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 fims__ExtensionGroup ** SOAP_FMAC4 soap_get_PointerTofims__ExtensionGroup(struct soap *soap, fims__ExtensionGroup **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTofims__ExtensionGroup(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToxsd__anyURI(struct soap *soap, std::wstring *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_xsd__anyURI))
		soap_serialize_xsd__anyURI(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToxsd__anyURI(struct soap *soap, const char *tag, int id, std::wstring *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_xsd__anyURI);
	if (id < 0)
		return soap->error;
	return soap_out_xsd__anyURI(soap, tag, id, *a, type);
}

SOAP_FMAC3 std::wstring ** SOAP_FMAC4 soap_in_PointerToxsd__anyURI(struct soap *soap, const char *tag, std::wstring **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (std::wstring **)soap_malloc(soap, sizeof(std::wstring *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_xsd__anyURI(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (std::wstring **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_xsd__anyURI, sizeof(std::wstring), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToxsd__anyURI(struct soap *soap, std::wstring *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToxsd__anyURI);
	if (soap_out_PointerToxsd__anyURI(soap, tag?tag:"xsd:anyURI", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::wstring ** SOAP_FMAC4 soap_get_PointerToxsd__anyURI(struct soap *soap, std::wstring **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToxsd__anyURI(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTofims__RevisionIDType(struct soap *soap, std::wstring *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_fims__RevisionIDType))
		soap_serialize_fims__RevisionIDType(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTofims__RevisionIDType(struct soap *soap, const char *tag, int id, std::wstring *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_fims__RevisionIDType);
	if (id < 0)
		return soap->error;
	return soap_out_fims__RevisionIDType(soap, tag, id, *a, type);
}

SOAP_FMAC3 std::wstring ** SOAP_FMAC4 soap_in_PointerTofims__RevisionIDType(struct soap *soap, const char *tag, std::wstring **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (std::wstring **)soap_malloc(soap, sizeof(std::wstring *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_fims__RevisionIDType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (std::wstring **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_fims__RevisionIDType, sizeof(std::wstring), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTofims__RevisionIDType(struct soap *soap, std::wstring *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTofims__RevisionIDType);
	if (soap_out_PointerTofims__RevisionIDType(soap, tag?tag:"fims:RevisionIDType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::wstring ** SOAP_FMAC4 soap_get_PointerTofims__RevisionIDType(struct soap *soap, std::wstring **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTofims__RevisionIDType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToedlprovider__MapItemType(struct soap *soap, edlprovider__MapItemType *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_edlprovider__MapItemType))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToedlprovider__MapItemType(struct soap *soap, const char *tag, int id, edlprovider__MapItemType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_edlprovider__MapItemType);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 edlprovider__MapItemType ** SOAP_FMAC4 soap_in_PointerToedlprovider__MapItemType(struct soap *soap, const char *tag, edlprovider__MapItemType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (edlprovider__MapItemType **)soap_malloc(soap, sizeof(edlprovider__MapItemType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (edlprovider__MapItemType *)soap_instantiate_edlprovider__MapItemType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	edlprovider__MapItemType ** p = (edlprovider__MapItemType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_edlprovider__MapItemType, sizeof(edlprovider__MapItemType), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToedlprovider__MapItemType(struct soap *soap, edlprovider__MapItemType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToedlprovider__MapItemType);
	if (soap_out_PointerToedlprovider__MapItemType(soap, tag?tag:"edlprovider:MapItemType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 edlprovider__MapItemType ** SOAP_FMAC4 soap_get_PointerToedlprovider__MapItemType(struct soap *soap, edlprovider__MapItemType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToedlprovider__MapItemType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_edlprovider__Map(struct soap *soap, _edlprovider__Map *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__edlprovider__Map))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_edlprovider__Map(struct soap *soap, const char *tag, int id, _edlprovider__Map *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__edlprovider__Map);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _edlprovider__Map ** SOAP_FMAC4 soap_in_PointerTo_edlprovider__Map(struct soap *soap, const char *tag, _edlprovider__Map **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_edlprovider__Map **)soap_malloc(soap, sizeof(_edlprovider__Map *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_edlprovider__Map *)soap_instantiate__edlprovider__Map(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_edlprovider__Map ** p = (_edlprovider__Map **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__edlprovider__Map, sizeof(_edlprovider__Map), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_edlprovider__Map(struct soap *soap, _edlprovider__Map *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_edlprovider__Map);
	if (soap_out_PointerTo_edlprovider__Map(soap, tag?tag:"edlprovider:Map", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _edlprovider__Map ** SOAP_FMAC4 soap_get_PointerTo_edlprovider__Map(struct soap *soap, _edlprovider__Map **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_edlprovider__Map(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToxsd__base64Binary(struct soap *soap, xsd__base64Binary *const*a)
{
#ifndef WITH_NOIDREF
	if (*a)
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToxsd__base64Binary(struct soap *soap, const char *tag, int id, xsd__base64Binary *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, (struct soap_array*)(void*)&(*a)->__ptr, 1, type, SOAP_TYPE_xsd__base64Binary);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 xsd__base64Binary ** SOAP_FMAC4 soap_in_PointerToxsd__base64Binary(struct soap *soap, const char *tag, xsd__base64Binary **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (xsd__base64Binary **)soap_malloc(soap, sizeof(xsd__base64Binary *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (xsd__base64Binary *)soap_instantiate_xsd__base64Binary(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	xsd__base64Binary ** p = (xsd__base64Binary **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_xsd__base64Binary, sizeof(xsd__base64Binary), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToxsd__base64Binary(struct soap *soap, xsd__base64Binary *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToxsd__base64Binary);
	if (soap_out_PointerToxsd__base64Binary(soap, tag?tag:"xsd:base64Binary", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 xsd__base64Binary ** SOAP_FMAC4 soap_get_PointerToxsd__base64Binary(struct soap *soap, xsd__base64Binary **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToxsd__base64Binary(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTostd__wstring(struct soap *soap, std::wstring *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_std__wstring))
		soap_serialize_std__wstring(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTostd__wstring(struct soap *soap, const char *tag, int id, std::wstring *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_std__wstring);
	if (id < 0)
		return soap->error;
	return soap_out_std__wstring(soap, tag, id, *a, type);
}

SOAP_FMAC3 std::wstring ** SOAP_FMAC4 soap_in_PointerTostd__wstring(struct soap *soap, const char *tag, std::wstring **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (std::wstring **)soap_malloc(soap, sizeof(std::wstring *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_std__wstring(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (std::wstring **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_std__wstring, sizeof(std::wstring), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTostd__wstring(struct soap *soap, std::wstring *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTostd__wstring);
	if (soap_out_PointerTostd__wstring(soap, tag?tag:"string", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::wstring ** SOAP_FMAC4 soap_get_PointerTostd__wstring(struct soap *soap, std::wstring **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTostd__wstring(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToedlprovider__ArrayOfClips(struct soap *soap, edlprovider__ArrayOfClips *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_edlprovider__ArrayOfClips))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToedlprovider__ArrayOfClips(struct soap *soap, const char *tag, int id, edlprovider__ArrayOfClips *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_edlprovider__ArrayOfClips);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 edlprovider__ArrayOfClips ** SOAP_FMAC4 soap_in_PointerToedlprovider__ArrayOfClips(struct soap *soap, const char *tag, edlprovider__ArrayOfClips **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (edlprovider__ArrayOfClips **)soap_malloc(soap, sizeof(edlprovider__ArrayOfClips *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (edlprovider__ArrayOfClips *)soap_instantiate_edlprovider__ArrayOfClips(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	edlprovider__ArrayOfClips ** p = (edlprovider__ArrayOfClips **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_edlprovider__ArrayOfClips, sizeof(edlprovider__ArrayOfClips), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToedlprovider__ArrayOfClips(struct soap *soap, edlprovider__ArrayOfClips *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToedlprovider__ArrayOfClips);
	if (soap_out_PointerToedlprovider__ArrayOfClips(soap, tag?tag:"edlprovider:ArrayOfClips", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 edlprovider__ArrayOfClips ** SOAP_FMAC4 soap_get_PointerToedlprovider__ArrayOfClips(struct soap *soap, edlprovider__ArrayOfClips **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToedlprovider__ArrayOfClips(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTofims__BMObjectType(struct soap *soap, fims__BMObjectType *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_fims__BMObjectType))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTofims__BMObjectType(struct soap *soap, const char *tag, int id, fims__BMObjectType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_fims__BMObjectType);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 fims__BMObjectType ** SOAP_FMAC4 soap_in_PointerTofims__BMObjectType(struct soap *soap, const char *tag, fims__BMObjectType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (fims__BMObjectType **)soap_malloc(soap, sizeof(fims__BMObjectType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (fims__BMObjectType *)soap_instantiate_fims__BMObjectType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	fims__BMObjectType ** p = (fims__BMObjectType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_fims__BMObjectType, sizeof(fims__BMObjectType), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTofims__BMObjectType(struct soap *soap, fims__BMObjectType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTofims__BMObjectType);
	if (soap_out_PointerTofims__BMObjectType(soap, tag?tag:"fims:BMObjectType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 fims__BMObjectType ** SOAP_FMAC4 soap_get_PointerTofims__BMObjectType(struct soap *soap, fims__BMObjectType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTofims__BMObjectType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTofimstime__TimeType(struct soap *soap, fimstime__TimeType *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_fimstime__TimeType))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTofimstime__TimeType(struct soap *soap, const char *tag, int id, fimstime__TimeType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_fimstime__TimeType);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 fimstime__TimeType ** SOAP_FMAC4 soap_in_PointerTofimstime__TimeType(struct soap *soap, const char *tag, fimstime__TimeType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (fimstime__TimeType **)soap_malloc(soap, sizeof(fimstime__TimeType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (fimstime__TimeType *)soap_instantiate_fimstime__TimeType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	fimstime__TimeType ** p = (fimstime__TimeType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_fimstime__TimeType, sizeof(fimstime__TimeType), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTofimstime__TimeType(struct soap *soap, fimstime__TimeType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTofimstime__TimeType);
	if (soap_out_PointerTofimstime__TimeType(soap, tag?tag:"fimstime:TimeType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 fimstime__TimeType ** SOAP_FMAC4 soap_get_PointerTofimstime__TimeType(struct soap *soap, fimstime__TimeType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTofimstime__TimeType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToedlprovider__ClipType(struct soap *soap, edlprovider__ClipType *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_edlprovider__ClipType))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToedlprovider__ClipType(struct soap *soap, const char *tag, int id, edlprovider__ClipType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_edlprovider__ClipType);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 edlprovider__ClipType ** SOAP_FMAC4 soap_in_PointerToedlprovider__ClipType(struct soap *soap, const char *tag, edlprovider__ClipType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (edlprovider__ClipType **)soap_malloc(soap, sizeof(edlprovider__ClipType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (edlprovider__ClipType *)soap_instantiate_edlprovider__ClipType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	edlprovider__ClipType ** p = (edlprovider__ClipType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_edlprovider__ClipType, sizeof(edlprovider__ClipType), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToedlprovider__ClipType(struct soap *soap, edlprovider__ClipType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToedlprovider__ClipType);
	if (soap_out_PointerToedlprovider__ClipType(soap, tag?tag:"edlprovider:ClipType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 edlprovider__ClipType ** SOAP_FMAC4 soap_get_PointerToedlprovider__ClipType(struct soap *soap, edlprovider__ClipType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToedlprovider__ClipType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTounsignedByte(struct soap *soap, unsigned char *const*a)
{
#ifndef WITH_NOIDREF
	soap_reference(soap, *a, SOAP_TYPE_unsignedByte);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTounsignedByte(struct soap *soap, const char *tag, int id, unsigned char *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_unsignedByte);
	if (id < 0)
		return soap->error;
	return soap_out_unsignedByte(soap, tag, id, *a, type);
}

SOAP_FMAC3 unsigned char ** SOAP_FMAC4 soap_in_PointerTounsignedByte(struct soap *soap, const char *tag, unsigned char **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (unsigned char **)soap_malloc(soap, sizeof(unsigned char *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_unsignedByte(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (unsigned char **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_unsignedByte, sizeof(unsigned char), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTounsignedByte(struct soap *soap, unsigned char *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTounsignedByte);
	if (soap_out_PointerTounsignedByte(soap, tag?tag:"unsignedByte", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 unsigned char ** SOAP_FMAC4 soap_get_PointerTounsignedByte(struct soap *soap, unsigned char **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTounsignedByte(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__QName(struct soap *soap, char *const*a)
{
#ifndef WITH_NOIDREF
	soap_reference(soap, *a, SOAP_TYPE__QName);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__QName(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE__QName);
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in__QName(struct soap *soap, const char *tag, char **a, const char *type)
{	char **p;
	p = soap_instring(soap, tag, a, type, SOAP_TYPE__QName, 2, 0, -1);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__QName(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__QName);
	if (soap_out__QName(soap, tag?tag:"byte", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get__QName(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in__QName(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_string(struct soap *soap, char **a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_string
	*a = SOAP_DEFAULT_string;
#else
	*a = (char *)0;
#endif
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_string(struct soap *soap, char *const*a)
{
#ifndef WITH_NOIDREF
	soap_reference(soap, *a, SOAP_TYPE_string);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_string(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_string);
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in_string(struct soap *soap, const char *tag, char **a, const char *type)
{	char **p;
	p = soap_instring(soap, tag, a, type, SOAP_TYPE_string, 1, 0, -1);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_string(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_string);
	if (soap_out_string(soap, tag?tag:"byte", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_string(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in_string(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTofims__AncillaryDataFormatType(struct soap *soap, std::vector<fims__AncillaryDataFormatType * >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTofims__AncillaryDataFormatType(struct soap *soap, const std::vector<fims__AncillaryDataFormatType * >*a)
{
#ifndef WITH_NOIDREF
	for (std::vector<fims__AncillaryDataFormatType * >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTofims__AncillaryDataFormatType(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTofims__AncillaryDataFormatType(struct soap *soap, const char *tag, int id, const std::vector<fims__AncillaryDataFormatType * >*a, const char *type)
{
	for (std::vector<fims__AncillaryDataFormatType * >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTofims__AncillaryDataFormatType(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<fims__AncillaryDataFormatType * >* SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTofims__AncillaryDataFormatType(struct soap *soap, const char *tag, std::vector<fims__AncillaryDataFormatType * >*a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{	fims__AncillaryDataFormatType *n;
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href))
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_fims__AncillaryDataFormatType, SOAP_TYPE_std__vectorTemplateOfPointerTofims__AncillaryDataFormatType, sizeof(fims__AncillaryDataFormatType), 1))
				break;
			if (!soap_in_PointerTofims__AncillaryDataFormatType(soap, tag, NULL, "fims:AncillaryDataFormatType"))
				break;
		}
		else if (!soap_in_PointerTofims__AncillaryDataFormatType(soap, tag, &n, "fims:AncillaryDataFormatType"))
			break;
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTofims__AncillaryDataFormatType(soap, -1)))
			return NULL;
		a->push_back(n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<fims__AncillaryDataFormatType * > * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTofims__AncillaryDataFormatType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTofims__AncillaryDataFormatType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOfPointerTofims__AncillaryDataFormatType, n, EDLProvider_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(std::vector<fims__AncillaryDataFormatType * >);
		if (size)
			*size = sizeof(std::vector<fims__AncillaryDataFormatType * >);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(std::vector<fims__AncillaryDataFormatType * >, n);
		if (size)
			*size = n * sizeof(std::vector<fims__AncillaryDataFormatType * >);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (std::vector<fims__AncillaryDataFormatType * >*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfPointerTofims__AncillaryDataFormatType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<fims__AncillaryDataFormatType * > %p -> %p\n", q, p));
	*(std::vector<fims__AncillaryDataFormatType * >*)p = *(std::vector<fims__AncillaryDataFormatType * >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTofims__CaptioningFormatType(struct soap *soap, std::vector<fims__CaptioningFormatType * >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTofims__CaptioningFormatType(struct soap *soap, const std::vector<fims__CaptioningFormatType * >*a)
{
#ifndef WITH_NOIDREF
	for (std::vector<fims__CaptioningFormatType * >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTofims__CaptioningFormatType(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTofims__CaptioningFormatType(struct soap *soap, const char *tag, int id, const std::vector<fims__CaptioningFormatType * >*a, const char *type)
{
	for (std::vector<fims__CaptioningFormatType * >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTofims__CaptioningFormatType(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<fims__CaptioningFormatType * >* SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTofims__CaptioningFormatType(struct soap *soap, const char *tag, std::vector<fims__CaptioningFormatType * >*a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{	fims__CaptioningFormatType *n;
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href))
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_fims__CaptioningFormatType, SOAP_TYPE_std__vectorTemplateOfPointerTofims__CaptioningFormatType, sizeof(fims__CaptioningFormatType), 1))
				break;
			if (!soap_in_PointerTofims__CaptioningFormatType(soap, tag, NULL, "fims:CaptioningFormatType"))
				break;
		}
		else if (!soap_in_PointerTofims__CaptioningFormatType(soap, tag, &n, "fims:CaptioningFormatType"))
			break;
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTofims__CaptioningFormatType(soap, -1)))
			return NULL;
		a->push_back(n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<fims__CaptioningFormatType * > * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTofims__CaptioningFormatType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTofims__CaptioningFormatType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOfPointerTofims__CaptioningFormatType, n, EDLProvider_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(std::vector<fims__CaptioningFormatType * >);
		if (size)
			*size = sizeof(std::vector<fims__CaptioningFormatType * >);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(std::vector<fims__CaptioningFormatType * >, n);
		if (size)
			*size = n * sizeof(std::vector<fims__CaptioningFormatType * >);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (std::vector<fims__CaptioningFormatType * >*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfPointerTofims__CaptioningFormatType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<fims__CaptioningFormatType * > %p -> %p\n", q, p));
	*(std::vector<fims__CaptioningFormatType * >*)p = *(std::vector<fims__CaptioningFormatType * >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTofims__BMTrackType(struct soap *soap, std::vector<fims__BMTrackType * >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTofims__BMTrackType(struct soap *soap, const std::vector<fims__BMTrackType * >*a)
{
#ifndef WITH_NOIDREF
	for (std::vector<fims__BMTrackType * >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTofims__BMTrackType(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTofims__BMTrackType(struct soap *soap, const char *tag, int id, const std::vector<fims__BMTrackType * >*a, const char *type)
{
	for (std::vector<fims__BMTrackType * >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTofims__BMTrackType(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<fims__BMTrackType * >* SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTofims__BMTrackType(struct soap *soap, const char *tag, std::vector<fims__BMTrackType * >*a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{	fims__BMTrackType *n;
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href))
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_fims__BMTrackType, SOAP_TYPE_std__vectorTemplateOfPointerTofims__BMTrackType, sizeof(fims__BMTrackType), 1))
				break;
			if (!soap_in_PointerTofims__BMTrackType(soap, tag, NULL, "fims:BMTrackType"))
				break;
		}
		else if (!soap_in_PointerTofims__BMTrackType(soap, tag, &n, "fims:BMTrackType"))
			break;
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTofims__BMTrackType(soap, -1)))
			return NULL;
		a->push_back(n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<fims__BMTrackType * > * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTofims__BMTrackType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTofims__BMTrackType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOfPointerTofims__BMTrackType, n, EDLProvider_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(std::vector<fims__BMTrackType * >);
		if (size)
			*size = sizeof(std::vector<fims__BMTrackType * >);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(std::vector<fims__BMTrackType * >, n);
		if (size)
			*size = n * sizeof(std::vector<fims__BMTrackType * >);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (std::vector<fims__BMTrackType * >*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfPointerTofims__BMTrackType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<fims__BMTrackType * > %p -> %p\n", q, p));
	*(std::vector<fims__BMTrackType * >*)p = *(std::vector<fims__BMTrackType * >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTofims__TechnicalAttributeType(struct soap *soap, std::vector<fims__TechnicalAttributeType * >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTofims__TechnicalAttributeType(struct soap *soap, const std::vector<fims__TechnicalAttributeType * >*a)
{
#ifndef WITH_NOIDREF
	for (std::vector<fims__TechnicalAttributeType * >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTofims__TechnicalAttributeType(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTofims__TechnicalAttributeType(struct soap *soap, const char *tag, int id, const std::vector<fims__TechnicalAttributeType * >*a, const char *type)
{
	for (std::vector<fims__TechnicalAttributeType * >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTofims__TechnicalAttributeType(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<fims__TechnicalAttributeType * >* SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTofims__TechnicalAttributeType(struct soap *soap, const char *tag, std::vector<fims__TechnicalAttributeType * >*a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{	fims__TechnicalAttributeType *n;
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href))
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_fims__TechnicalAttributeType, SOAP_TYPE_std__vectorTemplateOfPointerTofims__TechnicalAttributeType, sizeof(fims__TechnicalAttributeType), 1))
				break;
			if (!soap_in_PointerTofims__TechnicalAttributeType(soap, tag, NULL, "fims:TechnicalAttributeType"))
				break;
		}
		else if (!soap_in_PointerTofims__TechnicalAttributeType(soap, tag, &n, "fims:TechnicalAttributeType"))
			break;
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTofims__TechnicalAttributeType(soap, -1)))
			return NULL;
		a->push_back(n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<fims__TechnicalAttributeType * > * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTofims__TechnicalAttributeType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTofims__TechnicalAttributeType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOfPointerTofims__TechnicalAttributeType, n, EDLProvider_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(std::vector<fims__TechnicalAttributeType * >);
		if (size)
			*size = sizeof(std::vector<fims__TechnicalAttributeType * >);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(std::vector<fims__TechnicalAttributeType * >, n);
		if (size)
			*size = n * sizeof(std::vector<fims__TechnicalAttributeType * >);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (std::vector<fims__TechnicalAttributeType * >*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfPointerTofims__TechnicalAttributeType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<fims__TechnicalAttributeType * > %p -> %p\n", q, p));
	*(std::vector<fims__TechnicalAttributeType * >*)p = *(std::vector<fims__TechnicalAttributeType * >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOffims__UID(struct soap *soap, std::vector<std::wstring >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOffims__UID(struct soap *soap, const std::vector<std::wstring >*a)
{
#ifndef WITH_NOIDREF
	for (std::vector<std::wstring >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_fims__UID(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOffims__UID(struct soap *soap, const char *tag, int id, const std::vector<std::wstring >*a, const char *type)
{
	for (std::vector<std::wstring >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_fims__UID(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<std::wstring >* SOAP_FMAC4 soap_in_std__vectorTemplateOffims__UID(struct soap *soap, const char *tag, std::vector<std::wstring >*a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{	std::wstring n;
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		soap_default_fims__UID(soap, &n);
		if (tag && *tag != '-' && (*soap->id || *soap->href))
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_fims__UID, SOAP_TYPE_std__vectorTemplateOffims__UID, sizeof(std::wstring), 0))
				break;
			if (!soap_in_fims__UID(soap, tag, NULL, "fims:UID"))
				break;
		}
		else if (!soap_in_fims__UID(soap, tag, &n, "fims:UID"))
			break;
		if (!a && !(a = soap_new_std__vectorTemplateOffims__UID(soap, -1)))
			return NULL;
		soap_update_pointers(soap, (char*)&n, (char*)&n + sizeof(n), (char*)&(*a->insert(a->end(), n)), (char*)&n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<std::wstring > * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOffims__UID(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOffims__UID(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOffims__UID, n, EDLProvider_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(std::vector<std::wstring >);
		if (size)
			*size = sizeof(std::vector<std::wstring >);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(std::vector<std::wstring >, n);
		if (size)
			*size = n * sizeof(std::vector<std::wstring >);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (std::vector<std::wstring >*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOffims__UID(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<std::wstring > %p -> %p\n", q, p));
	*(std::vector<std::wstring >*)p = *(std::vector<std::wstring >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfxsd__anyURI(struct soap *soap, std::vector<std::wstring >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfxsd__anyURI(struct soap *soap, const std::vector<std::wstring >*a)
{
#ifndef WITH_NOIDREF
	for (std::vector<std::wstring >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_xsd__anyURI(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfxsd__anyURI(struct soap *soap, const char *tag, int id, const std::vector<std::wstring >*a, const char *type)
{
	for (std::vector<std::wstring >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_xsd__anyURI(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<std::wstring >* SOAP_FMAC4 soap_in_std__vectorTemplateOfxsd__anyURI(struct soap *soap, const char *tag, std::vector<std::wstring >*a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{	std::wstring n;
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		soap_default_xsd__anyURI(soap, &n);
		if (tag && *tag != '-' && (*soap->id || *soap->href))
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_xsd__anyURI, SOAP_TYPE_std__vectorTemplateOfxsd__anyURI, sizeof(std::wstring), 0))
				break;
			if (!soap_in_xsd__anyURI(soap, tag, NULL, "xsd:anyURI"))
				break;
		}
		else if (!soap_in_xsd__anyURI(soap, tag, &n, "xsd:anyURI"))
			break;
		if (!a && !(a = soap_new_std__vectorTemplateOfxsd__anyURI(soap, -1)))
			return NULL;
		soap_update_pointers(soap, (char*)&n, (char*)&n + sizeof(n), (char*)&(*a->insert(a->end(), n)), (char*)&n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<std::wstring > * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfxsd__anyURI(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfxsd__anyURI(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOfxsd__anyURI, n, EDLProvider_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(std::vector<std::wstring >);
		if (size)
			*size = sizeof(std::vector<std::wstring >);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(std::vector<std::wstring >, n);
		if (size)
			*size = n * sizeof(std::vector<std::wstring >);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (std::vector<std::wstring >*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfxsd__anyURI(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<std::wstring > %p -> %p\n", q, p));
	*(std::vector<std::wstring >*)p = *(std::vector<std::wstring >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTofimsdescription__detailsType(struct soap *soap, std::vector<fimsdescription__detailsType * >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTofimsdescription__detailsType(struct soap *soap, const std::vector<fimsdescription__detailsType * >*a)
{
#ifndef WITH_NOIDREF
	for (std::vector<fimsdescription__detailsType * >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTofimsdescription__detailsType(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTofimsdescription__detailsType(struct soap *soap, const char *tag, int id, const std::vector<fimsdescription__detailsType * >*a, const char *type)
{
	for (std::vector<fimsdescription__detailsType * >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTofimsdescription__detailsType(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<fimsdescription__detailsType * >* SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTofimsdescription__detailsType(struct soap *soap, const char *tag, std::vector<fimsdescription__detailsType * >*a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{	fimsdescription__detailsType *n;
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href))
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_fimsdescription__detailsType, SOAP_TYPE_std__vectorTemplateOfPointerTofimsdescription__detailsType, sizeof(fimsdescription__detailsType), 1))
				break;
			if (!soap_in_PointerTofimsdescription__detailsType(soap, tag, NULL, "fimsdescription:detailsType"))
				break;
		}
		else if (!soap_in_PointerTofimsdescription__detailsType(soap, tag, &n, "fimsdescription:detailsType"))
			break;
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTofimsdescription__detailsType(soap, -1)))
			return NULL;
		a->push_back(n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<fimsdescription__detailsType * > * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTofimsdescription__detailsType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTofimsdescription__detailsType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOfPointerTofimsdescription__detailsType, n, EDLProvider_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(std::vector<fimsdescription__detailsType * >);
		if (size)
			*size = sizeof(std::vector<fimsdescription__detailsType * >);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(std::vector<fimsdescription__detailsType * >, n);
		if (size)
			*size = n * sizeof(std::vector<fimsdescription__detailsType * >);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (std::vector<fimsdescription__detailsType * >*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfPointerTofimsdescription__detailsType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<fimsdescription__detailsType * > %p -> %p\n", q, p));
	*(std::vector<fimsdescription__detailsType * >*)p = *(std::vector<fimsdescription__detailsType * >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOf_fimsdescription__entityType_role(struct soap *soap, std::vector<_fimsdescription__entityType_role >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOf_fimsdescription__entityType_role(struct soap *soap, const std::vector<_fimsdescription__entityType_role >*a)
{
#ifndef WITH_NOIDREF
	for (std::vector<_fimsdescription__entityType_role >::const_iterator i = a->begin(); i != a->end(); ++i)
		(*i).soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOf_fimsdescription__entityType_role(struct soap *soap, const char *tag, int id, const std::vector<_fimsdescription__entityType_role >*a, const char *type)
{
	for (std::vector<_fimsdescription__entityType_role >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if ((*i).soap_out(soap, tag, id, ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<_fimsdescription__entityType_role >* SOAP_FMAC4 soap_in_std__vectorTemplateOf_fimsdescription__entityType_role(struct soap *soap, const char *tag, std::vector<_fimsdescription__entityType_role >*a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{	_fimsdescription__entityType_role n;
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		n.soap_default(soap);
		if (tag && *tag != '-' && (*soap->id || *soap->href))
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE__fimsdescription__entityType_role, SOAP_TYPE_std__vectorTemplateOf_fimsdescription__entityType_role, sizeof(_fimsdescription__entityType_role), 0))
				break;
			if (!soap_in__fimsdescription__entityType_role(soap, tag, NULL, ""))
				break;
		}
		else if (!soap_in__fimsdescription__entityType_role(soap, tag, &n, ""))
			break;
		if (!a && !(a = soap_new_std__vectorTemplateOf_fimsdescription__entityType_role(soap, -1)))
			return NULL;
		soap_update_pointers(soap, (char*)&n, (char*)&n + sizeof(n), (char*)&(*a->insert(a->end(), n)), (char*)&n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<_fimsdescription__entityType_role > * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOf_fimsdescription__entityType_role(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOf_fimsdescription__entityType_role(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOf_fimsdescription__entityType_role, n, EDLProvider_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(std::vector<_fimsdescription__entityType_role >);
		if (size)
			*size = sizeof(std::vector<_fimsdescription__entityType_role >);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(std::vector<_fimsdescription__entityType_role >, n);
		if (size)
			*size = n * sizeof(std::vector<_fimsdescription__entityType_role >);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (std::vector<_fimsdescription__entityType_role >*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOf_fimsdescription__entityType_role(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<_fimsdescription__entityType_role > %p -> %p\n", q, p));
	*(std::vector<_fimsdescription__entityType_role >*)p = *(std::vector<_fimsdescription__entityType_role >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTofimsdescription__organisationDetailsType(struct soap *soap, std::vector<fimsdescription__organisationDetailsType * >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTofimsdescription__organisationDetailsType(struct soap *soap, const std::vector<fimsdescription__organisationDetailsType * >*a)
{
#ifndef WITH_NOIDREF
	for (std::vector<fimsdescription__organisationDetailsType * >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTofimsdescription__organisationDetailsType(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTofimsdescription__organisationDetailsType(struct soap *soap, const char *tag, int id, const std::vector<fimsdescription__organisationDetailsType * >*a, const char *type)
{
	for (std::vector<fimsdescription__organisationDetailsType * >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTofimsdescription__organisationDetailsType(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<fimsdescription__organisationDetailsType * >* SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTofimsdescription__organisationDetailsType(struct soap *soap, const char *tag, std::vector<fimsdescription__organisationDetailsType * >*a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{	fimsdescription__organisationDetailsType *n;
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href))
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_fimsdescription__organisationDetailsType, SOAP_TYPE_std__vectorTemplateOfPointerTofimsdescription__organisationDetailsType, sizeof(fimsdescription__organisationDetailsType), 1))
				break;
			if (!soap_in_PointerTofimsdescription__organisationDetailsType(soap, tag, NULL, "fimsdescription:organisationDetailsType"))
				break;
		}
		else if (!soap_in_PointerTofimsdescription__organisationDetailsType(soap, tag, &n, "fimsdescription:organisationDetailsType"))
			break;
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTofimsdescription__organisationDetailsType(soap, -1)))
			return NULL;
		a->push_back(n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<fimsdescription__organisationDetailsType * > * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTofimsdescription__organisationDetailsType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTofimsdescription__organisationDetailsType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOfPointerTofimsdescription__organisationDetailsType, n, EDLProvider_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(std::vector<fimsdescription__organisationDetailsType * >);
		if (size)
			*size = sizeof(std::vector<fimsdescription__organisationDetailsType * >);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(std::vector<fimsdescription__organisationDetailsType * >, n);
		if (size)
			*size = n * sizeof(std::vector<fimsdescription__organisationDetailsType * >);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (std::vector<fimsdescription__organisationDetailsType * >*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfPointerTofimsdescription__organisationDetailsType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<fimsdescription__organisationDetailsType * > %p -> %p\n", q, p));
	*(std::vector<fimsdescription__organisationDetailsType * >*)p = *(std::vector<fimsdescription__organisationDetailsType * >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTofimsdescription__contactDetailsType(struct soap *soap, std::vector<fimsdescription__contactDetailsType * >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTofimsdescription__contactDetailsType(struct soap *soap, const std::vector<fimsdescription__contactDetailsType * >*a)
{
#ifndef WITH_NOIDREF
	for (std::vector<fimsdescription__contactDetailsType * >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTofimsdescription__contactDetailsType(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTofimsdescription__contactDetailsType(struct soap *soap, const char *tag, int id, const std::vector<fimsdescription__contactDetailsType * >*a, const char *type)
{
	for (std::vector<fimsdescription__contactDetailsType * >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTofimsdescription__contactDetailsType(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<fimsdescription__contactDetailsType * >* SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTofimsdescription__contactDetailsType(struct soap *soap, const char *tag, std::vector<fimsdescription__contactDetailsType * >*a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{	fimsdescription__contactDetailsType *n;
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href))
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_fimsdescription__contactDetailsType, SOAP_TYPE_std__vectorTemplateOfPointerTofimsdescription__contactDetailsType, sizeof(fimsdescription__contactDetailsType), 1))
				break;
			if (!soap_in_PointerTofimsdescription__contactDetailsType(soap, tag, NULL, "fimsdescription:contactDetailsType"))
				break;
		}
		else if (!soap_in_PointerTofimsdescription__contactDetailsType(soap, tag, &n, "fimsdescription:contactDetailsType"))
			break;
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTofimsdescription__contactDetailsType(soap, -1)))
			return NULL;
		a->push_back(n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<fimsdescription__contactDetailsType * > * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTofimsdescription__contactDetailsType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTofimsdescription__contactDetailsType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOfPointerTofimsdescription__contactDetailsType, n, EDLProvider_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(std::vector<fimsdescription__contactDetailsType * >);
		if (size)
			*size = sizeof(std::vector<fimsdescription__contactDetailsType * >);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(std::vector<fimsdescription__contactDetailsType * >, n);
		if (size)
			*size = n * sizeof(std::vector<fimsdescription__contactDetailsType * >);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (std::vector<fimsdescription__contactDetailsType * >*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfPointerTofimsdescription__contactDetailsType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<fimsdescription__contactDetailsType * > %p -> %p\n", q, p));
	*(std::vector<fimsdescription__contactDetailsType * >*)p = *(std::vector<fimsdescription__contactDetailsType * >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOf_fimsdescription__typeType_targetAudience(struct soap *soap, std::vector<_fimsdescription__typeType_targetAudience >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOf_fimsdescription__typeType_targetAudience(struct soap *soap, const std::vector<_fimsdescription__typeType_targetAudience >*a)
{
#ifndef WITH_NOIDREF
	for (std::vector<_fimsdescription__typeType_targetAudience >::const_iterator i = a->begin(); i != a->end(); ++i)
		(*i).soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOf_fimsdescription__typeType_targetAudience(struct soap *soap, const char *tag, int id, const std::vector<_fimsdescription__typeType_targetAudience >*a, const char *type)
{
	for (std::vector<_fimsdescription__typeType_targetAudience >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if ((*i).soap_out(soap, tag, id, ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<_fimsdescription__typeType_targetAudience >* SOAP_FMAC4 soap_in_std__vectorTemplateOf_fimsdescription__typeType_targetAudience(struct soap *soap, const char *tag, std::vector<_fimsdescription__typeType_targetAudience >*a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{	_fimsdescription__typeType_targetAudience n;
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		n.soap_default(soap);
		if (tag && *tag != '-' && (*soap->id || *soap->href))
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE__fimsdescription__typeType_targetAudience, SOAP_TYPE_std__vectorTemplateOf_fimsdescription__typeType_targetAudience, sizeof(_fimsdescription__typeType_targetAudience), 0))
				break;
			if (!soap_in__fimsdescription__typeType_targetAudience(soap, tag, NULL, ""))
				break;
		}
		else if (!soap_in__fimsdescription__typeType_targetAudience(soap, tag, &n, ""))
			break;
		if (!a && !(a = soap_new_std__vectorTemplateOf_fimsdescription__typeType_targetAudience(soap, -1)))
			return NULL;
		soap_update_pointers(soap, (char*)&n, (char*)&n + sizeof(n), (char*)&(*a->insert(a->end(), n)), (char*)&n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<_fimsdescription__typeType_targetAudience > * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOf_fimsdescription__typeType_targetAudience(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOf_fimsdescription__typeType_targetAudience(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOf_fimsdescription__typeType_targetAudience, n, EDLProvider_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(std::vector<_fimsdescription__typeType_targetAudience >);
		if (size)
			*size = sizeof(std::vector<_fimsdescription__typeType_targetAudience >);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(std::vector<_fimsdescription__typeType_targetAudience >, n);
		if (size)
			*size = n * sizeof(std::vector<_fimsdescription__typeType_targetAudience >);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (std::vector<_fimsdescription__typeType_targetAudience >*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOf_fimsdescription__typeType_targetAudience(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<_fimsdescription__typeType_targetAudience > %p -> %p\n", q, p));
	*(std::vector<_fimsdescription__typeType_targetAudience >*)p = *(std::vector<_fimsdescription__typeType_targetAudience >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOf_fimsdescription__typeType_objectType(struct soap *soap, std::vector<_fimsdescription__typeType_objectType >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOf_fimsdescription__typeType_objectType(struct soap *soap, const std::vector<_fimsdescription__typeType_objectType >*a)
{
#ifndef WITH_NOIDREF
	for (std::vector<_fimsdescription__typeType_objectType >::const_iterator i = a->begin(); i != a->end(); ++i)
		(*i).soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOf_fimsdescription__typeType_objectType(struct soap *soap, const char *tag, int id, const std::vector<_fimsdescription__typeType_objectType >*a, const char *type)
{
	for (std::vector<_fimsdescription__typeType_objectType >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if ((*i).soap_out(soap, tag, id, ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<_fimsdescription__typeType_objectType >* SOAP_FMAC4 soap_in_std__vectorTemplateOf_fimsdescription__typeType_objectType(struct soap *soap, const char *tag, std::vector<_fimsdescription__typeType_objectType >*a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{	_fimsdescription__typeType_objectType n;
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		n.soap_default(soap);
		if (tag && *tag != '-' && (*soap->id || *soap->href))
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE__fimsdescription__typeType_objectType, SOAP_TYPE_std__vectorTemplateOf_fimsdescription__typeType_objectType, sizeof(_fimsdescription__typeType_objectType), 0))
				break;
			if (!soap_in__fimsdescription__typeType_objectType(soap, tag, NULL, ""))
				break;
		}
		else if (!soap_in__fimsdescription__typeType_objectType(soap, tag, &n, ""))
			break;
		if (!a && !(a = soap_new_std__vectorTemplateOf_fimsdescription__typeType_objectType(soap, -1)))
			return NULL;
		soap_update_pointers(soap, (char*)&n, (char*)&n + sizeof(n), (char*)&(*a->insert(a->end(), n)), (char*)&n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<_fimsdescription__typeType_objectType > * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOf_fimsdescription__typeType_objectType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOf_fimsdescription__typeType_objectType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOf_fimsdescription__typeType_objectType, n, EDLProvider_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(std::vector<_fimsdescription__typeType_objectType >);
		if (size)
			*size = sizeof(std::vector<_fimsdescription__typeType_objectType >);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(std::vector<_fimsdescription__typeType_objectType >, n);
		if (size)
			*size = n * sizeof(std::vector<_fimsdescription__typeType_objectType >);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (std::vector<_fimsdescription__typeType_objectType >*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOf_fimsdescription__typeType_objectType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<_fimsdescription__typeType_objectType > %p -> %p\n", q, p));
	*(std::vector<_fimsdescription__typeType_objectType >*)p = *(std::vector<_fimsdescription__typeType_objectType >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOf_fimsdescription__typeType_genre(struct soap *soap, std::vector<_fimsdescription__typeType_genre >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOf_fimsdescription__typeType_genre(struct soap *soap, const std::vector<_fimsdescription__typeType_genre >*a)
{
#ifndef WITH_NOIDREF
	for (std::vector<_fimsdescription__typeType_genre >::const_iterator i = a->begin(); i != a->end(); ++i)
		(*i).soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOf_fimsdescription__typeType_genre(struct soap *soap, const char *tag, int id, const std::vector<_fimsdescription__typeType_genre >*a, const char *type)
{
	for (std::vector<_fimsdescription__typeType_genre >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if ((*i).soap_out(soap, tag, id, ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<_fimsdescription__typeType_genre >* SOAP_FMAC4 soap_in_std__vectorTemplateOf_fimsdescription__typeType_genre(struct soap *soap, const char *tag, std::vector<_fimsdescription__typeType_genre >*a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{	_fimsdescription__typeType_genre n;
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		n.soap_default(soap);
		if (tag && *tag != '-' && (*soap->id || *soap->href))
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE__fimsdescription__typeType_genre, SOAP_TYPE_std__vectorTemplateOf_fimsdescription__typeType_genre, sizeof(_fimsdescription__typeType_genre), 0))
				break;
			if (!soap_in__fimsdescription__typeType_genre(soap, tag, NULL, ""))
				break;
		}
		else if (!soap_in__fimsdescription__typeType_genre(soap, tag, &n, ""))
			break;
		if (!a && !(a = soap_new_std__vectorTemplateOf_fimsdescription__typeType_genre(soap, -1)))
			return NULL;
		soap_update_pointers(soap, (char*)&n, (char*)&n + sizeof(n), (char*)&(*a->insert(a->end(), n)), (char*)&n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<_fimsdescription__typeType_genre > * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOf_fimsdescription__typeType_genre(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOf_fimsdescription__typeType_genre(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOf_fimsdescription__typeType_genre, n, EDLProvider_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(std::vector<_fimsdescription__typeType_genre >);
		if (size)
			*size = sizeof(std::vector<_fimsdescription__typeType_genre >);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(std::vector<_fimsdescription__typeType_genre >, n);
		if (size)
			*size = n * sizeof(std::vector<_fimsdescription__typeType_genre >);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (std::vector<_fimsdescription__typeType_genre >*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOf_fimsdescription__typeType_genre(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<_fimsdescription__typeType_genre > %p -> %p\n", q, p));
	*(std::vector<_fimsdescription__typeType_genre >*)p = *(std::vector<_fimsdescription__typeType_genre >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTofimsdescription__partType(struct soap *soap, std::vector<fimsdescription__partType * >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTofimsdescription__partType(struct soap *soap, const std::vector<fimsdescription__partType * >*a)
{
#ifndef WITH_NOIDREF
	for (std::vector<fimsdescription__partType * >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTofimsdescription__partType(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTofimsdescription__partType(struct soap *soap, const char *tag, int id, const std::vector<fimsdescription__partType * >*a, const char *type)
{
	for (std::vector<fimsdescription__partType * >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTofimsdescription__partType(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<fimsdescription__partType * >* SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTofimsdescription__partType(struct soap *soap, const char *tag, std::vector<fimsdescription__partType * >*a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{	fimsdescription__partType *n;
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href))
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_fimsdescription__partType, SOAP_TYPE_std__vectorTemplateOfPointerTofimsdescription__partType, sizeof(fimsdescription__partType), 1))
				break;
			if (!soap_in_PointerTofimsdescription__partType(soap, tag, NULL, "fimsdescription:partType"))
				break;
		}
		else if (!soap_in_PointerTofimsdescription__partType(soap, tag, &n, "fimsdescription:partType"))
			break;
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTofimsdescription__partType(soap, -1)))
			return NULL;
		a->push_back(n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<fimsdescription__partType * > * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTofimsdescription__partType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTofimsdescription__partType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOfPointerTofimsdescription__partType, n, EDLProvider_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(std::vector<fimsdescription__partType * >);
		if (size)
			*size = sizeof(std::vector<fimsdescription__partType * >);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(std::vector<fimsdescription__partType * >, n);
		if (size)
			*size = n * sizeof(std::vector<fimsdescription__partType * >);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (std::vector<fimsdescription__partType * >*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfPointerTofimsdescription__partType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<fimsdescription__partType * > %p -> %p\n", q, p));
	*(std::vector<fimsdescription__partType * >*)p = *(std::vector<fimsdescription__partType * >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTofimsdescription__rightsType(struct soap *soap, std::vector<fimsdescription__rightsType * >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTofimsdescription__rightsType(struct soap *soap, const std::vector<fimsdescription__rightsType * >*a)
{
#ifndef WITH_NOIDREF
	for (std::vector<fimsdescription__rightsType * >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTofimsdescription__rightsType(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTofimsdescription__rightsType(struct soap *soap, const char *tag, int id, const std::vector<fimsdescription__rightsType * >*a, const char *type)
{
	for (std::vector<fimsdescription__rightsType * >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTofimsdescription__rightsType(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<fimsdescription__rightsType * >* SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTofimsdescription__rightsType(struct soap *soap, const char *tag, std::vector<fimsdescription__rightsType * >*a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{	fimsdescription__rightsType *n;
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href))
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_fimsdescription__rightsType, SOAP_TYPE_std__vectorTemplateOfPointerTofimsdescription__rightsType, sizeof(fimsdescription__rightsType), 1))
				break;
			if (!soap_in_PointerTofimsdescription__rightsType(soap, tag, NULL, "fimsdescription:rightsType"))
				break;
		}
		else if (!soap_in_PointerTofimsdescription__rightsType(soap, tag, &n, "fimsdescription:rightsType"))
			break;
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTofimsdescription__rightsType(soap, -1)))
			return NULL;
		a->push_back(n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<fimsdescription__rightsType * > * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTofimsdescription__rightsType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTofimsdescription__rightsType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOfPointerTofimsdescription__rightsType, n, EDLProvider_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(std::vector<fimsdescription__rightsType * >);
		if (size)
			*size = sizeof(std::vector<fimsdescription__rightsType * >);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(std::vector<fimsdescription__rightsType * >, n);
		if (size)
			*size = n * sizeof(std::vector<fimsdescription__rightsType * >);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (std::vector<fimsdescription__rightsType * >*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfPointerTofimsdescription__rightsType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<fimsdescription__rightsType * > %p -> %p\n", q, p));
	*(std::vector<fimsdescription__rightsType * >*)p = *(std::vector<fimsdescription__rightsType * >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTofimsdescription__coverageType(struct soap *soap, std::vector<fimsdescription__coverageType * >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTofimsdescription__coverageType(struct soap *soap, const std::vector<fimsdescription__coverageType * >*a)
{
#ifndef WITH_NOIDREF
	for (std::vector<fimsdescription__coverageType * >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTofimsdescription__coverageType(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTofimsdescription__coverageType(struct soap *soap, const char *tag, int id, const std::vector<fimsdescription__coverageType * >*a, const char *type)
{
	for (std::vector<fimsdescription__coverageType * >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTofimsdescription__coverageType(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<fimsdescription__coverageType * >* SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTofimsdescription__coverageType(struct soap *soap, const char *tag, std::vector<fimsdescription__coverageType * >*a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{	fimsdescription__coverageType *n;
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href))
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_fimsdescription__coverageType, SOAP_TYPE_std__vectorTemplateOfPointerTofimsdescription__coverageType, sizeof(fimsdescription__coverageType), 1))
				break;
			if (!soap_in_PointerTofimsdescription__coverageType(soap, tag, NULL, "fimsdescription:coverageType"))
				break;
		}
		else if (!soap_in_PointerTofimsdescription__coverageType(soap, tag, &n, "fimsdescription:coverageType"))
			break;
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTofimsdescription__coverageType(soap, -1)))
			return NULL;
		a->push_back(n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<fimsdescription__coverageType * > * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTofimsdescription__coverageType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTofimsdescription__coverageType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOfPointerTofimsdescription__coverageType, n, EDLProvider_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(std::vector<fimsdescription__coverageType * >);
		if (size)
			*size = sizeof(std::vector<fimsdescription__coverageType * >);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(std::vector<fimsdescription__coverageType * >, n);
		if (size)
			*size = n * sizeof(std::vector<fimsdescription__coverageType * >);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (std::vector<fimsdescription__coverageType * >*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfPointerTofimsdescription__coverageType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<fimsdescription__coverageType * > %p -> %p\n", q, p));
	*(std::vector<fimsdescription__coverageType * >*)p = *(std::vector<fimsdescription__coverageType * >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTofimsdescription__relationType(struct soap *soap, std::vector<fimsdescription__relationType * >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTofimsdescription__relationType(struct soap *soap, const std::vector<fimsdescription__relationType * >*a)
{
#ifndef WITH_NOIDREF
	for (std::vector<fimsdescription__relationType * >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTofimsdescription__relationType(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTofimsdescription__relationType(struct soap *soap, const char *tag, int id, const std::vector<fimsdescription__relationType * >*a, const char *type)
{
	for (std::vector<fimsdescription__relationType * >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTofimsdescription__relationType(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<fimsdescription__relationType * >* SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTofimsdescription__relationType(struct soap *soap, const char *tag, std::vector<fimsdescription__relationType * >*a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{	fimsdescription__relationType *n;
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href))
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_fimsdescription__relationType, SOAP_TYPE_std__vectorTemplateOfPointerTofimsdescription__relationType, sizeof(fimsdescription__relationType), 1))
				break;
			if (!soap_in_PointerTofimsdescription__relationType(soap, tag, NULL, "fimsdescription:relationType"))
				break;
		}
		else if (!soap_in_PointerTofimsdescription__relationType(soap, tag, &n, "fimsdescription:relationType"))
			break;
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTofimsdescription__relationType(soap, -1)))
			return NULL;
		a->push_back(n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<fimsdescription__relationType * > * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTofimsdescription__relationType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTofimsdescription__relationType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOfPointerTofimsdescription__relationType, n, EDLProvider_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(std::vector<fimsdescription__relationType * >);
		if (size)
			*size = sizeof(std::vector<fimsdescription__relationType * >);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(std::vector<fimsdescription__relationType * >, n);
		if (size)
			*size = n * sizeof(std::vector<fimsdescription__relationType * >);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (std::vector<fimsdescription__relationType * >*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfPointerTofimsdescription__relationType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<fimsdescription__relationType * > %p -> %p\n", q, p));
	*(std::vector<fimsdescription__relationType * >*)p = *(std::vector<fimsdescription__relationType * >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTofimsdescription__languageType(struct soap *soap, std::vector<fimsdescription__languageType * >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTofimsdescription__languageType(struct soap *soap, const std::vector<fimsdescription__languageType * >*a)
{
#ifndef WITH_NOIDREF
	for (std::vector<fimsdescription__languageType * >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTofimsdescription__languageType(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTofimsdescription__languageType(struct soap *soap, const char *tag, int id, const std::vector<fimsdescription__languageType * >*a, const char *type)
{
	for (std::vector<fimsdescription__languageType * >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTofimsdescription__languageType(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<fimsdescription__languageType * >* SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTofimsdescription__languageType(struct soap *soap, const char *tag, std::vector<fimsdescription__languageType * >*a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{	fimsdescription__languageType *n;
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href))
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_fimsdescription__languageType, SOAP_TYPE_std__vectorTemplateOfPointerTofimsdescription__languageType, sizeof(fimsdescription__languageType), 1))
				break;
			if (!soap_in_PointerTofimsdescription__languageType(soap, tag, NULL, "fimsdescription:languageType"))
				break;
		}
		else if (!soap_in_PointerTofimsdescription__languageType(soap, tag, &n, "fimsdescription:languageType"))
			break;
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTofimsdescription__languageType(soap, -1)))
			return NULL;
		a->push_back(n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<fimsdescription__languageType * > * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTofimsdescription__languageType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTofimsdescription__languageType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOfPointerTofimsdescription__languageType, n, EDLProvider_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(std::vector<fimsdescription__languageType * >);
		if (size)
			*size = sizeof(std::vector<fimsdescription__languageType * >);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(std::vector<fimsdescription__languageType * >, n);
		if (size)
			*size = n * sizeof(std::vector<fimsdescription__languageType * >);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (std::vector<fimsdescription__languageType * >*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfPointerTofimsdescription__languageType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<fimsdescription__languageType * > %p -> %p\n", q, p));
	*(std::vector<fimsdescription__languageType * >*)p = *(std::vector<fimsdescription__languageType * >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTofimsdescription__identifierType(struct soap *soap, std::vector<fimsdescription__identifierType * >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTofimsdescription__identifierType(struct soap *soap, const std::vector<fimsdescription__identifierType * >*a)
{
#ifndef WITH_NOIDREF
	for (std::vector<fimsdescription__identifierType * >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTofimsdescription__identifierType(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTofimsdescription__identifierType(struct soap *soap, const char *tag, int id, const std::vector<fimsdescription__identifierType * >*a, const char *type)
{
	for (std::vector<fimsdescription__identifierType * >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTofimsdescription__identifierType(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<fimsdescription__identifierType * >* SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTofimsdescription__identifierType(struct soap *soap, const char *tag, std::vector<fimsdescription__identifierType * >*a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{	fimsdescription__identifierType *n;
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href))
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_fimsdescription__identifierType, SOAP_TYPE_std__vectorTemplateOfPointerTofimsdescription__identifierType, sizeof(fimsdescription__identifierType), 1))
				break;
			if (!soap_in_PointerTofimsdescription__identifierType(soap, tag, NULL, "fimsdescription:identifierType"))
				break;
		}
		else if (!soap_in_PointerTofimsdescription__identifierType(soap, tag, &n, "fimsdescription:identifierType"))
			break;
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTofimsdescription__identifierType(soap, -1)))
			return NULL;
		a->push_back(n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<fimsdescription__identifierType * > * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTofimsdescription__identifierType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTofimsdescription__identifierType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOfPointerTofimsdescription__identifierType, n, EDLProvider_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(std::vector<fimsdescription__identifierType * >);
		if (size)
			*size = sizeof(std::vector<fimsdescription__identifierType * >);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(std::vector<fimsdescription__identifierType * >, n);
		if (size)
			*size = n * sizeof(std::vector<fimsdescription__identifierType * >);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (std::vector<fimsdescription__identifierType * >*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfPointerTofimsdescription__identifierType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<fimsdescription__identifierType * > %p -> %p\n", q, p));
	*(std::vector<fimsdescription__identifierType * >*)p = *(std::vector<fimsdescription__identifierType * >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTofimsdescription__typeType(struct soap *soap, std::vector<fimsdescription__typeType * >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTofimsdescription__typeType(struct soap *soap, const std::vector<fimsdescription__typeType * >*a)
{
#ifndef WITH_NOIDREF
	for (std::vector<fimsdescription__typeType * >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTofimsdescription__typeType(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTofimsdescription__typeType(struct soap *soap, const char *tag, int id, const std::vector<fimsdescription__typeType * >*a, const char *type)
{
	for (std::vector<fimsdescription__typeType * >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTofimsdescription__typeType(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<fimsdescription__typeType * >* SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTofimsdescription__typeType(struct soap *soap, const char *tag, std::vector<fimsdescription__typeType * >*a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{	fimsdescription__typeType *n;
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href))
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_fimsdescription__typeType, SOAP_TYPE_std__vectorTemplateOfPointerTofimsdescription__typeType, sizeof(fimsdescription__typeType), 1))
				break;
			if (!soap_in_PointerTofimsdescription__typeType(soap, tag, NULL, "fimsdescription:typeType"))
				break;
		}
		else if (!soap_in_PointerTofimsdescription__typeType(soap, tag, &n, "fimsdescription:typeType"))
			break;
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTofimsdescription__typeType(soap, -1)))
			return NULL;
		a->push_back(n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<fimsdescription__typeType * > * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTofimsdescription__typeType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTofimsdescription__typeType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOfPointerTofimsdescription__typeType, n, EDLProvider_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(std::vector<fimsdescription__typeType * >);
		if (size)
			*size = sizeof(std::vector<fimsdescription__typeType * >);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(std::vector<fimsdescription__typeType * >, n);
		if (size)
			*size = n * sizeof(std::vector<fimsdescription__typeType * >);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (std::vector<fimsdescription__typeType * >*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfPointerTofimsdescription__typeType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<fimsdescription__typeType * > %p -> %p\n", q, p));
	*(std::vector<fimsdescription__typeType * >*)p = *(std::vector<fimsdescription__typeType * >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTofimsdescription__dateType(struct soap *soap, std::vector<fimsdescription__dateType * >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTofimsdescription__dateType(struct soap *soap, const std::vector<fimsdescription__dateType * >*a)
{
#ifndef WITH_NOIDREF
	for (std::vector<fimsdescription__dateType * >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTofimsdescription__dateType(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTofimsdescription__dateType(struct soap *soap, const char *tag, int id, const std::vector<fimsdescription__dateType * >*a, const char *type)
{
	for (std::vector<fimsdescription__dateType * >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTofimsdescription__dateType(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<fimsdescription__dateType * >* SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTofimsdescription__dateType(struct soap *soap, const char *tag, std::vector<fimsdescription__dateType * >*a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{	fimsdescription__dateType *n;
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href))
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_fimsdescription__dateType, SOAP_TYPE_std__vectorTemplateOfPointerTofimsdescription__dateType, sizeof(fimsdescription__dateType), 1))
				break;
			if (!soap_in_PointerTofimsdescription__dateType(soap, tag, NULL, "fimsdescription:dateType"))
				break;
		}
		else if (!soap_in_PointerTofimsdescription__dateType(soap, tag, &n, "fimsdescription:dateType"))
			break;
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTofimsdescription__dateType(soap, -1)))
			return NULL;
		a->push_back(n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<fimsdescription__dateType * > * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTofimsdescription__dateType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTofimsdescription__dateType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOfPointerTofimsdescription__dateType, n, EDLProvider_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(std::vector<fimsdescription__dateType * >);
		if (size)
			*size = sizeof(std::vector<fimsdescription__dateType * >);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(std::vector<fimsdescription__dateType * >, n);
		if (size)
			*size = n * sizeof(std::vector<fimsdescription__dateType * >);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (std::vector<fimsdescription__dateType * >*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfPointerTofimsdescription__dateType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<fimsdescription__dateType * > %p -> %p\n", q, p));
	*(std::vector<fimsdescription__dateType * >*)p = *(std::vector<fimsdescription__dateType * >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTofimsdescription__descriptionType(struct soap *soap, std::vector<fimsdescription__descriptionType * >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTofimsdescription__descriptionType(struct soap *soap, const std::vector<fimsdescription__descriptionType * >*a)
{
#ifndef WITH_NOIDREF
	for (std::vector<fimsdescription__descriptionType * >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTofimsdescription__descriptionType(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTofimsdescription__descriptionType(struct soap *soap, const char *tag, int id, const std::vector<fimsdescription__descriptionType * >*a, const char *type)
{
	for (std::vector<fimsdescription__descriptionType * >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTofimsdescription__descriptionType(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<fimsdescription__descriptionType * >* SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTofimsdescription__descriptionType(struct soap *soap, const char *tag, std::vector<fimsdescription__descriptionType * >*a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{	fimsdescription__descriptionType *n;
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href))
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_fimsdescription__descriptionType, SOAP_TYPE_std__vectorTemplateOfPointerTofimsdescription__descriptionType, sizeof(fimsdescription__descriptionType), 1))
				break;
			if (!soap_in_PointerTofimsdescription__descriptionType(soap, tag, NULL, "fimsdescription:descriptionType"))
				break;
		}
		else if (!soap_in_PointerTofimsdescription__descriptionType(soap, tag, &n, "fimsdescription:descriptionType"))
			break;
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTofimsdescription__descriptionType(soap, -1)))
			return NULL;
		a->push_back(n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<fimsdescription__descriptionType * > * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTofimsdescription__descriptionType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTofimsdescription__descriptionType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOfPointerTofimsdescription__descriptionType, n, EDLProvider_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(std::vector<fimsdescription__descriptionType * >);
		if (size)
			*size = sizeof(std::vector<fimsdescription__descriptionType * >);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(std::vector<fimsdescription__descriptionType * >, n);
		if (size)
			*size = n * sizeof(std::vector<fimsdescription__descriptionType * >);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (std::vector<fimsdescription__descriptionType * >*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfPointerTofimsdescription__descriptionType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<fimsdescription__descriptionType * > %p -> %p\n", q, p));
	*(std::vector<fimsdescription__descriptionType * >*)p = *(std::vector<fimsdescription__descriptionType * >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTofimsdescription__subjectType(struct soap *soap, std::vector<fimsdescription__subjectType * >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTofimsdescription__subjectType(struct soap *soap, const std::vector<fimsdescription__subjectType * >*a)
{
#ifndef WITH_NOIDREF
	for (std::vector<fimsdescription__subjectType * >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTofimsdescription__subjectType(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTofimsdescription__subjectType(struct soap *soap, const char *tag, int id, const std::vector<fimsdescription__subjectType * >*a, const char *type)
{
	for (std::vector<fimsdescription__subjectType * >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTofimsdescription__subjectType(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<fimsdescription__subjectType * >* SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTofimsdescription__subjectType(struct soap *soap, const char *tag, std::vector<fimsdescription__subjectType * >*a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{	fimsdescription__subjectType *n;
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href))
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_fimsdescription__subjectType, SOAP_TYPE_std__vectorTemplateOfPointerTofimsdescription__subjectType, sizeof(fimsdescription__subjectType), 1))
				break;
			if (!soap_in_PointerTofimsdescription__subjectType(soap, tag, NULL, "fimsdescription:subjectType"))
				break;
		}
		else if (!soap_in_PointerTofimsdescription__subjectType(soap, tag, &n, "fimsdescription:subjectType"))
			break;
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTofimsdescription__subjectType(soap, -1)))
			return NULL;
		a->push_back(n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<fimsdescription__subjectType * > * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTofimsdescription__subjectType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTofimsdescription__subjectType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOfPointerTofimsdescription__subjectType, n, EDLProvider_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(std::vector<fimsdescription__subjectType * >);
		if (size)
			*size = sizeof(std::vector<fimsdescription__subjectType * >);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(std::vector<fimsdescription__subjectType * >, n);
		if (size)
			*size = n * sizeof(std::vector<fimsdescription__subjectType * >);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (std::vector<fimsdescription__subjectType * >*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfPointerTofimsdescription__subjectType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<fimsdescription__subjectType * > %p -> %p\n", q, p));
	*(std::vector<fimsdescription__subjectType * >*)p = *(std::vector<fimsdescription__subjectType * >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTofimsdescription__entityType(struct soap *soap, std::vector<fimsdescription__entityType * >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTofimsdescription__entityType(struct soap *soap, const std::vector<fimsdescription__entityType * >*a)
{
#ifndef WITH_NOIDREF
	for (std::vector<fimsdescription__entityType * >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTofimsdescription__entityType(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTofimsdescription__entityType(struct soap *soap, const char *tag, int id, const std::vector<fimsdescription__entityType * >*a, const char *type)
{
	for (std::vector<fimsdescription__entityType * >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTofimsdescription__entityType(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<fimsdescription__entityType * >* SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTofimsdescription__entityType(struct soap *soap, const char *tag, std::vector<fimsdescription__entityType * >*a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{	fimsdescription__entityType *n;
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href))
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_fimsdescription__entityType, SOAP_TYPE_std__vectorTemplateOfPointerTofimsdescription__entityType, sizeof(fimsdescription__entityType), 1))
				break;
			if (!soap_in_PointerTofimsdescription__entityType(soap, tag, NULL, "fimsdescription:entityType"))
				break;
		}
		else if (!soap_in_PointerTofimsdescription__entityType(soap, tag, &n, "fimsdescription:entityType"))
			break;
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTofimsdescription__entityType(soap, -1)))
			return NULL;
		a->push_back(n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<fimsdescription__entityType * > * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTofimsdescription__entityType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTofimsdescription__entityType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOfPointerTofimsdescription__entityType, n, EDLProvider_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(std::vector<fimsdescription__entityType * >);
		if (size)
			*size = sizeof(std::vector<fimsdescription__entityType * >);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(std::vector<fimsdescription__entityType * >, n);
		if (size)
			*size = n * sizeof(std::vector<fimsdescription__entityType * >);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (std::vector<fimsdescription__entityType * >*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfPointerTofimsdescription__entityType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<fimsdescription__entityType * > %p -> %p\n", q, p));
	*(std::vector<fimsdescription__entityType * >*)p = *(std::vector<fimsdescription__entityType * >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTofimsdescription__titleType(struct soap *soap, std::vector<fimsdescription__titleType * >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTofimsdescription__titleType(struct soap *soap, const std::vector<fimsdescription__titleType * >*a)
{
#ifndef WITH_NOIDREF
	for (std::vector<fimsdescription__titleType * >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTofimsdescription__titleType(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTofimsdescription__titleType(struct soap *soap, const char *tag, int id, const std::vector<fimsdescription__titleType * >*a, const char *type)
{
	for (std::vector<fimsdescription__titleType * >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTofimsdescription__titleType(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<fimsdescription__titleType * >* SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTofimsdescription__titleType(struct soap *soap, const char *tag, std::vector<fimsdescription__titleType * >*a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{	fimsdescription__titleType *n;
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href))
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_fimsdescription__titleType, SOAP_TYPE_std__vectorTemplateOfPointerTofimsdescription__titleType, sizeof(fimsdescription__titleType), 1))
				break;
			if (!soap_in_PointerTofimsdescription__titleType(soap, tag, NULL, "fimsdescription:titleType"))
				break;
		}
		else if (!soap_in_PointerTofimsdescription__titleType(soap, tag, &n, "fimsdescription:titleType"))
			break;
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTofimsdescription__titleType(soap, -1)))
			return NULL;
		a->push_back(n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<fimsdescription__titleType * > * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTofimsdescription__titleType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTofimsdescription__titleType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOfPointerTofimsdescription__titleType, n, EDLProvider_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(std::vector<fimsdescription__titleType * >);
		if (size)
			*size = sizeof(std::vector<fimsdescription__titleType * >);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(std::vector<fimsdescription__titleType * >, n);
		if (size)
			*size = n * sizeof(std::vector<fimsdescription__titleType * >);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (std::vector<fimsdescription__titleType * >*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfPointerTofimsdescription__titleType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<fimsdescription__titleType * > %p -> %p\n", q, p));
	*(std::vector<fimsdescription__titleType * >*)p = *(std::vector<fimsdescription__titleType * >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTofimsdescription__textElementType(struct soap *soap, std::vector<fimsdescription__textElementType * >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTofimsdescription__textElementType(struct soap *soap, const std::vector<fimsdescription__textElementType * >*a)
{
#ifndef WITH_NOIDREF
	for (std::vector<fimsdescription__textElementType * >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTofimsdescription__textElementType(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTofimsdescription__textElementType(struct soap *soap, const char *tag, int id, const std::vector<fimsdescription__textElementType * >*a, const char *type)
{
	for (std::vector<fimsdescription__textElementType * >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTofimsdescription__textElementType(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<fimsdescription__textElementType * >* SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTofimsdescription__textElementType(struct soap *soap, const char *tag, std::vector<fimsdescription__textElementType * >*a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{	fimsdescription__textElementType *n;
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href))
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_fimsdescription__textElementType, SOAP_TYPE_std__vectorTemplateOfPointerTofimsdescription__textElementType, sizeof(fimsdescription__textElementType), 1))
				break;
			if (!soap_in_PointerTofimsdescription__textElementType(soap, tag, NULL, "fimsdescription:textElementType"))
				break;
		}
		else if (!soap_in_PointerTofimsdescription__textElementType(soap, tag, &n, "fimsdescription:textElementType"))
			break;
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTofimsdescription__textElementType(soap, -1)))
			return NULL;
		a->push_back(n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<fimsdescription__textElementType * > * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTofimsdescription__textElementType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTofimsdescription__textElementType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOfPointerTofimsdescription__textElementType, n, EDLProvider_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(std::vector<fimsdescription__textElementType * >);
		if (size)
			*size = sizeof(std::vector<fimsdescription__textElementType * >);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(std::vector<fimsdescription__textElementType * >, n);
		if (size)
			*size = n * sizeof(std::vector<fimsdescription__textElementType * >);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (std::vector<fimsdescription__textElementType * >*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfPointerTofimsdescription__textElementType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<fimsdescription__textElementType * > %p -> %p\n", q, p));
	*(std::vector<fimsdescription__textElementType * >*)p = *(std::vector<fimsdescription__textElementType * >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTofims__SystemPerformanceEventType(struct soap *soap, std::vector<fims__SystemPerformanceEventType * >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTofims__SystemPerformanceEventType(struct soap *soap, const std::vector<fims__SystemPerformanceEventType * >*a)
{
#ifndef WITH_NOIDREF
	for (std::vector<fims__SystemPerformanceEventType * >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTofims__SystemPerformanceEventType(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTofims__SystemPerformanceEventType(struct soap *soap, const char *tag, int id, const std::vector<fims__SystemPerformanceEventType * >*a, const char *type)
{
	for (std::vector<fims__SystemPerformanceEventType * >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTofims__SystemPerformanceEventType(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<fims__SystemPerformanceEventType * >* SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTofims__SystemPerformanceEventType(struct soap *soap, const char *tag, std::vector<fims__SystemPerformanceEventType * >*a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{	fims__SystemPerformanceEventType *n;
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href))
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_fims__SystemPerformanceEventType, SOAP_TYPE_std__vectorTemplateOfPointerTofims__SystemPerformanceEventType, sizeof(fims__SystemPerformanceEventType), 1))
				break;
			if (!soap_in_PointerTofims__SystemPerformanceEventType(soap, tag, NULL, "fims:SystemPerformanceEventType"))
				break;
		}
		else if (!soap_in_PointerTofims__SystemPerformanceEventType(soap, tag, &n, "fims:SystemPerformanceEventType"))
			break;
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTofims__SystemPerformanceEventType(soap, -1)))
			return NULL;
		a->push_back(n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<fims__SystemPerformanceEventType * > * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTofims__SystemPerformanceEventType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTofims__SystemPerformanceEventType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOfPointerTofims__SystemPerformanceEventType, n, EDLProvider_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(std::vector<fims__SystemPerformanceEventType * >);
		if (size)
			*size = sizeof(std::vector<fims__SystemPerformanceEventType * >);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(std::vector<fims__SystemPerformanceEventType * >, n);
		if (size)
			*size = n * sizeof(std::vector<fims__SystemPerformanceEventType * >);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (std::vector<fims__SystemPerformanceEventType * >*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfPointerTofims__SystemPerformanceEventType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<fims__SystemPerformanceEventType * > %p -> %p\n", q, p));
	*(std::vector<fims__SystemPerformanceEventType * >*)p = *(std::vector<fims__SystemPerformanceEventType * >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTofims__SystemExceptionEventType(struct soap *soap, std::vector<fims__SystemExceptionEventType * >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTofims__SystemExceptionEventType(struct soap *soap, const std::vector<fims__SystemExceptionEventType * >*a)
{
#ifndef WITH_NOIDREF
	for (std::vector<fims__SystemExceptionEventType * >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTofims__SystemExceptionEventType(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTofims__SystemExceptionEventType(struct soap *soap, const char *tag, int id, const std::vector<fims__SystemExceptionEventType * >*a, const char *type)
{
	for (std::vector<fims__SystemExceptionEventType * >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTofims__SystemExceptionEventType(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<fims__SystemExceptionEventType * >* SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTofims__SystemExceptionEventType(struct soap *soap, const char *tag, std::vector<fims__SystemExceptionEventType * >*a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{	fims__SystemExceptionEventType *n;
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href))
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_fims__SystemExceptionEventType, SOAP_TYPE_std__vectorTemplateOfPointerTofims__SystemExceptionEventType, sizeof(fims__SystemExceptionEventType), 1))
				break;
			if (!soap_in_PointerTofims__SystemExceptionEventType(soap, tag, NULL, "fims:SystemExceptionEventType"))
				break;
		}
		else if (!soap_in_PointerTofims__SystemExceptionEventType(soap, tag, &n, "fims:SystemExceptionEventType"))
			break;
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTofims__SystemExceptionEventType(soap, -1)))
			return NULL;
		a->push_back(n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<fims__SystemExceptionEventType * > * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTofims__SystemExceptionEventType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTofims__SystemExceptionEventType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOfPointerTofims__SystemExceptionEventType, n, EDLProvider_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(std::vector<fims__SystemExceptionEventType * >);
		if (size)
			*size = sizeof(std::vector<fims__SystemExceptionEventType * >);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(std::vector<fims__SystemExceptionEventType * >, n);
		if (size)
			*size = n * sizeof(std::vector<fims__SystemExceptionEventType * >);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (std::vector<fims__SystemExceptionEventType * >*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfPointerTofims__SystemExceptionEventType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<fims__SystemExceptionEventType * > %p -> %p\n", q, p));
	*(std::vector<fims__SystemExceptionEventType * >*)p = *(std::vector<fims__SystemExceptionEventType * >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTofims__SystemEventType(struct soap *soap, std::vector<fims__SystemEventType * >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTofims__SystemEventType(struct soap *soap, const std::vector<fims__SystemEventType * >*a)
{
#ifndef WITH_NOIDREF
	for (std::vector<fims__SystemEventType * >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTofims__SystemEventType(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTofims__SystemEventType(struct soap *soap, const char *tag, int id, const std::vector<fims__SystemEventType * >*a, const char *type)
{
	for (std::vector<fims__SystemEventType * >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTofims__SystemEventType(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<fims__SystemEventType * >* SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTofims__SystemEventType(struct soap *soap, const char *tag, std::vector<fims__SystemEventType * >*a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{	fims__SystemEventType *n;
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href))
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_fims__SystemEventType, SOAP_TYPE_std__vectorTemplateOfPointerTofims__SystemEventType, sizeof(fims__SystemEventType), 1))
				break;
			if (!soap_in_PointerTofims__SystemEventType(soap, tag, NULL, "fims:SystemEventType"))
				break;
		}
		else if (!soap_in_PointerTofims__SystemEventType(soap, tag, &n, "fims:SystemEventType"))
			break;
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTofims__SystemEventType(soap, -1)))
			return NULL;
		a->push_back(n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<fims__SystemEventType * > * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTofims__SystemEventType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTofims__SystemEventType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOfPointerTofims__SystemEventType, n, EDLProvider_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(std::vector<fims__SystemEventType * >);
		if (size)
			*size = sizeof(std::vector<fims__SystemEventType * >);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(std::vector<fims__SystemEventType * >, n);
		if (size)
			*size = n * sizeof(std::vector<fims__SystemEventType * >);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (std::vector<fims__SystemEventType * >*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfPointerTofims__SystemEventType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<fims__SystemEventType * > %p -> %p\n", q, p));
	*(std::vector<fims__SystemEventType * >*)p = *(std::vector<fims__SystemEventType * >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTofims__ContentCustomEventType(struct soap *soap, std::vector<fims__ContentCustomEventType * >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTofims__ContentCustomEventType(struct soap *soap, const std::vector<fims__ContentCustomEventType * >*a)
{
#ifndef WITH_NOIDREF
	for (std::vector<fims__ContentCustomEventType * >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTofims__ContentCustomEventType(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTofims__ContentCustomEventType(struct soap *soap, const char *tag, int id, const std::vector<fims__ContentCustomEventType * >*a, const char *type)
{
	for (std::vector<fims__ContentCustomEventType * >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTofims__ContentCustomEventType(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<fims__ContentCustomEventType * >* SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTofims__ContentCustomEventType(struct soap *soap, const char *tag, std::vector<fims__ContentCustomEventType * >*a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{	fims__ContentCustomEventType *n;
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href))
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_fims__ContentCustomEventType, SOAP_TYPE_std__vectorTemplateOfPointerTofims__ContentCustomEventType, sizeof(fims__ContentCustomEventType), 1))
				break;
			if (!soap_in_PointerTofims__ContentCustomEventType(soap, tag, NULL, "fims:ContentCustomEventType"))
				break;
		}
		else if (!soap_in_PointerTofims__ContentCustomEventType(soap, tag, &n, "fims:ContentCustomEventType"))
			break;
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTofims__ContentCustomEventType(soap, -1)))
			return NULL;
		a->push_back(n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<fims__ContentCustomEventType * > * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTofims__ContentCustomEventType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTofims__ContentCustomEventType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOfPointerTofims__ContentCustomEventType, n, EDLProvider_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(std::vector<fims__ContentCustomEventType * >);
		if (size)
			*size = sizeof(std::vector<fims__ContentCustomEventType * >);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(std::vector<fims__ContentCustomEventType * >, n);
		if (size)
			*size = n * sizeof(std::vector<fims__ContentCustomEventType * >);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (std::vector<fims__ContentCustomEventType * >*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfPointerTofims__ContentCustomEventType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<fims__ContentCustomEventType * > %p -> %p\n", q, p));
	*(std::vector<fims__ContentCustomEventType * >*)p = *(std::vector<fims__ContentCustomEventType * >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTofims__ContentStatusEventType(struct soap *soap, std::vector<fims__ContentStatusEventType * >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTofims__ContentStatusEventType(struct soap *soap, const std::vector<fims__ContentStatusEventType * >*a)
{
#ifndef WITH_NOIDREF
	for (std::vector<fims__ContentStatusEventType * >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTofims__ContentStatusEventType(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTofims__ContentStatusEventType(struct soap *soap, const char *tag, int id, const std::vector<fims__ContentStatusEventType * >*a, const char *type)
{
	for (std::vector<fims__ContentStatusEventType * >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTofims__ContentStatusEventType(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<fims__ContentStatusEventType * >* SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTofims__ContentStatusEventType(struct soap *soap, const char *tag, std::vector<fims__ContentStatusEventType * >*a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{	fims__ContentStatusEventType *n;
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href))
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_fims__ContentStatusEventType, SOAP_TYPE_std__vectorTemplateOfPointerTofims__ContentStatusEventType, sizeof(fims__ContentStatusEventType), 1))
				break;
			if (!soap_in_PointerTofims__ContentStatusEventType(soap, tag, NULL, "fims:ContentStatusEventType"))
				break;
		}
		else if (!soap_in_PointerTofims__ContentStatusEventType(soap, tag, &n, "fims:ContentStatusEventType"))
			break;
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTofims__ContentStatusEventType(soap, -1)))
			return NULL;
		a->push_back(n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<fims__ContentStatusEventType * > * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTofims__ContentStatusEventType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTofims__ContentStatusEventType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOfPointerTofims__ContentStatusEventType, n, EDLProvider_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(std::vector<fims__ContentStatusEventType * >);
		if (size)
			*size = sizeof(std::vector<fims__ContentStatusEventType * >);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(std::vector<fims__ContentStatusEventType * >, n);
		if (size)
			*size = n * sizeof(std::vector<fims__ContentStatusEventType * >);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (std::vector<fims__ContentStatusEventType * >*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfPointerTofims__ContentStatusEventType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<fims__ContentStatusEventType * > %p -> %p\n", q, p));
	*(std::vector<fims__ContentStatusEventType * >*)p = *(std::vector<fims__ContentStatusEventType * >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTofims__ContentEventType(struct soap *soap, std::vector<fims__ContentEventType * >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTofims__ContentEventType(struct soap *soap, const std::vector<fims__ContentEventType * >*a)
{
#ifndef WITH_NOIDREF
	for (std::vector<fims__ContentEventType * >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTofims__ContentEventType(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTofims__ContentEventType(struct soap *soap, const char *tag, int id, const std::vector<fims__ContentEventType * >*a, const char *type)
{
	for (std::vector<fims__ContentEventType * >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTofims__ContentEventType(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<fims__ContentEventType * >* SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTofims__ContentEventType(struct soap *soap, const char *tag, std::vector<fims__ContentEventType * >*a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{	fims__ContentEventType *n;
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href))
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_fims__ContentEventType, SOAP_TYPE_std__vectorTemplateOfPointerTofims__ContentEventType, sizeof(fims__ContentEventType), 1))
				break;
			if (!soap_in_PointerTofims__ContentEventType(soap, tag, NULL, "fims:ContentEventType"))
				break;
		}
		else if (!soap_in_PointerTofims__ContentEventType(soap, tag, &n, "fims:ContentEventType"))
			break;
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTofims__ContentEventType(soap, -1)))
			return NULL;
		a->push_back(n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<fims__ContentEventType * > * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTofims__ContentEventType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTofims__ContentEventType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOfPointerTofims__ContentEventType, n, EDLProvider_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(std::vector<fims__ContentEventType * >);
		if (size)
			*size = sizeof(std::vector<fims__ContentEventType * >);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(std::vector<fims__ContentEventType * >, n);
		if (size)
			*size = n * sizeof(std::vector<fims__ContentEventType * >);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (std::vector<fims__ContentEventType * >*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfPointerTofims__ContentEventType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<fims__ContentEventType * > %p -> %p\n", q, p));
	*(std::vector<fims__ContentEventType * >*)p = *(std::vector<fims__ContentEventType * >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTofims__EventPayloadType(struct soap *soap, std::vector<fims__EventPayloadType * >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTofims__EventPayloadType(struct soap *soap, const std::vector<fims__EventPayloadType * >*a)
{
#ifndef WITH_NOIDREF
	for (std::vector<fims__EventPayloadType * >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTofims__EventPayloadType(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTofims__EventPayloadType(struct soap *soap, const char *tag, int id, const std::vector<fims__EventPayloadType * >*a, const char *type)
{
	for (std::vector<fims__EventPayloadType * >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTofims__EventPayloadType(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<fims__EventPayloadType * >* SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTofims__EventPayloadType(struct soap *soap, const char *tag, std::vector<fims__EventPayloadType * >*a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{	fims__EventPayloadType *n;
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href))
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_fims__EventPayloadType, SOAP_TYPE_std__vectorTemplateOfPointerTofims__EventPayloadType, sizeof(fims__EventPayloadType), 1))
				break;
			if (!soap_in_PointerTofims__EventPayloadType(soap, tag, NULL, "fims:EventPayloadType"))
				break;
		}
		else if (!soap_in_PointerTofims__EventPayloadType(soap, tag, &n, "fims:EventPayloadType"))
			break;
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTofims__EventPayloadType(soap, -1)))
			return NULL;
		a->push_back(n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<fims__EventPayloadType * > * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTofims__EventPayloadType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTofims__EventPayloadType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOfPointerTofims__EventPayloadType, n, EDLProvider_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(std::vector<fims__EventPayloadType * >);
		if (size)
			*size = sizeof(std::vector<fims__EventPayloadType * >);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(std::vector<fims__EventPayloadType * >, n);
		if (size)
			*size = n * sizeof(std::vector<fims__EventPayloadType * >);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (std::vector<fims__EventPayloadType * >*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfPointerTofims__EventPayloadType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<fims__EventPayloadType * > %p -> %p\n", q, p));
	*(std::vector<fims__EventPayloadType * >*)p = *(std::vector<fims__EventPayloadType * >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTofims__EventEnvelopeType(struct soap *soap, std::vector<fims__EventEnvelopeType * >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTofims__EventEnvelopeType(struct soap *soap, const std::vector<fims__EventEnvelopeType * >*a)
{
#ifndef WITH_NOIDREF
	for (std::vector<fims__EventEnvelopeType * >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTofims__EventEnvelopeType(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTofims__EventEnvelopeType(struct soap *soap, const char *tag, int id, const std::vector<fims__EventEnvelopeType * >*a, const char *type)
{
	for (std::vector<fims__EventEnvelopeType * >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTofims__EventEnvelopeType(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<fims__EventEnvelopeType * >* SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTofims__EventEnvelopeType(struct soap *soap, const char *tag, std::vector<fims__EventEnvelopeType * >*a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{	fims__EventEnvelopeType *n;
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href))
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_fims__EventEnvelopeType, SOAP_TYPE_std__vectorTemplateOfPointerTofims__EventEnvelopeType, sizeof(fims__EventEnvelopeType), 1))
				break;
			if (!soap_in_PointerTofims__EventEnvelopeType(soap, tag, NULL, "fims:EventEnvelopeType"))
				break;
		}
		else if (!soap_in_PointerTofims__EventEnvelopeType(soap, tag, &n, "fims:EventEnvelopeType"))
			break;
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTofims__EventEnvelopeType(soap, -1)))
			return NULL;
		a->push_back(n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<fims__EventEnvelopeType * > * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTofims__EventEnvelopeType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTofims__EventEnvelopeType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOfPointerTofims__EventEnvelopeType, n, EDLProvider_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(std::vector<fims__EventEnvelopeType * >);
		if (size)
			*size = sizeof(std::vector<fims__EventEnvelopeType * >);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(std::vector<fims__EventEnvelopeType * >, n);
		if (size)
			*size = n * sizeof(std::vector<fims__EventEnvelopeType * >);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (std::vector<fims__EventEnvelopeType * >*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfPointerTofims__EventEnvelopeType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<fims__EventEnvelopeType * > %p -> %p\n", q, p));
	*(std::vector<fims__EventEnvelopeType * >*)p = *(std::vector<fims__EventEnvelopeType * >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTofims__CustomEventTemplateType(struct soap *soap, std::vector<fims__CustomEventTemplateType * >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTofims__CustomEventTemplateType(struct soap *soap, const std::vector<fims__CustomEventTemplateType * >*a)
{
#ifndef WITH_NOIDREF
	for (std::vector<fims__CustomEventTemplateType * >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTofims__CustomEventTemplateType(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTofims__CustomEventTemplateType(struct soap *soap, const char *tag, int id, const std::vector<fims__CustomEventTemplateType * >*a, const char *type)
{
	for (std::vector<fims__CustomEventTemplateType * >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTofims__CustomEventTemplateType(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<fims__CustomEventTemplateType * >* SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTofims__CustomEventTemplateType(struct soap *soap, const char *tag, std::vector<fims__CustomEventTemplateType * >*a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{	fims__CustomEventTemplateType *n;
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href))
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_fims__CustomEventTemplateType, SOAP_TYPE_std__vectorTemplateOfPointerTofims__CustomEventTemplateType, sizeof(fims__CustomEventTemplateType), 1))
				break;
			if (!soap_in_PointerTofims__CustomEventTemplateType(soap, tag, NULL, "fims:CustomEventTemplateType"))
				break;
		}
		else if (!soap_in_PointerTofims__CustomEventTemplateType(soap, tag, &n, "fims:CustomEventTemplateType"))
			break;
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTofims__CustomEventTemplateType(soap, -1)))
			return NULL;
		a->push_back(n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<fims__CustomEventTemplateType * > * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTofims__CustomEventTemplateType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTofims__CustomEventTemplateType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOfPointerTofims__CustomEventTemplateType, n, EDLProvider_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(std::vector<fims__CustomEventTemplateType * >);
		if (size)
			*size = sizeof(std::vector<fims__CustomEventTemplateType * >);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(std::vector<fims__CustomEventTemplateType * >, n);
		if (size)
			*size = n * sizeof(std::vector<fims__CustomEventTemplateType * >);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (std::vector<fims__CustomEventTemplateType * >*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfPointerTofims__CustomEventTemplateType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<fims__CustomEventTemplateType * > %p -> %p\n", q, p));
	*(std::vector<fims__CustomEventTemplateType * >*)p = *(std::vector<fims__CustomEventTemplateType * >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTofims__QueryGroupType(struct soap *soap, std::vector<fims__QueryGroupType * >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTofims__QueryGroupType(struct soap *soap, const std::vector<fims__QueryGroupType * >*a)
{
#ifndef WITH_NOIDREF
	for (std::vector<fims__QueryGroupType * >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTofims__QueryGroupType(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTofims__QueryGroupType(struct soap *soap, const char *tag, int id, const std::vector<fims__QueryGroupType * >*a, const char *type)
{
	for (std::vector<fims__QueryGroupType * >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTofims__QueryGroupType(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<fims__QueryGroupType * >* SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTofims__QueryGroupType(struct soap *soap, const char *tag, std::vector<fims__QueryGroupType * >*a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{	fims__QueryGroupType *n;
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href))
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_fims__QueryGroupType, SOAP_TYPE_std__vectorTemplateOfPointerTofims__QueryGroupType, sizeof(fims__QueryGroupType), 1))
				break;
			if (!soap_in_PointerTofims__QueryGroupType(soap, tag, NULL, "fims:QueryGroupType"))
				break;
		}
		else if (!soap_in_PointerTofims__QueryGroupType(soap, tag, &n, "fims:QueryGroupType"))
			break;
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTofims__QueryGroupType(soap, -1)))
			return NULL;
		a->push_back(n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<fims__QueryGroupType * > * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTofims__QueryGroupType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTofims__QueryGroupType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOfPointerTofims__QueryGroupType, n, EDLProvider_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(std::vector<fims__QueryGroupType * >);
		if (size)
			*size = sizeof(std::vector<fims__QueryGroupType * >);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(std::vector<fims__QueryGroupType * >, n);
		if (size)
			*size = n * sizeof(std::vector<fims__QueryGroupType * >);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (std::vector<fims__QueryGroupType * >*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfPointerTofims__QueryGroupType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<fims__QueryGroupType * > %p -> %p\n", q, p));
	*(std::vector<fims__QueryGroupType * >*)p = *(std::vector<fims__QueryGroupType * >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTofims__CustomQueryGroupOperatorType(struct soap *soap, std::vector<fims__CustomQueryGroupOperatorType * >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTofims__CustomQueryGroupOperatorType(struct soap *soap, const std::vector<fims__CustomQueryGroupOperatorType * >*a)
{
#ifndef WITH_NOIDREF
	for (std::vector<fims__CustomQueryGroupOperatorType * >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTofims__CustomQueryGroupOperatorType(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTofims__CustomQueryGroupOperatorType(struct soap *soap, const char *tag, int id, const std::vector<fims__CustomQueryGroupOperatorType * >*a, const char *type)
{
	for (std::vector<fims__CustomQueryGroupOperatorType * >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTofims__CustomQueryGroupOperatorType(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<fims__CustomQueryGroupOperatorType * >* SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTofims__CustomQueryGroupOperatorType(struct soap *soap, const char *tag, std::vector<fims__CustomQueryGroupOperatorType * >*a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{	fims__CustomQueryGroupOperatorType *n;
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href))
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_fims__CustomQueryGroupOperatorType, SOAP_TYPE_std__vectorTemplateOfPointerTofims__CustomQueryGroupOperatorType, sizeof(fims__CustomQueryGroupOperatorType), 1))
				break;
			if (!soap_in_PointerTofims__CustomQueryGroupOperatorType(soap, tag, NULL, "fims:CustomQueryGroupOperatorType"))
				break;
		}
		else if (!soap_in_PointerTofims__CustomQueryGroupOperatorType(soap, tag, &n, "fims:CustomQueryGroupOperatorType"))
			break;
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTofims__CustomQueryGroupOperatorType(soap, -1)))
			return NULL;
		a->push_back(n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<fims__CustomQueryGroupOperatorType * > * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTofims__CustomQueryGroupOperatorType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTofims__CustomQueryGroupOperatorType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOfPointerTofims__CustomQueryGroupOperatorType, n, EDLProvider_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(std::vector<fims__CustomQueryGroupOperatorType * >);
		if (size)
			*size = sizeof(std::vector<fims__CustomQueryGroupOperatorType * >);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(std::vector<fims__CustomQueryGroupOperatorType * >, n);
		if (size)
			*size = n * sizeof(std::vector<fims__CustomQueryGroupOperatorType * >);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (std::vector<fims__CustomQueryGroupOperatorType * >*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfPointerTofims__CustomQueryGroupOperatorType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<fims__CustomQueryGroupOperatorType * > %p -> %p\n", q, p));
	*(std::vector<fims__CustomQueryGroupOperatorType * >*)p = *(std::vector<fims__CustomQueryGroupOperatorType * >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTofims__QueryParameterType(struct soap *soap, std::vector<fims__QueryParameterType * >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTofims__QueryParameterType(struct soap *soap, const std::vector<fims__QueryParameterType * >*a)
{
#ifndef WITH_NOIDREF
	for (std::vector<fims__QueryParameterType * >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTofims__QueryParameterType(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTofims__QueryParameterType(struct soap *soap, const char *tag, int id, const std::vector<fims__QueryParameterType * >*a, const char *type)
{
	for (std::vector<fims__QueryParameterType * >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTofims__QueryParameterType(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<fims__QueryParameterType * >* SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTofims__QueryParameterType(struct soap *soap, const char *tag, std::vector<fims__QueryParameterType * >*a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{	fims__QueryParameterType *n;
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href))
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_fims__QueryParameterType, SOAP_TYPE_std__vectorTemplateOfPointerTofims__QueryParameterType, sizeof(fims__QueryParameterType), 1))
				break;
			if (!soap_in_PointerTofims__QueryParameterType(soap, tag, NULL, "fims:QueryParameterType"))
				break;
		}
		else if (!soap_in_PointerTofims__QueryParameterType(soap, tag, &n, "fims:QueryParameterType"))
			break;
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTofims__QueryParameterType(soap, -1)))
			return NULL;
		a->push_back(n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<fims__QueryParameterType * > * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTofims__QueryParameterType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTofims__QueryParameterType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOfPointerTofims__QueryParameterType, n, EDLProvider_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(std::vector<fims__QueryParameterType * >);
		if (size)
			*size = sizeof(std::vector<fims__QueryParameterType * >);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(std::vector<fims__QueryParameterType * >, n);
		if (size)
			*size = n * sizeof(std::vector<fims__QueryParameterType * >);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (std::vector<fims__QueryParameterType * >*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfPointerTofims__QueryParameterType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<fims__QueryParameterType * > %p -> %p\n", q, p));
	*(std::vector<fims__QueryParameterType * >*)p = *(std::vector<fims__QueryParameterType * >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTofims__CustomQueryParameterOperatorType(struct soap *soap, std::vector<fims__CustomQueryParameterOperatorType * >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTofims__CustomQueryParameterOperatorType(struct soap *soap, const std::vector<fims__CustomQueryParameterOperatorType * >*a)
{
#ifndef WITH_NOIDREF
	for (std::vector<fims__CustomQueryParameterOperatorType * >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTofims__CustomQueryParameterOperatorType(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTofims__CustomQueryParameterOperatorType(struct soap *soap, const char *tag, int id, const std::vector<fims__CustomQueryParameterOperatorType * >*a, const char *type)
{
	for (std::vector<fims__CustomQueryParameterOperatorType * >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTofims__CustomQueryParameterOperatorType(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<fims__CustomQueryParameterOperatorType * >* SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTofims__CustomQueryParameterOperatorType(struct soap *soap, const char *tag, std::vector<fims__CustomQueryParameterOperatorType * >*a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{	fims__CustomQueryParameterOperatorType *n;
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href))
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_fims__CustomQueryParameterOperatorType, SOAP_TYPE_std__vectorTemplateOfPointerTofims__CustomQueryParameterOperatorType, sizeof(fims__CustomQueryParameterOperatorType), 1))
				break;
			if (!soap_in_PointerTofims__CustomQueryParameterOperatorType(soap, tag, NULL, "fims:CustomQueryParameterOperatorType"))
				break;
		}
		else if (!soap_in_PointerTofims__CustomQueryParameterOperatorType(soap, tag, &n, "fims:CustomQueryParameterOperatorType"))
			break;
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTofims__CustomQueryParameterOperatorType(soap, -1)))
			return NULL;
		a->push_back(n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<fims__CustomQueryParameterOperatorType * > * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTofims__CustomQueryParameterOperatorType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTofims__CustomQueryParameterOperatorType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOfPointerTofims__CustomQueryParameterOperatorType, n, EDLProvider_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(std::vector<fims__CustomQueryParameterOperatorType * >);
		if (size)
			*size = sizeof(std::vector<fims__CustomQueryParameterOperatorType * >);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(std::vector<fims__CustomQueryParameterOperatorType * >, n);
		if (size)
			*size = n * sizeof(std::vector<fims__CustomQueryParameterOperatorType * >);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (std::vector<fims__CustomQueryParameterOperatorType * >*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfPointerTofims__CustomQueryParameterOperatorType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<fims__CustomQueryParameterOperatorType * > %p -> %p\n", q, p));
	*(std::vector<fims__CustomQueryParameterOperatorType * >*)p = *(std::vector<fims__CustomQueryParameterOperatorType * >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTofims__QueryExpressionType(struct soap *soap, std::vector<fims__QueryExpressionType * >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTofims__QueryExpressionType(struct soap *soap, const std::vector<fims__QueryExpressionType * >*a)
{
#ifndef WITH_NOIDREF
	for (std::vector<fims__QueryExpressionType * >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTofims__QueryExpressionType(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTofims__QueryExpressionType(struct soap *soap, const char *tag, int id, const std::vector<fims__QueryExpressionType * >*a, const char *type)
{
	for (std::vector<fims__QueryExpressionType * >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTofims__QueryExpressionType(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<fims__QueryExpressionType * >* SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTofims__QueryExpressionType(struct soap *soap, const char *tag, std::vector<fims__QueryExpressionType * >*a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{	fims__QueryExpressionType *n;
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href))
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_fims__QueryExpressionType, SOAP_TYPE_std__vectorTemplateOfPointerTofims__QueryExpressionType, sizeof(fims__QueryExpressionType), 1))
				break;
			if (!soap_in_PointerTofims__QueryExpressionType(soap, tag, NULL, "fims:QueryExpressionType"))
				break;
		}
		else if (!soap_in_PointerTofims__QueryExpressionType(soap, tag, &n, "fims:QueryExpressionType"))
			break;
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTofims__QueryExpressionType(soap, -1)))
			return NULL;
		a->push_back(n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<fims__QueryExpressionType * > * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTofims__QueryExpressionType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTofims__QueryExpressionType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOfPointerTofims__QueryExpressionType, n, EDLProvider_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(std::vector<fims__QueryExpressionType * >);
		if (size)
			*size = sizeof(std::vector<fims__QueryExpressionType * >);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(std::vector<fims__QueryExpressionType * >, n);
		if (size)
			*size = n * sizeof(std::vector<fims__QueryExpressionType * >);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (std::vector<fims__QueryExpressionType * >*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfPointerTofims__QueryExpressionType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<fims__QueryExpressionType * > %p -> %p\n", q, p));
	*(std::vector<fims__QueryExpressionType * >*)p = *(std::vector<fims__QueryExpressionType * >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTofims__SuperLockTokenType(struct soap *soap, std::vector<fims__SuperLockTokenType * >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTofims__SuperLockTokenType(struct soap *soap, const std::vector<fims__SuperLockTokenType * >*a)
{
#ifndef WITH_NOIDREF
	for (std::vector<fims__SuperLockTokenType * >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTofims__SuperLockTokenType(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTofims__SuperLockTokenType(struct soap *soap, const char *tag, int id, const std::vector<fims__SuperLockTokenType * >*a, const char *type)
{
	for (std::vector<fims__SuperLockTokenType * >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTofims__SuperLockTokenType(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<fims__SuperLockTokenType * >* SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTofims__SuperLockTokenType(struct soap *soap, const char *tag, std::vector<fims__SuperLockTokenType * >*a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{	fims__SuperLockTokenType *n;
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href))
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_fims__SuperLockTokenType, SOAP_TYPE_std__vectorTemplateOfPointerTofims__SuperLockTokenType, sizeof(fims__SuperLockTokenType), 1))
				break;
			if (!soap_in_PointerTofims__SuperLockTokenType(soap, tag, NULL, "fims:SuperLockTokenType"))
				break;
		}
		else if (!soap_in_PointerTofims__SuperLockTokenType(soap, tag, &n, "fims:SuperLockTokenType"))
			break;
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTofims__SuperLockTokenType(soap, -1)))
			return NULL;
		a->push_back(n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<fims__SuperLockTokenType * > * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTofims__SuperLockTokenType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTofims__SuperLockTokenType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOfPointerTofims__SuperLockTokenType, n, EDLProvider_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(std::vector<fims__SuperLockTokenType * >);
		if (size)
			*size = sizeof(std::vector<fims__SuperLockTokenType * >);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(std::vector<fims__SuperLockTokenType * >, n);
		if (size)
			*size = n * sizeof(std::vector<fims__SuperLockTokenType * >);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (std::vector<fims__SuperLockTokenType * >*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfPointerTofims__SuperLockTokenType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<fims__SuperLockTokenType * > %p -> %p\n", q, p));
	*(std::vector<fims__SuperLockTokenType * >*)p = *(std::vector<fims__SuperLockTokenType * >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTofims__LockTokenType(struct soap *soap, std::vector<fims__LockTokenType * >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTofims__LockTokenType(struct soap *soap, const std::vector<fims__LockTokenType * >*a)
{
#ifndef WITH_NOIDREF
	for (std::vector<fims__LockTokenType * >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTofims__LockTokenType(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTofims__LockTokenType(struct soap *soap, const char *tag, int id, const std::vector<fims__LockTokenType * >*a, const char *type)
{
	for (std::vector<fims__LockTokenType * >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTofims__LockTokenType(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<fims__LockTokenType * >* SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTofims__LockTokenType(struct soap *soap, const char *tag, std::vector<fims__LockTokenType * >*a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{	fims__LockTokenType *n;
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href))
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_fims__LockTokenType, SOAP_TYPE_std__vectorTemplateOfPointerTofims__LockTokenType, sizeof(fims__LockTokenType), 1))
				break;
			if (!soap_in_PointerTofims__LockTokenType(soap, tag, NULL, "fims:LockTokenType"))
				break;
		}
		else if (!soap_in_PointerTofims__LockTokenType(soap, tag, &n, "fims:LockTokenType"))
			break;
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTofims__LockTokenType(soap, -1)))
			return NULL;
		a->push_back(n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<fims__LockTokenType * > * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTofims__LockTokenType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTofims__LockTokenType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOfPointerTofims__LockTokenType, n, EDLProvider_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(std::vector<fims__LockTokenType * >);
		if (size)
			*size = sizeof(std::vector<fims__LockTokenType * >);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(std::vector<fims__LockTokenType * >, n);
		if (size)
			*size = n * sizeof(std::vector<fims__LockTokenType * >);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (std::vector<fims__LockTokenType * >*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfPointerTofims__LockTokenType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<fims__LockTokenType * > %p -> %p\n", q, p));
	*(std::vector<fims__LockTokenType * >*)p = *(std::vector<fims__LockTokenType * >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTofims__CredentialType(struct soap *soap, std::vector<fims__CredentialType * >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTofims__CredentialType(struct soap *soap, const std::vector<fims__CredentialType * >*a)
{
#ifndef WITH_NOIDREF
	for (std::vector<fims__CredentialType * >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTofims__CredentialType(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTofims__CredentialType(struct soap *soap, const char *tag, int id, const std::vector<fims__CredentialType * >*a, const char *type)
{
	for (std::vector<fims__CredentialType * >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTofims__CredentialType(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<fims__CredentialType * >* SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTofims__CredentialType(struct soap *soap, const char *tag, std::vector<fims__CredentialType * >*a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{	fims__CredentialType *n;
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href))
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_fims__CredentialType, SOAP_TYPE_std__vectorTemplateOfPointerTofims__CredentialType, sizeof(fims__CredentialType), 1))
				break;
			if (!soap_in_PointerTofims__CredentialType(soap, tag, NULL, "fims:CredentialType"))
				break;
		}
		else if (!soap_in_PointerTofims__CredentialType(soap, tag, &n, "fims:CredentialType"))
			break;
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTofims__CredentialType(soap, -1)))
			return NULL;
		a->push_back(n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<fims__CredentialType * > * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTofims__CredentialType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTofims__CredentialType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOfPointerTofims__CredentialType, n, EDLProvider_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(std::vector<fims__CredentialType * >);
		if (size)
			*size = sizeof(std::vector<fims__CredentialType * >);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(std::vector<fims__CredentialType * >, n);
		if (size)
			*size = n * sizeof(std::vector<fims__CredentialType * >);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (std::vector<fims__CredentialType * >*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfPointerTofims__CredentialType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<fims__CredentialType * > %p -> %p\n", q, p));
	*(std::vector<fims__CredentialType * >*)p = *(std::vector<fims__CredentialType * >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTofims__BMEssenceLocatorStatusType(struct soap *soap, std::vector<fims__BMEssenceLocatorStatusType * >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTofims__BMEssenceLocatorStatusType(struct soap *soap, const std::vector<fims__BMEssenceLocatorStatusType * >*a)
{
#ifndef WITH_NOIDREF
	for (std::vector<fims__BMEssenceLocatorStatusType * >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTofims__BMEssenceLocatorStatusType(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTofims__BMEssenceLocatorStatusType(struct soap *soap, const char *tag, int id, const std::vector<fims__BMEssenceLocatorStatusType * >*a, const char *type)
{
	for (std::vector<fims__BMEssenceLocatorStatusType * >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTofims__BMEssenceLocatorStatusType(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<fims__BMEssenceLocatorStatusType * >* SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTofims__BMEssenceLocatorStatusType(struct soap *soap, const char *tag, std::vector<fims__BMEssenceLocatorStatusType * >*a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{	fims__BMEssenceLocatorStatusType *n;
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href))
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_fims__BMEssenceLocatorStatusType, SOAP_TYPE_std__vectorTemplateOfPointerTofims__BMEssenceLocatorStatusType, sizeof(fims__BMEssenceLocatorStatusType), 1))
				break;
			if (!soap_in_PointerTofims__BMEssenceLocatorStatusType(soap, tag, NULL, "fims:BMEssenceLocatorStatusType"))
				break;
		}
		else if (!soap_in_PointerTofims__BMEssenceLocatorStatusType(soap, tag, &n, "fims:BMEssenceLocatorStatusType"))
			break;
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTofims__BMEssenceLocatorStatusType(soap, -1)))
			return NULL;
		a->push_back(n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<fims__BMEssenceLocatorStatusType * > * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTofims__BMEssenceLocatorStatusType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTofims__BMEssenceLocatorStatusType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOfPointerTofims__BMEssenceLocatorStatusType, n, EDLProvider_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(std::vector<fims__BMEssenceLocatorStatusType * >);
		if (size)
			*size = sizeof(std::vector<fims__BMEssenceLocatorStatusType * >);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(std::vector<fims__BMEssenceLocatorStatusType * >, n);
		if (size)
			*size = n * sizeof(std::vector<fims__BMEssenceLocatorStatusType * >);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (std::vector<fims__BMEssenceLocatorStatusType * >*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfPointerTofims__BMEssenceLocatorStatusType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<fims__BMEssenceLocatorStatusType * > %p -> %p\n", q, p));
	*(std::vector<fims__BMEssenceLocatorStatusType * >*)p = *(std::vector<fims__BMEssenceLocatorStatusType * >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTofims__BMContentStatusType(struct soap *soap, std::vector<fims__BMContentStatusType * >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTofims__BMContentStatusType(struct soap *soap, const std::vector<fims__BMContentStatusType * >*a)
{
#ifndef WITH_NOIDREF
	for (std::vector<fims__BMContentStatusType * >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTofims__BMContentStatusType(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTofims__BMContentStatusType(struct soap *soap, const char *tag, int id, const std::vector<fims__BMContentStatusType * >*a, const char *type)
{
	for (std::vector<fims__BMContentStatusType * >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTofims__BMContentStatusType(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<fims__BMContentStatusType * >* SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTofims__BMContentStatusType(struct soap *soap, const char *tag, std::vector<fims__BMContentStatusType * >*a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{	fims__BMContentStatusType *n;
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href))
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_fims__BMContentStatusType, SOAP_TYPE_std__vectorTemplateOfPointerTofims__BMContentStatusType, sizeof(fims__BMContentStatusType), 1))
				break;
			if (!soap_in_PointerTofims__BMContentStatusType(soap, tag, NULL, "fims:BMContentStatusType"))
				break;
		}
		else if (!soap_in_PointerTofims__BMContentStatusType(soap, tag, &n, "fims:BMContentStatusType"))
			break;
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTofims__BMContentStatusType(soap, -1)))
			return NULL;
		a->push_back(n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<fims__BMContentStatusType * > * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTofims__BMContentStatusType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTofims__BMContentStatusType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOfPointerTofims__BMContentStatusType, n, EDLProvider_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(std::vector<fims__BMContentStatusType * >);
		if (size)
			*size = sizeof(std::vector<fims__BMContentStatusType * >);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(std::vector<fims__BMContentStatusType * >, n);
		if (size)
			*size = n * sizeof(std::vector<fims__BMContentStatusType * >);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (std::vector<fims__BMContentStatusType * >*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfPointerTofims__BMContentStatusType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<fims__BMContentStatusType * > %p -> %p\n", q, p));
	*(std::vector<fims__BMContentStatusType * >*)p = *(std::vector<fims__BMContentStatusType * >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTofims__BMCustomStatusExtensionType(struct soap *soap, std::vector<fims__BMCustomStatusExtensionType * >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTofims__BMCustomStatusExtensionType(struct soap *soap, const std::vector<fims__BMCustomStatusExtensionType * >*a)
{
#ifndef WITH_NOIDREF
	for (std::vector<fims__BMCustomStatusExtensionType * >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTofims__BMCustomStatusExtensionType(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTofims__BMCustomStatusExtensionType(struct soap *soap, const char *tag, int id, const std::vector<fims__BMCustomStatusExtensionType * >*a, const char *type)
{
	for (std::vector<fims__BMCustomStatusExtensionType * >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTofims__BMCustomStatusExtensionType(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<fims__BMCustomStatusExtensionType * >* SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTofims__BMCustomStatusExtensionType(struct soap *soap, const char *tag, std::vector<fims__BMCustomStatusExtensionType * >*a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{	fims__BMCustomStatusExtensionType *n;
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href))
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_fims__BMCustomStatusExtensionType, SOAP_TYPE_std__vectorTemplateOfPointerTofims__BMCustomStatusExtensionType, sizeof(fims__BMCustomStatusExtensionType), 1))
				break;
			if (!soap_in_PointerTofims__BMCustomStatusExtensionType(soap, tag, NULL, "fims:BMCustomStatusExtensionType"))
				break;
		}
		else if (!soap_in_PointerTofims__BMCustomStatusExtensionType(soap, tag, &n, "fims:BMCustomStatusExtensionType"))
			break;
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTofims__BMCustomStatusExtensionType(soap, -1)))
			return NULL;
		a->push_back(n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<fims__BMCustomStatusExtensionType * > * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTofims__BMCustomStatusExtensionType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTofims__BMCustomStatusExtensionType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOfPointerTofims__BMCustomStatusExtensionType, n, EDLProvider_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(std::vector<fims__BMCustomStatusExtensionType * >);
		if (size)
			*size = sizeof(std::vector<fims__BMCustomStatusExtensionType * >);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(std::vector<fims__BMCustomStatusExtensionType * >, n);
		if (size)
			*size = n * sizeof(std::vector<fims__BMCustomStatusExtensionType * >);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (std::vector<fims__BMCustomStatusExtensionType * >*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfPointerTofims__BMCustomStatusExtensionType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<fims__BMCustomStatusExtensionType * > %p -> %p\n", q, p));
	*(std::vector<fims__BMCustomStatusExtensionType * >*)p = *(std::vector<fims__BMCustomStatusExtensionType * >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTofims__CustomValueType(struct soap *soap, std::vector<fims__CustomValueType * >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTofims__CustomValueType(struct soap *soap, const std::vector<fims__CustomValueType * >*a)
{
#ifndef WITH_NOIDREF
	for (std::vector<fims__CustomValueType * >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTofims__CustomValueType(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTofims__CustomValueType(struct soap *soap, const char *tag, int id, const std::vector<fims__CustomValueType * >*a, const char *type)
{
	for (std::vector<fims__CustomValueType * >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTofims__CustomValueType(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<fims__CustomValueType * >* SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTofims__CustomValueType(struct soap *soap, const char *tag, std::vector<fims__CustomValueType * >*a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{	fims__CustomValueType *n;
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href))
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_fims__CustomValueType, SOAP_TYPE_std__vectorTemplateOfPointerTofims__CustomValueType, sizeof(fims__CustomValueType), 1))
				break;
			if (!soap_in_PointerTofims__CustomValueType(soap, tag, NULL, "fims:CustomValueType"))
				break;
		}
		else if (!soap_in_PointerTofims__CustomValueType(soap, tag, &n, "fims:CustomValueType"))
			break;
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTofims__CustomValueType(soap, -1)))
			return NULL;
		a->push_back(n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<fims__CustomValueType * > * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTofims__CustomValueType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTofims__CustomValueType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOfPointerTofims__CustomValueType, n, EDLProvider_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(std::vector<fims__CustomValueType * >);
		if (size)
			*size = sizeof(std::vector<fims__CustomValueType * >);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(std::vector<fims__CustomValueType * >, n);
		if (size)
			*size = n * sizeof(std::vector<fims__CustomValueType * >);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (std::vector<fims__CustomValueType * >*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfPointerTofims__CustomValueType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<fims__CustomValueType * > %p -> %p\n", q, p));
	*(std::vector<fims__CustomValueType * >*)p = *(std::vector<fims__CustomValueType * >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTofims__ResourceReferenceType(struct soap *soap, std::vector<fims__ResourceReferenceType * >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTofims__ResourceReferenceType(struct soap *soap, const std::vector<fims__ResourceReferenceType * >*a)
{
#ifndef WITH_NOIDREF
	for (std::vector<fims__ResourceReferenceType * >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTofims__ResourceReferenceType(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTofims__ResourceReferenceType(struct soap *soap, const char *tag, int id, const std::vector<fims__ResourceReferenceType * >*a, const char *type)
{
	for (std::vector<fims__ResourceReferenceType * >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTofims__ResourceReferenceType(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<fims__ResourceReferenceType * >* SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTofims__ResourceReferenceType(struct soap *soap, const char *tag, std::vector<fims__ResourceReferenceType * >*a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{	fims__ResourceReferenceType *n;
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href))
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_fims__ResourceReferenceType, SOAP_TYPE_std__vectorTemplateOfPointerTofims__ResourceReferenceType, sizeof(fims__ResourceReferenceType), 1))
				break;
			if (!soap_in_PointerTofims__ResourceReferenceType(soap, tag, NULL, "fims:ResourceReferenceType"))
				break;
		}
		else if (!soap_in_PointerTofims__ResourceReferenceType(soap, tag, &n, "fims:ResourceReferenceType"))
			break;
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTofims__ResourceReferenceType(soap, -1)))
			return NULL;
		a->push_back(n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<fims__ResourceReferenceType * > * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTofims__ResourceReferenceType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTofims__ResourceReferenceType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOfPointerTofims__ResourceReferenceType, n, EDLProvider_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(std::vector<fims__ResourceReferenceType * >);
		if (size)
			*size = sizeof(std::vector<fims__ResourceReferenceType * >);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(std::vector<fims__ResourceReferenceType * >, n);
		if (size)
			*size = n * sizeof(std::vector<fims__ResourceReferenceType * >);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (std::vector<fims__ResourceReferenceType * >*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfPointerTofims__ResourceReferenceType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<fims__ResourceReferenceType * > %p -> %p\n", q, p));
	*(std::vector<fims__ResourceReferenceType * >*)p = *(std::vector<fims__ResourceReferenceType * >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTofims__DescriptionType(struct soap *soap, std::vector<fims__DescriptionType * >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTofims__DescriptionType(struct soap *soap, const std::vector<fims__DescriptionType * >*a)
{
#ifndef WITH_NOIDREF
	for (std::vector<fims__DescriptionType * >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTofims__DescriptionType(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTofims__DescriptionType(struct soap *soap, const char *tag, int id, const std::vector<fims__DescriptionType * >*a, const char *type)
{
	for (std::vector<fims__DescriptionType * >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTofims__DescriptionType(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<fims__DescriptionType * >* SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTofims__DescriptionType(struct soap *soap, const char *tag, std::vector<fims__DescriptionType * >*a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{	fims__DescriptionType *n;
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href))
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_fims__DescriptionType, SOAP_TYPE_std__vectorTemplateOfPointerTofims__DescriptionType, sizeof(fims__DescriptionType), 1))
				break;
			if (!soap_in_PointerTofims__DescriptionType(soap, tag, NULL, "fims:DescriptionType"))
				break;
		}
		else if (!soap_in_PointerTofims__DescriptionType(soap, tag, &n, "fims:DescriptionType"))
			break;
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTofims__DescriptionType(soap, -1)))
			return NULL;
		a->push_back(n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<fims__DescriptionType * > * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTofims__DescriptionType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTofims__DescriptionType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOfPointerTofims__DescriptionType, n, EDLProvider_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(std::vector<fims__DescriptionType * >);
		if (size)
			*size = sizeof(std::vector<fims__DescriptionType * >);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(std::vector<fims__DescriptionType * >, n);
		if (size)
			*size = n * sizeof(std::vector<fims__DescriptionType * >);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (std::vector<fims__DescriptionType * >*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfPointerTofims__DescriptionType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<fims__DescriptionType * > %p -> %p\n", q, p));
	*(std::vector<fims__DescriptionType * >*)p = *(std::vector<fims__DescriptionType * >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTofims__BMEssenceLocatorType(struct soap *soap, std::vector<fims__BMEssenceLocatorType * >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTofims__BMEssenceLocatorType(struct soap *soap, const std::vector<fims__BMEssenceLocatorType * >*a)
{
#ifndef WITH_NOIDREF
	for (std::vector<fims__BMEssenceLocatorType * >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTofims__BMEssenceLocatorType(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTofims__BMEssenceLocatorType(struct soap *soap, const char *tag, int id, const std::vector<fims__BMEssenceLocatorType * >*a, const char *type)
{
	for (std::vector<fims__BMEssenceLocatorType * >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTofims__BMEssenceLocatorType(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<fims__BMEssenceLocatorType * >* SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTofims__BMEssenceLocatorType(struct soap *soap, const char *tag, std::vector<fims__BMEssenceLocatorType * >*a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{	fims__BMEssenceLocatorType *n;
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href))
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_fims__BMEssenceLocatorType, SOAP_TYPE_std__vectorTemplateOfPointerTofims__BMEssenceLocatorType, sizeof(fims__BMEssenceLocatorType), 1))
				break;
			if (!soap_in_PointerTofims__BMEssenceLocatorType(soap, tag, NULL, "fims:BMEssenceLocatorType"))
				break;
		}
		else if (!soap_in_PointerTofims__BMEssenceLocatorType(soap, tag, &n, "fims:BMEssenceLocatorType"))
			break;
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTofims__BMEssenceLocatorType(soap, -1)))
			return NULL;
		a->push_back(n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<fims__BMEssenceLocatorType * > * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTofims__BMEssenceLocatorType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTofims__BMEssenceLocatorType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOfPointerTofims__BMEssenceLocatorType, n, EDLProvider_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(std::vector<fims__BMEssenceLocatorType * >);
		if (size)
			*size = sizeof(std::vector<fims__BMEssenceLocatorType * >);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(std::vector<fims__BMEssenceLocatorType * >, n);
		if (size)
			*size = n * sizeof(std::vector<fims__BMEssenceLocatorType * >);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (std::vector<fims__BMEssenceLocatorType * >*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfPointerTofims__BMEssenceLocatorType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<fims__BMEssenceLocatorType * > %p -> %p\n", q, p));
	*(std::vector<fims__BMEssenceLocatorType * >*)p = *(std::vector<fims__BMEssenceLocatorType * >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTofims__BMContentFormatType(struct soap *soap, std::vector<fims__BMContentFormatType * >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTofims__BMContentFormatType(struct soap *soap, const std::vector<fims__BMContentFormatType * >*a)
{
#ifndef WITH_NOIDREF
	for (std::vector<fims__BMContentFormatType * >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTofims__BMContentFormatType(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTofims__BMContentFormatType(struct soap *soap, const char *tag, int id, const std::vector<fims__BMContentFormatType * >*a, const char *type)
{
	for (std::vector<fims__BMContentFormatType * >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTofims__BMContentFormatType(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<fims__BMContentFormatType * >* SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTofims__BMContentFormatType(struct soap *soap, const char *tag, std::vector<fims__BMContentFormatType * >*a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{	fims__BMContentFormatType *n;
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href))
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_fims__BMContentFormatType, SOAP_TYPE_std__vectorTemplateOfPointerTofims__BMContentFormatType, sizeof(fims__BMContentFormatType), 1))
				break;
			if (!soap_in_PointerTofims__BMContentFormatType(soap, tag, NULL, "fims:BMContentFormatType"))
				break;
		}
		else if (!soap_in_PointerTofims__BMContentFormatType(soap, tag, &n, "fims:BMContentFormatType"))
			break;
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTofims__BMContentFormatType(soap, -1)))
			return NULL;
		a->push_back(n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<fims__BMContentFormatType * > * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTofims__BMContentFormatType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTofims__BMContentFormatType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOfPointerTofims__BMContentFormatType, n, EDLProvider_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(std::vector<fims__BMContentFormatType * >);
		if (size)
			*size = sizeof(std::vector<fims__BMContentFormatType * >);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(std::vector<fims__BMContentFormatType * >, n);
		if (size)
			*size = n * sizeof(std::vector<fims__BMContentFormatType * >);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (std::vector<fims__BMContentFormatType * >*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfPointerTofims__BMContentFormatType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<fims__BMContentFormatType * > %p -> %p\n", q, p));
	*(std::vector<fims__BMContentFormatType * >*)p = *(std::vector<fims__BMContentFormatType * >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTofims__BMContentType(struct soap *soap, std::vector<fims__BMContentType * >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTofims__BMContentType(struct soap *soap, const std::vector<fims__BMContentType * >*a)
{
#ifndef WITH_NOIDREF
	for (std::vector<fims__BMContentType * >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTofims__BMContentType(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTofims__BMContentType(struct soap *soap, const char *tag, int id, const std::vector<fims__BMContentType * >*a, const char *type)
{
	for (std::vector<fims__BMContentType * >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTofims__BMContentType(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<fims__BMContentType * >* SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTofims__BMContentType(struct soap *soap, const char *tag, std::vector<fims__BMContentType * >*a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{	fims__BMContentType *n;
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href))
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_fims__BMContentType, SOAP_TYPE_std__vectorTemplateOfPointerTofims__BMContentType, sizeof(fims__BMContentType), 1))
				break;
			if (!soap_in_PointerTofims__BMContentType(soap, tag, NULL, "fims:BMContentType"))
				break;
		}
		else if (!soap_in_PointerTofims__BMContentType(soap, tag, &n, "fims:BMContentType"))
			break;
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTofims__BMContentType(soap, -1)))
			return NULL;
		a->push_back(n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<fims__BMContentType * > * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTofims__BMContentType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTofims__BMContentType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOfPointerTofims__BMContentType, n, EDLProvider_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(std::vector<fims__BMContentType * >);
		if (size)
			*size = sizeof(std::vector<fims__BMContentType * >);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(std::vector<fims__BMContentType * >, n);
		if (size)
			*size = n * sizeof(std::vector<fims__BMContentType * >);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (std::vector<fims__BMContentType * >*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfPointerTofims__BMContentType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<fims__BMContentType * > %p -> %p\n", q, p));
	*(std::vector<fims__BMContentType * >*)p = *(std::vector<fims__BMContentType * >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTofims__BMObjectType(struct soap *soap, std::vector<fims__BMObjectType * >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTofims__BMObjectType(struct soap *soap, const std::vector<fims__BMObjectType * >*a)
{
#ifndef WITH_NOIDREF
	for (std::vector<fims__BMObjectType * >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTofims__BMObjectType(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTofims__BMObjectType(struct soap *soap, const char *tag, int id, const std::vector<fims__BMObjectType * >*a, const char *type)
{
	for (std::vector<fims__BMObjectType * >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTofims__BMObjectType(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<fims__BMObjectType * >* SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTofims__BMObjectType(struct soap *soap, const char *tag, std::vector<fims__BMObjectType * >*a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{	fims__BMObjectType *n;
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href))
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_fims__BMObjectType, SOAP_TYPE_std__vectorTemplateOfPointerTofims__BMObjectType, sizeof(fims__BMObjectType), 1))
				break;
			if (!soap_in_PointerTofims__BMObjectType(soap, tag, NULL, "fims:BMObjectType"))
				break;
		}
		else if (!soap_in_PointerTofims__BMObjectType(soap, tag, &n, "fims:BMObjectType"))
			break;
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTofims__BMObjectType(soap, -1)))
			return NULL;
		a->push_back(n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<fims__BMObjectType * > * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTofims__BMObjectType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTofims__BMObjectType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOfPointerTofims__BMObjectType, n, EDLProvider_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(std::vector<fims__BMObjectType * >);
		if (size)
			*size = sizeof(std::vector<fims__BMObjectType * >);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(std::vector<fims__BMObjectType * >, n);
		if (size)
			*size = n * sizeof(std::vector<fims__BMObjectType * >);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (std::vector<fims__BMObjectType * >*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfPointerTofims__BMObjectType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<fims__BMObjectType * > %p -> %p\n", q, p));
	*(std::vector<fims__BMObjectType * >*)p = *(std::vector<fims__BMObjectType * >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTofims__DataFormatType(struct soap *soap, std::vector<fims__DataFormatType * >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTofims__DataFormatType(struct soap *soap, const std::vector<fims__DataFormatType * >*a)
{
#ifndef WITH_NOIDREF
	for (std::vector<fims__DataFormatType * >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTofims__DataFormatType(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTofims__DataFormatType(struct soap *soap, const char *tag, int id, const std::vector<fims__DataFormatType * >*a, const char *type)
{
	for (std::vector<fims__DataFormatType * >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTofims__DataFormatType(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<fims__DataFormatType * >* SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTofims__DataFormatType(struct soap *soap, const char *tag, std::vector<fims__DataFormatType * >*a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{	fims__DataFormatType *n;
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href))
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_fims__DataFormatType, SOAP_TYPE_std__vectorTemplateOfPointerTofims__DataFormatType, sizeof(fims__DataFormatType), 1))
				break;
			if (!soap_in_PointerTofims__DataFormatType(soap, tag, NULL, "fims:DataFormatType"))
				break;
		}
		else if (!soap_in_PointerTofims__DataFormatType(soap, tag, &n, "fims:DataFormatType"))
			break;
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTofims__DataFormatType(soap, -1)))
			return NULL;
		a->push_back(n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<fims__DataFormatType * > * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTofims__DataFormatType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTofims__DataFormatType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOfPointerTofims__DataFormatType, n, EDLProvider_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(std::vector<fims__DataFormatType * >);
		if (size)
			*size = sizeof(std::vector<fims__DataFormatType * >);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(std::vector<fims__DataFormatType * >, n);
		if (size)
			*size = n * sizeof(std::vector<fims__DataFormatType * >);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (std::vector<fims__DataFormatType * >*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfPointerTofims__DataFormatType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<fims__DataFormatType * > %p -> %p\n", q, p));
	*(std::vector<fims__DataFormatType * >*)p = *(std::vector<fims__DataFormatType * >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTofims__ContainerFormatType(struct soap *soap, std::vector<fims__ContainerFormatType * >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTofims__ContainerFormatType(struct soap *soap, const std::vector<fims__ContainerFormatType * >*a)
{
#ifndef WITH_NOIDREF
	for (std::vector<fims__ContainerFormatType * >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTofims__ContainerFormatType(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTofims__ContainerFormatType(struct soap *soap, const char *tag, int id, const std::vector<fims__ContainerFormatType * >*a, const char *type)
{
	for (std::vector<fims__ContainerFormatType * >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTofims__ContainerFormatType(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<fims__ContainerFormatType * >* SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTofims__ContainerFormatType(struct soap *soap, const char *tag, std::vector<fims__ContainerFormatType * >*a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{	fims__ContainerFormatType *n;
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href))
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_fims__ContainerFormatType, SOAP_TYPE_std__vectorTemplateOfPointerTofims__ContainerFormatType, sizeof(fims__ContainerFormatType), 1))
				break;
			if (!soap_in_PointerTofims__ContainerFormatType(soap, tag, NULL, "fims:ContainerFormatType"))
				break;
		}
		else if (!soap_in_PointerTofims__ContainerFormatType(soap, tag, &n, "fims:ContainerFormatType"))
			break;
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTofims__ContainerFormatType(soap, -1)))
			return NULL;
		a->push_back(n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<fims__ContainerFormatType * > * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTofims__ContainerFormatType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTofims__ContainerFormatType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOfPointerTofims__ContainerFormatType, n, EDLProvider_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(std::vector<fims__ContainerFormatType * >);
		if (size)
			*size = sizeof(std::vector<fims__ContainerFormatType * >);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(std::vector<fims__ContainerFormatType * >, n);
		if (size)
			*size = n * sizeof(std::vector<fims__ContainerFormatType * >);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (std::vector<fims__ContainerFormatType * >*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfPointerTofims__ContainerFormatType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<fims__ContainerFormatType * > %p -> %p\n", q, p));
	*(std::vector<fims__ContainerFormatType * >*)p = *(std::vector<fims__ContainerFormatType * >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTofims__AudioFormatType(struct soap *soap, std::vector<fims__AudioFormatType * >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTofims__AudioFormatType(struct soap *soap, const std::vector<fims__AudioFormatType * >*a)
{
#ifndef WITH_NOIDREF
	for (std::vector<fims__AudioFormatType * >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTofims__AudioFormatType(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTofims__AudioFormatType(struct soap *soap, const char *tag, int id, const std::vector<fims__AudioFormatType * >*a, const char *type)
{
	for (std::vector<fims__AudioFormatType * >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTofims__AudioFormatType(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<fims__AudioFormatType * >* SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTofims__AudioFormatType(struct soap *soap, const char *tag, std::vector<fims__AudioFormatType * >*a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{	fims__AudioFormatType *n;
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href))
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_fims__AudioFormatType, SOAP_TYPE_std__vectorTemplateOfPointerTofims__AudioFormatType, sizeof(fims__AudioFormatType), 1))
				break;
			if (!soap_in_PointerTofims__AudioFormatType(soap, tag, NULL, "fims:AudioFormatType"))
				break;
		}
		else if (!soap_in_PointerTofims__AudioFormatType(soap, tag, &n, "fims:AudioFormatType"))
			break;
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTofims__AudioFormatType(soap, -1)))
			return NULL;
		a->push_back(n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<fims__AudioFormatType * > * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTofims__AudioFormatType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTofims__AudioFormatType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOfPointerTofims__AudioFormatType, n, EDLProvider_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(std::vector<fims__AudioFormatType * >);
		if (size)
			*size = sizeof(std::vector<fims__AudioFormatType * >);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(std::vector<fims__AudioFormatType * >, n);
		if (size)
			*size = n * sizeof(std::vector<fims__AudioFormatType * >);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (std::vector<fims__AudioFormatType * >*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfPointerTofims__AudioFormatType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<fims__AudioFormatType * > %p -> %p\n", q, p));
	*(std::vector<fims__AudioFormatType * >*)p = *(std::vector<fims__AudioFormatType * >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTofims__VideoFormatType(struct soap *soap, std::vector<fims__VideoFormatType * >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTofims__VideoFormatType(struct soap *soap, const std::vector<fims__VideoFormatType * >*a)
{
#ifndef WITH_NOIDREF
	for (std::vector<fims__VideoFormatType * >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTofims__VideoFormatType(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTofims__VideoFormatType(struct soap *soap, const char *tag, int id, const std::vector<fims__VideoFormatType * >*a, const char *type)
{
	for (std::vector<fims__VideoFormatType * >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTofims__VideoFormatType(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<fims__VideoFormatType * >* SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTofims__VideoFormatType(struct soap *soap, const char *tag, std::vector<fims__VideoFormatType * >*a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{	fims__VideoFormatType *n;
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href))
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_fims__VideoFormatType, SOAP_TYPE_std__vectorTemplateOfPointerTofims__VideoFormatType, sizeof(fims__VideoFormatType), 1))
				break;
			if (!soap_in_PointerTofims__VideoFormatType(soap, tag, NULL, "fims:VideoFormatType"))
				break;
		}
		else if (!soap_in_PointerTofims__VideoFormatType(soap, tag, &n, "fims:VideoFormatType"))
			break;
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTofims__VideoFormatType(soap, -1)))
			return NULL;
		a->push_back(n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<fims__VideoFormatType * > * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTofims__VideoFormatType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTofims__VideoFormatType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOfPointerTofims__VideoFormatType, n, EDLProvider_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(std::vector<fims__VideoFormatType * >);
		if (size)
			*size = sizeof(std::vector<fims__VideoFormatType * >);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(std::vector<fims__VideoFormatType * >, n);
		if (size)
			*size = n * sizeof(std::vector<fims__VideoFormatType * >);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (std::vector<fims__VideoFormatType * >*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfPointerTofims__VideoFormatType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<fims__VideoFormatType * > %p -> %p\n", q, p));
	*(std::vector<fims__VideoFormatType * >*)p = *(std::vector<fims__VideoFormatType * >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTofims__JobType(struct soap *soap, std::vector<fims__JobType * >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTofims__JobType(struct soap *soap, const std::vector<fims__JobType * >*a)
{
#ifndef WITH_NOIDREF
	for (std::vector<fims__JobType * >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTofims__JobType(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTofims__JobType(struct soap *soap, const char *tag, int id, const std::vector<fims__JobType * >*a, const char *type)
{
	for (std::vector<fims__JobType * >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTofims__JobType(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<fims__JobType * >* SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTofims__JobType(struct soap *soap, const char *tag, std::vector<fims__JobType * >*a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{	fims__JobType *n;
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href))
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_fims__JobType, SOAP_TYPE_std__vectorTemplateOfPointerTofims__JobType, sizeof(fims__JobType), 1))
				break;
			if (!soap_in_PointerTofims__JobType(soap, tag, NULL, "fims:JobType"))
				break;
		}
		else if (!soap_in_PointerTofims__JobType(soap, tag, &n, "fims:JobType"))
			break;
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTofims__JobType(soap, -1)))
			return NULL;
		a->push_back(n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<fims__JobType * > * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTofims__JobType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTofims__JobType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOfPointerTofims__JobType, n, EDLProvider_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(std::vector<fims__JobType * >);
		if (size)
			*size = sizeof(std::vector<fims__JobType * >);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(std::vector<fims__JobType * >, n);
		if (size)
			*size = n * sizeof(std::vector<fims__JobType * >);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (std::vector<fims__JobType * >*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfPointerTofims__JobType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<fims__JobType * > %p -> %p\n", q, p));
	*(std::vector<fims__JobType * >*)p = *(std::vector<fims__JobType * >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTofims__QueueType(struct soap *soap, std::vector<fims__QueueType * >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTofims__QueueType(struct soap *soap, const std::vector<fims__QueueType * >*a)
{
#ifndef WITH_NOIDREF
	for (std::vector<fims__QueueType * >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTofims__QueueType(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTofims__QueueType(struct soap *soap, const char *tag, int id, const std::vector<fims__QueueType * >*a, const char *type)
{
	for (std::vector<fims__QueueType * >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTofims__QueueType(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<fims__QueueType * >* SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTofims__QueueType(struct soap *soap, const char *tag, std::vector<fims__QueueType * >*a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{	fims__QueueType *n;
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href))
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_fims__QueueType, SOAP_TYPE_std__vectorTemplateOfPointerTofims__QueueType, sizeof(fims__QueueType), 1))
				break;
			if (!soap_in_PointerTofims__QueueType(soap, tag, NULL, "fims:QueueType"))
				break;
		}
		else if (!soap_in_PointerTofims__QueueType(soap, tag, &n, "fims:QueueType"))
			break;
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTofims__QueueType(soap, -1)))
			return NULL;
		a->push_back(n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<fims__QueueType * > * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTofims__QueueType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTofims__QueueType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOfPointerTofims__QueueType, n, EDLProvider_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(std::vector<fims__QueueType * >);
		if (size)
			*size = sizeof(std::vector<fims__QueueType * >);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(std::vector<fims__QueueType * >, n);
		if (size)
			*size = n * sizeof(std::vector<fims__QueueType * >);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (std::vector<fims__QueueType * >*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfPointerTofims__QueueType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<fims__QueueType * > %p -> %p\n", q, p));
	*(std::vector<fims__QueueType * >*)p = *(std::vector<fims__QueueType * >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTofims__ServiceType(struct soap *soap, std::vector<fims__ServiceType * >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTofims__ServiceType(struct soap *soap, const std::vector<fims__ServiceType * >*a)
{
#ifndef WITH_NOIDREF
	for (std::vector<fims__ServiceType * >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTofims__ServiceType(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTofims__ServiceType(struct soap *soap, const char *tag, int id, const std::vector<fims__ServiceType * >*a, const char *type)
{
	for (std::vector<fims__ServiceType * >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTofims__ServiceType(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<fims__ServiceType * >* SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTofims__ServiceType(struct soap *soap, const char *tag, std::vector<fims__ServiceType * >*a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{	fims__ServiceType *n;
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href))
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_fims__ServiceType, SOAP_TYPE_std__vectorTemplateOfPointerTofims__ServiceType, sizeof(fims__ServiceType), 1))
				break;
			if (!soap_in_PointerTofims__ServiceType(soap, tag, NULL, "fims:ServiceType"))
				break;
		}
		else if (!soap_in_PointerTofims__ServiceType(soap, tag, &n, "fims:ServiceType"))
			break;
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTofims__ServiceType(soap, -1)))
			return NULL;
		a->push_back(n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<fims__ServiceType * > * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTofims__ServiceType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTofims__ServiceType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOfPointerTofims__ServiceType, n, EDLProvider_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(std::vector<fims__ServiceType * >);
		if (size)
			*size = sizeof(std::vector<fims__ServiceType * >);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(std::vector<fims__ServiceType * >, n);
		if (size)
			*size = n * sizeof(std::vector<fims__ServiceType * >);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (std::vector<fims__ServiceType * >*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfPointerTofims__ServiceType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<fims__ServiceType * > %p -> %p\n", q, p));
	*(std::vector<fims__ServiceType * >*)p = *(std::vector<fims__ServiceType * >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTofims__ProfileType(struct soap *soap, std::vector<fims__ProfileType * >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTofims__ProfileType(struct soap *soap, const std::vector<fims__ProfileType * >*a)
{
#ifndef WITH_NOIDREF
	for (std::vector<fims__ProfileType * >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTofims__ProfileType(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTofims__ProfileType(struct soap *soap, const char *tag, int id, const std::vector<fims__ProfileType * >*a, const char *type)
{
	for (std::vector<fims__ProfileType * >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTofims__ProfileType(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<fims__ProfileType * >* SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTofims__ProfileType(struct soap *soap, const char *tag, std::vector<fims__ProfileType * >*a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{	fims__ProfileType *n;
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href))
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_fims__ProfileType, SOAP_TYPE_std__vectorTemplateOfPointerTofims__ProfileType, sizeof(fims__ProfileType), 1))
				break;
			if (!soap_in_PointerTofims__ProfileType(soap, tag, NULL, "fims:ProfileType"))
				break;
		}
		else if (!soap_in_PointerTofims__ProfileType(soap, tag, &n, "fims:ProfileType"))
			break;
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTofims__ProfileType(soap, -1)))
			return NULL;
		a->push_back(n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<fims__ProfileType * > * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTofims__ProfileType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTofims__ProfileType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOfPointerTofims__ProfileType, n, EDLProvider_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(std::vector<fims__ProfileType * >);
		if (size)
			*size = sizeof(std::vector<fims__ProfileType * >);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(std::vector<fims__ProfileType * >, n);
		if (size)
			*size = n * sizeof(std::vector<fims__ProfileType * >);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (std::vector<fims__ProfileType * >*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfPointerTofims__ProfileType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<fims__ProfileType * > %p -> %p\n", q, p));
	*(std::vector<fims__ProfileType * >*)p = *(std::vector<fims__ProfileType * >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTofims__ResourceType(struct soap *soap, std::vector<fims__ResourceType * >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTofims__ResourceType(struct soap *soap, const std::vector<fims__ResourceType * >*a)
{
#ifndef WITH_NOIDREF
	for (std::vector<fims__ResourceType * >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTofims__ResourceType(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTofims__ResourceType(struct soap *soap, const char *tag, int id, const std::vector<fims__ResourceType * >*a, const char *type)
{
	for (std::vector<fims__ResourceType * >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTofims__ResourceType(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<fims__ResourceType * >* SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTofims__ResourceType(struct soap *soap, const char *tag, std::vector<fims__ResourceType * >*a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{	fims__ResourceType *n;
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href))
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_fims__ResourceType, SOAP_TYPE_std__vectorTemplateOfPointerTofims__ResourceType, sizeof(fims__ResourceType), 1))
				break;
			if (!soap_in_PointerTofims__ResourceType(soap, tag, NULL, "fims:ResourceType"))
				break;
		}
		else if (!soap_in_PointerTofims__ResourceType(soap, tag, &n, "fims:ResourceType"))
			break;
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTofims__ResourceType(soap, -1)))
			return NULL;
		a->push_back(n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<fims__ResourceType * > * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTofims__ResourceType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTofims__ResourceType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOfPointerTofims__ResourceType, n, EDLProvider_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(std::vector<fims__ResourceType * >);
		if (size)
			*size = sizeof(std::vector<fims__ResourceType * >);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(std::vector<fims__ResourceType * >, n);
		if (size)
			*size = n * sizeof(std::vector<fims__ResourceType * >);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (std::vector<fims__ResourceType * >*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfPointerTofims__ResourceType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<fims__ResourceType * > %p -> %p\n", q, p));
	*(std::vector<fims__ResourceType * >*)p = *(std::vector<fims__ResourceType * >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTofims__InnerFaultType(struct soap *soap, std::vector<fims__InnerFaultType * >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTofims__InnerFaultType(struct soap *soap, const std::vector<fims__InnerFaultType * >*a)
{
#ifndef WITH_NOIDREF
	for (std::vector<fims__InnerFaultType * >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTofims__InnerFaultType(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTofims__InnerFaultType(struct soap *soap, const char *tag, int id, const std::vector<fims__InnerFaultType * >*a, const char *type)
{
	for (std::vector<fims__InnerFaultType * >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTofims__InnerFaultType(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<fims__InnerFaultType * >* SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTofims__InnerFaultType(struct soap *soap, const char *tag, std::vector<fims__InnerFaultType * >*a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{	fims__InnerFaultType *n;
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href))
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_fims__InnerFaultType, SOAP_TYPE_std__vectorTemplateOfPointerTofims__InnerFaultType, sizeof(fims__InnerFaultType), 1))
				break;
			if (!soap_in_PointerTofims__InnerFaultType(soap, tag, NULL, "fims:InnerFaultType"))
				break;
		}
		else if (!soap_in_PointerTofims__InnerFaultType(soap, tag, &n, "fims:InnerFaultType"))
			break;
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTofims__InnerFaultType(soap, -1)))
			return NULL;
		a->push_back(n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<fims__InnerFaultType * > * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTofims__InnerFaultType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTofims__InnerFaultType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOfPointerTofims__InnerFaultType, n, EDLProvider_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(std::vector<fims__InnerFaultType * >);
		if (size)
			*size = sizeof(std::vector<fims__InnerFaultType * >);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(std::vector<fims__InnerFaultType * >, n);
		if (size)
			*size = n * sizeof(std::vector<fims__InnerFaultType * >);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (std::vector<fims__InnerFaultType * >*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfPointerTofims__InnerFaultType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<fims__InnerFaultType * > %p -> %p\n", q, p));
	*(std::vector<fims__InnerFaultType * >*)p = *(std::vector<fims__InnerFaultType * >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOf_XML(struct soap *soap, std::vector<char * >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOf_XML(struct soap *soap, const std::vector<char * >*a)
{
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOf_XML(struct soap *soap, const char *tag, int id, const std::vector<char * >*a, const char *type)
{
	for (std::vector<char * >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_outliteral(soap, tag, &(*i), NULL))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<char * >* SOAP_FMAC4 soap_in_std__vectorTemplateOf_XML(struct soap *soap, const char *tag, std::vector<char * >*a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{	char *n;
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href))
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE__XML, SOAP_TYPE_std__vectorTemplateOf_XML, sizeof(char *), 1))
				break;
			if (!soap_inliteral(soap, tag, NULL))
				break;
		}
		else if (!soap_inliteral(soap, tag, &n))
			break;
		if (!a && !(a = soap_new_std__vectorTemplateOf_XML(soap, -1)))
			return NULL;
		a->push_back(n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<char * > * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOf_XML(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOf_XML(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOf_XML, n, EDLProvider_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(std::vector<char * >);
		if (size)
			*size = sizeof(std::vector<char * >);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(std::vector<char * >, n);
		if (size)
			*size = n * sizeof(std::vector<char * >);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (std::vector<char * >*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOf_XML(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<char * > %p -> %p\n", q, p));
	*(std::vector<char * >*)p = *(std::vector<char * >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerToedlprovider__MapItemType(struct soap *soap, std::vector<edlprovider__MapItemType * >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerToedlprovider__MapItemType(struct soap *soap, const std::vector<edlprovider__MapItemType * >*a)
{
#ifndef WITH_NOIDREF
	for (std::vector<edlprovider__MapItemType * >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerToedlprovider__MapItemType(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerToedlprovider__MapItemType(struct soap *soap, const char *tag, int id, const std::vector<edlprovider__MapItemType * >*a, const char *type)
{
	for (std::vector<edlprovider__MapItemType * >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerToedlprovider__MapItemType(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<edlprovider__MapItemType * >* SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerToedlprovider__MapItemType(struct soap *soap, const char *tag, std::vector<edlprovider__MapItemType * >*a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{	edlprovider__MapItemType *n;
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href))
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_edlprovider__MapItemType, SOAP_TYPE_std__vectorTemplateOfPointerToedlprovider__MapItemType, sizeof(edlprovider__MapItemType), 1))
				break;
			if (!soap_in_PointerToedlprovider__MapItemType(soap, tag, NULL, "edlprovider:MapItemType"))
				break;
		}
		else if (!soap_in_PointerToedlprovider__MapItemType(soap, tag, &n, "edlprovider:MapItemType"))
			break;
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerToedlprovider__MapItemType(soap, -1)))
			return NULL;
		a->push_back(n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<edlprovider__MapItemType * > * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerToedlprovider__MapItemType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerToedlprovider__MapItemType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOfPointerToedlprovider__MapItemType, n, EDLProvider_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(std::vector<edlprovider__MapItemType * >);
		if (size)
			*size = sizeof(std::vector<edlprovider__MapItemType * >);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(std::vector<edlprovider__MapItemType * >, n);
		if (size)
			*size = n * sizeof(std::vector<edlprovider__MapItemType * >);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (std::vector<edlprovider__MapItemType * >*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfPointerToedlprovider__MapItemType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<edlprovider__MapItemType * > %p -> %p\n", q, p));
	*(std::vector<edlprovider__MapItemType * >*)p = *(std::vector<edlprovider__MapItemType * >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerToedlprovider__ClipType(struct soap *soap, std::vector<edlprovider__ClipType * >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerToedlprovider__ClipType(struct soap *soap, const std::vector<edlprovider__ClipType * >*a)
{
#ifndef WITH_NOIDREF
	for (std::vector<edlprovider__ClipType * >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerToedlprovider__ClipType(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerToedlprovider__ClipType(struct soap *soap, const char *tag, int id, const std::vector<edlprovider__ClipType * >*a, const char *type)
{
	for (std::vector<edlprovider__ClipType * >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerToedlprovider__ClipType(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<edlprovider__ClipType * >* SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerToedlprovider__ClipType(struct soap *soap, const char *tag, std::vector<edlprovider__ClipType * >*a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{	edlprovider__ClipType *n;
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href))
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_edlprovider__ClipType, SOAP_TYPE_std__vectorTemplateOfPointerToedlprovider__ClipType, sizeof(edlprovider__ClipType), 1))
				break;
			if (!soap_in_PointerToedlprovider__ClipType(soap, tag, NULL, "edlprovider:ClipType"))
				break;
		}
		else if (!soap_in_PointerToedlprovider__ClipType(soap, tag, &n, "edlprovider:ClipType"))
			break;
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerToedlprovider__ClipType(soap, -1)))
			return NULL;
		a->push_back(n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<edlprovider__ClipType * > * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerToedlprovider__ClipType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerToedlprovider__ClipType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOfPointerToedlprovider__ClipType, n, EDLProvider_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(std::vector<edlprovider__ClipType * >);
		if (size)
			*size = sizeof(std::vector<edlprovider__ClipType * >);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(std::vector<edlprovider__ClipType * >, n);
		if (size)
			*size = n * sizeof(std::vector<edlprovider__ClipType * >);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (std::vector<edlprovider__ClipType * >*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfPointerToedlprovider__ClipType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<edlprovider__ClipType * > %p -> %p\n", q, p));
	*(std::vector<edlprovider__ClipType * >*)p = *(std::vector<edlprovider__ClipType * >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfstd__wstring(struct soap *soap, std::vector<std::wstring >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfstd__wstring(struct soap *soap, const std::vector<std::wstring >*a)
{
#ifndef WITH_NOIDREF
	for (std::vector<std::wstring >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_std__wstring(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfstd__wstring(struct soap *soap, const char *tag, int id, const std::vector<std::wstring >*a, const char *type)
{
	for (std::vector<std::wstring >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_std__wstring(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<std::wstring >* SOAP_FMAC4 soap_in_std__vectorTemplateOfstd__wstring(struct soap *soap, const char *tag, std::vector<std::wstring >*a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{	std::wstring n;
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		soap_default_std__wstring(soap, &n);
		if (tag && *tag != '-' && (*soap->id || *soap->href))
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_std__wstring, SOAP_TYPE_std__vectorTemplateOfstd__wstring, sizeof(std::wstring), 0))
				break;
			if (!soap_in_std__wstring(soap, tag, NULL, "xsd:string"))
				break;
		}
		else if (!soap_in_std__wstring(soap, tag, &n, "xsd:string"))
			break;
		if (!a && !(a = soap_new_std__vectorTemplateOfstd__wstring(soap, -1)))
			return NULL;
		soap_update_pointers(soap, (char*)&n, (char*)&n + sizeof(n), (char*)&(*a->insert(a->end(), n)), (char*)&n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<std::wstring > * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfstd__wstring(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfstd__wstring(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOfstd__wstring, n, EDLProvider_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(std::vector<std::wstring >);
		if (size)
			*size = sizeof(std::vector<std::wstring >);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(std::vector<std::wstring >, n);
		if (size)
			*size = n * sizeof(std::vector<std::wstring >);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (std::vector<std::wstring >*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfstd__wstring(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<std::wstring > %p -> %p\n", q, p));
	*(std::vector<std::wstring >*)p = *(std::vector<std::wstring >*)q;
}

#if defined(__BORLANDC__)
#pragma option pop
#pragma option pop
#endif

/* End of EDLProviderC.cpp */
